<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARTIST</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://martist.cn/"/>
  <updated>2018-05-11T11:49:59.799Z</updated>
  <id>http://martist.cn/</id>
  
  <author>
    <name>马闯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>laravel的核心</title>
    <link href="http://martist.cn/2018/05/10/LARAVEL/laravel%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://martist.cn/2018/05/10/LARAVEL/laravel核心概念/</id>
    <published>2018-05-09T16:00:00.000Z</published>
    <updated>2018-05-11T11:49:59.799Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="依赖注入容器不止laravel一家"><a href="#依赖注入容器不止laravel一家" class="headerlink" title="依赖注入容器不止laravel一家"></a>依赖注入容器不止laravel一家</h2><p>目前市面上流行有数十个依赖注入容器, 而这些DI(Dependency Injection)容器有着大相径庭的方式来存储条目.</p><pre><code>有一些基于回调(callbacks) (Pimple, Laravel, …)其他的基于配置(Symfony, ZendFramework, …), 配置有多种格式(PHP数组, YAML文件, XML文件)有一些可以 利用工厂(leverage factories)有一些使用PHP API来创建条目(PHP-DI, ZF, Symfony, Mouf, …)有一些可以自动装配(Laravel, PHP-DI)    即自动处理依赖其他的一些能根据注释来解决依赖(PHP-DI, JMS Bundle…)有一些提供图形用户界面(Mouf)有一些可以使用配置文件编译成PHP类(Symfony, ZF)有一些支持别名有一些可以使用代理以提供依赖关系的延迟加载(lazy loading of dependencies)</code></pre><p>局势就是如此, 当前有着非常多种方式来解决依赖注入问题, 因此有很多种DI容器的实现方式.<br>然而, 所有的DI容器都在满足同样的需求: 它们为应用程序提供一种检索一组配置对象(通常是服务)的方法.</p><p>通过标准化从容器中获取条目的方式, 使用 容器PSR规范 的框架和库可以与与任何兼容的容器.<br>这更便于用户(指使用容器的开发者)根据各自的喜好来选择容器.</p><h2 id="laravel的IOC"><a href="#laravel的IOC" class="headerlink" title="laravel的IOC"></a>laravel的IOC</h2><p>上面一篇文章《正确的理解IOC》提到，laravel的核心【IOC容器】很轻量，具体有以下几个特点：</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>类也不依赖DI对象，依赖注入是通过反射分析出类所依赖的其他类，然后从容器中获取相应的对象并自动注入到类里面。<br>依赖注入的写法是强类型参数，也就是参数有提示类名/接口。<br>laravel的服务容器实现了 PSR-11 接口。 因此，你可以使用 PSR-11容器『接口类型提示』来获取 Laravel 容器的实例。</p><h3 id="Facades"><a href="#Facades" class="headerlink" title="Facades"></a>Facades</h3><p>在 Laravel 应用程序的环境中，facade 是个提供从容器访问对象的类。Facade 类是让这个机制可以运作的原因。Laravel 的 facades 和你建立的任何自定义 facades，将会继承基类 Facade。</p><p>你的 facade 类只需要去实现一个方法：getFacadeAccessor。getFacadeAccessor 方法的工作是定义要从容器解析什么。基类 Facade 利用 __callStatic() 魔术方法来从你的 facade 调用到解析出来的对象。</p><p>所以当你对 facade 调用，例如 Cache::get，Laravel 从服务容器解析缓存管理类出来，并对该类调用 get 方法。用专业口吻来说，Laravel Facades 是使用 Laravel 服务容器作为服务定位器的便捷语法。<br>下面是route的facade类:</p><pre><code>namespace Illuminate\Support\Facades;class Route extends Facade{    /**     * Get the registered name of the component.     *     * @return string     */    protected static function getFacadeAccessor()    {        return &apos;router&apos;;    }}</code></pre><h3 id="serviceProvider"><a href="#serviceProvider" class="headerlink" title="serviceProvider"></a>serviceProvider</h3><p>服务提供者是所有 Laravel 应用程序的启动中心。你的应用程序，以及所有 Laravel 的核心服务，都是透过服务提供者启动。</p><p>但我们所说的「启动」指的是什么？一般而言，我们指注册事物，包括注册服务容器绑定、事件监听器、过滤器，甚至路由。服务提供者是你的应用程序配置中心所在。</p><p>如果你打开包含于 Laravel 中的 config/app.php 这一文件，你会看到 providers 数组。这些是所有将加载至你的应用程序里的服务提供者类。当然，它们之中有很多属于「缓载」提供者，意思是除非真正需要它们所提供的服务，否则它们并不会在每一个请求中都被加载。</p><h3 id="serviceProvider和Facades的关系"><a href="#serviceProvider和Facades的关系" class="headerlink" title="serviceProvider和Facades的关系"></a>serviceProvider和Facades的关系</h3><p>如果要把所有可能的service绑定，container类会变得非常庞大，如果在应用的开始调用N次bind方法，依次绑定需要的所有service，这个文件将难以维护，比如</p><pre><code>class Container {  protected $service_arr = [];  public function bind($name, $instance) {     $this-&gt;servie_arr[$name] = $instance;  }  public function get($name) {    return $this-&gt;service_arr[$name];  }}$con = new Container();$db = new DBClass([&apos;locahost&apos;,3306,root,pwd]);$con-&gt;bind(&apos;db&apos;, $db);$cache = new Cache([&apos;127.0.0.1&apos;,11211]);$con-&gt;bind(&apos;cache&apos;,$cache);//...</code></pre><p>所有的类的实例化都写到一个文件里了，讲会是耦合性升高。<br>ServiceProvider就是解决这个问题的<br>每一个需要绑定到container的service，你需要创建一个对应ServiceProvider，这个ServiceProvider中有一个register方法，在这里面进行绑定，而不是像上述那样。比如：</p><pre><code>class SomeServiceProvider extends ServiceProvider {  public function register() {      $this-&gt;app-&gt;bind(&apos;some&apos;, new Some());  }}</code></pre><p>Laravel的container为了知道需要绑定哪些service,它会去读一个数组，这个数组是config/app.php中的Providers，然后你只需要把你的SomeServiceProvider写进这个数组，就可以绑定上了。<br>Facade</p><p>刚开始看Facade其实还是不太好理解，到底什么是Facade呢，它存在的意义又是什么呢？<br>我的理解</p><pre><code>简化对service的使用，可以理解为语法糖可以方便的替换</code></pre><p>可能你有疑惑，到底替换什么呢？看看下面的代码吧</p><pre><code>use Illuminate\Support\Facades\Redis;class IndexController extends Controller {  public function index() {    $redis = Redis::connect();    //do something  }}</code></pre><p>然而当我们打开Illuminate\Support\Facades\Redis看看，并没有connect的静态方法啊？但是可以发现唯一的一个方法返回了一个redis字符串，有什么玄机呢？<br>那么我们再看看RedisServiceProvider，我们的RedisServiceProvider在container里绑定了一个redis……所以大概你也猜到了，没错！</p><pre><code>Redis::connect() 等价于 $this-&gt;app-&gt;get(&apos;redis&apos;)-&gt;connect()</code></pre><p>get的到底是什么，取决于Facade中getFacadeAccessor方法返回的字符串！<br>这样有什么好处呢？文档也说了，除了简便使用以外最大的用处是测试，想想看，你把Redis的getFacadeAccessor方法返回值变成’memcached’，那么你所有使用Redis::some()是不是就全部切换成memcache啦？</p><h2 id="Application-php"><a href="#Application-php" class="headerlink" title="Application.php"></a>Application.php</h2><p>我们可以在Illuminate\Foundation命名空间下的Application.php里面看下，这个文件时laravel的基础。</p><pre><code>class Application extends Container implements ApplicationContract, HttpKernelInterface{}</code></pre><p>Application.php继承自 Container ，也就是说Foundation命名空间下的Application 类本身是一个容器。<br>我们可以在Illuminate\Container命名空间下的Container.php里面看下，这个文件时laravel的容器，基础中的基础。</p><h2 id="后期静态绑定"><a href="#后期静态绑定" class="headerlink" title="后期静态绑定"></a>后期静态绑定</h2><p>laravel框架中Model类的部分代码，$model = new static($attributes); 和 return static::create($attributes);<br>因为该类是抽象类，所以他的实现类在调用这些函数时，最终动态绑定的是实现类，而非model抽象类。</p><h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><p>Trait是PHP 5.4引入的新概念，看上去既像类又像接口，其实都不是，Trait可以看做类的部分实现，可以混入一个或多个现有的PHP类中。<br>其作用有两个：表明类可以做什么；提供模块化实现。<br>Trait是一种代码复用技术，为PHP的单继承限制提供了一套灵活的代码复用机制。</p><h3 id="从index-php进入项目"><a href="#从index-php进入项目" class="headerlink" title="从index.php进入项目"></a>从index.php进入项目</h3><pre><code>&lt;?php/*设置脚本开始时间 define(&apos;LARAVEL_START&apos;, microtime(true));  引入composer的自动加载，在composer.json中可以看出相当于    require(&apos;app/*&apos;) require(&apos;database/*&apos;) require(&apos;vendor/*&apos;)    之后使用时只要引入命名空间即可*/require __DIR__.&apos;/../bootstrap/autoload.php&apos;;$app = require_once __DIR__.&apos;/../bootstrap/app.php&apos;;/*在phpstrom中ctrl+左键单击查看app.php代码。*//*app.php代码如下:*//*首先创建app服务容器，即ioc容器，稍后分析*/$app = new Illuminate\Foundation\Application(    realpath(__DIR__.&apos;/../&apos;));/*看官方文档可知，singleton 方法绑定一个只需要解析一次的类或接口到容器，然后接下来对容器的调用将会返回同一个实例即以后需要使用Illuminate\Contracts\Http\Kernel这个类时，会返回App\Http\Kernel使用代码 $app-&gt;make(&apos;Illuminate\Contracts\Http\Kernel&apos;)*//*在laravel中Contracts（契约）文件夹里面的都是interfere类实现时都在Foundation这个文件夹中而查看App\Http\Kernel会发现它继承了实现接口类的类*//*这里绑定的是http启动的一些启动服务（session。env。config等）和中间件。以后分析。*/$app-&gt;singleton(    Illuminate\Contracts\Http\Kernel::class,    App\Http\Kernel::class);/*这里绑定的是控制台用的服务，即php artisan 如果上线了可以省去。*/$app-&gt;singleton(    Illuminate\Contracts\Console\Kernel::class,    App\Console\Kernel::class);/*绑定错误提示类上线后可以省去。*/$app-&gt;singleton(    Illuminate\Contracts\Debug\ExceptionHandler::class,    App\Exceptions\Handler::class);return $app;/*继续查看index.php*//*这里解析http的核心*/$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);/*处理请求，生成响应这里的handle函数是一大难点。其实现贼复杂*/$response = $kernel-&gt;handle(/*这里利用symfont的http request解析http请求里面有post。get。文件。路径等很多信息。*/    $request = Illuminate\Http\Request::capture());/*发送响应*/$response-&gt;send();/*后续处理，比如写log等*/$kernel-&gt;terminate($request, $response);/*由app.php里面的singleton很容易得知handle函数的所在*/public function handle($request)    {        try {/*这是symfont的允许在路由中使用GET和POST以外的HTTP方法 */            $request-&gt;enableHttpMethodParameterOverride();/*把request交给router处理，首先肯定是要匹配的你在route里面定义的方法*/            $response = $this-&gt;sendRequestThroughRouter($request);        } catch (Exception $e) {/*接下来都是些错误处理*/            $this-&gt;reportException($e);            $response = $this-&gt;renderException($request, $e);        } catch (Throwable $e) {            $this-&gt;reportException($e = new FatalThrowableError($e));            $response = $this-&gt;renderException($request, $e);        }/*分发事件，让事件监听获取信息，以后说*/        event(new Events\RequestHandled($request, $response));        return $response;    }/*然后我们专注于sendRequestThroughRouter这函数*/protected function sendRequestThroughRouter($request)    {/*绑定一个实例。laravel实现3种绑定，bind singleton instance。每次绑定如果名字相同会覆盖掉上次绑定的。bind每次make返回的都是新的实例singleton每次make返回的都是同一个实例instance每次返回的都是绑定时给的实例*/        $this-&gt;app-&gt;instance(&apos;request&apos;, $request);/*未知作用*/        Facade::clearResolvedInstance(&apos;request&apos;);/*启动初始服务，比如config。env等，以后有机会分析*/        $this-&gt;bootstrap();/*利用管道类处理请求，先绑定app容器，然后发送request请求，通过中间件，最后匹配路由，并执行route里面定义的方法，生成并返回reponse，其中源码绕来绕去就不一一解析*/        return (new Pipeline($this-&gt;app))                    -&gt;send($request)                    -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware)                    -&gt;then($this-&gt;dispatchToRouter());    }</code></pre><h3 id="laravel的spl-autoload-register-注册了什么"><a href="#laravel的spl-autoload-register-注册了什么" class="headerlink" title="laravel的spl_autoload_register()注册了什么"></a>laravel的spl_autoload_register()注册了什么</h3><p>在路由文件中经常会出现Route::get()这样的写法，但实际上并没有Route类，Route只是\Illuminate\Support\Facades\Route::class外观类的别名，这样取个别名只是为了简化作用。</p><pre><code>namespace Illuminate\Foundation;class AliasLoader{   /**     * Register the loader on the auto-loader stack.     *     * @return void     */     public function register()    {        if (! $this-&gt;registered) {            $this-&gt;prependToLoaderStack();            $this-&gt;registered = true;        }    }     /**     * Prepend the load method to the auto-loader stack.     *     * @return void     */    protected function prependToLoaderStack()    {        spl_autoload_register([$this, &apos;load&apos;], true, true);    }     /**     * Load a class alias if it is registered.     *     * @param  string  $alias     * @return bool|null     */    public function load($alias)    {        if (static::$facadeNamespace &amp;&amp; strpos($alias, static::$facadeNamespace) === 0) {            $this-&gt;loadFacade($alias);            return true;        }        if (isset($this-&gt;aliases[$alias])) {            return class_alias($this-&gt;aliases[$alias], $alias);        }    }   ...}</code></pre><p>Route::get()的调用过程就是，首先发现没有Route类，就去自动加载函数堆栈中通过AliasLoader::load()函数查找到Route是IlluminateSupportFacadesRoute的别名，那就调用IlluminateSupportFacadesRoute::get()，当然这里IlluminateSupportFacadesRoute没有get()静态方法，那就调用父类Facade的__callStatic()来找到名为router的服务，名为’router’的服务那就是早就注册到容器中的IlluminateRoutingRouter对象，所以最终就是调用IlluminateRoutingRouter::get()方法。这个过程主要使用了两个技术：一个是外观类的别名；一个是PHP的重载，</p><p>参考：<br><a href="https://segmentfault.com/a/1190000006946685" target="_blank" rel="external">https://segmentfault.com/a/1190000006946685</a></p><h1 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h1><p>route.php文件中，</p><pre><code>Class Foo{}//如果没有这个class会报错。Route::get(&apos;/&apos;,function(Foo $foo){  dd($foo);});</code></pre><p>Foo $foo 是依赖注入的写法，</p><p>laravel框架利用反射机制，尝试解释语义Foo $foo，<br>在laravel内核执行实例化</p><pre><code>$foo = new Foo();</code></pre><p>当laravel尝试new依赖的这个类，找不到的话就会报错找不到这个类。</p><p>当laravel找到的依赖的类。这个类本身依赖注入的类不明确时。<br>会爆其他错误：不能解析。</p><p>另一种方式</p><p>当使用App:bind这个方法时，laravel会优先通过这里加载这个类<br>而不是 反射机制 根据命名空间或者require路径去寻找。</p><pre><code>App::bind(&apos;Foo&apos;,function(){    dd(&apos;called here&apos;);    return new Foo();})</code></pre><hr><h1 id="service-provider"><a href="#service-provider" class="headerlink" title="service provider"></a>service provider</h1><p>service provider 的类中，有意义的是register（）方法，</p><p>在index.php里面有$app这个变量，这是框架的核心。</p><pre><code>$this-&gt;app-&gt;sigleton(&apos;files&apos;,functionZ(){    return new Filesystem;})</code></pre><p>在这里的‘files’我们可以看做键名，指向Filesystem这个类的实例化。<br>这样我们可以在路由中试用下看看。</p><pre><code>Route::get(&apos;/&apos;,function(Foo $foo){  $content = app(&apos;files&apos;)-&gt;get(__DIR__.&apos;/kernel.php&apos;);  dd($content);});//打印出来这个文件的内容</code></pre><p>使用service provider中注册并提供一个简明的键名去申明这个类，<br>可以节约代码，易于管理。</p><h1 id="在Ioc容器中添加自己的类"><a href="#在Ioc容器中添加自己的类" class="headerlink" title="在Ioc容器中添加自己的类"></a>在Ioc容器中添加自己的类</h1><p>比如说项目中需要收费的功能，</p><p>app目录下新建目录billing，生成类文件</p><pre><code>Class stripe{  public function pay(){        dd(&apos;I pay&apos;);    }}</code></pre><p>artisan命令：<br>php artisan  make:provider BillingServicePovider</p><p>在 app/Providers目录下生成BillingServicePovider.php文件，<br>里面有意义的就是register（），我们在这里面注册stripe类。</p><pre><code>public function register(){  $this-&gt;app-&gt;bind(&apos;billing&apos;,fintion(){    return new Stripe();    });}</code></pre><p>再把它放到IOC容器中，config/app.php中添加。</p><p>此时，app(‘billing’)就可以相当于new Stripe()了。</p><p>app(‘billing’)-&gt;pay();//输出 I pay</p><h1 id="Facade-门面-运行机制"><a href="#Facade-门面-运行机制" class="headerlink" title="Facade(门面)运行机制"></a>Facade(门面)运行机制</h1><p>config/app.php下  alias数组，</p><p>用IDE的查找类的功能点进去，比如点route,Mail<br>进去一个类是继承的Facade，</p><p>里面有 getFacadeAccessor()函数返回一个字符串，//return ‘mailer’;<br>这个字符串对应MailserviceProvider.php中register()的字符串。</p><p>Facade类里面有__callStatic(),里面有</p><pre><code>$instance = static::getFacadeRoot();//IOC容器生成$instance，可以使用真正类中的方法//看下面pubilic static function getFacadeRoot(){  return static::resolveFacadeInstance(static::getFacadeAccessor());//app(&apos;mailer&apos;);}</code></pre><p>流程：</p><p>app.php下的别名数组的值指向一个类，这个类通过返回给Facade一个字符串实现app（‘name’）,<br>然后通过serviceProvider去注册返回实例化之后的类。</p><hr><h1 id="contract-契约"><a href="#contract-契约" class="headerlink" title="contract (契约)"></a>contract (契约)</h1><p>在项目目录framework/src/Illuminate/Contracts下面定义了很多interface。</p><p>面向接口编程。在依赖注入中很大好处。该目录下的类都是接口类。</p><p>比如：Config真正是新的类，在Illuminate\Contracts\Config\Repository，</p><p>app()方法:</p><pre><code>dd(app(&apos;Illuminate\Contracts\Config\Repository&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysqldd(Config::get());//可以看到laravel的配置dd(app(&apos;config&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysql</code></pre><p>contract给出整个框架给出的扩展接口，比如config类不能满足你的需求，<br>可以自己集成config接口实现这个类。</p><h1 id="Container的背后"><a href="#Container的背后" class="headerlink" title="Container的背后"></a>Container的背后</h1><p>这几种的返回结果都一样</p><pre><code>dd(Hash::make(&apos;pwd&apos;));//dsdsvdrssrbsssret5u4h6l8mdd(app(&apos;Hash&apos;)-&gt;make(&apos;pwd&apos;));dd(app()[&apos;Hash&apos;]-&gt;make(&apos;pwd&apos;));dd(app(&apos;Illuminate\Hashing\BcryptHasher&apos;)-&gt;make(&apos;pwd&apos;));</code></pre><p>想知道laravel单个功能的源代码，比如hash的功能，去serviceProvider去找。</p><pre><code>$this-&gt;app-&gt;singleton(&apos;hash&apos;,function(){  return new BcryptHasher;})</code></pre><p>singleton，bind是在核心的Contianer里面，</p><p>callFunction 是 Clouse ，会在singleton，bind中进行判断。</p><p>singleton，将hash的值保存到container的binding数组。</p><p>make(),build()可以通过serviceProvider、别名实现实例。</p><p>app（）判断传入的是key =&gt; serviceProvider去实现实例</p><p>包含命名空间的类 =&gt; Application.php  中 registerCoreContainerAliases()</p><p>Application.php里面是laravel的核心内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>laravel的IOC容器和php反射机制</title>
    <link href="http://martist.cn/2018/05/10/LARAVEL/laravel%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E5%92%8Cphp%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://martist.cn/2018/05/10/LARAVEL/laravel的IOC容器和php反射机制/</id>
    <published>2018-05-09T16:00:00.000Z</published>
    <updated>2018-05-11T04:21:06.281Z</updated>
    
    <content type="html"><![CDATA[<p>以下是代码实例，利用反射可以寻找类的【构造函数中的参数】，然后根据【类型提示类】，利用反射机制实例化类，从而实现依赖加载</p><pre><code>&lt;?php/**** 工具类，使用该类来实现自动依赖注入。**/class Ioc {    static $i = 0;    // 获得类的对象实例    public static function getInstance($className) {        $paramArr = self::getMethodParams($className);        var_dump($paramArr);die;        return (new ReflectionClass($className))-&gt;newInstanceArgs($paramArr);//newInstanceArgs 从给出的参数创建一个新的类实例。    }    /**     * 执行类的方法     * @param  [type] $className  [类名]     * @param  [type] $methodName [方法名称]     * @param  [type] $params     [额外的参数]     * @return [type]             [description]     */    public static function make($className, $methodName, $params = []) {        // 获取类的实例        $instance = self::getInstance($className);        // 获取该方法所需要依赖注入的参数        $paramArr = self::getMethodParams($className, $methodName);        return $instance-&gt;{$methodName}(...array_merge($paramArr, $params));// ... 可变函数参数    }    /**     * 获得类的方法参数，只获得有类型的参数     * @param  [type] $className   [description]     * @param  [type] $methodsName [description]     * @return [type]              [description]     */    protected static function getMethodParams($className, $methodsName = &apos;__construct&apos;) {self::$i++;        // 通过反射获得该类        $class = new ReflectionClass($className);        echo  &quot;&lt;pre&gt;&quot;;        // print_r($class);        $paramArr = []; // 记录参数，和参数类型        // dd($class);  //       ReflectionClass Object        // (        //     [name] =&gt; B        // )        // 判断该类是否有构造函数        if ($class-&gt;hasMethod($methodsName)) {            // 获得构造函数            $construct = $class-&gt;getMethod($methodsName); //getMethod 检查方法是否已定义            // dd($construct);              //ReflectionMethod Object            // (            //     [name] =&gt; __construct            //     [class] =&gt; B            // )            // 判断构造函数是否有参数            $params = $construct-&gt;getParameters();// 获取参数            // dd($params);            //  Array            // (            //     [0] =&gt; ReflectionParameter Object            //         (            //             [name] =&gt; a            //         )            // )            if (count($params) &gt; 0) {                // 判断参数类型                foreach ($params as $key =&gt; $param) {                    if ($paramClass = $param-&gt;getClass()) { //getClass 获得类型提示类                        // dd($paramClass);      //                   ReflectionClass Object                        // (                        //     [name] =&gt; A                        // )                        // 获得参数类型名称                        $paramClassName = $paramClass-&gt;getName(); //获取类名                        // dd($paramClassName);                        // A                        // 获得参数类型                        $args = self::getMethodParams($paramClassName);                        // print_r($args);                        // Array                        // (                        // )                        // Array                        // (                        //     [0] =&gt; C Object                        //         (                        //         )                        // )                        $paramArr[] = (new ReflectionClass($paramClass-&gt;getName()))-&gt;newInstanceArgs($args);                         // print_r($paramArr);//                         Array                        // (                        //     [0] =&gt; C Object                        //         (                        //         )                        // )//                         Array                        // (                        //     [0] =&gt; A Object                        //         (                        //             [cObj:protected] =&gt; C Object                        //                 (                        //                 )                        //         )                        // )                        //  newInstanceArgs 从给出的参数创建一个新的类实例。                    }                }            }        }        return $paramArr;    }}class A {    protected $cObj;    /**     * 用于测试多级依赖注入 B依赖A，A依赖C     * @param C $c [description]     */    public function __construct(C $c) {        $this-&gt;cObj = $c;    }    public function aa() {        echo &apos;this is A-&gt;test&apos;;    }    public function aac() {        $this-&gt;cObj-&gt;cc();    }}class B {    protected $aObj;    /**     * 测试构造函数依赖注入     * @param A $a [使用引来注入A]     */    public function __construct(A $a) {        $this-&gt;aObj = $a;    }    /**     * [测试方法调用依赖注入]     * @param  C      $c [依赖注入C]     * @param  string $b [这个是自己手动填写的参数]     * @return [type]    [description]     */    public function bb(C $c, $b) {        $c-&gt;cc();        echo &quot;\r\n&quot;;        echo &apos;params:&apos; . $b;    }    /**     * 验证依赖注入是否成功     * @return [type] [description]     */    public function bbb() {        $this-&gt;aObj-&gt;aac();    }}class C {    public function cc() {        echo &apos;this is C-&gt;cc&apos;;    }}function dd($dd){    echo &quot;&lt;pre&gt;&quot;;    print_r($dd);    die;}//实例化B，B构造依赖A,A构造依赖C.// 使用Ioc来创建B类的实例，B的构造函数依赖A类，A的构造函数依赖C类。$bObj = Ioc::getInstance(&apos;B&apos;);$bObj-&gt;bbb(); // 输出：this is C-&gt;cc ， 说明依赖注入成功。// 打印$bObj// var_dump($bObj);// // 打印结果，可以看出B中有A实例，A中有C实例，说明依赖注入成功。// object(B)#3 (1) {//   [&quot;aObj&quot;:protected]=&gt;//   object(A)#7 (1) {//     [&quot;cObj&quot;:protected]=&gt;//     object(C)#10 (0) {//     }//   }// }Ioc::make(&apos;B&apos;, &apos;bb&apos;, [&apos;this is param b&apos;]);// // 输出结果，可以看出依赖注入成功。// this is C-&gt;cc// params:this is param b</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是代码实例，利用反射可以寻找类的【构造函数中的参数】，然后根据【类型提示类】，利用反射机制实例化类，从而实现依赖加载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
/**
*
* 工具类，使用该类来实现自动依赖注入。
*
*/
class Ioc {

    sta
      
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>记住密码基本原理</title>
    <link href="http://martist.cn/2018/05/08/PHP/%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://martist.cn/2018/05/08/PHP/记住密码基本原理/</id>
    <published>2018-05-07T16:00:00.000Z</published>
    <updated>2018-05-08T02:42:40.535Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="怎么在浏览器退出登录后保持状态"><a href="#怎么在浏览器退出登录后保持状态" class="headerlink" title="怎么在浏览器退出登录后保持状态"></a>怎么在浏览器退出登录后保持状态</h2><p>SESSION信息存储在服务端，相对于存储在客户端的COOKIE更为安全，所以正常一般网站在用于“判断用户是否登录”时，确实是使用SESSION，例如可以在SESSION里存储如下一个数组：</p><pre><code>//验证用户名和密码成功后$_SESSION[&apos;userinfo&apos;] = [  &apos;uid&apos; =&gt; 123,  &apos;username&apos; =&gt; &apos;testuser&apos;];</code></pre><p>而后在需要验证登录的地方加入类似如下判断</p><pre><code>if(empty($_SESSION[&apos;userinfo&apos;]) || empty($_SESSION[&apos;userinfo&apos;][&apos;uid&apos;])){  //未登录，引导登录}</code></pre><p>以上是使用SESSION做用户登录的基本存储和验证逻辑，当然实际开发过程中会将这部分的代码封装</p><p>我们都知道，SESSION一般是通过在COOKIE里记录一个KEY为PHPSESSID的COOKIE来保持上下文的，而这个PHPSESSID的COOKIE的有效期是设置为“会话”，意味着关闭浏览器后该COOKIE被销毁，相应的后端SESSION也就销毁，如图<br>另外，由于PHP的Session本身就有GC的机制，一般默认1440秒内页面没有刷新动作（准确的说是没有新的请求来刷新该PHPSESSID的生命周期），该SESSION也就被自动回收，伴随着用户的登录就失效了。</p><p>虽然COOKIE保存在客户端，不安全，易被伪造，这是客观存在的事实，但要实现这个“记住我”，还确实就得用到COOKIE，我们能做的是尽量去提高伪造的门槛。</p><h2 id="一个参考的设计方案"><a href="#一个参考的设计方案" class="headerlink" title="一个参考的设计方案"></a>一个参考的设计方案</h2><h3 id="签名机制"><a href="#签名机制" class="headerlink" title="签名机制"></a>签名机制</h3><p>1、将用户信息，比如一个[‘uid’=&gt;123, ‘username’=&gt;’testuser’]的数组，序列化后成为字符串，使用可逆加密算法加密该字符串，写到一个Key为userinfo的COOKIE里<br>2、由于可逆加密算法容易被解密，一旦加密的规则被别人猜测到以后，就可以轻易篡改这个COOKIE的内容，然后自行根据加密规则加密后伪造，所以，我们另外加入一个infodig的COOKIE，是将以上的userinfo的COOKIE内容，加入salt后使用不可逆加密算法生成散列，至于salt咱们可以自己定，总之要对外保密，不可逆算法例如md5，甚至多次加盐多次md5<br>3、以上两个COOKIE，为增强安全性，防止用户被XSS攻击后拿到，可以设置http-only属性</p><h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>服务端判断存在以上两个COOKIE后<br>1、验证infodig与userinfo是否匹配（将userinfo的内容使用生成infodig的方法计算后，与COOKIE传上来的infodig匹配是否一致）<br>2、infodig验证通过后，使用解密算法解密userinfo串，得到用户信息，如果用户信息里的uid存在用户表中，则写SESSION，通过SESSION保持本次会话</p><p>总而言之，使用COOKIE记录用户信息是可行的（当然不建议把用户敏感的东西存在COOKIE，例如邮箱、手机、甚至密码，只记录对登录有用的部分，例如uid、username等标识，以及nickname可能会在某些地方提升用户体验），可以确定的是，这个COOKIE对用户可见，我们要做的就是两点：<br>1、尽量让用户看不懂，而只有我们服务端自己认识（可逆加密算法）；<br>2、即使用户看懂了，他也不能够轻易的伪造（不可逆的散列算法）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>nginx如何配置重定向</title>
    <link href="http://martist.cn/2018/05/07/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/nginx%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://martist.cn/2018/05/07/服务部署/nginx如何配置重定向/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-05-07T07:38:47.974Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="Nginx中if语句中的判断条件"><a href="#Nginx中if语句中的判断条件" class="headerlink" title="Nginx中if语句中的判断条件"></a>Nginx中if语句中的判断条件</h2><h3 id="if语句中的判断条件-nginx"><a href="#if语句中的判断条件-nginx" class="headerlink" title="if语句中的判断条件(nginx)"></a>if语句中的判断条件(nginx)</h3><ol><li><p>正则表达式匹配：</p><pre><code>==:等值比较;~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；</code></pre></li></ol><ol><li>文件及目录匹配判断：</li></ol><p>-f, !-f：判断指定的路径是否为存在且为文件；</p><p>-d, !-d：判断指定的路径是否为存在且为目录；</p><p>-e, !-e：判断指定的路径是否存在，文件或目录均可；</p><p>-x, !-x：判断指定路径的文件是否存在且可执行；</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>有些公司可能有这样的需求，如:我的网站或者网页游戏需要更新，所有的用户或者玩家访问到的是一个停服更新页面，而本公司的IP可以访问，甚至说本公司的某个内网IP可以访问，用于确认更新成功与否，针对这个问题写了如下的访问控制规则:</p><ol><li><p>可以作为nginx的停服更新使用，仅允许222.222.222.222或者内网的两个IP访问,其他IP都rewrite到停服页面<br>Nginx.conf中加入在你项目的正确位置</p><pre><code>set $my_ip &apos;&apos;; if ( $remote_addr = 222.222.222.222){set $my_ip 1;} #注意这里的$remote_addr如何用了负载均衡的话,这里应该是$http_x_forwarded_forif ( $remote_addr = 192.168.1.170 ){ set $my_ip 1;}if ( $remote_addr = 192.168.1.169 ){ set $my_ip 1;}if ( $my_ip != 1) {rewrite ^/design/(.*)\.php$ /tingfu.html?$1&amp;;}  #将*.php转到tingfu.html</code></pre><ol><li><p>访问某个php应用的时候我只想让内部的某个IP访问，其他的IP都转到另一个PHP上。如下:<br>访问test.php，且IP不等222.222.222.222的跳转到55555.php:</p><p>  set $test ‘’;<br>  if ( $request_uri ~* /img/test.php ) {</p><pre><code>set $test P;</code></pre><p>  }</p></li></ol></li></ol><pre><code>if ( $http_x_forwarded_for !~* ^222\.222\.222\.222.* ) {        set $test &quot;${test}C&quot;;}if ( $test = PC ) {  #当条件符合 访问test.php并且 ip不是222.222.222.222的 转发到55555.phprewrite ^(.*)$ /img/55555.php permanent;  }</code></pre><ol><li><p>区分PC或手机访问不同网站</p><pre><code>location / {                proxy_pass http://10.10.100.60:8183;        if ( $http_user_agent ~* &quot;(mobile|nokia|iPhone|ipad|android|samsung|htc|blackberry)&quot; )                {                rewrite  ^/$    http://www.baidu.com;                }                index index.html index.htm;        }</code></pre></li></ol><ol><li><p>if判断&amp;&amp;(并且)写法【post 提交并且是php文件的把变量$allowss设置成false】</p><pre><code>set $allowphp &apos;&apos;;if ($request_method ~ ^(POST)$) {     set $allowphp p;}if ( $request_filename !~ \.php$) {    set $allowphp &quot;${allowphp}c&quot;;}if ( $allowphp = pc) {    set $allowss false;}</code></pre></li></ol><ol><li><p>nginx if判断||(或)写法【ip地址222.186.34.41或180.97.106.37的把变量$allowss设置成false】</p><pre><code>set $allowss true;if ($http_x_forwarded_for ~ &quot; ?222\.186\.34\.41$&quot;) {   set $allowss false;}if ($http_x_forwarded_for ~ &quot; ?180\.97\.106\.37$&quot;) {   set $allowss false;}</code></pre></li></ol><p>加上下面的代码，可以拒绝访问。</p><pre><code>if ($allowss = false) {return 403;}</code></pre><ol><li>post请求转发维持数据</li></ol><p>用301重定向给网站更换新域名get有效，但是post会失效变成get怎么办？针对301的response，浏览器的行为就是发送GET请求Location中的URL。<br>如果需要保持原来的POST方法不变去重新请求，需要使用307，但这未必是你想要的，因为根据标准浏览器针对307的POST请求需要用户明确确认（比如会弹一个alert）。可以用代理的方式去解决（proxy_pass）。</p><pre><code>server {     server_name  gaogd.com;    location / {    if ($request_method ~ ^(POST)$) {        proxy_pass http://www.gaogd.com;        break ;    }    rewrite ^/(.*)$   http://www.gaogd.com/$1 permanent;}</code></pre><h2 id="nginx参数作用"><a href="#nginx参数作用" class="headerlink" title="nginx参数作用"></a>nginx参数作用</h2><pre><code>$arg_PARAMETER #这个变量包含GET请求中，如果有变量PARAMETER时的值。$args #这个变量等于请求行中(GET请求)的参数，例如foo=123&amp;bar=blahblah;$binary_remote_addr #二进制的客户地址。$body_bytes_sent #响应时送出的body字节数数量。即使连接中断，这个数据也是精确的。$content_length #请求头中的Content-length字段。$content_type #请求头中的Content-Type字段。$cookie_COOKIE #cookie COOKIE变量的值$document_root #当前请求在root指令中指定的值。$document_uri #与$uri相同。$host #请求主机头字段，否则为服务器名称。$hostname #Set to the machine&apos;s hostname as returned by gethostname$http_HEADER$is_args #如果有$args参数，这个变量等于”?”，否则等于”&quot;，空值。$http_user_agent #客户端agent信息$http_cookie #客户端cookie信息$limit_rate #这个变量可以限制连接速率。$query_string #与$args相同。$request_body_file #客户端请求主体信息的临时文件名。$request_method #客户端请求的动作，通常为GET或POST。$remote_addr #客户端的IP地址。$remote_port #客户端的端口。$remote_user #已经经过Auth Basic Module验证的用户名。$request_completion #如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)。$request_method #GET或POST$request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。$request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。$scheme #HTTP方法（如http，https）。$server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr #服务器地址，在完成一次系统调用后可以确定这个值。$server_name #服务器名称。$server_port #请求到达服务器的端口号。$uri #不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。该值有可能和$request_uri 不一致。$request_uri是浏览器发过来的值。该值是rewrite后的值。例如做了internal redirects后。</code></pre><h2 id="重定向举例"><a href="#重定向举例" class="headerlink" title="重定向举例"></a>重定向举例</h2><h3 id="rewrite同时参数保留"><a href="#rewrite同时参数保留" class="headerlink" title="rewrite同时参数保留"></a>rewrite同时参数保留</h3><p>把<a href="http://example.com/test.php?para=xxx" target="_blank" rel="external">http://example.com/test.php?para=xxx</a> 重定向到 <a href="http://example.com/new" target="_blank" rel="external">http://example.com/new</a><br>若按照默认的写法：rewrite ^/test.php(.<em>) /new permanent;<br>重定向后的结果是：<a href="http://example.com/new?para=xxx" target="_blank" rel="external">http://example.com/new?para=xxx</a><br>如果改写成：rewrite ^/test.php(.</em>) /new? permanent;<br>那结果就是：<a href="http://example.com/new" target="_blank" rel="external">http://example.com/new</a></p><p>所以，关键点就在于“？”这个尾缀。假如又想保留某个特定的参数，那又该如何呢？可以利用Nginx本身就带有的$arg_PARAMETER参数来实现。</p><p>例如：<br>把<a href="http://example.com/test.php?para=xxx&amp;p=xx" target="_blank" rel="external">http://example.com/test.php?para=xxx&amp;p=xx</a> 重写向到 <a href="http://example.com/new?p=xx" target="_blank" rel="external">http://example.com/new?p=xx</a><br>可以写成：rewrite  ^/test.php   /new?p=$arg_p?  permanent;</p><p>只求结果的朋友可以直接忽略前面的内容，看这里：</p><pre><code>rewrite  ^/test.php  /new  permanent;       //重写向带参数的地址rewrite  ^/test.php  /new?  permanent;      //重定向后不带参数rewrite  ^/test.php   /new?id=$arg_id?  permanent;    //重定向后带指定的参数</code></pre><p>permanent是永久重定向参数，根据需要去掉也可以，不过最好是带有。</p><p> 首先Apache的Rewite规则差别不是很大,但是Nginx的Rewrite规则比Apache的简单灵活多了<br>Nginx可以用if进行条件匹配，语法规则类似C</p><pre><code>if ($http_user_agent ~ MSIE) {rewrite ^(.*)$ /msie/$1 break;}</code></pre><h3 id="Rewrite的Flags"><a href="#Rewrite的Flags" class="headerlink" title="Rewrite的Flags"></a>Rewrite的Flags</h3><p>last - 完成重写指令后，搜索相应的URI和位置。相当于Apache里的[L]标记，表示完成rewrite，不再匹配后面的规则。<br>break - 中止Rewirte，不在继续匹配。<br>redirect - 返回临时重定向的HTTP状态302。<br>permanent - 返回永久重定向的HTTP状态301。</p><h3 id="ZEND-Framework的重定向规则"><a href="#ZEND-Framework的重定向规则" class="headerlink" title="ZEND Framework的重定向规则"></a>ZEND Framework的重定向规则</h3><p>案例一：<br>全部重定向到 /index.php</p><pre><code>rewrite ^/(.*) /index.php?$1&amp;;</code></pre><p>案例二：<br>如果文件或目录不存在则重定向到index.php</p><pre><code>if (!-e $request_filename) {rewrite ^/(.*) /index.php?$1&amp;;}</code></pre><h3 id="WordPress的重定向规则"><a href="#WordPress的重定向规则" class="headerlink" title="WordPress的重定向规则"></a>WordPress的重定向规则</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><p><a href="http://www.wemvc.com/12" target="_blank" rel="external">http://www.wemvc.com/12</a> 重定向到 <a href="http://www.wemvc.com/index.php?p=12" target="_blank" rel="external">http://www.wemvc.com/index.php?p=12</a></p><pre><code>if (!-e $request_filename) {rewrite ^/(.+)$ /index.php?p=$1 last;}</code></pre><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><p>与zendframework配置很像</p><pre><code>if (!-e $request_filename) {rewrite ^/(.*) /index.php?$1&amp;;}</code></pre><h3 id="Discuz完整的Rewrite-for-Nginx规则"><a href="#Discuz完整的Rewrite-for-Nginx规则" class="headerlink" title="Discuz完整的Rewrite for Nginx规则"></a>Discuz完整的Rewrite for Nginx规则</h3><pre><code>if (!-f $request_filename) {rewrite ^/archiver/((fid|tid)-[\w\-]+\.html)$ /archiver/index.php?$1 last;rewrite ^/forum-([0-9]+)-([0-9]+)\.html$ /forumdisplay.php?fid=$1&amp;page=$2 last;rewrite ^/thread-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /viewthread.php?tid=$1&amp;extra=page=$3&amp;page=$2 last;rewrite ^/space-(username|uid)-(.+)\.html$ /space.php?$1=$2 last;rewrite ^/tag-(.+)\.html$ /tag.php?name=$1 last;}</code></pre><h2 id="文件及目录匹配【参数释义】"><a href="#文件及目录匹配【参数释义】" class="headerlink" title="文件及目录匹配【参数释义】"></a>文件及目录匹配【参数释义】</h2><pre><code>-f和!-f用来判断是否存在文件-d和!-d用来判断是否存在目录-e和!-e用来判断是否存在文件或目录-x和!-x用来判断文件是否可执行</code></pre><h2 id="正则表达式全部符号解释"><a href="#正则表达式全部符号解释" class="headerlink" title="正则表达式全部符号解释"></a>正则表达式全部符号解释</h2><pre><code>~ 为区分大小写匹配~* 为不区分大小写匹配!~和!~* 分别为区分大小写不匹配及不区分大小写不匹配(pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript. 中使用 SubMatches 集合，在JScript. 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘\(&apos; 或 ‘\)&apos;。^ 匹配输入字符串的开始位置。$ 匹配输入字符串的结束位置。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php-fpm" scheme="http://martist.cn/categories/php-fpm/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
      <category term="php-fpm" scheme="http://martist.cn/tags/php-fpm/"/>
    
  </entry>
  
  <entry>
    <title>正确的理解IOC</title>
    <link href="http://martist.cn/2018/05/05/LARAVEL/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3IOC/"/>
    <id>http://martist.cn/2018/05/05/LARAVEL/正确的理解IOC/</id>
    <published>2018-05-04T16:00:00.000Z</published>
    <updated>2018-05-10T09:13:29.229Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h2><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。<br>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。</p><h2 id="IOC也叫依赖注入-DI"><a href="#IOC也叫依赖注入-DI" class="headerlink" title="IOC也叫依赖注入(DI)"></a>IOC也叫依赖注入(DI)</h2><p>IOC是控制反转是哪些方面的控制被反转了呢？<br>“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。</p><h2 id="实现IOC的方法"><a href="#实现IOC的方法" class="headerlink" title="实现IOC的方法"></a>实现IOC的方法</h2><p>注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p><h2 id="IOC容器的技术实现"><a href="#IOC容器的技术实现" class="headerlink" title="IOC容器的技术实现"></a>IOC容器的技术实现</h2><p>IOC中最基本的技术就是“反射(Reflection)”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中 NHibernate、Spring.Net框架都是把“反射”做为最基本的技术手段。</p><h2 id="代码层面的技术剖析"><a href="#代码层面的技术剖析" class="headerlink" title="代码层面的技术剖析"></a>代码层面的技术剖析</h2><h3 id="new-class"><a href="#new-class" class="headerlink" title="new class"></a>new class</h3><p>先假设我们这里有一个类，类里面需要用到数据库连接，按照最最原始的办法，我们可能是这样写这个类的：</p><pre><code>class example {     private $_db;     function __construct(){         include &quot;./Lib/Db.php&quot;;         $this-&gt;_db = new Db(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;test&quot;);     }     function getList(){         $this-&gt;_db-&gt;query(&quot;......&quot;);//这里具体sql语句就省略不写了     } }</code></pre><p>过程：</p><p>在构造函数里先将数据库类文件include进来；<br>然后又通过new Db并传入数据库连接信息实例化db类；<br>之后getList方法就可以通过$this-&gt;_db来调用数据库类，实现数据库操作。</p><p>看上去我们实现了想要的功能，但是这是一个噩梦的开始，以后example1,example2,example3….越来越多的类需要用到db组件，如果都这么写的话，万一有一天数据库密码改了或者db类发生变化了，岂不是要回头修改所有类文件？</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>ok，为了解决这个问题，工厂模式出现了，我们创建了一个Factory方法，并通过Factory::getDb()方法来获得db组件的实例：</p><pre><code>class Factory {     public static function getDb(){         include &quot;./Lib/Db.php&quot;;         return new Db(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;test&quot;);     } }</code></pre><p>sample类变成：</p><pre><code>class example {     private $_db;     function __construct(){         $this-&gt;_db = Factory::getDb();     }     function getList(){         $this-&gt;_db-&gt;query(&quot;......&quot;);//这里具体sql语句就省略不写了     } }</code></pre><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>这样就完美了吗？再次想想一下以后example1,example2,example3….所有的类，你都需要在构造函数里通过Factory::getDb();获的一个Db实例，实际上你由原来的直接与Db类的耦合变为了和Factory工厂类的耦合，工厂类只是帮你把数据库连接信息给包装起来了，虽然当数据库信息发生变化时只要修改Factory::getDb()方法就可以了，但是突然有一天工厂方法需要改名，或者getDb方法需要改名，你又怎么办？当然这种需求其实还是很操蛋的，但有时候确实存在这种情况，一种解决方式是：</p><p>我们不从example类内部实例化Db组件，我们依靠从外部的注入，什么意思呢？看下面的例子：</p><pre><code>class example {     private $_db;     function getList(){         $this-&gt;_db-&gt;query(&quot;......&quot;);//这里具体sql语句就省略不写了     }     //从外部注入db连接     function setDb($connection){         $this-&gt;_db = $connection;     } } //调用 $example = new example(); $example-&gt;setDb(Factory::getDb());//注入db连接 $example-&gt;getList();</code></pre><p>这样一来，example类完全与外部类解除耦合了，你可以看到Db类里面已经没有工厂方法或Db类的身影了。我们通过从外部调用example类的setDb方法，将连接实例直接注入进去。这样example完全不用关心db连接怎么生成的了。</p><p><strong>这就叫依赖注入</strong></p><p>实现不是在代码内部创建依赖关系，而是让其作为一个参数传递，这使得我们的程序更容易维护，降低程序代码的耦合度，实现一种松耦合。</p><h3 id="松耦合的写法"><a href="#松耦合的写法" class="headerlink" title="松耦合的写法"></a>松耦合的写法</h3><p>这还没完，我们再假设example类里面除了db还要用到其他外部类，我们通过：</p><pre><code>$example-&gt;setDb(Factory::getDb());//注入db连接 $example-&gt;setFile(Factory::getFile());//注入文件处理类 $example-&gt;setImage(Factory::getImage());//注入Image处理类 ...</code></pre><p>我们没完没了的写这么多set？累不累?</p><p>ok，为了不用每次写这么多行代码，我们又去弄了一个工厂方法：</p><pre><code>class Factory {     public static function getExample(){         $example = new example();         $example-&gt;setDb(Factory::getDb());//注入db连接         $example-&gt;setFile(Factory::getFile());//注入文件处理类         $example-&gt;setImage(Factory::getImage());//注入Image处理类         return $expample;     } }</code></pre><p>实例化example时变为：</p><pre><code>$example=Factory::getExample(); $example-&gt;getList();</code></pre><p>似乎完美了，但是怎么感觉又回到了上面第一次用工厂方法时的场景？这确实不是一个好的解决方案，所以又提出了一个概念：容器，又叫做IoC容器、DI容器。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>我们本来是通过setXXX方法注入各种类，代码很长，方法很多，虽然可以通过一个工厂方法包装，但是还不是那么爽，好吧，我们不用setXXX方法了，这样也就不用工厂方法二次包装了，那么我们还怎么实现依赖注入呢？</p><p>这里我们引入一个约定：在example类的构造函数里传入一个名为Di $di的参数，如下：</p><pre><code>class example {     private $_di;     function __construct(Di &amp;$di){         $this-&gt;_di = $di;     }     //通过di容器获取db实例     function getList(){         $this-&gt;_di-&gt;get(&apos;db&apos;)-&gt;query(&quot;......&quot;);//这里具体sql语句就省略不写了     } } $di = new Di(); $di-&gt;set(&quot;db&quot;,function(){    return new Db(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;test&quot;);  }); $example = new example($di); $example-&gt;getList();</code></pre><p>Di就是IoC容器，所谓容器就是存放我们可能会用到的各种类的实例，我们通过$di-&gt;set()设置一个名为db的实例，因为是通过回调函数的方式传入的，所以set的时候并不会立即实例化db类，而是当$di-&gt;get(‘db’)的时候才会实例化，同样，在设计di类的时候还可以融入单例模式。</p><p>这样我们只要在全局范围内申明一个Di类，将所有需要注入的类放到容器里，然后将容器作为构造函数的参数传入到example，即可在example类里面从容器中获取实例。当然也不一定是构造函数，你也可以用一个 setDi(Di $di)的方法来传入Di容器，总之约定是你制定的，你自己清楚就行。</p><h3 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h3><p>我们需要一种高级的生产车间，我们只需要向生产车间提交一个脚本，工厂便能够通过指令自动化生产。这种更为高级的工厂，就是工厂模式的升华 —— IoC 容器。</p><pre><code>class Container{    protected $binds;    protected $instances;    public function bind($abstract, $concrete)    {        if ($concrete instanceof Closure) {            $this-&gt;binds[$abstract] = $concrete;        } else {            $this-&gt;instances[$abstract] = $concrete;        }    }    public function make($abstract, $parameters = [])    {        if (isset($this-&gt;instances[$abstract])) {            return $this-&gt;instances[$abstract];        }        array_unshift($parameters, $this);        return call_user_func_array($this-&gt;binds[$abstract], $parameters);    }}</code></pre><p>这时候，一个十分粗糙的容器就诞生了。现在的确很简陋，但不妨碍我们进一步提升他。先着眼现在，看看这个容器如何使用吧！</p><pre><code>// 创建一个容器（后面称作超级工厂）$container = new Container;// 向该 超级工厂添加超人的生产脚本$container-&gt;bind(&apos;superman&apos;, function($container, $moduleName) {    return new Superman($container-&gt;make($moduleName));});// 向该 超级工厂添加超能力模组的生产脚本$container-&gt;bind(&apos;xpower&apos;, function($container) {    return new XPower;});// 同上$container-&gt;bind(&apos;ultrabomb&apos;, function($container) {    return new UltraBomb;});// ****************** 华丽丽的分割线 **********************// 开始启动生产$superman_1 = $container-&gt;make(&apos;superman&apos;, &apos;xpower&apos;);$superman_2 = $container-&gt;make(&apos;superman&apos;, &apos;ultrabomb&apos;);$superman_3 = $container-&gt;make(&apos;superman&apos;, &apos;xpower&apos;);// ...随意添加</code></pre><p>通过最初的 绑定（bind） 操作，我们向 工厂类 注册了这些依赖，这些依赖在生产指令下达之时便会执行。</p><p>我们彻底的解除了 实例 与 创建 的依赖关系，更重要的是，容器类也丝毫没有和他们产生任何依赖！我们通过注册、绑定的方式向容器中添加一段可以被执行的回调（可以是匿名函数、非匿名函数、类的方法）作为生产一个类的实例的 脚本 ，只有在真正的 生产（make） 操作被调用执行时，才会触发。</p><p>这样一种方式，使得我们更容易在创建一个实例的同时解决其依赖关系，并且更加灵活。当有新的需求，只需另外绑定一个“生产脚本”即可。</p><h3 id="更高级的用法"><a href="#更高级的用法" class="headerlink" title="更高级的用法"></a>更高级的用法</h3><p>实际上类也不应当依赖$di对象，依赖注入的意思是通过反射分析类所依赖的其他类，从容器中获取相应的对象并自动注入到类里面。laravel 就是这种写法。此处推荐laravel作者写的书，中文译名叫《从百草园到三味书屋》。</p><h2 id="laravel中的IOC容器源码分析"><a href="#laravel中的IOC容器源码分析" class="headerlink" title="laravel中的IOC容器源码分析"></a>laravel中的IOC容器源码分析</h2><p>laravel中的 IoC 容器会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。</p><p>自动搜寻依赖需求的功能，是通过反射（Reflection）实现的。</p><p>laravel中有这些概念：</p><pre><code>IoC(Inversion of Controller) 控制反转(概念)DI(Dependency Inject) 依赖注入(IoC概念中的一种类型实现) 通过依赖声明自动实例化依赖的类(通常通过反射实现)Container 容器  存储实例化对象 单例的一种实现工具ServiceProvider 服务提供者  一次实例化一批(也可能是一个) 需要使用的类，并可做一个容器中对象的别名绑定    Facades 门面 为应用程序的 服务容器 中可用的类提供了一个「静态」接口。契约（Contracts）</code></pre><h3 id="Laravel的核心"><a href="#Laravel的核心" class="headerlink" title="Laravel的核心"></a>Laravel的核心</h3><p>现在，我们开始慢慢解读 Laravel 的核心。其实，Laravel 的核心就是一个 IoC 容器，也恰好是我之前所说的高级的 IoC 容器。</p><p>可以说，Laravel 的核心本身十分轻量，并没有什么很神奇很实质性的应用功能。很多人用到的各种功能模块比如 Route（路由）、Eloquent ORM（数据库 ORM 组件）、Request（请求）以及 Response（响应）等等等等，实际上都是与核心无关的类模块提供的，这些类从注册到实例化，最终被你所使用，其实都是 Laravel 的服务容器负责的。</p><p>我们以大家最常见的 Route 类作为例子。大家可能经常见到路由定义是这样的：</p><pre><code>Route::get(&apos;/&apos;, function() {    // bla bla bla...});</code></pre><p>实际上， Route 类被定义在这个命名空间：Illuminate\Routing\Router，文件 vendor/laravel/framework/src/Illuminate/Routing/Router.php。</p><p>我们通过打开发现，这个类的这一系列方法，如 get，post，any 等都不是静态（static）方法，这是怎么一回事儿？不要急，我们继续。<br>服务提供者</p><p>我们在前文介绍 IoC 容器的部分中，提到了，一个类需要绑定、注册至容器中，才能被“制造”。</p><p>对，一个类要被容器所能够提取，必须要先注册至这个容器。既然 Laravel 称这个容器叫做服务容器，那么我们需要某个服务，就得先注册、绑定这个服务到容器，那么提供服务并绑定服务至容器的东西，就是服务提供者（Service Provider）。</p><p>虽然，绑定一个类到容器不一定非要通过服务提供者。</p><p>但是，我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，Laravel 将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的服务提供者。</p><p>服务提供者主要分为两个部分，register（注册） 和 boot（引导、初始化），具体参考文档。register 负责进行向容器注册“脚本”，但要注意注册部分不要有对未知事物的依赖，如果有，就要移步至 boot 部分。<br>门面（Facade）</p><p>我们现在解答之前关于 Route 的方法为何能以静态方法访问的问题。实际上这个问题文档上有写，简单说来就是模拟一个类，提供一个静态魔术方法__callStatic，并将该静态方法映射到真正的方法上。</p><p>我们使用的 Route 类实际上是 Illuminate\Support\Facades\Route 通过 class_alias() 函数创造的别名而已，这个类被定义在文件 vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php 。</p><p>我们打开文件一看……诶？怎么只有这么简单的一段代码呢？</p><pre><code>&lt;?php     namespace Illuminate\Support\Facades;    /**     * @see \Illuminate\Routing\Router     */    class Route extends Facade {        /**         * Get the registered name of the component.         *         * @return string         */        protected static function getFacadeAccessor()        {            return &apos;router&apos;;        }}</code></pre><p>其实仔细看，会发现这个类继承了一个叫做 Facade 的类，到这里谜底差不多要解开了。</p><p>上述简单的定义中，我们看到了 getFacadeAccessor 方法返回了一个 route，这是什么意思呢？事实上，这个值被一个 ServiceProvider 注册过，大家应该知道注册了个什么，当然是那个真正的路由类！</p><h3 id="PSR-11"><a href="#PSR-11" class="headerlink" title="PSR-11"></a>PSR-11</h3><p>Laravel 的服务容器实现了 PSR-11 接口。 因此，你可以使用 PSR-11容器『接口类型提示』来获取 Laravel 容器的实例.<br>目前还没有很好的译文，需要读者自己去看英文文档。</p><h2 id="laravel中常见的写法-强类型"><a href="#laravel中常见的写法-强类型" class="headerlink" title="laravel中常见的写法-强类型"></a>laravel中常见的写法-强类型</h2><pre><code>class User {    function ec(){        echo &quot;123333&quot;;    }}$u = new User();function billUser(User $user){   $user-&gt;ec();}billUser($u);</code></pre><p>结果：</p><pre><code>123333</code></pre><p>如果最后一行换成其他代码，如：</p><pre><code>billUser(‘u’);</code></pre><p>结果：</p><pre><code>Fatal error: Uncaught TypeError: Argument 1 passed to billUser() must be an instance of User, string given, called in /Users/machuang/Desktop/m.php on line 20 and defined in /Users/machuang/Desktop/m.php:12Stack trace:#0 /Users/machuang/Desktop/m.php(20): billUser(&apos;u&apos;)#1 {main}  thrown in /Users/machuang/Desktop/m.php on line 12</code></pre><p>有个关于鸭子类型（下文译作：弱类型）的解释：如果一个东西看起来像个鸭子，叫声也像鸭子叫，那他就是个鸭子。换言之在程序里，一个对象看上去是个User，方法响应也像个User，那他就是个User。</p><p>PHP到底有没有任何强类型功能呢？当然有！PHP混合了强类型和弱类型的结构。<br>给方法加上了加上了User类型提示后， 我们可以确信的说所有传入billUser方法的参数，都是User类或是继承自User类的一个实例。如果不是，会引起报错。</p><h3 id="laravel-中的接口使用"><a href="#laravel-中的接口使用" class="headerlink" title="laravel 中的接口使用"></a>laravel 中的接口使用</h3><p><a href="https://my.oschina.net/zgldh/blog/340975" target="_blank" rel="external">https://my.oschina.net/zgldh/blog/340975</a></p><p>参考这一篇，理解接口和容器的使用。</p><pre><code>interface OrderRepositoryInterface {    public function getMostRecent(User $user);}</code></pre><p>一旦建立了约定，就算约定还没实现，前端开发者也可以测试他的控制器了！这样应用中的不同组件就可以按不同的速度开发，并且单元测试也可以做。而且这种处理方法还可以使组件内部的改动不会影响到其他不相关组件。要记着无知是福。我们写的那些类们不用知道别的类如何实现的，只要知道它们能实现什么。这下咱们有了定义好的约定，再来写控制器：</p><pre><code>&lt;!-- lang:php --&gt;class OrderController {    public function __construct(OrderRepositoryInterface $orders)    {        $this-&gt;orders = $orders;    }    public function getRecent()    {        $recent = $this-&gt;orders-&gt;getMostRecent(Auth::user());        return View::make(&apos;orders.recent&apos;, compact(&apos;recent&apos;));    }}</code></pre><p>一旦假实现写好了，就可以被绑定到IoC容器里，然后整个程序都可以调用他了：</p><pre><code>&lt;!-- lang:php --&gt;App::bind(&apos;OrderRepositoryInterface&apos;, &apos;DummyOrderRepository&apos;);</code></pre><p>接下来一旦后台开发者写完了真正的实现代码，比如叫RedisOrderRepository。那么IoC容器就可以轻易的切换到真正的实现上。整个应用就会使用从Redis读出来的数据。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>具体参见：<br><a href="http://php.net/manual/zh/book.reflection.php" target="_blank" rel="external">http://php.net/manual/zh/book.reflection.php</a></p><p>我博客里面也有一篇总结的文章，可供借鉴。</p><h2 id="PHP基础补充"><a href="#PHP基础补充" class="headerlink" title="PHP基础补充"></a>PHP基础补充</h2><h3 id="compact"><a href="#compact" class="headerlink" title="compact()"></a>compact()</h3><p>创建一个包含变量名和它们的值的数组：</p><pre><code>&lt;?php$firstname = &quot;Bill&quot;;$lastname = &quot;Gates&quot;;$age = &quot;60&quot;;$result = compact(&quot;firstname&quot;, &quot;lastname&quot;, &quot;age&quot;);print_r($result);?&gt;</code></pre><p>结果：</p><pre><code>Array ( [firstname] =&gt; Bill [lastname] =&gt; Gates [age] =&gt; 60 ) </code></pre><h3 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h3><p>把数组中的值赋给一些变量：</p><pre><code>&lt;?php$my_array = array(&quot;Dog&quot;,&quot;Cat&quot;,&quot;Horse&quot;);list($a, $b, $c) = $my_array;echo &quot;I have several animals, a $a, a $b and a $c.&quot;;?&gt;</code></pre><p>结果：</p><pre><code>I have several animals, a Dog, a Cat and a Horse. </code></pre><h3 id="array-reduce"><a href="#array-reduce" class="headerlink" title="array_reduce()"></a>array_reduce()</h3><p>向用户自定义函数发送数组中的值，并返回一个字符串：</p><pre><code>&lt;?phpfunction myfunction($v1,$v2){return $v1 . &quot;-&quot; . $v2;}$a=array(&quot;Dog&quot;,&quot;Cat&quot;,&quot;Horse&quot;);print_r(array_reduce($a,&quot;myfunction&quot;));?&gt;</code></pre><p>结果： </p><pre><code>-Dog-Cat-Horse </code></pre><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><p><a href="http://www.w3school.com.cn/php/php_ref_array.asp" target="_blank" rel="external">http://www.w3school.com.cn/php/php_ref_array.asp</a><br><a href="https://my.oschina.net/zgldh/blog/389246" target="_blank" rel="external">https://my.oschina.net/zgldh/blog/389246</a><br><a href="http://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html" target="_blank" rel="external">http://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html</a><br><a href="https://www.tuicool.com/articles/Jbeyuur" target="_blank" rel="external">https://www.tuicool.com/articles/Jbeyuur</a><br>www.thinkphp.cn/topic/12180.html<br><a href="https://segmentfault.com/a/1190000002411255" target="_blank" rel="external">https://segmentfault.com/a/1190000002411255</a><br><a href="https://blog.csdn.net/qq_20678155/article/details/70158374" target="_blank" rel="external">https://blog.csdn.net/qq_20678155/article/details/70158374</a><br><a href="https://laravel-china.org/docs/laravel/5.6" target="_blank" rel="external">https://laravel-china.org/docs/laravel/5.6</a><br><a href="http://php.net/manual/zh/book.reflection.php" target="_blank" rel="external">http://php.net/manual/zh/book.reflection.php</a><br><a href="https://www.insp.top/article/realization-of-pipeline-component-for-laravel" target="_blank" rel="external">https://www.insp.top/article/realization-of-pipeline-component-for-laravel</a><br><a href="http://laravelacademy.org/post/2792.html" target="_blank" rel="external">http://laravelacademy.org/post/2792.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>laravel路由组件源码分析</title>
    <link href="http://martist.cn/2018/05/03/LARAVEL/laravel%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://martist.cn/2018/05/03/LARAVEL/laravel路由组件源码分析/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-05-04T01:33:28.235Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>Macaw是一个类似laravel路由形式的组件，一共不到200行源码，这里具体分析下怎么实现的路由部分。</p><p>项目地址:<a href="https://github.com/noahbuscher/Macaw" target="_blank" rel="external">https://github.com/noahbuscher/Macaw</a></p><h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><p>composer安装：</p><pre><code>composer require noahbuscher/macaw</code></pre><p>index.php 文件：</p><pre><code>&lt;?php    use NoahBuscher\Macaw\Macaw;// Autoload 自动载入require &apos;../vendor/autoload.php&apos;;Macaw::get(&apos;success&apos;, function() {  echo &quot;成功！&quot;;});Macaw::get(&apos;(:all)&apos;, function($fu) {  echo &apos;未匹配到路由&lt;br&gt;&apos;.$fu;});Macaw::dispatch();</code></pre><p>然后你就可以在浏览器进行测试了,具体源码可以参见本文最下面。</p><h2 id="基础补习"><a href="#基础补习" class="headerlink" title="基础补习"></a>基础补习</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">array_push() 函数向第一个参数的数组尾部添加一个或多个元素（入栈），然后返回新数组的长度。</div><div class="line">strtoupper() 函数把字符串转换为大写。</div><div class="line"></div><div class="line">strpos() 函数查找字符串在另一字符串中第一次出现的位置（区分大小写）</div><div class="line">strrpos() 查找字符串在另一字符串中最后一次出现的位置（区分大小写）</div><div class="line"></div><div class="line">stripos()  查找字符串在另一字符串中第一次出现的位置（不区分大小写）</div><div class="line">strripos()  查找字符串在另一字符串中最后一次出现的位置（不区分大小写）</div><div class="line"></div><div class="line">parse_url()  解析 URL，返回其组成部分</div><div class="line">preg_replace()  函数执行一个正则表达式的搜索和替换</div><div class="line"></div><div class="line">$_SERVER[&apos;REQUEST_URI&apos;]  域名之后的路由部分</div><div class="line">$_SERVER[&apos;REQUEST_METHOD&apos;] 请求方式，如GET，POST</div><div class="line"></div><div class="line">call_user_func() 调用一个回调函数处理字符串,可以用匿名函数，可以用有名函数，可以传递类的方法，</div><div class="line">call_user_func_array()  调用回调函数，并把一个数组参数作为回调函数的参数</div></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>一开始进入路由：</p><pre><code>Macaw::get(&apos;success&apos;, function() {    echo &quot;进入成功！&quot;;});</code></pre><p>调用Macaw的静态方法get(),但是Macaw类里面没有get(),于是进入__callstatic()方法。</p><p>打印下这个路由进去之后，的大的method和param参数是个啥，</p><pre><code>string(3) &quot;get&quot;array(2) {  [0]=&gt;  string(4) &quot;success&quot;  [1]=&gt;  object(Closure)#12 (0) {  }}</code></pre><p>如果路由是：</p><pre><code>Macaw::get(&apos;home&apos;, &apos;HomeController@home&apos;);</code></pre><p>打印结果就是：</p><pre><code>string(3) &quot;get&quot;array(2) {  [0]=&gt;  string(4) &quot;home&quot;  [1]=&gt;  string(19) &quot;HomeController@home&quot;}</code></pre><p>然后Macaw把整个路有文件读一遍，把路由和function或者控制器都array_push到类的静态变量里面。</p><p>路由文件最后一行的 Macaw::dispatch()方法才是真正处理当前 URL 的地方。</p><p>下面看一下dispatch()</p><ol><li>先判断$uri是否在 self::$routes数组里面</li><li>1成立，再看method是不是匹配</li><li>1，2成立，然后进入action阶段，判断是闭包（闭包是一种对象来判断）还是字符串</li><li>如果是闭包，则通过call_user_func()执行</li><li>如果是字符串，则通过new controller调用方法去执行(这样的处理方式导致路由组件不能处理‘？param=value’这样的传值，不过我们可以改造它让他可以接受get传参)</li><li>回到1，如果$uri不在 self::$routes数组里面，则再次正则匹配判断，判断是否符合$patterns数组内元素的格式</li><li>如果符合则call_user_func_array（）调用方法并传递参数执行；如果不符合，继续执行下面的代码。</li><li>最后没有找到路由的情况下，$found_route为假，根据self::$error_callback处理路由错误。</li><li>路由不存在处理有两种办法，（1）闭包直接执行；（2）字符串则将不存在的路由加入路由数组内，将错误处理方法加入$callback数组。再一次发起dispatch（），就可以在找到了处理办法。</li></ol><h2 id="代码中使用了大量的静态方法和静态变量，为什么呢？"><a href="#代码中使用了大量的静态方法和静态变量，为什么呢？" class="headerlink" title="代码中使用了大量的静态方法和静态变量，为什么呢？"></a>代码中使用了大量的静态方法和静态变量，为什么呢？</h2><p>类的方法定义成static，就尽量定义成static，它的速度会提升将近4倍。<br>能够在多次调用类时保留数据。</p><h2 id="关于laravel中的使用"><a href="#关于laravel中的使用" class="headerlink" title="关于laravel中的使用"></a>关于laravel中的使用</h2><p>laravel在这个包的基础上，加上了中间件和路由组等用法，实现了更多的功能。当然你在laravel项目中式找不到这个包的，作者自己写了Routing包。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>&lt;?phpnamespace NoahBuscher\Macaw;/** * @method static Macaw get(string $route, Callable $callback) * @method static Macaw post(string $route, Callable $callback) * @method static Macaw put(string $route, Callable $callback) * @method static Macaw delete(string $route, Callable $callback) * @method static Macaw options(string $route, Callable $callback) * @method static Macaw head(string $route, Callable $callback) */class Macaw {  public static $halts = false;  public static $routes = array();  public static $methods = array();  public static $callbacks = array();  public static $maps = array();  public static $patterns = array(      &apos;:any&apos; =&gt; &apos;[^/]+&apos;,      &apos;:num&apos; =&gt; &apos;[0-9]+&apos;,      &apos;:all&apos; =&gt; &apos;.*&apos;  );  public static $error_callback;  /**   * Defines a route w/ callback and method   */  public static function __callstatic($method, $params) {    if ($method == &apos;map&apos;) {        $maps = array_map(&apos;strtoupper&apos;, $params[0]);        $uri = strpos($params[1], &apos;/&apos;) === 0 ? $params[1] : &apos;/&apos; . $params[1];        $callback = $params[2];    } else {        $maps = null;        $uri = strpos($params[0], &apos;/&apos;) === 0 ? $params[0] : &apos;/&apos; . $params[0];        $callback = $params[1];    }    array_push(self::$maps, $maps);    array_push(self::$routes, $uri);    array_push(self::$methods, strtoupper($method));    array_push(self::$callbacks, $callback);  }  /**   * Defines callback if route is not found  */  public static function error($callback) {    self::$error_callback = $callback;  }  public static function haltOnMatch($flag = true) {    self::$halts = $flag;  }  /**   * Runs the callback for the given request   */  public static function dispatch(){    $uri = parse_url($_SERVER[&apos;REQUEST_URI&apos;], PHP_URL_PATH);    $method = $_SERVER[&apos;REQUEST_METHOD&apos;];    $searches = array_keys(static::$patterns);    $replaces = array_values(static::$patterns);    $found_route = false;    self::$routes = preg_replace(&apos;/\/+/&apos;, &apos;/&apos;, self::$routes);    // Check if route is defined without regex    if (in_array($uri, self::$routes)) {      $route_pos = array_keys(self::$routes, $uri);      foreach ($route_pos as $route) {        // Using an ANY option to match both GET and POST requests        if (self::$methods[$route] == $method || self::$methods[$route] == &apos;ANY&apos; || in_array($method, self::$maps[$route])) {          $found_route = true;          // If route is not an object          if (!is_object(self::$callbacks[$route])) {            // Grab all parts based on a / separator            $parts = explode(&apos;/&apos;,self::$callbacks[$route]);            // Collect the last index of the array            $last = end($parts);            // Grab the controller name and method call            $segments = explode(&apos;@&apos;,$last);            // Instanitate controller            $controller = new $segments[0]();            // Call method            $controller-&gt;{$segments[1]}();            if (self::$halts) return;          } else {            // Call closure            call_user_func(self::$callbacks[$route]);            if (self::$halts) return;          }        }      }    } else {      // Check if defined with regex      $pos = 0;      foreach (self::$routes as $route) {        if (strpos($route, &apos;:&apos;) !== false) {          $route = str_replace($searches, $replaces, $route);        }        if (preg_match(&apos;#^&apos; . $route . &apos;$#&apos;, $uri, $matched)) {          if (self::$methods[$pos] == $method || self::$methods[$pos] == &apos;ANY&apos; || (!empty(self::$maps[$pos]) &amp;&amp; in_array($method, self::$maps[$pos]))) {            $found_route = true;            // Remove $matched[0] as [1] is the first parameter.            array_shift($matched);            if (!is_object(self::$callbacks[$pos])) {              // Grab all parts based on a / separator              $parts = explode(&apos;/&apos;,self::$callbacks[$pos]);              // Collect the last index of the array              $last = end($parts);              // Grab the controller name and method call              $segments = explode(&apos;@&apos;,$last);              // Instanitate controller              $controller = new $segments[0]();              // Fix multi parameters              if (!method_exists($controller, $segments[1])) {                echo &quot;controller and action not found&quot;;              } else {                call_user_func_array(array($controller, $segments[1]), $matched);              }              if (self::$halts) return;            } else {              call_user_func_array(self::$callbacks[$pos], $matched);              if (self::$halts) return;            }          }        }        $pos++;      }    }    // Run the error callback if the route was not found    if ($found_route == false) {      if (!self::$error_callback) {        self::$error_callback = function() {          header($_SERVER[&apos;SERVER_PROTOCOL&apos;].&quot; 404 Not Found&quot;);          echo &apos;404&apos;;        };      } else {        if (is_string(self::$error_callback)) {          self::get($_SERVER[&apos;REQUEST_URI&apos;], self::$error_callback);          self::$error_callback = null;          self::dispatch();          return ;        }      }      call_user_func(self::$error_callback);    }  }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>实现一个类似laravel的现代化PHP框架</title>
    <link href="http://martist.cn/2018/05/03/%E6%A1%86%E6%9E%B6/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BClaravel%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8C%96PHP%E6%A1%86%E6%9E%B6/"/>
    <id>http://martist.cn/2018/05/03/框架/实现一个类似laravel的现代化PHP框架/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-05-03T07:01:33.950Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>读了JohnLui的7篇博文之后，我想要把学到的东西总结一下，于是写了这篇文章。<br>他的博客地址：<a href="https://lvwenhan.com/sort/php" target="_blank" rel="external">https://lvwenhan.com/sort/php</a></p><h2 id="路由组件Macaw"><a href="#路由组件Macaw" class="headerlink" title="路由组件Macaw"></a>路由组件Macaw</h2><p>推荐 <a href="https://github.com/NoahBuscher/Macaw" target="_blank" rel="external">https://github.com/NoahBuscher/Macaw</a> , 这个包体积小，很优雅。</p><p>下面开始安装它，更改 composer.json：</p><pre><code>{  &quot;require&quot;: {    &quot;noahbuscher/macaw&quot;: &quot;dev-master&quot;  }}</code></pre><p>运行</p><pre><code>composer update</code></pre><p>新建 MFFC/public 文件夹，这个文件夹将是用户唯一可见的部分。在文件夹下新建 index.php 文件：</p><pre><code>&lt;?php// Autoload 自动载入require &apos;../vendor/autoload.php&apos;;// 路由配置require &apos;../config/routes.php&apos;;上面一行表示引入 Composer 的自动载入功能，下面一行表示载入路由配置文件。新建 MFFC/config 文件夹，在里面新建 routs.php 文件，内容如下：&lt;?phpuse NoahBuscher\Macaw\Macaw;Macaw::get(&apos;fuck&apos;, function() {  echo &quot;成功！&quot;;});Macaw::get(&apos;(:all)&apos;, function($fu) {  echo &apos;未匹配到路由&lt;br&gt;&apos;.$fu;});Macaw::dispatch();</code></pre><p>然后你就可以在浏览器进行测试了。</p><p>Macaw 的文档位于 <a href="https://github.com/NoahBuscher/Macaw" target="_blank" rel="external">https://github.com/NoahBuscher/Macaw</a>  , 请按照你的 HTTP 服务软件类型自行设置伪静态，其实跟绝大多数框架一样：“将所有非静态文件全部指向 index.php”。</p><p>Macaw 只有一个文件，去除空行总共也就一百行多一点，通过代码我们能直接看明白它是怎么工作。</p><p>路由文件最后一行的 Macaw::dispatch(); 方法才是真正处理当前 URL 的地方。</p><h2 id="设计MVC架构"><a href="#设计MVC架构" class="headerlink" title="设计MVC架构"></a>设计MVC架构</h2><h3 id="规划文件夹"><a href="#规划文件夹" class="headerlink" title="规划文件夹"></a>规划文件夹</h3><p>新建 MFFC/app 文件夹，在 app 中创建 controllers、models、views 三个文件夹，开始正式开始踏上 MVC 的征程。</p><h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h3><p>增加一条路由： Macaw::get(‘’, ‘HomeController@home’);，打开浏览器直接访问 <a href="http://127.0.0.1:81/，出现以下提示：" target="_blank" rel="external">http://127.0.0.1:81/，出现以下提示：</a></p><pre><code>Fatal error: Class &apos;HomeController&apos; not found in /Library/WebServer/Documents/wwwroot/MFFC/vendor/codingbean/macaw/Macaw.php on line 93</code></pre><p>为什么没找到 HomeController 类？因为我们没有让他自动加载，修改 composer.json 为：</p><pre><code>&quot;autoload&quot;: {  &quot;classmap&quot;: [    &quot;app/controllers&quot;,    &quot;app/models&quot;  ]}</code></pre><p>运行 composer 命令</p><pre><code>composer dump-autoload</code></pre><h2 id="ORM组件illuminate-database"><a href="#ORM组件illuminate-database" class="headerlink" title="ORM组件illuminate/database"></a>ORM组件illuminate/database</h2><p>给 composer.json 增加一个 require 项：</p><pre><code>&quot;illuminate/database&quot;: &quot;*&quot;</code></pre><p>运行 composer update ，等待安装完成。</p><pre><code>&lt;?phpuse Illuminate\Database\Capsule\Manager as Capsule;// Autoload 自动载入require &apos;../vendor/autoload.php&apos;;// Eloquent ORM$capsule = new Capsule;$capsule-&gt;addConnection(require &apos;../config/database.php&apos;);$capsule-&gt;bootEloquent();// 路由配置require &apos;../config/routes.php&apos;;</code></pre><p>新增 config/database.php （注意替换数据库密码）：</p><pre><code>&lt;?phpreturn [  &apos;driver&apos;    =&gt; &apos;mysql&apos;,  &apos;host&apos;      =&gt; &apos;localhost&apos;,  &apos;database&apos;  =&gt; &apos;mffc&apos;,  &apos;username&apos;  =&gt; &apos;root&apos;,  &apos;password&apos;  =&gt; &apos;password&apos;,  &apos;charset&apos;   =&gt; &apos;utf8&apos;,  &apos;collation&apos; =&gt; &apos;utf8_general_ci&apos;,  &apos;prefix&apos;    =&gt; &apos;&apos;  ];</code></pre><p>修改 models/Article.php ：</p><pre><code>&lt;?phpclass Article extends Illuminate\Database\Eloquent\Model{  public $timestamps = false;}</code></pre><p>controllers/HomeController.php ：</p><pre><code>&lt;?phpclass HomeController extends BaseController{    public function index()    {        $article = Article::first();        require dirname(__FILE__).&apos;/../views/home.php&apos;;//模板文件    }}</code></pre><p>更新自动加载配置</p><pre><code>composer dump-autoload</code></pre><p>SQL 语句：</p><pre><code>DROP TABLE IF EXISTS `articles`;CREATE TABLE `articles` (  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,  `title` varchar(255) DEFAULT NULL,  `content` longtext,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;LOCK TABLES `articles` WRITE;/*!40000 ALTER TABLE `articles` DISABLE KEYS */;INSERT INTO `articles` (`id`, `title`, `content`)VALUES    (1,&apos;我是标题&apos;,&apos;&lt;h3&gt;我是内容呀~~&lt;/h3&gt;&lt;p&gt;我真的是内容，不信算了，哼~ O(∩_∩)O&lt;/p&gt;&apos;),    (2,&apos;我是标题&apos;,&apos;&lt;h3&gt;我是内容呀~~&lt;/h3&gt;&lt;p&gt;我真的是内容，不信算了，哼~ O(∩_∩)O&lt;/p&gt;&apos;);/*!40000 ALTER TABLE `articles` ENABLE KEYS */;UNLOCK TABLES;</code></pre><p>刷新页面，可以看到成功出现数据库的数据了。</p><h2 id="错误页面提示组件whoops"><a href="#错误页面提示组件whoops" class="headerlink" title="错误页面提示组件whoops"></a>错误页面提示组件whoops</h2><p>引入错误页面提示组件，修改  composer.json ：</p><pre><code>&quot;require&quot;: {  &quot;codingbean/macaw&quot;: &quot;dev-master&quot;,  &quot;illuminate/database&quot;: &quot;*&quot;,  &quot;filp/whoops&quot;: &quot;*&quot;},</code></pre><p>运行  composer update ，然后在  bootstrap.php  的最后添加：</p><pre><code>// whoops 错误提示$whoops = new \Whoops\Run;$whoops-&gt;pushHandler(new \Whoops\Handler\PrettyPageHandler);$whoops-&gt;register();</code></pre><p>下面我们将增加路由配置中  无匹配项  的错误页面，修改  config/routes.php ：</p><pre><code>&lt;?phpuse NoahBuscher\Macaw\Macaw;Macaw::get(&apos;&apos;, &apos;HomeController@home&apos;);Macaw::get(&apos;fuck&apos;, function() {  echo &quot;成功！&quot;;});Macaw::$error_callback = function() {  throw new Exception(&quot;路由无匹配项 404 Not Found&quot;);};Macaw::dispatch();</code></pre><p>这时随便在配的域名后面加上个路由，系统就会报错了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个项目学下来，整个目录结构差不多就这样。</p><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/martp目录.png" alt=""></p><p>里面有几个用到的函数和概念，需要在这里做下笔记。</p><h3 id="PHP写startswith和endswith"><a href="#PHP写startswith和endswith" class="headerlink" title="PHP写startswith和endswith"></a>PHP写startswith和endswith</h3><pre><code>&lt;?phpfunction starts_with($a,$b){    return strpos($a, $b) &gt; 0?true: false;}var_dump(starts_with(&apos;I love she&apos;,&apos;L&apos;));function end_with($a,$b,$lowerorup=1){    // 如果$lowerorup = 0则不用区分大小写        $begin= $lowerorup?strpos($a,$b):stripos($a,$b);    if($begin){    echo &apos;开始于第&apos;,$begin,&apos;个字符&lt;br /&gt;&apos;;    echo &apos;结束于&apos;,$begin+strlen($b);    }}echo &apos;&lt;br /&gt;&apos;;end_with(&apos;I love she&apos;,&apos;Lov&apos;,0);</code></pre><h3 id="ctype-lower"><a href="#ctype-lower" class="headerlink" title="ctype_lower()"></a>ctype_lower()</h3><p>做小写字符检测,数字不能通过检测。</p><pre><code>bool ctype_lower ( string $text )</code></pre><h3 id="strtolower"><a href="#strtolower" class="headerlink" title="strtolower()"></a>strtolower()</h3><p>函数把字符串转换为小写。</p><p>相关函数：</p><pre><code>lcfirst() - 把字符串中的首字符转换为小写strtoupper() - 把字符串转换为大写ucfirst() - 把字符串中的首字符转换为大写ucwords() - 把字符串中每个单词的首字符转换为大写</code></pre><h3 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h3><p>该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</p><p>举例：</p><pre><code>&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;?&gt;</code></pre><p>结果：</p><pre><code>$a = Cat; $b = Dog; $c = Horse</code></pre>]]></content>
    
    <summary type="html">
    
      实现一个类似laravel的现代化PHP框架
    
    </summary>
    
      <category term="框架" scheme="http://martist.cn/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="框架" scheme="http://martist.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>实现一个类似tp的轻量级框架</title>
    <link href="http://martist.cn/2018/05/02/%E6%A1%86%E6%9E%B6/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCtp%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A1%86%E6%9E%B6/"/>
    <id>http://martist.cn/2018/05/02/框架/实现一个类似tp的轻量级框架/</id>
    <published>2018-05-01T16:00:00.000Z</published>
    <updated>2018-05-02T10:10:22.326Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h2><h3 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h3><blockquote><p>MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式。</p></blockquote><p>MVC把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p><p>PHP中MVC模式也称Web MVC，从上世纪70年代进化而来。</p><p>MVC的目的是实现一种动态的程序设计，便于后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。</p><p>除此之外，此模式通过对复杂度的简化，使程序结构更加直观。</p><h3 id="MVC各部分的职能"><a href="#MVC各部分的职能" class="headerlink" title="MVC各部分的职能"></a>MVC各部分的职能</h3><pre><code>模型Model – 管理大部分的业务逻辑和所有的数据库逻辑。模型提供了连接和操作数据库的抽象层。控制器Controller - 负责响应用户请求、准备数据，以及决定如何展示数据。视图View – 负责渲染数据，通过HTML方式呈现给用户。</code></pre><h3 id="MVC流程图"><a href="#MVC流程图" class="headerlink" title="MVC流程图"></a>MVC流程图</h3><p>一个典型的Web MVC流程：</p><pre><code>Controller截获用户发出的请求；Controller调用Model完成状态的读写操作；Controller把数据传递给View；View渲染最终结果并呈献给用户。</code></pre><h3 id="为什么要自己开发MVC框架"><a href="#为什么要自己开发MVC框架" class="headerlink" title="为什么要自己开发MVC框架"></a>为什么要自己开发MVC框架</h3><p>网络上有大量优秀的MVC框架可供使用，本教程并不是为了开发一个全面的、终极的MVC框架解决方案。</p><p>我们将它看作是一个很好的从内部学习PHP的机会。</p><p>在此过程中，你将学习面向对象编程和MVC设计模式，并学习到开发中的一些注意事项。</p><p>更重要的是，通过自制MVC框架，每个人都可以完全控制自己的框架，将你的想法融入到你开发的框架中。</p><p>虽然不一定是最好的，但是你可以按照自己的方式开发各种功能。</p><h2 id="开始开发自己的MVC框架"><a href="#开始开发自己的MVC框架" class="headerlink" title="开始开发自己的MVC框架"></a>开始开发自己的MVC框架</h2><h3 id="目录准备"><a href="#目录准备" class="headerlink" title="目录准备"></a>目录准备</h3><p>在开始开发前，让我们先来把项目建立好。</p><p>假设我们建立的项目为 project，MVC的框架命名为 fastphp，那么接下来，第一步要把目录结构设置好。</p><p>project  WEB部署目录<br>├─application           应用目录<br>│  ├─controllers        控制器目录<br>│  ├─models             模块目录<br>│  ├─views              视图目录<br>├─config                配置文件目录<br>├─fastphp               框架核心目录<br>├─static                静态文件目录<br>├─index.php             入口文件</p><p>然后把Nginx或者Apache的站点根目录配置到project目录。</p><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>在目录设置好以后，我们接下来规定代码的规范：</p><pre><code>MySQL的表名需小写或小写加下划线，如：item，car_orders。模块名（Models）需用大驼峰命名法，即首字母大写，并在名称后添加Model，如：ItemModel，CarModel。控制器（Controllers）需用大驼峰命名法，即首字母大写，并在名称后添加Controller，如：ItemController，CarController。方法名（Action）需用小驼峰命名法，即首字母小写，如：index，indexPost。视图（Views）部署结构为控制器名/行为名，如：item/view.php，car/buy.php。</code></pre><p>上述规则是为了程序能更好地相互调用。</p><p>接下来就开始真正的PHP MVC编程了。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向的目的有两个：设置根目录为project所在位置，以及将所有请求都发送给 index.php 文件。</p><p>如果是Apache服务器，在 project 目录下新建一个 .htaccess 文件，内容为：</p><pre><code>&lt;IfModule mod_rewrite.c&gt;    RewriteEngine On    RewriteCond %{REQUEST_FILENAME} !-f    RewriteCond %{REQUEST_FILENAME} !-d    RewriteRule . index.php&lt;/IfModule&gt;</code></pre><p>如果是Nginx服务器，修改配置文件，在server块中加入如下的重定向：</p><pre><code>location / {    try_files $uri $uri/ /index.php$args;}</code></pre><h4 id="主要原因"><a href="#主要原因" class="headerlink" title="主要原因"></a>主要原因</h4><h5 id="静态文件能直接访问"><a href="#静态文件能直接访问" class="headerlink" title="静态文件能直接访问"></a>静态文件能直接访问</h5><p>如果文件或者目录真实存在，则直接访问存在的文件/目录。</p><p>比如，静态文件static/css/main.css真实存在，就可以直接访问它。</p><h5 id="程序有单一的入口"><a href="#程序有单一的入口" class="headerlink" title="程序有单一的入口"></a>程序有单一的入口</h5><p>这种情况是请求地址不是真实存在的文件或目录，这样请求就会传到 index.php 上。</p><p>例如，访问地址：localhost/item/view/1，在文件系统中并不存在这样的文件或目录。</p><p>那么，Apache或Nginx服务器会把请求发给index.php，并且把域名之后的字符串赋值给REQUEST_URI变量。</p><p>这样在PHP中用$_SERVER[‘REQUEST_URI’]就能拿到/item/view/1；</p><h5 id="可以用来生成美化的URL，利于SEO。"><a href="#可以用来生成美化的URL，利于SEO。" class="headerlink" title="可以用来生成美化的URL，利于SEO。"></a>可以用来生成美化的URL，利于SEO。</h5><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>接下来，在 project 目录下新建 index.php 入口文件，文件内容为：</p><pre><code>&lt;?phpdefine(&apos;APP_PATH&apos;, __DIR__ . &apos;/&apos;);define(&apos;APP_DEBUG&apos;, true);require(APP_PATH . &apos;fastphp/Fastphp.php&apos;);$config = require(APP_PATH . &apos;config/config.php&apos;);(new Fastphp($config))-&gt;run();</code></pre><p>注意，上面的PHP代码中，并没有添加PHP结束符号?&gt;。</p><h4 id="主要原因-1"><a href="#主要原因-1" class="headerlink" title="主要原因"></a>主要原因</h4><p>对于只有 PHP 代码的文件，最好没有结束标志 ?&gt;</p><p>PHP自身并不需要结束符号，不加结束符让程序更加安全，很大程度防止了末尾被注入额外的内容。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在入口文件中，我们加载了config.php文件的内容，那它有何作用呢？</p><p>从名称不难看出，它的作用是保存一些常用配置。</p><p>config.php 文件内容如下，作用是定义数据库连接参数参数，以及配置默认控制器名和操作名：</p><pre><code>&lt;?phpdefine(&apos;DB_NAME&apos;, &apos;project&apos;);define(&apos;DB_USER&apos;, &apos;root&apos;);define(&apos;DB_PASSWORD&apos;, &apos;123456&apos;);define(&apos;DB_HOST&apos;, &apos;localhost&apos;);$config[&apos;defaultController&apos;] = &apos;Item&apos;;$config[&apos;defaultAction&apos;] = &apos;index&apos;;return $config;</code></pre><p>入口中的$config变量接收到配置参数后，再传给框架的核心类，也就是Fastphp类。</p><h3 id="框架核心类"><a href="#框架核心类" class="headerlink" title="框架核心类"></a>框架核心类</h3><p>入口文件对框架类做了两步操作：实例化，调用run()方法。</p><p>实例化操作接受$config参数配置，并保存到类属性中。</p><p>run()方法则调用用类自身方法，完成：自动加载类文件、监测开发环境、过滤敏感字符、移除全局变量的老用法、和处理路由。</p><pre><code>&lt;?phpclass Fastphp{    protected $_config = [];    public function __construct($config)    {        $this-&gt;_config = $config;    }    public function run()    {        spl_autoload_register(array($this, &apos;loadClass&apos;));        $this-&gt;setReporting();        $this-&gt;removeMagicQuotes();        $this-&gt;unregisterGlobals();        $this-&gt;setDbConfig();        $this-&gt;route();    }    public function route()    {        $controllerName = $this-&gt;_config[&apos;defaultController&apos;];        $actionName = $this-&gt;_config[&apos;defaultAction&apos;];        $param = array();        $url = $_SERVER[&apos;REQUEST_URI&apos;];        $position = strpos($url, &apos;?&apos;);        $url = $position === false ? $url : substr($url, 0, $position);        $url = trim($url, &apos;/&apos;);        if ($url) {            $urlArray = explode(&apos;/&apos;, $url);            $urlArray = array_filter($urlArray);            $controllerName = ucfirst($urlArray[0]);            array_shift($urlArray);            $actionName = $urlArray ? $urlArray[0] : $actionName;            array_shift($urlArray);            $param = $urlArray ? $urlArray : array();        }        $controller = $controllerName . &apos;Controller&apos;;        if (!class_exists($controller)) {            exit($controller . &apos;控制器不存在&apos;);        }        if (!method_exists($controller, $actionName)) {            exit($actionName . &apos;方法不存在&apos;);        }        $dispatch = new $controller($controllerName, $actionName);        call_user_func_array(array($dispatch, $actionName), $param);    }    public function setReporting()    {        if (APP_DEBUG === true) {            error_reporting(E_ALL);            ini_set(&apos;display_errors&apos;,&apos;On&apos;);        } else {            error_reporting(E_ALL);            ini_set(&apos;display_errors&apos;,&apos;Off&apos;);            ini_set(&apos;log_errors&apos;, &apos;On&apos;);        }    }    public function stripSlashesDeep($value)    {        $value = is_array($value) ? array_map(array($this, &apos;stripSlashesDeep&apos;), $value) : stripslashes($value);        return $value;    }    public function removeMagicQuotes()    {        if (get_magic_quotes_gpc()) {            $_GET = isset($_GET) ? $this-&gt;stripSlashesDeep($_GET ) : &apos;&apos;;            $_POST = isset($_POST) ? $this-&gt;stripSlashesDeep($_POST ) : &apos;&apos;;            $_COOKIE = isset($_COOKIE) ? $this-&gt;stripSlashesDeep($_COOKIE) : &apos;&apos;;            $_SESSION = isset($_SESSION) ? $this-&gt;stripSlashesDeep($_SESSION) : &apos;&apos;;        }    }    public function unregisterGlobals()    {        if (ini_get(&apos;register_globals&apos;)) {            $array = array(&apos;_SESSION&apos;, &apos;_POST&apos;, &apos;_GET&apos;, &apos;_COOKIE&apos;, &apos;_REQUEST&apos;, &apos;_SERVER&apos;, &apos;_ENV&apos;, &apos;_FILES&apos;);            foreach ($array as $value) {                foreach ($GLOBALS[$value] as $key =&gt; $var) {                    if ($var === $GLOBALS[$key]) {                        unset($GLOBALS[$key]);                    }                }            }        }    }    public function setDbConfig()    {        if ($this-&gt;_config[&apos;db&apos;]) {            Model::$dbConfig = $this-&gt;_config[&apos;db&apos;];        }    }    public static function loadClass($class)    {        $frameworks = __DIR__ . &apos;/&apos; . $class . &apos;.php&apos;;        $controllers = APP_PATH . &apos;application/controllers/&apos; . $class . &apos;.php&apos;;        $models = APP_PATH . &apos;application/models/&apos; . $class . &apos;.php&apos;;        if (file_exists($frameworks)) {            include $frameworks;        } elseif (file_exists($controllers)) {            include $controllers;        } elseif (file_exists($models)) {            include $models;        } else {        }    }}</code></pre><p>下面重点讲解主请求方法<br> route()，它也称路由方法，作用是：截取URL，并解析出控制器名、方法名和URL参数。</p><p>假设我们的 URL 是这样：</p><pre><code>yoursite.com/controllerName/actionName/queryString</code></pre><p>当浏览器访问上面的URL，route()从全局变量 $_SERVER[‘REQUEST_URI’]中获取到字符串/controllerName/actionName/queryString。</p><p>然后，会将这个字符串分割成三部分：controller、action 和 queryString。</p><p>例如，URL链接为：yoursite.com/item/view/1/hello，那么route()分割之后，</p><pre><code>Controller名就是：itemaction名就是：viewURL参数就是：array(1, hello)</code></pre><p>分割完成后，再实例化控制器：itemController，并调用其中的view方法 。</p><h3 id="Controller基类"><a href="#Controller基类" class="headerlink" title="Controller基类"></a>Controller基类</h3><p>接下来，就是在 fastphp 中创建MVC基类，包括控制器、模型和视图三个基类。</p><p>新建控制器基类，文件名 Controller.class.php，功能就是总调度，内容如下：</p><pre><code>&lt;?phpclass Controller{    protected $_controller;    protected $_action;    protected $_view;    public function __construct($controller, $action)    {        $this-&gt;_controller = $controller;        $this-&gt;_action = $action;        $this-&gt;_view = new View($controller, $action);    }    public function assign($name, $value)    {        $this-&gt;_view-&gt;assign($name, $value);    }    public function render()    {        $this-&gt;_view-&gt;render();    }}Controller 类用assign()方法实现把变量保存到View对象中。这样，在调用$this-&gt; render() 后视图文件就能显示这些变量。</code></pre><h3 id="Model基类"><a href="#Model基类" class="headerlink" title="Model基类"></a>Model基类</h3><pre><code>新建模型基类，继承自数据库操作类Sql类（因为数据库操作比较复杂）。</code></pre><h4 id="模型基类-Model-class-php"><a href="#模型基类-Model-class-php" class="headerlink" title="模型基类 Model.class.php"></a>模型基类 Model.class.php</h4><pre><code>&lt;?phpclass Model extends Sql{    protected $_model;    protected $_table;    public static $dbConfig = [];    public function __construct()    {        $this-&gt;connect(self::$dbConfig[&apos;host&apos;], self::$dbConfig[&apos;username&apos;], self::$dbConfig[&apos;password&apos;],            self::$dbConfig[&apos;dbname&apos;]);        if (!$this-&gt;_table) {            $this-&gt;_model = get_class($this);            $this-&gt;_model = substr($this-&gt;_model, 0, -5);            $this-&gt;_table = strtolower($this-&gt;_model);        }    }}</code></pre><h4 id="数据库基类-Sql-class-php"><a href="#数据库基类-Sql-class-php" class="headerlink" title="数据库基类 Sql.class.php"></a>数据库基类 Sql.class.php</h4><pre><code>&lt;?phpclass Sql{    protected $_dbHandle;    protected $_result;    private $filter = &apos;&apos;;    public function connect($host, $username, $password, $dbname)    {        try {            $dsn = sprintf(&quot;mysql:host=%s;dbname=%s;charset=utf8&quot;, $host, $dbname);            $option = array(PDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC);            $this-&gt;_dbHandle = new PDO($dsn, $username, $password, $option);        } catch (PDOException $e) {            exit(&apos;错误: &apos; . $e-&gt;getMessage());        }    }    public function where($where = array())    {        if (isset($where)) {            $this-&gt;filter .= &apos; WHERE &apos;;            $this-&gt;filter .= implode(&apos; &apos;, $where);        }        return $this;    }    public function order($order = array())    {        if(isset($order)) {            $this-&gt;filter .= &apos; ORDER BY &apos;;            $this-&gt;filter .= implode(&apos;,&apos;, $order);        }        return $this;    }    public function selectAll()    {        $sql = sprintf(&quot;select * from `%s` %s&quot;, $this-&gt;_table, $this-&gt;filter);        $sth = $this-&gt;_dbHandle-&gt;prepare($sql);        $sth-&gt;execute();        return $sth-&gt;fetchAll();    }    public function select($id)    {        $sql = sprintf(&quot;select * from `%s` where `id` = &apos;%s&apos;&quot;, $this-&gt;_table, $id);        $sth = $this-&gt;_dbHandle-&gt;prepare($sql);        $sth-&gt;execute();        return $sth-&gt;fetch();    }    public function delete($id)    {        $sql = sprintf(&quot;delete from `%s` where `id` = &apos;%s&apos;&quot;, $this-&gt;_table, $id);        $sth = $this-&gt;_dbHandle-&gt;prepare($sql);        $sth-&gt;execute();        return $sth-&gt;rowCount();    }    public function query($sql)    {        $sth = $this-&gt;_dbHandle-&gt;prepare($sql);        $sth-&gt;execute();        return $sth-&gt;rowCount();    }    public function add($data)    {        $sql = sprintf(&quot;insert into `%s` %s&quot;, $this-&gt;_table, $this-&gt;formatInsert($data));        return $this-&gt;query($sql);    }    public function update($id, $data)    {        $sql = sprintf(&quot;update `%s` set %s where `id` = &apos;%s&apos;&quot;, $this-&gt;_table, $this-&gt;formatUpdate($data), $id);        return $this-&gt;query($sql);    }    private function formatInsert($data)    {        $fields = array();        $values = array();        foreach ($data as $key =&gt; $value) {            $fields[] = sprintf(&quot;`%s`&quot;, $key);            $values[] = sprintf(&quot;&apos;%s&apos;&quot;, $value);        }        $field = implode(&apos;,&apos;, $fields);        $value = implode(&apos;,&apos;, $values);        return sprintf(&quot;(%s) values (%s)&quot;, $field, $value);    }    private function formatUpdate($data)    {        $fields = array();        foreach ($data as $key =&gt; $value) {            $fields[] = sprintf(&quot;`%s` = &apos;%s&apos;&quot;, $key, $value);        }        return implode(&apos;,&apos;, $fields);    }}</code></pre><p>应该说，Sql.class.php 是框架的核心部分。为什么？</p><p>因为通过它，我们创建了一个 SQL 抽象层，可以大大减少了数据库的编程工作。</p><p>虽然 PDO 接口本来已经很简洁，但是抽象之后框架的可灵活性更高。</p><p>这里的数据库句柄$this-&gt;_dbHandle还能用单例模式返回，让数据读写更高效，这部分可自行实现。</p><h3 id="View基类"><a href="#View基类" class="headerlink" title="View基类"></a>View基类</h3><h4 id="视图基类-View-class-php"><a href="#视图基类-View-class-php" class="headerlink" title="视图基类 View.class.php"></a>视图基类 View.class.php</h4><pre><code>&lt;?phpclass View{    protected $variables = array();    protected $_controller;    protected $_action;    function __construct($controller, $action)    {        $this-&gt;_controller = $controller;        $this-&gt;_action = $action;    }    public function assign($name, $value)    {        $this-&gt;variables[$name] = $value;    }    public function render()    {        extract($this-&gt;variables);        $defaultHeader = APP_PATH . &apos;application/views/header.php&apos;;        $defaultFooter = APP_PATH . &apos;application/views/footer.php&apos;;        $controllerHeader = APP_PATH . &apos;application/views/&apos; . $this-&gt;_controller . &apos;/header.php&apos;;        $controllerFooter = APP_PATH . &apos;application/views/&apos; . $this-&gt;_controller . &apos;/footer.php&apos;;        $controllerLayout = APP_PATH . &apos;application/views/&apos; . $this-&gt;_controller . &apos;/&apos; . $this-&gt;_action . &apos;.php&apos;;        if (file_exists($controllerHeader)) {            include ($controllerHeader);        } else {            include ($defaultHeader);        }        include ($controllerLayout);        if (file_exists($controllerFooter)) {            include ($controllerFooter);        } else {            include ($defaultFooter);        }    }}</code></pre><p>这样，核心的PHP MVC框架核心就完成了。</p><p>下面我们编写应用来测试框架功能。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="部署数据库"><a href="#部署数据库" class="headerlink" title="部署数据库"></a>部署数据库</h3><p>在 SQL 中新建一个 project 数据库，增加一个item 表、并插入两条记录，命令如下：</p><pre><code>CREATE DATABASE `project` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;USE `project`;CREATE TABLE `item` (    `id` int(11) NOT NULL auto_increment,    `item_name` varchar(255) NOT NULL,    PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;INSERT INTO `item` VALUES(1, &apos;Hello World.&apos;);INSERT INTO `item` VALUES(2, &apos;Lets go!&apos;);</code></pre><h3 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h3><p>然后，我们还需要在 models 目录中创建一个 ItemModel.php 模型，内容如下：</p><pre><code>&lt;?phpclass ItemModel extends Model{    public $_table = &apos;item&apos;;}</code></pre><p>因为 Item 模型继承了 Model基类，所以它拥有 Model 类的所有功能。</p><h3 id="部署控制器"><a href="#部署控制器" class="headerlink" title="部署控制器"></a>部署控制器</h3><p>在 controllers 目录下创建一个 ItemController.php 控制器，内容如下：</p><pre><code>&lt;?phpclass ItemController extends Controller{    public function index()    {        $items = (new ItemModel)-&gt;selectAll();        $this-&gt;assign(&apos;title&apos;, &apos;全部条目&apos;);        $this-&gt;assign(&apos;items&apos;, $items);        $this-&gt;render();    }    public function add()    {        $data[&apos;item_name&apos;] = $_POST[&apos;value&apos;];        $count = (new ItemModel)-&gt;add($data);        $this-&gt;assign(&apos;title&apos;, &apos;添加成功&apos;);        $this-&gt;assign(&apos;count&apos;, $count);        $this-&gt;render();    }    public function view($id = null)    {        $item = (new ItemModel)-&gt;select($id);        $this-&gt;assign(&apos;title&apos;, &apos;正在查看&apos; . $item[&apos;item_name&apos;]);        $this-&gt;assign(&apos;item&apos;, $item);        $this-&gt;render();    }    public function update()    {        $data = array(&apos;id&apos; =&gt; $_POST[&apos;id&apos;], &apos;item_name&apos; =&gt; $_POST[&apos;value&apos;]);        $count = (new ItemModel)-&gt;update($data[&apos;id&apos;], $data);        $this-&gt;assign(&apos;title&apos;, &apos;修改成功&apos;);        $this-&gt;assign(&apos;count&apos;, $count);        $this-&gt;render();    }    public function delete($id = null)    {        $count = (new ItemModel)-&gt;delete($id);        $this-&gt;assign(&apos;title&apos;, &apos;删除成功&apos;);        $this-&gt;assign(&apos;count&apos;, $count);        $this-&gt;render();    }}</code></pre><h3 id="部署视图"><a href="#部署视图" class="headerlink" title="部署视图"></a>部署视图</h3><p>在 views 目录下新建 header.php 和 footer.php 两个页头页脚模板，如下。</p><h4 id="header-php"><a href="#header-php" class="headerlink" title="header.php"></a>header.php</h4><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;    &lt;title&gt;&lt;?php echo $title ?&gt;&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/main.css&quot; type=&quot;text/css&quot; /&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&lt;?php echo $title ?&gt;&lt;/h1&gt;</code></pre><h4 id="footer-php"><a href="#footer-php" class="headerlink" title="footer.php"></a>footer.php</h4><pre><code>&lt;/body&gt;&lt;/html&gt;</code></pre><p>页头文件用到了main.css样式文件，内容：</p><pre><code>input {    font-family:georgia,times;    font-size:24px;    line-height:1.2em;}a {    color:blue;    font-family:georgia,times;    font-size:20px;    line-height:1.2em;    text-decoration:none;}a:hover {    text-decoration:underline;}h1 {    color:#000000;    font-size:41px;    border-bottom:1px dotted #cccccc;}</code></pre><p>然后，在 views/item 创建以下几个视图文件。</p><h4 id="index-php-浏览数据库内-item-表的所有记录"><a href="#index-php-浏览数据库内-item-表的所有记录" class="headerlink" title="index.php[浏览数据库内 item 表的所有记录]"></a>index.php[浏览数据库内 item 表的所有记录]</h4><pre><code>&lt;form action=&quot;/item/add&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; value=&quot;点击添加&quot; onclick=&quot;this.value=&apos;&apos;&quot; name=&quot;value&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;&lt;/form&gt;&lt;br/&gt;&lt;?php foreach ($items as $item): ?&gt;    &lt;a class=&quot;big&quot; href=&quot;/item/view/&lt;?php echo $item[&apos;id&apos;] ?&gt;&quot; title=&quot;点击修改&quot;&gt;        &lt;span class=&quot;item&quot;&gt;            &lt;?php echo $item[&apos;id&apos;] ?&gt;            &lt;?php echo $item[&apos;item_name&apos;] ?&gt;        &lt;/span&gt;    &lt;/a&gt;    ----    &lt;a class=&quot;big&quot; href=&quot;/item/delete/&lt;?php echo $item[&apos;id&apos;]?&gt;&quot;&gt;删除&lt;/a&gt;&lt;br/&gt;&lt;?php endforeach ?&gt;</code></pre><h4 id="add-php-添加记录"><a href="#add-php-添加记录" class="headerlink" title="add.php[添加记录]"></a>add.php[添加记录]</h4><pre><code>&lt;a class=&quot;big&quot; href=&quot;/item/index&quot;&gt;成功添加&lt;?php echo $count ?&gt;条记录，点击返回&lt;/a&gt;</code></pre><h4 id="view-php-查看单条记录"><a href="#view-php-查看单条记录" class="headerlink" title="view.php[查看单条记录]"></a>view.php[查看单条记录]</h4><pre><code>&lt;form action=&quot;/item/update&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;value&quot; value=&quot;&lt;?php echo $item[&apos;item_name&apos;] ?&gt;&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&lt;?php echo $item[&apos;id&apos;] ?&gt;&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt;&lt;/form&gt;</code></pre><p><a class="big" href="/item/index">返回</a></p><h4 id="update-php-更改记录"><a href="#update-php-更改记录" class="headerlink" title="update.php[更改记录]"></a>update.php[更改记录]</h4><pre><code>&lt;a class=&quot;big&quot; href=&quot;/item/index&quot;&gt;成功修改&lt;?php echo $count ?&gt;项，点击返回&lt;/a&gt;</code></pre><h4 id="delete-php-删除记录"><a href="#delete-php-删除记录" class="headerlink" title="delete.php[删除记录]"></a>delete.php[删除记录]</h4><pre><code>&lt;a href=&quot;/item/index&quot;&gt;成功删除&lt;?php echo $count ?&gt;项，点击返回&lt;/a&gt;</code></pre><h3 id="应用测试"><a href="#应用测试" class="headerlink" title="应用测试"></a>应用测试</h3><p>这样，在浏览器中访问 project程序：<a href="http://localhost/item/index/，就可以看到效果了。" target="_blank" rel="external">http://localhost/item/index/，就可以看到效果了。</a></p>]]></content>
    
    <summary type="html">
    
      实现一个类似tp的轻量级框架
    
    </summary>
    
      <category term="框架" scheme="http://martist.cn/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="框架" scheme="http://martist.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>PHP源码【学习笔记】</title>
    <link href="http://martist.cn/2018/05/01/PHP/%E6%B7%B1%E5%85%A5PHP%E6%BA%90%E7%A0%81/"/>
    <id>http://martist.cn/2018/05/01/PHP/深入PHP源码/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-05-11T11:51:37.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h2><p>PHP的源码在结构上非常清晰。下面先简单介绍一下PHP源码的目录结构。</p><pre><code>根目录: / 这个目录包含的东西比较多，主要包含一些说明文件以及设计方案。 其实项目中的这些README文件是非常值得阅读的例如：    /README.PHP4-TO-PHP5-THIN-CHANGES 这个文件就详细列举了PHP4和PHP5的一些差异。    还有有一个比较重要的文件/CODING_STANDARDS，如果要想写PHP扩展的话，这个文件一定要阅读一下， 不管你个人的代码风格是什么样，怎么样使用缩进和花括号，既然来到了这样一个团体里就应该去适应这样的规范，这样在阅读代码或者别人阅读你的 代码是都会更轻松。build 顾名思义，这里主要放置一些和源码编译相关的一些文件，比如开始构建之前的buildconf脚本等文件，还有一些检查环境的脚本等。ext 官方扩展目录，包括了绝大多数PHP的函数的定义和实现，如array系列，pdo系列，spl系列等函数的实现，都在这个目录中。个人写的扩展在测试时也可以放到这个目录，方便测试和调试。main 这里存放的就是PHP最为核心的文件了，主要实现PHP的基本设施，这里和Zend引擎不一样，Zend引擎主要实现语言最核心的语言运行环境。Zend Zend引擎的实现目录，比如脚本的词法语法解析，opcode的执行以及扩展机制的实现等等。pear “PHP 扩展与应用仓库”，包含PEAR的核心文件。sapi 包含了各种服务器抽象层的代码，例如apache的mod_php，cgi，fastcgi以及fpm等等接口。TSRM PHP的线程安全是构建在TSRM库之上的，PHP实现中常见的*G宏通常是对TSRM的封装，TSRM(Thread Safe Resource Manager)线程安全资源管理器。tests PHP的测试脚本集合，包含PHP各项功能的测试文件win32 这个目录主要包括Windows平台相关的一些实现，比如sokcet的实现在Windows下和*Nix平台就不太一样，同时也包括了Windows下编译PHP相关的脚本。</code></pre><p>继续学下去，看来还是要学c…</p><h2 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h2><p><a href="http://www.php-internals.com/book/?p=chapt01/01-02-code-structure" target="_blank" rel="external">http://www.php-internals.com/book/?p=chapt01/01-02-code-structure</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码目录结构&quot;&gt;&lt;a href=&quot;#源码目录结构&quot; class=&quot;headerlink&quot; title=&quot;源码目录结构&quot;&gt;&lt;/a&gt;源码目录结构&lt;/h2&gt;&lt;p&gt;PHP的源码在结构上非常清晰。下面先简单介绍一下PHP源码的目录结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;根目录
      
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php7性能分析-xhprof【laravel】</title>
    <link href="http://martist.cn/2018/04/20/PHP/php%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/"/>
    <id>http://martist.cn/2018/04/20/PHP/php性能分析入门/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-26T11:06:09.048Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="xhprof"><a href="#xhprof" class="headerlink" title="xhprof"></a>xhprof</h2><p>Xhprof是facebook开源出来的一个php轻量级的性能分析工具，跟Xdebug类似，但性能开销更低，还可以用在生产环境中，也可以由程序开关来控制是否进行profile。</p><h2 id="xhprof-for-PHP7"><a href="#xhprof-for-PHP7" class="headerlink" title="xhprof for PHP7"></a>xhprof for PHP7</h2><p>xhprof已经不维护很久了，同事他也不再支持php7.这对我学习性能测试造成了困扰，好在有这个xhprof for PHP7的开源项目，供大家一起使用。</p><h3 id="适配PHP版本"><a href="#适配PHP版本" class="headerlink" title="适配PHP版本"></a>适配PHP版本</h3><pre><code>7.07.17.2</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>git clone https://github.com/longxinH/xhprof.git ./xhprofcd xhprof/extension/phpize./configure --with-php-config=/path/to/php7/bin/php-configmake &amp;&amp; sudo make install</code></pre><p>出现</p><pre><code>Installing shared extensions:     /opt/php-7.0.14/lib/php/extensions/no-debug-non-zts-20151012/</code></pre><p>代表编译成功</p><h4 id="编译过程问题"><a href="#编译过程问题" class="headerlink" title="编译过程问题"></a>编译过程问题</h4><pre><code>configure: error: Cannot find php-config. Please use --with-php-config=PATH</code></pre><p>configure: error: Cannot find php-config. Please use –with-php-config=PATH</p><p>一般出现这个错误说明你执行 ./configure 时  –with-php-config 这个参数配置路径错误导致的。</p><p>查找:</p><pre><code>find / -name  php-config</code></pre><p>修改为：</p><pre><code>./configure --with-php-config=/usr/local/php/bin/php-config</code></pre><p>就可以解决问题，上面的 /usr/local/php/ 是你的 php 安装路径。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="添加配置项到php-ini"><a href="#添加配置项到php-ini" class="headerlink" title="添加配置项到php.ini"></a>添加配置项到php.ini</h4><pre><code>[xhprof]extension=xhprof.soxhprof.output_dir=/Users/machuang/Desktop/project/xhprof/save_output_dir//此处你就留一个存放xhprof记录文件的目录ok了</code></pre><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><pre><code>mkdir -p  /Users/machuang/Desktop/project/xhprof/save_output_dir</code></pre><h4 id="重启php-fpm-php-ini就生效了"><a href="#重启php-fpm-php-ini就生效了" class="headerlink" title="重启php-fpm, php.ini就生效了"></a>重启php-fpm, php.ini就生效了</h4><pre><code>machuangdeMacBook-Pro:7.1 machuang$ fpm-n Gracefully shutting down php-fpm-n . done-n Starting php-fpm done</code></pre><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/longxinH/xhprof" target="_blank" rel="external">https://github.com/longxinH/xhprof</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="植入xhprof"><a href="#植入xhprof" class="headerlink" title="植入xhprof"></a>植入xhprof</h3><p>此处写个脚本就OK，文件命名为b.php。</p><pre><code>&lt;?php//1.开启xhprofxhprof_enable();//2.你需要分析的代码for($i=1;$i&lt;1000;$i++){  if($i%100 == 0){    echo  $i;    echo &quot;&lt;br&gt;&quot;;  }}//3.关闭xhprof,收集数据$xhprof_data = xhprof_disable();include_once &apos;./xhprof/xhprof_lib/utils/xhprof_lib.php&apos;;include_once &apos;./xhprof/xhprof_lib/utils/xhprof_runs.php&apos;;$xhprof_runs = new XHProfRuns_Default();$run_id = $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_test&quot;);echo &quot;&lt;br&gt;&quot;;echo  $run_id;die;//将run_id保存起来或者随代码一起输出</code></pre><h3 id="使用php内置部署工具"><a href="#使用php内置部署工具" class="headerlink" title="使用php内置部署工具"></a>使用php内置部署工具</h3><pre><code>php -S 127.0.0.1:9001</code></pre><h3 id="在浏览器运行脚本"><a href="#在浏览器运行脚本" class="headerlink" title="在浏览器运行脚本"></a>在浏览器运行脚本</h3><p>打开：<a href="http://127.0.0.1:9001/b.php" target="_blank" rel="external">http://127.0.0.1:9001/b.php</a></p><p>输出：</p><pre><code>1002003004005006007008009005ad88171addf9</code></pre><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>在浏览器输入url，HOST为你的项目当前域名，get参数run的值为$run_id</p><pre><code>HOST/xhpfrof_html/index.php?run=58d3b28b521f6&amp;source=xhprof_test</code></pre><p>打开：<a href="http://127.0.0.1:9001/xhprof/xhprof_html/" target="_blank" rel="external">http://127.0.0.1:9001/xhprof/xhprof_html/</a></p><p>可见生成的文件，点击一个打开，url地址变为  <a href="http://127.0.0.1:9001/xhprof/xhprof_html/index.php?run=5ad88171addf9&amp;source=xhprof_test" target="_blank" rel="external">http://127.0.0.1:9001/xhprof/xhprof_html/index.php?run=5ad88171addf9&amp;source=xhprof_test</a></p><pre><code>Function Name    Calls    Calls%    Incl. Wall Time(microsec)    IWall%    Excl. Wall Time(microsec)    EWall%main()     1     50.0%     3     100.0%     3     100.0%xhprof_disable     1     50.0%     0     0.0%     0     0.0%</code></pre><h3 id="xhprof-enable的参数控制"><a href="#xhprof-enable的参数控制" class="headerlink" title="xhprof_enable的参数控制"></a>xhprof_enable的参数控制</h3><pre><code>HPROF_FLAGS_NO_BUILTINS 跳过所有内置（内部）函数。XHPROF_FLAGS_CPU 输出的性能数据中添加 CPU 数据。XHPROF_FLAGS_MEMORY 输出的性能数据中添加内存数据。</code></pre><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>xhprof_html/index.php将记录的结果整理并可视化，默认的UI里列出了：</p><pre><code>funciton name ： 函数名calls: 调用次数Incl. Wall Time (microsec)： 函数运行时间（包括子函数）IWall%：函数运行时间（包括子函数）占比Excl. Wall Time(microsec)：函数运行时间（不包括子函数）EWall%：函数运行时间（不包括子函数）</code></pre><p>在xhprof_html/index.php中还可以看到[View Full Callgraph]链接，点击后可以绘制出一张可视化的性能分析图，如果点击后报错的话，可能是缺少依赖graphviz，<br>graphviz是一个绘制图形的工具，可以更为直观的让你查看性能的瓶颈。</p><h2 id="优化读取测试数据"><a href="#优化读取测试数据" class="headerlink" title="优化读取测试数据"></a>优化读取测试数据</h2><ul><li>graphviz<br><a href="https://graphviz.gitlab.io/download/" target="_blank" rel="external">https://graphviz.gitlab.io/download/</a></li></ul><p>macbook上的安装很简单，brew就可以。</p><pre><code>brew install  graphviz</code></pre><p>安装成功，brew会帮你配置graphviz，所以后面可以直接使用。点击 [View Full Callgraph] ，可以更直观查看所有的性能测试信息。</p><h2 id="XHProf报告含义"><a href="#XHProf报告含义" class="headerlink" title="XHProf报告含义"></a>XHProf报告含义</h2><p>XHProf报告中有许多列，它们代表的含义见下表：</p><table><thead><tr><th>列名</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Function Name</td><td style="text-align:center">方法名称。</td></tr><tr><td>Calls</td><td style="text-align:center">方法被调用的次数。</td></tr><tr><td>Calls%</td><td style="text-align:center">方法调用次数在同级方法总数调用次数中所占的百分比。</td></tr><tr><td>Incl.Wall Time(microsec)</td><td style="text-align:center">方法执行花费的时间，包括子方法的执行时间。（单位：微秒）</td></tr><tr><td>IWall%</td><td style="text-align:center">方法执行花费的时间百分比。</td></tr><tr><td>Excl. Wall Time(microsec)</td><td style="text-align:center">方法本身执行花费的时间，不包括子方法的执行时间。（单位：微秒）</td></tr><tr><td>EWall%</td><td style="text-align:center">方法本身执行花费的时间百分比。</td></tr><tr><td>Incl. CPU(microsecs)</td><td style="text-align:center">方法执行花费的CPU时间，包括子方法的执行时间。（单位：微秒）</td></tr><tr><td>ICpu%</td><td style="text-align:center">方法执行花费的CPU时间百分比。</td></tr><tr><td>Excl. CPU(microsec)</td><td style="text-align:center">方法本身执行花费的CPU时间，不包括子方法的执行时间。（单位：微秒）</td></tr><tr><td>ECPU%</td><td style="text-align:center">方法本身执行花费的CPU时间百分比。</td></tr><tr><td>Incl.MemUse(bytes)</td><td style="text-align:center">方法执行占用的内存，包括子方法执行占用的内存。（单位：字节）</td></tr><tr><td>IMemUse%</td><td style="text-align:center">方法执行占用的内存百分比。</td></tr><tr><td>Excl.MemUse(bytes)</td><td style="text-align:center">方法本身执行占用的内存，不包括子方法执行占用的内存。（单位：字节）</td></tr><tr><td>EMemUse%</td><td style="text-align:center">方法本身执行占用的内存百分比。</td></tr><tr><td>Incl.PeakMemUse(bytes)</td><td style="text-align:center">Incl.MemUse峰值。（单位：字节）</td></tr><tr><td>IPeakMemUse%</td><td style="text-align:center">ncl.MemUse峰值百分比。</td></tr><tr><td>Excl.PeakMemUse(bytes)</td><td style="text-align:center">Excl.MemUse峰值。单位：（字节）</td></tr><tr><td>EPeakMemUse%</td><td style="text-align:center">Excl.MemUse峰值百分比。</td></tr></tbody></table><h2 id="php框架中使用"><a href="#php框架中使用" class="headerlink" title="php框架中使用"></a>php框架中使用</h2><p>此处我们有比较优雅的注入方式，首先，把xhprof项目放到laravel项目的public目录下，<br>然后在index.php的最上面加入如下代码：</p><pre><code>ini_set(&apos;xhprof.output_dir&apos;,dirname(__DIR__).&apos;/xhprof_save_dir&apos;);//echo ini_get(&apos;xhprof.output_dir&apos;); die;$xhprof_lib_dir = dirname(__DIR__).&apos;/public/xhprof/xhprof_lib/utils/xhprof_lib.php&apos;;$xhprof_runs_dir = dirname(__DIR__).&apos;/public/xhprof/xhprof_lib/utils/xhprof_runs.php&apos;;include_once $xhprof_lib_dir;include_once $xhprof_runs_dir;//开启xhprofxhprof_enable(XHPROF_FLAGS_MEMORY );//在程序结束后收集数据register_shutdown_function(function() {    $xhprof_data        = xhprof_disable();    //让数据收集程序在后台运行    if (function_exists(&apos;fastcgi_finish_request&apos;)) {        fastcgi_finish_request();    }    //保存    $xhprof_runs = new XHProfRuns_Default();    $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_crm&quot;);});</code></pre><p>然后，在xhprof/xhprof_html/index.php增加一行代码，如下：</p><pre><code>ini_set(&apos;xhprof.output_dir&apos;,dirname(dirname(dirname(__DIR__))).&apos;/xhprof_save_dir&apos;);</code></pre><p>这是为了保证数据的存储和读取目录一致。</p><p>打开类似链接，即可看到测试数据分析了<br><a href="http://xhprof.your-laravel.app/xhprof/xhprof_html/index.php?run=5adeaebf97d31&amp;source=xhprof_crm" target="_blank" rel="external">http://xhprof.your-laravel.app/xhprof/xhprof_html/index.php?run=5adeaebf97d31&amp;source=xhprof_crm</a></p><h3 id="数据如下"><a href="#数据如下" class="headerlink" title="数据如下"></a>数据如下</h3><p>  Overall Summary<br>  Total Incl. Wall Time (microsec):    818,313 microsecs<br>  Total Incl. MemUse (bytes):    10,521,952 bytes<br>  Total Incl. PeakMemUse (bytes):    10,435,224 bytes<br>  Number of Function Calls:    56,935</p><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/xhprof.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="性能测试" scheme="http://martist.cn/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>nginx中的PHP_VALUE</title>
    <link href="http://martist.cn/2018/04/20/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/nginx%E4%B8%AD%E7%9A%84PHP_VALUE/"/>
    <id>http://martist.cn/2018/04/20/服务部署/nginx中的PHP_VALUE/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-19T11:30:38.665Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>PHP_VALUE实现了动态修改php的配置项 ，而不需要去改项目代码。</p><p>我们一般修改php的配置项都是在php.ini中修改。在php,ini中的修改会影响到所有使用php的程序。假如我想让修改只在某个域名下生效，该如何做呢?首先想到的可能是使用ini_set()方法在脚本中修改。但是这个只能修改作用域为PHP_INI_USER和PHP_INI_ALL的配置项。所以我们用PHP_VALUE这个更好的做法。</p><h3 id="PHP配置指令作用域说明"><a href="#PHP配置指令作用域说明" class="headerlink" title="PHP配置指令作用域说明"></a>PHP配置指令作用域说明</h3><p>PHP总共有4个配置指令作用域，分别是PHP_INI_USER，PHP_INI_PERDIR，PHP_INI_SYSTEM，PHP_INI_ALL。这些作用域限制了指令是否可以被修改，在那里可以被修改。php的每个配置项都会有一个作用域。下面是对四种作用域的说明。</p><pre><code>作用域类型         说明PHP_INI_USER     可在用户脚本(如 ini_set())或Windows注册表(PHP 5.3 起)以及.user.ini中设定PHP_INI_PERDIR   可在 php.ini，.htaccess 或 httpd.conf 中设定PHP_INI_SYSTEM   可在 php.ini 或 httpd.conf 中设定PHP_INI_ALL      可在任何地方设定</code></pre><p>例如 output_buffering 指令是属于 PHP_INI_PERDIR，因而就不能用 ini_set() 来设定。但是 display_errors 指令是属于 PHP_INI_ALL 因而就可以在任何地方被设定，包括 ini_set()。httpd.conf相比ini_set()中可以设定更多级别的配置项。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>如果是apache+php的组合，我们可以在apache的配置文件中加入如下指令即可。</p><pre><code>PHP_VALUE auto_prepend_file /home/www/bo56.com/header.php</code></pre><p>如果是nginx+php组合，可以加入如下指令</p><pre><code>fastcgi_param PHP_VALUE &quot;auto_prepend_file=/home/www/bo56.com/header.php&quot;;</code></pre><p>注意，nginx中多次使用 PHP_VALUE时，最后的一个会覆盖之前的。如果想设置多个配置项，需要写在一起，然后用换行分割。如：</p><pre><code>fastcgi_param PHP_VALUE &quot;auto_prepend_file=/home/www/bo56.com/header.php \n auto_append_file=/home/www/bo56.com/external/footer.php&quot;;</code></pre><h2 id="fastcgi-pass配置"><a href="#fastcgi-pass配置" class="headerlink" title="fastcgi_pass配置"></a>fastcgi_pass配置</h2><p>我们看到nginx的虚拟主机server中的fastcgi_param，这是什么呢，引起了我的好奇心，下面讲解下。</p><p>Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。</p><pre><code>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;#脚本文件请求的路径,也就是说当访问127.0.0.1/index.php的时候，需要读取网站根目录下面的index.php文件，如果没有配置这一配置项时，nginx不回去网站根目录下访问.php文件，所以返回空白fastcgi_param QUERY_STRING $query_string;                        #请求的参数;如?app=123fastcgi_param REQUEST_METHOD $request_method;                    #请求的动作(GET,POST)fastcgi_param CONTENT_TYPE $content_type;                        #请求头中的Content-Type字段fastcgi_param CONTENT_LENGTH $content_length;                    #请求头中的Content-length字段。fastcgi_param SCRIPT_NAME $fastcgi_script_name;                  #脚本名称fastcgi_param REQUEST_URI $request_uri;                          #请求的地址不带参数fastcgi_param DOCUMENT_URI $document_uri;                        #与$uri相同。fastcgi_param DOCUMENT_ROOT $document_root;                      #网站的根目录。在server配置中root指令中指定的值fastcgi_param SERVER_PROTOCOL $server_protocol;                  #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。fastcgi_param GATEWAY_INTERFACE CGI/1.1;                         #cgi 版本fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;              #nginx 版本号，可修改、隐藏fastcgi_param REMOTE_ADDR $remote_addr;                          #客户端IPfastcgi_param REMOTE_PORT $remote_port;                          #客户端端口fastcgi_param SERVER_ADDR $server_addr;                          #服务器IP地址fastcgi_param SERVER_PORT $server_port;                          #服务器端口fastcgi_param SERVER_NAME $server_name;                          #服务器名，域名在server配置中指定的server_namefastcgi_param PATH_INFO $path_info;                             #可自定义变量-- PHP only, required if PHP was built with --enable-force-cgi-redirectfastcgi_param REDIRECT_STATUS 200;</code></pre><p>在php可打印出上面的服务环境变量<br>如：</p><pre><code>echo $_SERVER[&apos;REMOTE_ADDR&apos;]</code></pre><h2 id="open-basedir限制目录"><a href="#open-basedir限制目录" class="headerlink" title="open_basedir限制目录"></a>open_basedir限制目录</h2><p>open_basedir 将PHP所能打开的文件限制在指定的目录树中，包括文件本身。当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开。</p><p>本指令不受安全模式打开或关闭的影响。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>httpd.conf中的VritualHost</p><pre><code>php_admin_value open_basedir &quot;指定目录&quot;</code></pre><p>nginx fastcgi.conf</p><pre><code>fastcgi_param PHP_VALUE &quot;open_basedir=指定目录&quot;</code></pre><p>1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="nginx" scheme="http://martist.cn/categories/nginx/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>深蹲怎么不伤膝盖</title>
    <link href="http://martist.cn/2018/04/18/%E5%81%A5%E8%BA%AB/%E6%B7%B1%E8%B9%B2%E6%80%8E%E4%B9%88%E4%B8%8D%E4%BC%A4%E8%86%9D%E7%9B%96/"/>
    <id>http://martist.cn/2018/04/18/健身/深蹲怎么不伤膝盖/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-18T03:10:11.417Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="关于膝关节"><a href="#关于膝关节" class="headerlink" title="关于膝关节"></a>关于膝关节</h2><p>膝关节是人体运动最多、负重最大的关节之一。<br>膝关节承受来自人体的所有重量，甚至是额外的负重。据研究显示，两腿同时站立无屈曲时，双膝关节分别承受膝以上体重的一半，约43%的体重；单腿站立时约承受2倍体重；平地行走时，膝关节承载的负荷可达体重的2至3倍；平地快速行走时，可增加到体重的4.3倍；而上下楼时则分别达到4.4倍和4.9倍；跑步时负重大约是4倍；打球时大约是6倍；蹲和跪时可增高至约8倍。</p><p>膝关节的位置与结构，使它比其他关节承受更大的冲击和压力，是很容易发生运动损伤的关节。</p><h2 id="膝关节弹响的原因"><a href="#膝关节弹响的原因" class="headerlink" title="膝关节弹响的原因"></a>膝关节弹响的原因</h2><h3 id="膝关节温度低，运动时尚发凉发紧，肌肉粘滞性大，血液循环不好。"><a href="#膝关节温度低，运动时尚发凉发紧，肌肉粘滞性大，血液循环不好。" class="headerlink" title="膝关节温度低，运动时尚发凉发紧，肌肉粘滞性大，血液循环不好。"></a>膝关节温度低，运动时尚发凉发紧，肌肉粘滞性大，血液循环不好。</h3><p>解决方法：深蹲前或运动前充分热身，活动开髋关节、膝关节、踝关节，提高组织温度。那么如何热身呢：一般准备活动部分（5-10分钟）：进行慢跑或跳跃目的：提高心率肌肉温度，降低关节肌肉的粘滞性，使血液循环2. 专项活动部分（10-12分钟）：可以进行动态拉伸和专项技能相关训练。比如深蹲前你可以你可以做原地高抬腿100次，充分活动关节。目的：进一步在运动模式下激活肌肉。</p><h3 id="柔韧性不好"><a href="#柔韧性不好" class="headerlink" title="柔韧性不好"></a>柔韧性不好</h3><p>要想让膝关节在负重运动的时候没有摩擦，就要要保持膝关节在负重运动中下的空间。所以呢大腿肌肉就需要有很好的柔韧性。如果柔韧性不好肌肉过紧膝关节肌肉把关节向中间挤压关节软骨。随着咱们的训练，肌肉越来越发达，如果做不好柔韧性练习就会导致肌肉越来越近，关节间隙会越来越小。解决方法：滚泡沫轴。拉伸肌肉。注意大腿前侧，后侧，内侧，外侧肌肉的拉伸，组间和训练前后要及时拉伸，放松肌肉，防止关节过紧。</p><h3 id="强化你的膝盖"><a href="#强化你的膝盖" class="headerlink" title="强化你的膝盖"></a>强化你的膝盖</h3><p>可能有的人会问，既练习肌肉的柔韧性和力量会不会冲突呢，答案是不会的。肌肉本身是既有力量又有弹性和伸展性的。好的健美运动员，在肌肉收缩的时候像铁一样硬，但是松下来之后用手抓能够陷进去。强化你膝关节部的稳定，训练脚的肌肉群，除了股四头(quadriceps)之外，尤其是膕绳肌(hamstrings)及臀肌(glutes)。</p><h3 id="改善髋关节的灵活性"><a href="#改善髋关节的灵活性" class="headerlink" title="改善髋关节的灵活性"></a>改善髋关节的灵活性</h3><p>膝盖的功用是稳定，而髋关节的目的在于灵活性。髋关节缺乏活动性时，膝盖就必须补偿回来，势必会增加膝盖的负担。</p><h3 id="改善脚踝的灵活性"><a href="#改善脚踝的灵活性" class="headerlink" title="改善脚踝的灵活性"></a>改善脚踝的灵活性</h3><p>跟第四点是同样的说明，脚踝缺乏活动性，膝盖就必须补偿回来，势必会增加膝盖的负担。</p><h3 id="活化臀肌"><a href="#活化臀肌" class="headerlink" title="活化臀肌"></a>活化臀肌</h3><p>髋屈肌过紧．髋关节会缺乏活动性，也连带影响了臀肌的运作。臀肌无力会导致脚后跟离开地面、膝关节弯曲。</p><h3 id="下蹲的技术动作"><a href="#下蹲的技术动作" class="headerlink" title="下蹲的技术动作"></a>下蹲的技术动作</h3><p>正确的深蹲动作(Squat Correctly.)脚长及躯干的长度影响你在进行深蹲时，膝盖的位置。根据每个人的状 ，在进行深蹲时，有人的膝盖可能会超过脚趾，而有人不会，所以要注意，应在以下几点：</p><h4 id="比水平高度在低一点"><a href="#比水平高度在低一点" class="headerlink" title="比水平高度在低一点"></a>比水平高度在低一点</h4><p>平行高度的深蹲，对于身体后方的肌肉群(posterior chain)训练较少，会导致身体肌肉的失衡。所以建议是髋关节(hip joint)的高度要低于膝关节。 并且腘绳肌的力量本来就比股四头肌要弱，如果腘绳肌力量低于股四头肌力量的60％就很容易出问题。</p><h4 id="往后坐"><a href="#往后坐" class="headerlink" title="往后坐"></a>往后坐</h4><p>做深蹲的重点是，先是臀是往后坐的，不是脚往前弯。 膝外开．趾外开(Knees out, Toes out.) 训练你的内缩肌群。</p><h4 id="后脚跟请著地"><a href="#后脚跟请著地" class="headerlink" title="后脚跟请著地"></a>后脚跟请著地</h4><p>脚跟著离地在进行深蹲时，膝盖也承受压力。很多举重的动作，都会造成膝盖的受伤，所以先从合适的动作开始训练起，再渐进式的开始增加重量，让肌肉在渐进成长的情况下，去负荷更重的重量。</p><h4 id="重点动作"><a href="#重点动作" class="headerlink" title="重点动作"></a>重点动作</h4><p>1 两脚分开与肩同宽，脚尖稍微外旋，左右脚对准11点5分的方向。</p><p>2 膝盖打开，髋部打开。</p><p>3 在蹲和起的过程中，膝盖对准脚尖，膝盖角度始终保持不变。4 节奏缓慢。</p><h3 id="膝关节有受伤有疼痛时，请停止能引起膝关节4分疼痛以上的动作。膝关节至关重要，大家一定要保护好自己的膝关节。"><a href="#膝关节有受伤有疼痛时，请停止能引起膝关节4分疼痛以上的动作。膝关节至关重要，大家一定要保护好自己的膝关节。" class="headerlink" title="膝关节有受伤有疼痛时，请停止能引起膝关节4分疼痛以上的动作。膝关节至关重要，大家一定要保护好自己的膝关节。"></a>膝关节有受伤有疼痛时，请停止能引起膝关节4分疼痛以上的动作。膝关节至关重要，大家一定要保护好自己的膝关节。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="健身" scheme="http://martist.cn/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>phper需要注意的web安全</title>
    <link href="http://martist.cn/2018/04/18/PHP/phper%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84web%E5%AE%89%E5%85%A8/"/>
    <id>http://martist.cn/2018/04/18/PHP/phper需要注意的web安全/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-18T11:27:59.064Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>我一开始想写，思想被局限在后端了，可能是因为我是一名后端开发吧，其实前端也可以做很多事情来防止网络攻击，下面以前后端来分类简单讲讲web安全。</p><h2 id="前端眼里的web安全"><a href="#前端眼里的web安全" class="headerlink" title="前端眼里的web安全"></a>前端眼里的web安全</h2><ul><li>xss</li><li>csrf</li></ul><p>XSS（cross-site scripting跨域脚本攻击）攻击也是最常见的WEB攻击之一，其重点是“跨域”和“客户端执行”。<br>CSRF（cross-site request forgery），翻译为跨站请求伪造，与XSS非常相似，但XSS是利用用户对当前网站的信任来发起攻击，而CSRF是利用网站对用户的信任来发起攻击。<br>推荐阅读：<br><a href="https://www.cnblogs.com/vajoy/p/4176908.html" target="_blank" rel="external">https://www.cnblogs.com/vajoy/p/4176908.html</a><br><a href="https://segmentfault.com/a/1190000006672214" target="_blank" rel="external">https://segmentfault.com/a/1190000006672214</a></p><h2 id="后端眼里的web安全"><a href="#后端眼里的web安全" class="headerlink" title="后端眼里的web安全"></a>后端眼里的web安全</h2><p>SQL注入攻击<br>中间人攻击（会话劫持）<br>文件上传漏洞攻击<br>DoS和DDoS攻击<br>不安全加密<br>后门</p><p>推荐阅读：<br><a href="https://www.cnblogs.com/Miss-mickey/p/6636813.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">https://www.cnblogs.com/Miss-mickey/p/6636813.html?utm_source=tuicool&amp;utm_medium=referral</a><br><a href="https://segmentfault.com/a/1190000007028595" target="_blank" rel="external">https://segmentfault.com/a/1190000007028595</a><br><a href="https://www.cnblogs.com/luyucheng/p/6234524.html" target="_blank" rel="external">https://www.cnblogs.com/luyucheng/p/6234524.html</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前我也在学习阶段，发现一本书很不多，《白帽子讲web安全》，希望大家可以和我一起学习。</p><p>1</p>]]></content>
    
    <summary type="html">
    
      关于网络安全，phper开发时候需要注意到的地方
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>加密如何保障安全</title>
    <link href="http://martist.cn/2018/04/18/%E6%9E%B6%E6%9E%84/%E5%8A%A0%E5%AF%86%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://martist.cn/2018/04/18/架构/加密如何保障安全/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-19T03:12:12.810Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>你还在用md5+salt方式加密密码吗？PHP5.5引入了Password Hashing函数，内核自带无需安装扩展。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>  password_get_info — 返回指定散列（hash）的相关信息<br>  password_hash — 创建密码的散列（hash）<br>  password_needs_rehash — 检测散列值是否匹配指定的选项<br>  password_verify — 验证密码是否和散列值匹配</p><p>提供了这4个函数，具体案例可以看 <a href="http://php.net/manual/zh/function.password-hash.php" target="_blank" rel="external">http://php.net/manual/zh/function.password-hash.php</a></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>代码：</p><pre><code>&lt;?php$pwd = password_hash(&apos;123456abc&apos;,PASSWORD_DEFAULT);$v = password_get_info($pwd);if(password_verify(&apos;123456abc&apos;, $pwd)){  echo &apos;yes&apos;;  echo  PHP_EOL;}var_dump($v);  echo  PHP_EOL;var_dump($pwd);  echo  PHP_EOL;</code></pre><p>在cli模式下运行结果：</p><pre><code>$ php b.phpyesarray(3) {  [&quot;algo&quot;]=&gt;  int(1)  [&quot;algoName&quot;]=&gt;  string(6) &quot;bcrypt&quot;  [&quot;options&quot;]=&gt;  array(1) {    [&quot;cost&quot;]=&gt;    int(10)  }}string(60) &quot;$2y$10$PQcdiu8BHfKS.43/RJ5xUeYDdHQ8/vcDSlM6lubIdCiTwso6T9.7.&quot;</code></pre><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>通过password_hash加密后的密码，使用字典方式很难破解，因为每次生成的密码都是不一样的,破解这种加密只能采用暴力破解。加密方法再好，原始密码设置的过于简单都容易被破解，设置复杂的密码才是王道。</p><h2 id="laravel框架中的使用"><a href="#laravel框架中的使用" class="headerlink" title="laravel框架中的使用"></a>laravel框架中的使用</h2><p>这两篇文章从框架源码讲解了Password Hashing函数的应用。<br><a href="http://laravelacademy.org/post/8327.html" target="_blank" rel="external">http://laravelacademy.org/post/8327.html</a><br><a href="http://laravelacademy.org/post/4764.html" target="_blank" rel="external">http://laravelacademy.org/post/4764.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然通过password_hash()创建的哈希密码更加安全，但是却降低了互操作性。<br>如我们使用md5方式，在php中用标准的MD5加密，很容易通过其他语言来校验，因为md5的加密方式其他语言也可以使用。而使用password_hash()加密的哈希值基本只能通过PHP的password_verify来校验。<br>这2种方法各有优劣，是使用md5(或sha1等)+salt(干扰字符串)的方式还是使用password_hash()大家根据具体情况取舍把。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>php-fpm概念理解和优化总结</title>
    <link href="http://martist.cn/2018/04/17/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/php-fpm%E4%BC%98%E5%8C%96/"/>
    <id>http://martist.cn/2018/04/17/服务部署/php-fpm优化/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-19T11:06:48.232Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>fpm 是FastCGI Process Manager (FPM)的简拼。php-fpm就是FastCGI的后端实现。并提供了进程管理的功能。</p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>因本文提到的概念比较多，首先提炼下关键词，读者不解之处可以自行百度。</p><ul><li>Apache</li><li>nginx</li><li>反向代理</li><li>cgi</li><li>fastcgi</li><li>php-fpm</li><li>进程</li><li>并发</li><li>kill命令</li></ul><p>Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器，Web Application 一般指PHP、Java、Asp.net等应用程序。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>支持平滑停止/启动的高级进程管理功能；</li><li>可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe_mode 的设置）；</li><li>stdout 和 stderr 日志记录;</li><li>在发生意外情况的时候能够重新启动并缓存被破坏的 opcode;</li><li>文件上传优化支持;</li><li>“慢日志” - 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢;</li><li>fastcgi_finish_request() - 特殊功能：用于在请求完成和刷新数据后，继续在后台执行耗时的工作（录入视频转换、统计处理等）；</li><li>动态／静态子进程产生；</li><li>基本 SAPI 运行状态信息（类似Apache的 mod_status）；</li><li>基于 php.ini 的配置文件。</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="php-fpm-conf"><a href="#php-fpm-conf" class="headerlink" title="php-fpm.conf"></a>php-fpm.conf</h3><p>首先要找到php-fpm.conf配置文件,查看pid的配置路径</p><p>···<br>    machuangdeMacBook-Pro:etc machuang$  ps aux | grep php-fpm<br>    machuang          1619   0.0  0.0  4267768    888 s000  S+   10:17上午   0:00.00 grep php-fpm<br>    _www              1610   0.0  0.0  4327128    856   ??  S    10:17上午   0:00.00 /usr/local/Cellar/php71/7.1.11_22/sbin/php-fpm –daemonize –fpm-config /usr/local/etc/php/7.1/php-fpm.conf –pid /usr/local/var/run/php-fpm.pid<br>    _www              1609   0.0  0.0  4328152    892   ??  S    10:17上午   0:00.00 /usr/local/Cellar/php71/7.1.11_22/sbin/php-fpm –daemonize –fpm-config /usr/local/etc/php/7.1/php-fpm.conf –pid /usr/local/var/run/php-fpm.pid<br>    root              1608   0.0  0.0  4326104   1108   ??  Ss   10:17上午   0:00.00 /usr/local/Cellar/php71/7.1.11_22/sbin/php-fpm –daemonize –fpm-config /usr/local/etc/php/7.1/php-fpm.conf –pid /usr/local/var/run/php-fpm.pid<br>···</p><h3 id="查看php-fpm进程数"><a href="#查看php-fpm进程数" class="headerlink" title="查看php-fpm进程数"></a>查看php-fpm进程数</h3><pre><code>ps aux | grep -c php-fpm</code></pre><p>此处应该减一，因为这条命令也被统计进去了。同时统计进去的还有php-fom的master worker进程。</p><h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><p>见文末。</p><h2 id="nginx和php-fpm的工作机制"><a href="#nginx和php-fpm的工作机制" class="headerlink" title="nginx和php-fpm的工作机制"></a>nginx和php-fpm的工作机制</h2><p>Nginx通过类似反向代理的功能将动态请求转向后端Php-fpm。</p><p>FastCGI 是一个协议，它是应用程序和 WEB 服务器连接的桥梁。Nginx 并不能直接与 PHP-FPM 通信，而是将请求通过 FastCGI 交给 PHP-FPM 处理。<br>下面是nginx的虚拟主机配置内容：</p><pre><code>location ~ \.php$ {    try_files $uri /index.php =404;    fastcgi_pass 127.0.0.1:9000;    fastcgi_index index.php;    fastcgi_buffers 16 16k;    fastcgi_buffer_size 32k;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;}</code></pre><p>这里 fastcgi_pass 就是把所有 php 请求转发给 php-fpm 进行处理。通过 netstat 命令可以看到，127.0.0.1:9000 这个端口上运行的进程就是 php-fpm.</p><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>Nginx 反向代理最重要的指令是 proxy_pass，如：</p><pre><code>location ^~ /seckill_query/ {    proxy_pass http://ris.xxmail.gdrive:8090/;    proxy_set_header Host ris.xxmail.gdrive;}location ^~ /push_message/ {    proxy_pass http://channel.xxmail.gdrive:8090/;    proxy_set_header Host channel.xxmail.gdrive;}location ^~ /data/ {    proxy_pass http://ds.xxmail.gdrive:8087/;    proxy_set_header Host ds.xxmail.gdrive;}</code></pre><p>通过 location 匹配 url 路径，将其转发到另外一个服务器处理。</p><p>通过负载均衡 upstream 也可以实现反向代理。</p><h3 id="Nginx-负载均衡"><a href="#Nginx-负载均衡" class="headerlink" title="Nginx 负载均衡"></a>Nginx 负载均衡</h3><p>介绍一下 upstream 模块：</p><pre><code>负载均衡模块用于从”upstream”指令定义的后端主机列表中选取一台主机。nginx先使用负载均衡模块找到一台主机，再使用upstream模块实现与这台主机的交互。</code></pre><p>负载均衡配置：</p><pre><code>upstream php-upstream {    ip_hash;    server 192.168.0.1;    server 192.168.0.2;}location / {    root   html;    index  index.html index.htm;    proxy_pass http://php-upstream;}</code></pre><p>该例定义了一个 php-upstream 的负载均衡配置，通过 proxy_pass 反向代理指令应用这个配置。这里用的 ip_hash 算法，负载均衡的算法有多种，就不一一列举了。</p><p>负载均衡也可以用在 fastcgi_pass 上。</p><p>如：</p><pre><code>fastcgi_pass http://php-upstream</code></pre><p>如果使用负载均衡，可能存在一个 session 失效的问题，你的每次请求可能分配到不同的服务器，一个解决方法是把 Memcached 或 Redis 作为 session 存储的方式，而且还可以提高性能。</p><p>反向代理和负载均衡这两个词经常出现在一起，但他们实际上是不同的概念，负载均衡它更多的是强调的是一种算法或策略，将请求分布到不同的机器上，因此实际上也起到了反向代理的作用。<br>可以说是使用反向代理和算法实现了负载均衡。</p><h3 id="proxy-pass-和-fastcgi-pass-的区别"><a href="#proxy-pass-和-fastcgi-pass-的区别" class="headerlink" title="proxy_pass 和 fastcgi_pass 的区别"></a>proxy_pass 和 fastcgi_pass 的区别</h3><p>一个是反向代理模块，一个是转发给 factcgi 后端处理。</p><pre><code>fastcgi_pass客户端----[HTTP]----webserver(nginx)----[fastcgi]----fastcgi服务(php-fpm)proxy_pass客户端----[HTTP]----webserver(nginx)----[HTTP]----webserver(nginx)</code></pre><h3 id="webserver配置和运行"><a href="#webserver配置和运行" class="headerlink" title="webserver配置和运行"></a>webserver配置和运行</h3><p>1、配置nginx.conf文件</p><p>进入nginx目录下，编辑 nginx.conf文件。<br>如图，在nginx.conf最后一行，</p><ul><li><p>添加include文件（引入虚拟主机的配置目录）</p><p>  include /usr/local/etc/nginx/erver/*</p></li><li><p>添加对应的server（进入上面include的路径，添加一个server）</p></li></ul><p>比如新建一个文件,路径为 /usr/local/etc/nginx/erver/www.example.com.conf，内容如下：</p><pre><code>server {    listen       80; #监听80端口，接收http请求    server_name  www.example.com; #就是网站地址    root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径    #路由到网站根目录www.example.com时候的处理    location / {        index index.php; #跳转到www.example.com/index.php        autoindex on;    }       #当请求网站下php文件的时候，反向代理到php-fpm    location ~ \.php$ {        include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块        fastcgi_intercept_errors on;        fastcgi_pass   127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口    }}</code></pre><p>总而言之：当我们访问www.example.com的时候，处理流程是这样的：</p><pre><code>www.example.com      |      |    Nginx      |      |路由到www.example.com/index.php      |      |加载nginx的fast-cgi模块      |      |fast-cgi监听127.0.0.1:9000地址      |      |www.example.com/index.php请求到达127.0.0.1:9000      |      |   等待处理...</code></pre><p>下面我们启用php的php-fpm来处理这个请求，打开php-fpm.conf文件，我们看到如下配置：</p><pre><code>listen 127.0.0.1:9000</code></pre><p>即:php-fpm模块监听127.0.0.1:9000端口，等待请求到来去处理。</p><h3 id="nginx与php-fpm的结合后的完整流程"><a href="#nginx与php-fpm的结合后的完整流程" class="headerlink" title="nginx与php-fpm的结合后的完整流程"></a>nginx与php-fpm的结合后的完整流程</h3><pre><code>www.example.com       |       |     Nginx       |       |路由到www.example.com/index.php       |       |加载nginx的fast-cgi模块       |       |fast-cgi监听127.0.0.1:9000地址       |       |www.example.com/index.php请求到达127.0.0.1:9000       |       |php-fpm 监听127.0.0.1:9000       |       |php-fpm 接收到请求，启用worker进程处理请求       |       |php-fpm 处理完请求，返回给nginx       |       |nginx将结果通过http返回给浏览器</code></pre><p>下面继续相信研究php-fpm是具体怎么工作的。</p><h2 id="Nginx和fastcgi的通信机制"><a href="#Nginx和fastcgi的通信机制" class="headerlink" title="Nginx和fastcgi的通信机制"></a>Nginx和fastcgi的通信机制</h2><p>我们来看一段Nginx中fastcgi_pass的配置：</p><p>   location ~ .php$ {<br>        root           /home/wwwroot;<br>        fastcgi_pass   127.0.0.1:9000;</p><pre><code>    #fastcgi_pass  unix:/var/run/php-fpm/php-fpm.sock;    #fastcgi_pass  unix:/tmp/php-cgi.sock;    try_files $uri /index.php =404;    fastcgi_split_path_info ^(.+\.php)(/.+)$;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><h3 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h3><p>Nginx和PHP-FPM的进程间通信有两种方式,一种是TCP,一种是UNIX Domain Socket.</p><p>其中TCP是IP加端口,可以跨服务器.而UNIX Domain Socket不经过网络,只能用于Nginx跟PHP-FPM都在同一服务器的场景.用哪种取决于你的PHP-FPM配置:</p><pre><code>方式1:php-fpm.conf: listen = 127.0.0.1:9000nginx.conf: fastcgi_pass 127.0.0.1:9000;方式2:php-fpm.conf: listen = /tmp/php-fpm.socknginx.conf: fastcgi_pass unix:/tmp/php-fpm.sock;</code></pre><p>其中php-fpm.sock是一个文件,由php-fpm生成,类型是srw-rw—-.</p><h3 id="UNIX-Domain-Socket和tcp链接的区别"><a href="#UNIX-Domain-Socket和tcp链接的区别" class="headerlink" title="UNIX Domain Socket和tcp链接的区别"></a>UNIX Domain Socket和tcp链接的区别</h3><p>UNIX Domain Socket可用于两个没有亲缘关系的进程,是目前广泛使用的IPC机制,比如X Window服务器和GUI程序之间就是通过UNIX Domain Socket通讯的.这种通信方式是发生在系统内核里而不会在网络里传播.UNIX Domain Socket和长连接都能避免频繁创建TCP短连接而导致TIME_WAIT连接过多的问题.对于进程间通讯的两个程序,UNIX Domain Socket的流程不会走到TCP那层,直接以文件形式,以stream socket通讯.如果是TCP Socket,则需要走到IP层,对于非同一台服务器上,TCP Socket走的就更多了.</p><pre><code>UNIX Domain Socket:Nginx &lt;=&gt; socket &lt;=&gt; PHP-FPMTCP Socket(本地回环):Nginx &lt;=&gt; socket &lt;=&gt; TCP/IP &lt;=&gt; socket &lt;=&gt; PHP-FPMTCP Socket(Nginx和PHP-FPM位于不同服务器):Nginx &lt;=&gt; socket &lt;=&gt; TCP/IP &lt;=&gt; 物理层 &lt;=&gt; 路由器 &lt;=&gt; 物理层 &lt;=&gt; TCP/IP &lt;=&gt; socket &lt;=&gt; PHP-FPM</code></pre><p>像mysql命令行客户端连接mysqld服务也类似有这两种方式:</p><p>使用Unix Socket连接(默认):</p><pre><code>mysql -uroot -p --protocol=socket --socket=/tmp/mysql.sock</code></pre><p>使用TCP连接:</p><pre><code>mysql -uroot -p --protocol=tcp --host=127.0.0.1 --port=3306</code></pre><h2 id="php-fpm的运行机制"><a href="#php-fpm的运行机制" class="headerlink" title="php-fpm的运行机制"></a>php-fpm的运行机制</h2><h3 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h3><p>php-fpm是一种master（主）/worker（子）多进程架构。<br>master进程主要负责CGI及PHP环境初始化、事件监听、子进程状态等等，worker进程负责处理php请求。<br>在介绍运行原理之前，我们先了解下它的几种运行模式。</p><h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h3><p>php-fpm支持三种运行模式，分别为static、ondemand、dynamic，默认为dynamic 。</p><pre><code>static : 静态模式，启动时分配固定的worker进程。ondemand: 按需分配，当收到用户请求时fork worker进程。dynamic: 动态模式，启动时分配固定的进程。伴随着请求数增加，在设定的浮动范围调整worker进程。</code></pre><p>这三种模式各有千秋，大家可以根据不同的环境调整相应的配置。</p><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>php-fpm采用master/worker架构设计，前面简单地描述master和worker进程模块的功能。下面将详细讲解这两个模块的运行原理。<br>master进程</p><p>master进程工作流程分为4个阶段，</p><pre><code>初始化cgi-----&gt; 初始化php环境  -----&gt; 初始化php-fpm -----&gt; 运行php-fpm</code></pre><ol><li>cgi初始化阶段：分别调用fcgi_init()和 sapi_startup()函数，注册进程信号以及初始化sapi_globals全局变量。</li><li>php环境初始化阶段：由cgi_sapi_module.startup 触发。实际调用php_cgi_startup函数，而php_cgi_startup内部又调用php_module_startup执行。 php_module_startup主要功能：a).加载和解析php配置；b).加载php模块并记入函数符号表(function_table)；c).加载zend扩展 ; d).设置禁用函数和类库配置；e).注册回收内存方法；</li><li>php-fpm初始化阶段：执行fpm_init()函数。负责解析php-fpm.conf文件配置，获取进程相关参数（允许进程打开的最大文件数等）,初始化进程池及事件模型等操作。</li><li>php-fpm运行阶段：执行fpm_run() 函数，运行后主进程发生阻塞。该阶段分为两部分：fork子进程 和 循环事件。fork子进程部分交由fpm_children_create_initial函数处理（ 注：ondemand模式在fpm_pctl_on_socket_accept函数创建）。循环事件部分通过fpm_event_loop函数处理，其内部是一个死循环，负责事件的收集工作。</li></ol><h3 id="worker进程"><a href="#worker进程" class="headerlink" title="worker进程"></a>worker进程</h3><p>worker进程分为 接收客户端请求、处理请求、请求结束三个阶段。</p><ol><li><p>接收客户端请求：执行fcgi_accept_request函数，其内部通过调用accept 函数获取客户端请求。</p><p> //请求锁<br> FCGI_LOCK(req-&gt;listen_socket);<br> req-&gt;fd = accept(listen_socket, (struct sockaddr *)&amp;sa, &amp;len);<br> //释放锁<br> FCGI_UNLOCK(req-&gt;listen_socket);</p></li></ol><p>从上面的代码，可以注意到accept之前有一个请求锁的操作，这么设计是为了避免请求出现“惊群”的现象。当然，这是一个可选的选项，可以取消该功能。</p><ol><li><p>处理请求阶段：首先，分别调用fpm_request_info、php_request_startup获取请求内容及注册全局变量($_GET、$_POST、$_SERVER、$_ENV、$_FILES)；然后根据请求信息调用php_fopen_primary_script访问脚本文件；最后交给php_execute_script执行。php_execute_script内部调用zend_execute_scripts方法将脚本交给zend引擎处理。</p></li><li><p>请求结束阶段：执行php_request_shutdown函数。此时 回调register_shutdown_function注册的函数及__destruct()方法，发送响应内容、释放内存等操作。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>php-fpm采用master/worker架构设计， master进程负责CGI、PHP公共环境的初始化及事件监听操作。worker进程负责请求的处理功能。在worker进程处理请求时，无需再次初始化PHP运行环境，这也是php-fpm性能优异的原因之一。</p><h2 id="CGI、FastCGI、php-fpm的关系"><a href="#CGI、FastCGI、php-fpm的关系" class="headerlink" title="CGI、FastCGI、php-fpm的关系"></a>CGI、FastCGI、php-fpm的关系</h2><h3 id="CGI（Common-Gateway-Interface）"><a href="#CGI（Common-Gateway-Interface）" class="headerlink" title="CGI（Common Gateway Interface）"></a>CGI（Common Gateway Interface）</h3><p>最初，CGI 是在 1993 年由美国国家超级电脑应用中心（NCSA）为 NCSA HTTPd Web 服务器开发的。</p><p>这个 Web 服务器使用了 UNIX shell 环境变量 来保存从 Web 服务器传递出去的参数，然后生成一个运行 CGI 的独立进程。CGI的第一个实现是 Perl 写的 1。</p><ul><li>效率低下：每一个连接 fork 一个进程处理。</li><li>功能十分有限：CGI只能收到一个请求，输出一个响应。很难在CGI体系去对Web请求的控制，例如：用户认证等。</li></ul><p>正因为这些问题，在CGI诞生后的很长一段时间，各种Web Server都还是采用API这种强绑定的方式去支持Web开发，其中Apache的mod_php就属于这种方式。所以后面就有大神提出了FastCGI标准。</p><h3 id="FastCGI（Fast-Common-Gateway-Interface）"><a href="#FastCGI（Fast-Common-Gateway-Interface）" class="headerlink" title="FastCGI（Fast Common Gateway Interface）"></a>FastCGI（Fast Common Gateway Interface）</h3><p>FastCGI使用进程/线程池来处理一连串的请求。这些进程/线程由FastCGI服务器管理，而不是Web服务器。 当进来一个请求时，Web服务器把环境变量和这个页面请求通过一个Socket长连接传递给FastCGI进程。所以FastCGI有如下的优点：</p><p>性能：通过进程/线程池规避了CGI开辟新的进程的开销。<br>兼容：非常容易改造现有CGI标准的程序。<br>语言无关：FastCGI是一套标准，理论上讲只要能进行标准输出（stdout）的语言都可以作为FastCGI标准的Web后端。<br>下面是一个简单FastCGI后端的伪代码</p><pre><code>void main(void){int count = 0;  while(FCGI_Accept() &gt;= 0) {    printf(“Content-type: text/html\r\n”);    printf(“\r\n”);    printf(“Hello world!\r\n”);    printf(“Request number %d.”, count++);  }exit(0);}</code></pre><ul><li>Web Server隔离：FastCGI后端和Web Server运行在不同的进程中，后端的任何故障不会导致Web Server挂掉。</li><li>专利：没有Apache mod_php之类的私有API的知识产权问题。</li><li>扩展：FastCGI后端和Web Server通过Socket进行通信，两者可以分布式部署并方便进行横向扩展。</li></ul><p>所以FastCGI一推出就几乎获得了所有主流Web Server的支持，Apache、Lighttpd、IIS、Cherokee……</p><p>But，事情总是还有改进的余地的，FastCGI这套工作模式实际上没有什么太大缺陷，但是有些不安分的Python程序猿觉得，FastCGI标准下写异步的Web服务还是不太方便，如果能够收到请求后CGI端去处理，处理完毕后通过Callback回调来返回结果，那样岂不是很Cool？！所以WSGI就被创造出来了：</p><h3 id="WSGI（Web-Server-Gateway-Interface）"><a href="#WSGI（Web-Server-Gateway-Interface）" class="headerlink" title="WSGI（Web Server Gateway Interface）"></a>WSGI（Web Server Gateway Interface）</h3><p>Web服务器网关接口（Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。</p><p>当Web Server收到一个请求后，可以通过Socket把环境变量和一个Callback回调函数传给后端Web应用，Web应用在完成页面组装后通过Callback把内容返回给Web Server。这样做的优点有很多：</p><ul><li>异步化，通过Callback将Web请求的工作拆解开，可以很方便的在一个线程空间里同时处理多个Web请求。</li><li>方便进行各种负载均衡和请求转发，不会造成后端Web应用阻塞。</li></ul><p>Web开发有3P：Perl、Python、PHP。<br>Perl是1987年发布的，Python是1989年，PHP是1995年。CGI标准提出的时候正是Perl如日中天的时候，所以CGI的提出当时也是主要为了解决Perl作为Web编程语言的需求。熟悉正则（regex）的程序员可能知道正则的事实标准叫做pcre（Perl兼容正则表达式，Perl Compatible Regular Expressions），这也从一个侧面体现了Perl作为一个古老的语言在当时对各种业界标准的影响。</p><h3 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a>简而言之</h3><ul><li>CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。</li><li>FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。同样，SCGI 协议与 FastCGI 类似。</li><li>PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。</li><li>PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。</li></ul><h2 id="进程数和并发数的关系"><a href="#进程数和并发数的关系" class="headerlink" title="进程数和并发数的关系"></a>进程数和并发数的关系</h2><p>PHP-FPM 采用 master/worker 多进程架构。<br>即：众多的 worker 进程组成了进程池，等待 master 进程分配任务，而且每个 worker 进程只能同时处理单个任务，前一个处理结束，才能为下一个服务。<br>PHP-FPM 是 1:1 模型。单机情况下，如果 PHP-FPM 配置的最大子进程数为 20，那么就最多可以并发处理 20 个请求。之后的请求会进行排队，这个排队由fpm主进程完成，nginx采用的是异步IO模型，不会产生阻塞。</p><h2 id="php-fpm-进程管理"><a href="#php-fpm-进程管理" class="headerlink" title="php-fpm 进程管理"></a>php-fpm 进程管理</h2><p>进程包含 master 进程和 worker 进程两种进程。<br>master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。</p><h2 id="php-fpm和进程数量的关系"><a href="#php-fpm和进程数量的关系" class="headerlink" title="php-fpm和进程数量的关系"></a>php-fpm和进程数量的关系</h2><h3 id="php-fpm的两种进程管理模式"><a href="#php-fpm的两种进程管理模式" class="headerlink" title="php-fpm的两种进程管理模式"></a>php-fpm的两种进程管理模式</h3><p>php-fpm的进程数也是可以根据设置分为动态和静态的。<br>一种是直接开启指定数量的php-fpm进程，不再增加或者减少；<br>另一种则是开始的时候开启一定数量的php-fpm进程，当请求量变大的时候，动态的增加php-fpm进程数到上限，当空闲的时候自动释放空闲的进程数到一个下限。</p><p>这两种不同的执行方式，可以根据服务器的实际需求来进行调整。 这里先说一下涉及到这个的几个参数吧，他们分别是</p><pre><code>pmpm.max_childrenpm.start_serverspm.min_spare_serverspm.max_spare_servers</code></pre><p>pm表示使用那种方式，有两个值可以选择，就是static（静态）或者dynamic（动态）。 在更老一些的版本中，dynamic被称作apache-like。这个要注意看配置文件给出的说明了。PHP5.3 php-fpm的默认静态处理方式会使得php-cgi的进程长期占用内存而无法释放，这也是导致nginx出错的原因之 一，因此可以将php-fpm的处理方式改成apache模式。</p><p>下面4个参数的意思分别为：</p><pre><code>pm.max_children：静态方式下开启的php-fpm进程数量。 pm.start_servers：动态方式下的起始php-fpm进程数量。 pm.min_spare_servers：动态方式下的最小php-fpm进程数量。 pm.max_spare_servers：动态方式下的最大php-fpm进程数量。</code></pre><p>如果dm设置为static，那么其实只有pm.max_children这个参数生效。系统会开启设置的数量个php-fpm进程。<br> 如果dm设置为dynamic，那么pm.max_children参数失效，后面3个参数生效。</p><p> 系统会在php-fpm运行开始的时候启动 pm.start_servers个php-fpm进程，然后根据系统的需求动态在pm.min_spare_servers和 pm.max_spare_servers之间调整php-fpm进程数。</p><h3 id="那么，对于我们的服务器，选择哪种执行方式比较好呢？"><a href="#那么，对于我们的服务器，选择哪种执行方式比较好呢？" class="headerlink" title="那么，对于我们的服务器，选择哪种执行方式比较好呢？"></a>那么，对于我们的服务器，选择哪种执行方式比较好呢？</h3><p> 事实上，跟Apache一样，我们运行的PHP程序在执行完成后，或多或少会有内存泄露的问题。 这也是为什么开始的时候一个php-fpm进程只占用3M左右内存，运行一段时间后就会上升到20-30M的原因了。所以，动态方式因为会结束掉多余的进程，可以回收释放一些内存，所以推荐在内存较少的服务器或者VPS上使用。具体最大数量根据 内存/20M 得到。比如说512M的VPS，议pm.max_spare_servers设置为20。至于pm.min_spare_servers，则建议根据服务器的负载情况来设置，比较合适的值在5~10之间。 然后对于比较大内存的服务器来说，设置为静态的话会提高效率。因为频繁开关php-fpm进程也会有时滞，所以内存够大的情况下开静态效果会更好。数量也可以根据内存/30M 得到。比如说2GB内存的服务器，可以设置为50；4GB内存可以设置为100等。</p><h2 id="php-fpm操作"><a href="#php-fpm操作" class="headerlink" title="php-fpm操作"></a>php-fpm操作</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>/usr/local/php/sbin/php-fpm</code></pre><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>master进程可以理解以下信号</p><pre><code>INT, TERM 立刻终止QUIT 平滑终止USR1 重新打开日志文件USR2 平滑重载所有worker进程并重新载入配置和二进制模块</code></pre><p>关闭命令</p><pre><code>kill -QUIT 42891</code></pre><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>先查看php-fpm的master进程号</p><pre><code># ps aux|grep php-fpmroot     21891  0.0  0.0 112660   960 pts/3    R+   16:18   0:00 grep --color=auto php-fpmroot     42891  0.0  0.1 182796  1220 ?        Ss   4月18   0:19 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)nobody   42892  0.0  0.6 183000  6516 ?        S    4月18   0:07 php-fpm: pool wwwnobody   42893  0.0  0.6 183000  6508 ?        S    4月18   0:17 php-fpm: pool www</code></pre><p>重启命令</p><pre><code>kill -USR2 42891</code></pre><p>上面方案一般是没有生成php-fpm.pid文件时使用，如果要生成php-fpm.pid，使用下面这种方案：</p><p>上面master进程可以看到，matster使用的是/usr/local/php/etc/php-fpm.conf这个配置文件，cat /usr/local/php/etc/php-fpm.conf 发现：</p><pre><code>[global]; Pid file; Note: the default prefix is /usr/local/php/var; Default Value: none;pid = run/php-fpm.pid</code></pre><p>pid文件路径应该位于/usr/local/php/var/run/php-fpm.pid，由于注释掉，所以没有生成，我们把注释去除，再kill -USR2 42891 重启php-fpm,便会生成pid文件，下次就可以使用以下命令重启,关闭php-fpm了：</p><pre><code>php-fpm 关闭：kill -INT &apos;cat /usr/local/php/var/run/php-fpm.pid&apos;php-fpm 重启：kill -USR2 &apos;cat /usr/local/php/var/run/php-fpm.pid&apos;</code></pre><h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2><h3 id="避免程序跑死（hang）"><a href="#避免程序跑死（hang）" class="headerlink" title="避免程序跑死（hang）"></a>避免程序跑死（hang）</h3><p>在负载较高的服务器上定时重载php-fpm，reload可以平滑重启而不影响生产系统的php脚本运行，每15分钟reload一次，定时任务如下：</p><pre><code>0-59/15 * * * * /usr/local/php/sbin/php-fpm reload</code></pre><h3 id="增加最大处理请求数"><a href="#增加最大处理请求数" class="headerlink" title="增加最大处理请求数"></a>增加最大处理请求数</h3><p>最大处理请求数是指一个php-fpm的worker进程在处理多少个请求后就终止掉，master进程会重新respawn新的。该配置可以避免php解释器自身或程序引起的memory leaks。默认值是500，可以修改为如下配置：</p><pre><code>pm.max_requests = 1024</code></pre><p>这段配置的意思是，当一个 PHP-CGI 进程处理的请求数累积到 500 个后，自动重启该进程。<br>但是为什么要重启进程呢？</p><p>一般在项目中，我们多多少少都会用到一些 PHP 的第三方库，这些第三方库经常存在内存泄漏问题，如果不定期重启 PHP-CGI 进程，势必造成内存使用量不断增长。因此 PHP-FPM 作为 PHP-CGI 的管理器，提供了这么一项监控功能，对请求达到指定次数的 PHP-CGI 进程进行重启，保证内存使用量不增长。</p><p>正是因为这个机制，在高并发的站点中，经常导致 502 错误，我猜测原因是 PHP-FPM 对从 NGINX 过来的请求队列没处理好。不过我目前用的还是 PHP 5.3.2，不知道在 PHP 5.3.3 中是否还存在这个问题。</p><p>目前我们的解决方法是，把这个值尽量设置大些，尽可能减少 PHP-CGI 重新 SPAWN 的次数，同时也能提高总体性能。在我们自己实际的生产环境中发现，内存泄漏并不明显，因此我们将这个值设置得非常大（204800）。大家要根据自己的实际情况设置这个值，不能盲目地加大。</p><h3 id="优化动态fpm进程数"><a href="#优化动态fpm进程数" class="headerlink" title="优化动态fpm进程数"></a>优化动态fpm进程数</h3><pre><code>pm.max_children = 100pm.start_servers = 30pm.min_spare_servers = 20pm.max_spare_servers = 100pm.max_requests = 500</code></pre><p>对于我们的服务器，选择哪种执行方式比较好呢？事实上，跟Apache一样，运行的PHP程序在执行完成后，或多或少会有内存泄露的问题。<br>这也是为什么开始的时候一个php-fpm进程只占用3M左右内存，运行一段时间后就会上升到20-30M的原因了。<br>对于内存大的服务器（比如8G以上）来说，指定静态的max_children实际上更为妥当，因为这样不需要进行额外的进程数目控制，会提高效率。<br>因为频繁开关php-fpm进程也会有时滞，所以内存够大的情况下开静态效果会更好。数量也可以根据 内存/30M 得到，比如8GB内存可以设置为100，<br>那么php-fpm耗费的内存就能控制在 2G-3G的样子。如果内存稍微小点，比如1G，那么指定静态的进程数量更加有利于服务器的稳定。<br>这样可以保证php-fpm只获取够用的内存，将不多的内存分配给其他应用去使用，会使系统的运行更加畅通。<br>对于小内存的服务器来说，比如256M内存的VPS，即使按照一个20M的内存量来算，10个php-cgi进程就将耗掉200M内存，那系统的崩溃就应该很正常了。<br>因此应该尽量地控制php-fpm进程的数量，大体明确其他应用占用的内存后，给它指定一个静态的小数量，会让系统更加平稳一些。或者使用动态方式，<br>因为动态方式会结束掉多余的进程，可以回收释放一些内存，所以推荐在内存较少的服务器或VPS上使用。具体最大数量根据 内存/20M 得到。<br>比如说512M的VPS，建议pm.max_spare_servers设置为20。至于pm.min_spare_servers，则建议根据服务器的负载情况来设置，比如服务器上只是部署php环境的话，比较合适的值在5~10之间。</p><h2 id="php-fpm-config的参数配置"><a href="#php-fpm-config的参数配置" class="headerlink" title="php-fpm.config的参数配置"></a>php-fpm.config的参数配置</h2><p>FPM 使用类似 php.ini 语法的 php-fpm.conf 和进程池配置文件。<br>php-fpm.conf 全局配置段</p><h4 id="pid-string"><a href="#pid-string" class="headerlink" title="pid string"></a>pid string</h4><p>   PID 文件的位置。默认为空。</p><h4 id="error-log-string"><a href="#error-log-string" class="headerlink" title="error_log string"></a>error_log string</h4><p>   错误日志的位置。默认：#INSTALL_PREFIX#/log/php-fpm.log。 如果设置为 “syslog”，日志将不会写入本地文件，而是发送到 syslogd。</p><h4 id="log-level-string"><a href="#log-level-string" class="headerlink" title="log_level string"></a>log_level string</h4><p>   错误级别。可用级别为：alert（必须立即处理），error（错误情况），warning（警告情况），notice（一般重要信息），debug（调试信息）。默认：notice。</p><h4 id="syslog-facility-string"><a href="#syslog-facility-string" class="headerlink" title="syslog.facility string"></a>syslog.facility string</h4><p>   设置何种程序记录消息，默认值：daemon。</p><h4 id="syslog-ident-string"><a href="#syslog-ident-string" class="headerlink" title="syslog.ident string"></a>syslog.ident string</h4><p>   为每条信息添加前缀。 如果在同一台服务器上运行了多个 FPM 实例，可以修改此默认值来满足需求。默认值：php-fpm。</p><h4 id="emergency-restart-threshold-int"><a href="#emergency-restart-threshold-int" class="headerlink" title="emergency_restart_threshold int"></a>emergency_restart_threshold int</h4><p>   如果子进程在 emergency_restart_interval 设定的时间内收到该参数设定次数的 SIGSEGV 或者 SIGBUS退出信息号，则FPM会重新启动。0 表示“关闭该功能”。默认值：0（关闭）。</p><h4 id="emergency-restart-interval-mixed"><a href="#emergency-restart-interval-mixed" class="headerlink" title="emergency_restart_interval mixed"></a>emergency_restart_interval mixed</h4><p>   emergency_restart_interval 用于设定平滑重启的间隔时间。这么做有助于解决加速器中共享内存的使用问题。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。</p><h4 id="process-control-timeout-mixed"><a href="#process-control-timeout-mixed" class="headerlink" title="process_control_timeout mixed"></a>process_control_timeout mixed</h4><p>   设置子进程接受主进程复用信号的超时时间。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。</p><h4 id="process-max-int"><a href="#process-max-int" class="headerlink" title="process.max int"></a>process.max int</h4><p>   Fork 的最大 FPM 进程数。使用动态管理进程数时，此设计可以控制在一个进程池内的全局进程数量。 使用需谨慎。默认值：0。</p><h4 id="process-priority-int"><a href="#process-priority-int" class="headerlink" title="process.priority int"></a>process.priority int</h4><p>   设置 master 进程的 nice(2) 优先级（如果设置了此值）。 可以是 -19（最高优先级）到 20 （更低优先级）。 默认值：不设置。</p><h4 id="daemonize-boolean"><a href="#daemonize-boolean" class="headerlink" title="daemonize boolean"></a>daemonize boolean</h4><p>   设置 FPM 在后台运行。设置“no”将 FPM 保持在前台运行用于调试。默认值：yes。</p><h4 id="rlimit-files-int"><a href="#rlimit-files-int" class="headerlink" title="rlimit_files int"></a>rlimit_files int</h4><p>   设置 master 进程的打开文件描述符 rlimit 数。</p><h4 id="rlimit-core-int"><a href="#rlimit-core-int" class="headerlink" title="rlimit_core int"></a>rlimit_core int</h4><p>   设置 master 进程最大 core 的 rlimit 尺寸。 默认值：0。</p><h4 id="events-mechanism-string"><a href="#events-mechanism-string" class="headerlink" title="events.mechanism string"></a>events.mechanism string</h4><p>   设置 FPM 使用的事件机制。 可用以下选项：select、pool、epoll、kqueue (*BSD)、port (Solaris)。 默认值：不设置（自动检测）</p><h4 id="systemd-interval-int"><a href="#systemd-interval-int" class="headerlink" title="systemd_interval int"></a>systemd_interval int</h4><p>   使用 systemd 集成的 FPM 时，设置间歇秒数，报告健在通知给 systemd。 设置为 0 表示禁用。默认值：10。</p><h3 id="运行配置区段"><a href="#运行配置区段" class="headerlink" title="运行配置区段"></a>运行配置区段</h3><p>在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。</p><h4 id="listen-string"><a href="#listen-string" class="headerlink" title="listen string"></a>listen string</h4><p>   设置接受 FastCGI 请求的地址。可用格式为：’ip:port’，’port’，’/path/to/unix/socket’。每个进程池都需要设置。</p><h4 id="listen-backlog-int"><a href="#listen-backlog-int" class="headerlink" title="listen.backlog int"></a>listen.backlog int</h4><p>   设置 listen(2) 的 backlog 最大值。“-1”表示无限制。默认值：-1。</p><h4 id="listen-allowed-clients-string"><a href="#listen-allowed-clients-string" class="headerlink" title="listen.allowed_clients string"></a>listen.allowed_clients string</h4><p>   设置允许连接到 FastCGI 的服务器 IPV4 地址。等同于 PHP FastCGI (5.2.2+) 中的 FCGI_WEB_SERVER_ADDRS 环境变量。仅对 TCP 监听起作用。每个地址是用逗号分隔，如果没有设置或者为空，则允许任何服务器请求连接。默认值：any。 PHP 5.5.20 和 5.6.4起，开始支持 IPv6 地址。</p><h4 id="listen-owner-string"><a href="#listen-owner-string" class="headerlink" title="listen.owner string"></a>listen.owner string</h4><p>   如果使用了 Unix 套接字，表示它的权限。在 Linux 中必须设置读/写权限，以便用于 WEB 服务器连接。 在很多 BSD 派生的系统中可以忽略权限允许自由连接。 默认值：运行所使用的用户和组，权限为 0660。</p><h4 id="listen-group-string"><a href="#listen-group-string" class="headerlink" title="listen.group string"></a>listen.group string</h4><p>   参见 listen.owner。</p><h4 id="listen-mode-string"><a href="#listen-mode-string" class="headerlink" title="listen.mode string"></a>listen.mode string</h4><p>   参见 listen.owner。</p><h4 id="listen-acl-users-string"><a href="#listen-acl-users-string" class="headerlink" title="listen.acl_users string"></a>listen.acl_users string</h4><p>   当系统支持 POSIX ACL（Access Control Lists）时，可以设置使用此选项。 当设置了的时候，将会忽略 listen.owner 和 listen.group。 值是逗号分割的用户名列表。 PHP 5.6.5 起可用。</p><h4 id="listen-acl-groups-string"><a href="#listen-acl-groups-string" class="headerlink" title="listen.acl_groups string"></a>listen.acl_groups string</h4><p>   参见 listen.acl_users。 值是逗号分割的用户组名称列表。 PHP 5.6.5 起可用。</p><h4 id="user-string"><a href="#user-string" class="headerlink" title="user string"></a>user string</h4><p>   FPM 进程运行的Unix用户。必须设置。</p><h4 id="group-string"><a href="#group-string" class="headerlink" title="group string"></a>group string</h4><p>   FPM 进程运行的 Unix 用户组。如果不设置，就使用默认用户的用户组。</p><h4 id="pm-string"><a href="#pm-string" class="headerlink" title="pm string"></a>pm string</h4><p>   设置进程管理器如何管理子进程。可用值：static，ondemand，dynamic。必须设置。</p><p>   static - 子进程的数量是固定的（pm.max_children）。</p><p>   ondemand - 进程在有需求时才产生（当请求时才启动。与 dynamic 相反，在服务启动时 pm.start_servers 就启动了。</p><p>   dynamic - 子进程的数量在下面配置的基础上动态设置：pm.max_children，pm.start_servers，pm.min_spare_servers，pm.max_spare_servers。</p><h4 id="pm-max-children-int"><a href="#pm-max-children-int" class="headerlink" title="pm.max_children int"></a>pm.max_children int</h4><p>   pm 设置为 static 时表示创建的子进程的数量，pm 设置为 dynamic 时表示最大可创建的子进程的数量。必须设置。</p><p>   该选项设置可以同时提供服务的请求数限制。类似 Apache 的 mpm_prefork 中 MaxClients 的设置和 普通PHP FastCGI中的 PHP_FCGI_CHILDREN 环境变量。</p><h4 id="pm-start-servers-in"><a href="#pm-start-servers-in" class="headerlink" title="pm.start_servers in"></a>pm.start_servers in</h4><p>   设置启动时创建的子进程数目。仅在 pm 设置为 dynamic 时使用。默认值：min_spare_servers + (max_spare_servers - min_spare_servers) / 2。</p><h4 id="pm-min-spare-servers-int"><a href="#pm-min-spare-servers-int" class="headerlink" title="pm.min_spare_servers int"></a>pm.min_spare_servers int</h4><p>   设置空闲服务进程的最低数目。仅在 pm 设置为 dynamic 时使用。必须设置。</p><h4 id="pm-max-spare-servers-int"><a href="#pm-max-spare-servers-int" class="headerlink" title="pm.max_spare_servers int"></a>pm.max_spare_servers int</h4><p>   设置空闲服务进程的最大数目。仅在 pm 设置为 dynamic 时使用。必须设置。</p><h4 id="pm-process-idle-timeout-mixed"><a href="#pm-process-idle-timeout-mixed" class="headerlink" title="pm.process_idle_timeout mixed"></a>pm.process_idle_timeout mixed</h4><p>   秒数，多久之后结束空闲进程。 仅当设置 pm 为 ondemand。 可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：10s。</p><h4 id="pm-max-requests-int"><a href="#pm-max-requests-int" class="headerlink" title="pm.max_requests int"></a>pm.max_requests int</h4><p>   设置每个子进程重生之前服务的请求数。对于可能存在内存泄漏的第三方模块来说是非常有用的。如果设置为 ‘0’ 则一直接受请求，等同于 PHP_FCGI_MAX_REQUESTS 环境变量。默认值：0。</p><h4 id="pm-status-path-string"><a href="#pm-status-path-string" class="headerlink" title="pm.status_path string"></a>pm.status_path string</h4><p>   FPM 状态页面的网址。如果没有设置，则无法访问状态页面，默认值：无。</p><h4 id="ping-path-string"><a href="#ping-path-string" class="headerlink" title="ping.path string"></a>ping.path string</h4><p>   FPM 监控页面的 ping 网址。如果没有设置，则无法访问 ping 页面。该页面用于外部检测 FPM 是否存活并且可以响应请求。请注意必须以斜线开头（/）。</p><h4 id="ping-response-string"><a href="#ping-response-string" class="headerlink" title="ping.response string"></a>ping.response string</h4><p>   用于定义 ping 请求的返回响应。返回为 HTTP 200 的 text/plain 格式文本。默认值：pong。</p><h4 id="process-priority-int-1"><a href="#process-priority-int-1" class="headerlink" title="process.priority int"></a>process.priority int</h4><p>   设置 worker 的 nice(2)优先级（如果设置了的话）。 该值从 -19（最高优先级） 到 20（更低优先级）。 默认值：不设置</p><h4 id="prefix-string"><a href="#prefix-string" class="headerlink" title="prefix string"></a>prefix string</h4><p>   检测路径时使用的前缀。</p><h4 id="request-terminate-timeout-mixed"><a href="#request-terminate-timeout-mixed" class="headerlink" title="request_terminate_timeout mixed"></a>request_terminate_timeout mixed</h4><p>   设置单个请求的超时中止时间。该选项可能会对 php.ini 设置中的 ‘max_execution_time’ 因为某些特殊原因没有中止运行的脚本有用。设置为 ‘0’ 表示 ‘Off’。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。</p><h4 id="request-slowlog-timeout-mixed"><a href="#request-slowlog-timeout-mixed" class="headerlink" title="request_slowlog_timeout mixed"></a>request_slowlog_timeout mixed</h4><p>   当一个请求该设置的超时时间后，就会将对应的 PHP 调用堆栈信息完整写入到慢日志中。设置为 ‘0’ 表示 ‘Off’。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。</p><h4 id="slowlog-string"><a href="#slowlog-string" class="headerlink" title="slowlog string"></a>slowlog string</h4><p>   慢请求的记录日志。默认值：#INSTALL_PREFIX#/log/php-fpm.log.slow。</p><h4 id="rlimit-files-int-1"><a href="#rlimit-files-int-1" class="headerlink" title="rlimit_files int"></a>rlimit_files int</h4><p>   设置文件打开描述符的 rlimit 限制。默认值：系统定义值。</p><h4 id="rlimit-core-int-1"><a href="#rlimit-core-int-1" class="headerlink" title="rlimit_core int"></a>rlimit_core int</h4><p>   设置核心 rlimit 最大限制值。可用值：’unlimited’，0 或者正整数。默认值：系统定义值。</p><h4 id="chroot-string"><a href="#chroot-string" class="headerlink" title="chroot string"></a>chroot string</h4><p>   启动时的 Chroot 目录。所定义的目录需要是绝对路径。如果没有设置，则 chroot 不被使用。</p><h4 id="chdir-string"><a href="#chdir-string" class="headerlink" title="chdir string"></a>chdir string</h4><p>   设置启动目录，启动时会自动 Chdir 到该目录。所定义的目录需要是绝对路径。默认值：当前目录，或者根目录（chroot时）。</p><h4 id="catch-workers-output-boolean"><a href="#catch-workers-output-boolean" class="headerlink" title="catch_workers_output boolean"></a>catch_workers_output boolean</h4><p>   重定向运行过程中的 stdout 和 stderr 到主要的错误日志文件中。如果没有设置，stdout 和 stderr 将会根据 FastCGI 的规则被重定向到 /dev/null。默认值：无。</p><h4 id="clear-env-boolean"><a href="#clear-env-boolean" class="headerlink" title="clear_env boolean"></a>clear_env boolean</h4><p>   为 FPM worker 进程清除环境变量。 在进程池配置文件里设置环境变量前，阻止任意系统的环境变量进入 FPM worker 进程。 自 PHP 5.4.27、 5.5.11 和 5.6.0 起。 默认值: Yes</p><h4 id="security-limit-extensions-string"><a href="#security-limit-extensions-string" class="headerlink" title="security.limit_extensions string"></a>security.limit_extensions string</h4><p>   限制 FPM 允许解析的脚本扩展名。 此设置可以预防 web 服务器配置的错误。 应当限制 FPM 仅仅解析 .php 扩展名，阻止恶意用户使用其他扩展名运行 php 代码。 默认值： .php .phar</p><h4 id="access-log-string"><a href="#access-log-string" class="headerlink" title="access.log string"></a>access.log string</h4><p>   Access log 文件。 默认值：不设置</p><h4 id="access-format-string"><a href="#access-format-string" class="headerlink" title="access.format string"></a>access.format string</h4><p>   access log 的格式。 默认值: “%R - %u %t \”%m %r\” %s”</p><p>还可以在为一个运行池传递附加的环境变量，或者更新 PHP 的配置值。可以在进程池配置文件中如下面的配置参数来做到：</p><h4 id="Example-1-给运行池传递环境变量和设置-PHP-的配置值"><a href="#Example-1-给运行池传递环境变量和设置-PHP-的配置值" class="headerlink" title="Example #1 给运行池传递环境变量和设置 PHP 的配置值"></a>Example #1 给运行池传递环境变量和设置 PHP 的配置值</h4><pre><code>env[HOSTNAME] = $HOSTNAMEenv[PATH] = /usr/local/bin:/usr/bin:/binenv[TMP] = /tmpenv[TMPDIR] = /tmpenv[TEMP] = /tmpphp_admin_value[sendmail_path] = /usr/sbin/sendmail -t -i -f www@my.domain.comphp_flag[display_errors] = offphp_admin_value[error_log] = /var/log/fpm-php.www.logphp_admin_flag[log_errors] = onphp_admin_value[memory_limit] = 32M</code></pre><p>PHP配置值通过 php_value 或者 php_flag 设置，并且会覆盖以前的值。请注意 disable_functions 或者 disable_classes 在 php.ini 之中定义的值不会被覆盖掉，但是会将新的设置附加在原有值的后面。</p><p>使用 php_admin_value 或者 php_admin_flag 定义的值，不能被 PHP 代码中的 ini_set() 覆盖。</p><p>自 5.3.3 起，也可以通过 web 服务器设置 PHP 的设定。</p><h4 id="Example-2-在-nginx-conf-中设定-PHP"><a href="#Example-2-在-nginx-conf-中设定-PHP" class="headerlink" title="Example #2 在 nginx.conf 中设定 PHP"></a>Example #2 在 nginx.conf 中设定 PHP</h4><pre><code>set $php_value &quot;pcre.backtrack_limit=424242&quot;;set $php_value &quot;$php_value \n pcre.recursion_limit=99999&quot;;fastcgi_param  PHP_VALUE $php_value;fastcgi_param  PHP_ADMIN_VALUE &quot;open_basedir=/var/www/htdocs&quot;;</code></pre><h4 id="Caution"><a href="#Caution" class="headerlink" title="Caution"></a>Caution</h4><p>由于这些设定是以 FastCGI 标头传递给 php-fpm，php-fpm 不应绑定到外部网可以访问的地址上，否则任何人都能修改 PHP 的配置选项了。参见 listen.allowed_clients。</p><h3 id="各项配置解析"><a href="#各项配置解析" class="headerlink" title="各项配置解析"></a>各项配置解析</h3><pre><code>pid = run/php-fpm.pid#pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启error_log = log/php-fpm.log#错误日志，默认在安装目录中的var/log/php-fpm.loglog_level = notice#错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.emergency_restart_threshold = 60emergency_restart_interval = 60s#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。process_control_timeout = 0#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.daemonize = yes#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。listen = 127.0.0.1:9000#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’. 每个进程池都需要设置.listen.backlog = -1#backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：http://www.3gyou.cc/?p=41listen.allowed_clients = 127.0.0.1#允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接listen.owner = wwwlisten.group = wwwlisten.mode = 0666#unix socket设置选项，如果使用tcp方式访问，这里注释即可。user = wwwgroup = www#启动进程的帐户和组pm = dynamic #对于专用服务器，pm可以设置为static。#如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：pm.max_children #，子进程最大数pm.start_servers #，启动时的进程数pm.min_spare_servers #，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程pm.max_spare_servers #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理pm.max_requests = 1000#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ’0′ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.pm.status_path = /status#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到ping.path = /ping#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。ping.response = pong#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.request_terminate_timeout = 0#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ’0′ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。request_slowlog_timeout = 10s#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 ’0′ 表示 ‘Off’slowlog = log/$pool.log.slow#慢请求的记录日志,配合request_slowlog_timeout使用rlimit_files = 1024#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。rlimit_core = 0#设置核心rlimit最大限制值. 可用值: ‘unlimited’ 、0或者正整数. 默认值: 系统定义值.chroot =#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.chdir =#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）catch_workers_output = yes#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空.</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://php.net/manual/zh/install.fpm.configuration.php" target="_blank" rel="external">http://php.net/manual/zh/install.fpm.configuration.php</a><br><a href="http://blog.51reboot.com/cgi-fastcgi-wsgi/" target="_blank" rel="external">http://blog.51reboot.com/cgi-fastcgi-wsgi/</a><br><a href="https://www.awaimai.com/371.html" target="_blank" rel="external">https://www.awaimai.com/371.html</a><br><a href="https://www.cnblogs.com/ahaii/p/5776809.html" target="_blank" rel="external">https://www.cnblogs.com/ahaii/p/5776809.html</a><br><a href="https://blog.csdn.net/mijar2016/article/details/53311986" target="_blank" rel="external">https://blog.csdn.net/mijar2016/article/details/53311986</a></p><p>1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php-fpm" scheme="http://martist.cn/categories/php-fpm/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
      <category term="php-fpm" scheme="http://martist.cn/tags/php-fpm/"/>
    
  </entry>
  
  <entry>
    <title>monolog</title>
    <link href="http://martist.cn/2018/04/13/PHP/monolog/"/>
    <id>http://martist.cn/2018/04/13/PHP/monolog/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-16T08:55:05.910Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="php中的日志库"><a href="#php中的日志库" class="headerlink" title="php中的日志库"></a>php中的日志库</h2><p>php中并没有内建的日志接口，故长期以来也没一个功能完备并且应用广泛的日志库。monolog是一个为5.3以上版本php开发的日志库，但是需要注意的是现在主干版本只支持php 7以上版本，如果你的服务器环境还是php 5的话，可以使用monolog的1.x版本。</p><p>monolog的github地址：<a href="https://github.com/Seldaek/monolog" target="_blank" rel="external">https://github.com/Seldaek/monolog</a><br>中文文档地址：<a href="https://github.com/Clarence-pan/monolog-zh-doc" target="_blank" rel="external">https://github.com/Clarence-pan/monolog-zh-doc</a><br>psr规范官方地址：<a href="https://www.php-fig.org/psr" target="_blank" rel="external">https://www.php-fig.org/psr</a></p><p>值得一提的是monolog是一个符合psr-3规范的日志类库，并且符合psr-4加载规范。这有利于松耦合的融入框架中。下面是正在使用monolog作为日志组件的框架。</p><h3 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h3><p>使用 PSR-3 的框架和库可以非常简单地集成 Monolog, 因为它实现了这个接口。<br>Symfony2 开箱即用 Monolog.<br>Silex 开箱即用 Monolog.<br>Laravel 4 &amp; 5 开箱即用 Monolog.<br>Lumen 开箱即用 Monolog.<br>PPI 开箱即用 Monolog.<br>CakePHP 可以通过 cakephp-monolog 这个插件来使用 Monolog.<br>Slim 可以通过 Slim-Monolog 这个日志适配器来使用 Monolog.<br>XOOPS 2.6 开箱即用 Monolog.<br>Aura.Web_Project 开箱即用 Monolog.<br>Nette Framework 可以通过 Kdyby/Monolog 这个扩展来使用 Monolog.<br>Proton Micro Framework 开箱即用 Monolog.<br>FuelPHP 开箱即用 Monolog.<br>Equip Framework 开箱即用 Monolog.<br>Yii 2 可以通过 yii2-monolog 这个插件来使用 Monolog.<br>Hawkbit Micro Framework 开箱即用 Monolog.</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>Monolog 需要 PHP 7.0 或以上版本才能正常工作。至于 PHP 5.3 请使用 Monolog ^1.0.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>composer require monolog/monolog</code></pre><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;// 创建一个日志通道$log = new Logger(&apos;name&apos;);$log-&gt;pushHandler(new StreamHandler(&apos;path/to/your.log&apos;, Logger::WARNING));// 添加日志记录$log-&gt;warning(&apos;Foo&apos;);$log-&gt;error(&apos;Bar&apos;);</code></pre><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>每一个日志服务实例 (Logger) 都有一个通道（名称），并有一个处理器 (Handler)栈. 无论何时你添加一条 记录 到对应的日志服务实例，这个处理器栈将被遍历一遍：每个处理器都将依次决定是否要处理这条记录，而如果要处理，则遍历结束（译注：类似DOM事件冒泡）。</p><p>这样子可以创建非常灵活的日志配置。比如一个 StreamHandler 可以把所有日志都写入磁盘，而上面加个MailHandler 可以把错误日志作为邮件发送出去。处理器还有一个 $bubble 属性定义了是否屏蔽某条记录或者处理了某条记录。在这个示例中，配置 MailHandler 的 $bubble 参数为 false 则意味着 MailHandler 将不会把自己已处理过的记录继续冒泡给 StreamHandler.</p><p>你可以创建许多日志服务实例(Logger)，每一个则定义一个通道（比如数据库、请求、路由…）。而每一个日志服务实例都可以组合各种各样的处理器，可以共享处理器也可以不共享。这个通道将会在日志中反映出来，从而允许你可以很容易地查看或者筛选记录。</p><p>每一个处理还会有一个格式化器（Formatter）。如果你没有配置一个，则一个有意义的默认的格式化器将被创建。格式化器用来规范化并格式化输入的记录，以便处理器能输出一些有用的信息。</p><p>不支持自定义的严重性级别。只支持使用RFC 5424中定义的八个级别（调试/Debug、信息/Info、提示/Notice、警告/Warning、错误/Error、严重/Critical、警报/Alert、紧急/Emergency）来作为基本的筛选目的。不过，如果为了排序或者其他需要灵活性的使用场景，你可以添加加工程序（Processor）从而可以在（处理器）处理前添加额外的信息（标签、用户IP…）。</p><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>Monolog 支持一下 RFC 5424 中的日志级别：</p><pre><code>调试/DEBUG (100): 详细的调试信息。信息/INFO (200): 有意义的事件，比如用户登录、SQL日志。提示/NOTICE (250): 正常但是值得注意的事件。警告/WARNING (300): 异常事件，但是并不是错误。比如使用了废弃了的API，错误地使用了一个API，以及其他不希望发生但是并非必要的错误。错误/ERROR (400): 运行时的错误，不需要立即注意到，但是需要被专门记录并监控到。严重/CRITICAL (500): 边界条件/危笃场景。比如应用组件不可用了，未预料到的异常。警报/ALERT (550): 必须立即采取行动。比如整个网站都挂了，数据库不可用了等。这种情况应该发送短信警报，并把你叫醒。紧急/EMERGENCY (600): 紧急请求：系统不可用了。</code></pre><h2 id="配置一个日志服务"><a href="#配置一个日志服务" class="headerlink" title="配置一个日志服务"></a>配置一个日志服务</h2><p>这里有一个基本的配置，可以记录日志到文件，并在 DEBUG 级别下记录到 firephp 中:</p><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;use Monolog\Handler\FirePHPHandler;// 创建日志服务$logger = new Logger(&apos;my_logger&apos;);// 添加一些处理器$logger-&gt;pushHandler(new StreamHandler(__DIR__.&apos;/my_app.log&apos;, Logger::DEBUG));$logger-&gt;pushHandler(new FirePHPHandler());// 现在你就可以用日志服务了$logger-&gt;info(&apos;My logger is now ready&apos;);</code></pre><p>解释一下。第一步是创建日志服务实例，这个实例后将在代码中用到。唯一的参数是通道的名称，它在你有多个日志服务实例的时候很有用。（更多详情参见下面）</p><p>这个日志服务实例自己是不是知道如何处理一条日志记录的。它把记录代理给了一些处理器。上面的代码中注册了两个处理器到栈中，以便允许使用两种不同的方式来处理日志记录。</p><p>注意，FirePHPHandler 是被先调用的，因而它被添加到了栈顶。这允许你临时添加一个禁止冒泡的处理器从而允许你覆盖其他配置的日志（处理器）。</p><pre><code>如果你单独使用 Monolog, 并且在寻找一种简单的方式来配置许多处理器，那可以用 theorchard/monolog-cascade 。 它可以帮你使用PHP数组、YAML或者JSON来构建复杂的日志配置。</code></pre><h2 id="为记录添加额外的数据"><a href="#为记录添加额外的数据" class="headerlink" title="为记录添加额外的数据"></a>为记录添加额外的数据</h2><p>Monolog 提供了两种不同的方式来为简单的文本消息增加额外的信息</p><h3 id="使用上下文-context"><a href="#使用上下文-context" class="headerlink" title="使用上下文(context)"></a>使用上下文(context)</h3><p>第一种方式是使用上下文（context），这允许你在传递记录的时候传递一个数组格式的数据：</p><pre><code>&lt;?php$logger-&gt;info(&apos;Adding a new user&apos;, array(&apos;username&apos; =&gt; &apos;Seldaek&apos;));</code></pre><p>简单的处理器（比如StreamHandler）将只是把数组转换成字符串。而复杂的处理器则可以利用上下文的优点（如 FirePHP 则将以一种优美的方式显示数组）。</p><h3 id="使用加工程序-Processor"><a href="#使用加工程序-Processor" class="headerlink" title="使用加工程序(Processor)"></a>使用加工程序(Processor)</h3><p>第二种方式是使用加工程序来为所有的记录添加额外数据。加工程序可以是任何可以调用的函数。 加工程序接收日志记录作为参数，并且需要在修改了extra字段后再返回日志记录。让我们来写一个添加一些假数据的加工程序：</p><pre><code>&lt;?php$logger-&gt;pushProcessor(function ($record) {    $record[&apos;extra&apos;][&apos;dummy&apos;] = &apos;Hello world!&apos;;    return $record;});</code></pre><p>Monolog提供了一些内置的加工程序，你可以在你的项目中使用它们。请参见对应的章节.</p><pre><code>小技巧：加工程序可以被注册到一个特定的处理器上而不是直接在日志服务实例上，从而可以只在对应的处理器上生效。</code></pre><h2 id="使用通道"><a href="#使用通道" class="headerlink" title="使用通道"></a>使用通道</h2><p>通道是一种非常棒的方式来区分是应用的哪个部分的日志被记录下来的。这通常在大型项目中非常有用（而且被Symfony2的MonologBundle所使用）。</p><p>假设有两个日志服务实例共享了一个处理器，这个处理器将日志写入单个日志文件。通道则将允许你来区分是哪个日志服务实例记录了哪条日志。你可以很简单地通过通道来筛选日志。</p><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;use Monolog\Handler\FirePHPHandler;// 创建一些处理器$stream = new StreamHandler(__DIR__.&apos;/my_app.log&apos;, Logger::DEBUG);$firephp = new FirePHPHandler();// 创建应用的主要日志服务实例$logger = new Logger(&apos;my_logger&apos;);$logger-&gt;pushHandler($stream);$logger-&gt;pushHandler($firephp);// 使用另外的通道来创建安全相关的日志服务示例$securityLogger = new Logger(&apos;security&apos;);$securityLogger-&gt;pushHandler($stream);$securityLogger-&gt;pushHandler($firephp);// 或者克隆第一个，只是改变下通道$securityLogger = $logger-&gt;withName(&apos;security&apos;);</code></pre><h2 id="自定义日志格式"><a href="#自定义日志格式" class="headerlink" title="自定义日志格式"></a>自定义日志格式</h2><p>在Monolog中，可以很简单地来自定义日志的格式，无论是写入文件、套接字、邮件、数据库还是其他处理器。大多数处理器都是用 $record[‘formatted’] 这个值来自动写入日志设备。这个值依赖格式化器的配置。你可以选择预定义的格式化器类，也可以自己写一个（比如一个可读的多行文本文件）。</p><p>想要配置一个预定义的格式化器类，可以直接把它设置为处理器的字段：</p><p>// 默认的日期格式是 “Y-m-d H:i:s”<br>$dateFormat = “Y n j, g:i a”;<br>// 默认的输出格式是 “[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n”<br>$output = “%datetime% &gt; %level_name% &gt; %message% %context% %extra%\n”;<br>// 最后创建一个格式化器<br>$formatter = new LineFormatter($output, $dateFormat);</p><p>// 创建一个处理器<br>$stream = new StreamHandler(<strong>DIR</strong>.’/my_app.log’, Logger::DEBUG);<br>$stream-&gt;setFormatter($formatter);</p><p>// 将其绑定到日志服务对象上<br>$securityLogger = new Logger(‘security’);<br>$securityLogger-&gt;pushHandler($stream);</p><p>// 你还可以在多个处理器之间复用同一个格式化器，并且在多个日志服务实例间共享这些处理器。</p>]]></content>
    
    <summary type="html">
    
      这可能是php世界中最好的日志库——monolog
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>关于小产权房的一些看法</title>
    <link href="http://martist.cn/2018/04/09/%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%85%B3%E4%BA%8E%E5%B0%8F%E4%BA%A7%E6%9D%83%E6%88%BF%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/"/>
    <id>http://martist.cn/2018/04/09/非技术文章/关于小产权房的一些看法/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2018-04-16T07:37:24.915Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="先回答几个问题"><a href="#先回答几个问题" class="headerlink" title="先回答几个问题"></a>先回答几个问题</h2><h3 id="什么是小产权房？"><a href="#什么是小产权房？" class="headerlink" title="什么是小产权房？"></a>什么是小产权房？</h3><p>小产权房是指在农村集体土地上建设的房屋，未缴纳土地出让金等费用，其产权证不是由国家房管部门颁发，而是由乡政府或村政府颁发，亦称“乡产权房”。“小产权房”不是法律概念，是人们在社会实践中形成的一种约定俗成的称谓。该类房没有国家发放的土地使用证和预售许可证，购房合同在国土房管局不会给予备案。所谓产权证亦不是真正合法有效的产权证。按照国家的相关要求，“小产权房”不得确权发证，不受法律保护。</p><h3 id="小产权房有保障吗？"><a href="#小产权房有保障吗？" class="headerlink" title="小产权房有保障吗？"></a>小产权房有保障吗？</h3><p>如果有一天这些村民把开发商买地的钱花完了，没钱了，开始动歪脑筋找钱花的时候，这群敢买小产权房的羔羊是再好宰不过了。隔三差五要求你每个月交物业费，村管理费，或者看当下房价高想在卖一次，直接撕毁合同。都是买房者不能承受之重</p><blockquote><p>家里在京郊有一套小产权，可谓依山傍水，空气清新，景色怡人，完全脱离城市的喧嚣。简单整了整之后，父母每周末都要过去住两天，感情状态回到新婚的水准。<br>然后，开放商想把这卖给某企业，就断水断电，列了个正常人不会签的条件，准备收房了。– 郭云昊</p></blockquote><h3 id="小产权房为什么不受保护？"><a href="#小产权房为什么不受保护？" class="headerlink" title="小产权房为什么不受保护？"></a>小产权房为什么不受保护？</h3><p>1.本集体组织成员之间买卖小产权房一般认定合同有效<br>2.本集体与他集体组织成员之间买卖小产权房一般认定合同无效<br>3.集体组织成员与城镇居民之间买卖小产权房一般认定合同无效<br>例外情形:城镇居民在签订小产权房买卖合同后取得了该集体组织户口并经相关部门批准，该房屋买卖合同一般认定有效。<br>4.小产权房买卖合同被认定无效之后的处理规则<br>5.上海地区对小产权房纠纷特别规定</p><p><strong> 法律禁止非同一集体组织成员间小产权房买卖，因此，买卖小产权房请慎重！</strong></p><p>具体参见： <a href="https://www.zhihu.com/question/20158141" target="_blank" rel="external">https://www.zhihu.com/question/20158141</a></p><h3 id="如果购买了小产权房，需要承担什么风险呢？"><a href="#如果购买了小产权房，需要承担什么风险呢？" class="headerlink" title="如果购买了小产权房，需要承担什么风险呢？"></a>如果购买了小产权房，需要承担什么风险呢？</h3><ol><li>法律效力<br>“小产权房”买卖合同的效力一般认定无效。</li><li>房产转让<br>“小产权房”拿不到正式的房产证，因此并不构成真正法律意义上的产权。即小产权房只有使用权，没有所有权。<br>根据《中华人民共和国土地管理法》的规定，小产权房不能向非本集体成员的第三人转让或出售，即购买后不能合法转让过户。其同时对房屋的保值和升值也有一定影响。</li><li>政策风险<br>购买在建小产权房时，购房人与开发商签订合同并交付房款后，如果相关部门整顿乡产权房的建设项目，可导致部分项目停建甚至被强迫拆除。购房人会面临既无法取得房屋，又不能及时索回房款的尴尬境地。<br>其次，购房后如果遇到国家征地拆迁，由于乡产权房没有国家认可的合法产权，购房人并非合法的产权人，所以无法得到对产权进行的拆迁补偿。</li><li>监管缺位<br>乡产权房屋的开发建设没有明确的规定加以约束，开发建设的监管存在缺位，对购房者的利益有一定的影响。同时，开发单位的资质没有，房屋质量和房屋售后保修难以保证。</li></ol><p><strong>综上所述，小产权房是不受法律保障的，所以不建议购买。</strong></p><h2 id="“小产权房”能不能买？"><a href="#“小产权房”能不能买？" class="headerlink" title="“小产权房”能不能买？"></a>“小产权房”能不能买？</h2><p>通俗的说，没有所谓小产权房，咱们国家从来没有过这个概念。你口中的“小产权”其实是“没产权”，不出纠纷还好，出了事没有任何保障，断水断电，然后三天两头村民去你家闹，你不能维权。反过头来国家或者村里要整你，也只需要一纸公文。</p><p>不是内行不要碰。</p><p>小产权房经常要求全款支付，也不能贷款。其次手续各方面容易出问题。如果不是自己涉入很深，对风险把控非常彻底，或者是对卖方有十足的把控能力的话，绝对不要碰。</p><p>这类房子不能考虑未来转手，不能考虑增值空间。</p><p>千万别碰小产权“期房”，那就等于是拿着血汗钱做了一次风投。</p>]]></content>
    
    <summary type="html">
    
      北漂生活
    
    </summary>
    
      <category term="生活" scheme="http://martist.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>健身相关文章的推荐</title>
    <link href="http://martist.cn/2018/04/08/%E5%81%A5%E8%BA%AB/%E5%81%A5%E8%BA%AB%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%E7%9A%84%E6%8E%A8%E8%8D%90/"/>
    <id>http://martist.cn/2018/04/08/健身/健身相关文章的推荐/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-16T02:15:40.514Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="健身还是伤身？"><a href="#健身还是伤身？" class="headerlink" title="健身还是伤身？"></a>健身还是伤身？</h2><p><a href="https://zhuanlan.zhihu.com/p/34315947" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34315947</a></p><h2 id="健身后的禁忌—10个不要，关乎身家性命"><a href="#健身后的禁忌—10个不要，关乎身家性命" class="headerlink" title="健身后的禁忌—10个不要，关乎身家性命"></a>健身后的禁忌—10个不要，关乎身家性命</h2><p><a href="https://zhuanlan.zhihu.com/p/25606492" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25606492</a></p><h2 id="运动不是膝盖杀手，它才是"><a href="#运动不是膝盖杀手，它才是" class="headerlink" title="运动不是膝盖杀手，它才是!"></a>运动不是膝盖杀手，它才是!</h2><p><a href="https://zhuanlan.zhihu.com/p/31894631" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/31894631</a></p><h2 id="史上最全面的拉伸指南"><a href="#史上最全面的拉伸指南" class="headerlink" title="史上最全面的拉伸指南"></a>史上最全面的拉伸指南</h2><p><a href="https://zhuanlan.zhihu.com/p/32118734" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/32118734</a></p><h2 id="严谨的健身书籍推荐2-姿态评估、运动损伤和身体疼痛"><a href="#严谨的健身书籍推荐2-姿态评估、运动损伤和身体疼痛" class="headerlink" title="严谨的健身书籍推荐2 - 姿态评估、运动损伤和身体疼痛"></a>严谨的健身书籍推荐2 - 姿态评估、运动损伤和身体疼痛</h2><p><a href="https://zhuanlan.zhihu.com/p/22864752" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22864752</a></p><h2 id="物美价廉的健身装备推荐，亲测好用！"><a href="#物美价廉的健身装备推荐，亲测好用！" class="headerlink" title="物美价廉的健身装备推荐，亲测好用！"></a>物美价廉的健身装备推荐，亲测好用！</h2><p><a href="https://zhuanlan.zhihu.com/p/22762552" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22762552</a></p><p>持续更新！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="健身" scheme="http://martist.cn/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>SaaS的php技术实现</title>
    <link href="http://martist.cn/2018/04/01/%E6%9E%B6%E6%9E%84/SaaS%E7%9A%84php%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>http://martist.cn/2018/04/01/架构/SaaS的php技术实现/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-03T03:33:56.321Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="SOFTWARE-AS-A-SERVICE"><a href="#SOFTWARE-AS-A-SERVICE" class="headerlink" title="SOFTWARE AS A SERVICE"></a>SOFTWARE AS A SERVICE</h3><p>在某些方面，SaaS非常类似于早些年的瘦客户端软件模式，其中客户端（在这种情况下通常是Web浏览器）提供对服务器上运行的软件的访问点。 SaaS是消费者最熟悉的云服务形式。 SaaS将管理软件及其部署的任务转移到第三方服务。最熟悉的业务SaaS应用程序是客户关系管理应用程序，如Salesforce，像Google Apps这样的生产力软件，以及Box和Dropbox等存储解决方案的软件。</p><p>使用SaaS应用程序往往会降低软件所有权成本，因为不需要技术人员来管理软件的安装，管理和升级，同时这也可以降低软件许可的成本。SaaS应用程序通常在订阅模式上被提出来。</p><h3 id="PLATFORM-AS-A-SERVICE"><a href="#PLATFORM-AS-A-SERVICE" class="headerlink" title="PLATFORM AS A SERVICE"></a>PLATFORM AS A SERVICE</h3><p>PaaS提供比SaaS低一级的功能，通常提供可以开发和部署软件的平台。 PaaS提供者抽象处理服务器的大部分工作，并为客户提供了操作系统和服务器软件以及底层服务器硬件和网络基础设施的环境，使用户可以自由地关注业务端可扩展性及其产品或服务的应用开发。</p><p>与大多数云服务一样，PaaS是建立在虚拟化技术之上的。企业可以根据需要申请资源，随着需求的增长而不是以冗余资源投入硬件。</p><p>PaaS提供商的例子包括Heroku，Google App Engine和Red Hat的OpenShift。</p><h3 id="INFRASTRUCTURE-AS-A-SERVICE"><a href="#INFRASTRUCTURE-AS-A-SERVICE" class="headerlink" title="INFRASTRUCTURE AS A SERVICE"></a>INFRASTRUCTURE AS A SERVICE</h3><p>继续朝服务的下层看，我们就可以看到云服务的基本构件。 IaaS由高度自动化和可扩展的计算资源组成，由云存储和可以自动配置，计量和可用的按需网络功能组成。</p><p>IaaS提供商通过仪表板以及API（API可能没有）提供这些云服务器及其相关资源。 IaaS客户可以直接访问其服务器和存储，就像传统服务器一样，但这样拥有更高级别的可扩展性。 IaaS的用户可以在云中外包和构建“虚拟数据中心”，并可以访问许多与传统数据中心相同的技术和资源功能，而无需投资于服务器容量规划或物理管理维护。</p><p>IaaS是最灵活的云计算模式，允许自动的服务器，处理能力，存储和网络的自动部署。 IaaS客户对基础设施拥有真正的控制，比PaaS或SaaS服务的用户不知道高到哪里去了。 IaaS的主要用途包括PaaS，SaaS和网络规模应用程序的实际开发和部署。</p><p>有很多提供商提供Iaas，比如Navisite，Exoscale和Softlayer，具有自己独特的价格方案和服务组合可供选择。</p><p>ComputeNext（作者的网站）为IaaS提供一个经纪服务，以便你可以确保为您的应用需求选择合适的IaaS提供商。通过使用单一API对20多个云提供商进行归一化的访问，您可以比较提供商的价格和性能，从而找到最佳配置，然后构建和部署，而不会被绑死到一个平台。</p><p>具体例子可以参考：<a href="https://www.zhihu.com/question/21641778/answer/95652959" target="_blank" rel="external">https://www.zhihu.com/question/21641778/answer/95652959</a></p><h3 id="通俗的讲pass和saas的区别"><a href="#通俗的讲pass和saas的区别" class="headerlink" title="通俗的讲pass和saas的区别"></a>通俗的讲pass和saas的区别</h3><p>paas给你一个完善的开发，测试，上线的环境，应用工程代码还是需要你来开发，在开发过程需要的一些服务已经帮你做好，比如：短信服务，邮件服务，分布式文件系统服务，域名备案服务，网络端负载均衡服务，数据库端负载主从热备服务，分片服务，vpn服务，https服务，各个线上服务器的监控统计服务等；saas是应用工程帮你做好，你只需要调整下页面配置，即可上线运营，有点类似淘宝平台与淘宝入驻商家之间的关系。</p><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>saas系统分层大概是：  </p><blockquote><p>租户识别&gt;应用层&gt;数据访问层&gt;缓存层&gt;数据库  </p></blockquote><p>业务代码都是写在应用层。<br>租户识别可以用spring拦截器实现，然后使用ThreadLocal传递给后端<br>数据库和缓存层对应用层应该是透明的。程序员在写代码的时候，只关心业务逻辑，不应该担心多租户的问题。</p><h3 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h3><p>saas系统说起来很简单，任何系统似乎加个tenant_id(租户id)就变成saas系统了。比如原来的用户登录是：</p><pre><code>select username,password from users where email=&apos;abc@qq.com&apos;</code></pre><p>改成</p><pre><code>select username,password from users where email=&apos;abc@qq.com&apos; and tenant_id =1;</code></pre><p>对于复杂业务的saas系统，这样做法非常危险，而且开发效率很低。你想想如果那个程序员写sql时候忘了加 “ and tenant_id =1” . 结果不堪设想。<br>比较好做法是在数据库访问层对SQL进行改写。</p><pre><code>TenantContext.exec(&quot;select username,password from users where email=&apos;abc@qq.com&apos; &quot;);</code></pre><p>在连接池根据TenatnContext改写Sql.<br>这样做好处是，一来程序猿最多把系统搞down了，也不至于信息串了互相泄露。二来将来做分表分库也很方便，上层应用不用修改。</p><h3 id="租户识别方案"><a href="#租户识别方案" class="headerlink" title="租户识别方案"></a>租户识别方案</h3><p>比较好做法是通过url识别租户。系统是给租户生成一个随机的三级域名，比如 abc.crm.baidu.com.   如果客户想使用自己的域名，可以在cname到我们生成的三级域名，并在管理系统里面做绑定。<br>这样一个租户可以有两个域名，访问saas,一个随机生成的三级域名，另外一个租户自己的域名.代码里面可以根据过来的域名，判断是那个租户然后初始化TenantContext.<br>如果不想通过域名来做，也可以通过登录名来判断。这种方式要涉及到租户切换问题。</p><h3 id="租户管理系统（计费，订购，定制，充值，催缴）"><a href="#租户管理系统（计费，订购，定制，充值，催缴）" class="headerlink" title="租户管理系统（计费，订购，定制，充值，催缴）"></a>租户管理系统（计费，订购，定制，充值，催缴）</h3><p>Saas系统是必须考虑计费系统和租户控制系统。这个系统需要都是独立设计。比如那个租户购买了那些模块，一个月多少钱。租户可以创建最多的用户数。计费到期邮件提醒等功能。<br>计费方式一般有两种，周期性计费，类似月租方案，和使用量计费,用多少付多少。 周期性计费比较简单。也可以两者结合起来。</p><h3 id="定制化开发"><a href="#定制化开发" class="headerlink" title="定制化开发"></a>定制化开发</h3><p>SAAS的优势在于一套系统多人使用，似乎和定制化开发有冲突。比如A客户想要A功能，B客户不想要。但定制化开发是无法避免的，比如CRM系统这样复杂的系统，不可能一套系统满足所有公司的要求。定制化开发尽可能分系统，分模块去做。然后通过控制台中配置不同租户订购不同模块，那些模块可以在前端页面上显示。不同的子系统需要分开部署。前端可通过nginx根据url分发，比如 abc.crm.baidu.com/bi/xxx/xx这个地址，就分发到BI子系统。不要尝试OSGI去搞模块化，这个是个大坑。<br>还有开发和产品，现有需求一定要分析清楚，不要一上线发现后患无穷。新功能尽量做的独立可以配置。</p><h3 id="灰度升级"><a href="#灰度升级" class="headerlink" title="灰度升级"></a>灰度升级</h3><p>SAAS付费企业客户对系统问题都特别敏感。 为了减少升级可能出现问题的影响范围，一般都采用灰度升级策略。如果使用了url来区分不同租户，灰度升级配置就会很方便。可以配置nginx 来根据域名做分发，比如租户A（aaa.com）到实例1（版本1.0），租户B(bbb.com)到实例2(版本). 当需要域名配置非常多的时候，nginx配置文档会乱。这块时候可以考虑使用nignx_lua来写一些扩展模块。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="关于多租户的数据隔离方案"><a href="#关于多租户的数据隔离方案" class="headerlink" title="关于多租户的数据隔离方案"></a>关于多租户的数据隔离方案</h3><h4 id="独立数据库"><a href="#独立数据库" class="headerlink" title="独立数据库"></a>独立数据库</h4><p>这是第一种方案，即一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本较高。<br>优点：<br>为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。<br>缺点：<br>增多了数据库的安装数量，随之带来维护成本和购置成本的增加。<br>这种方案与传统的一个客户、一套数据、一套部署类似，差别只在于软件统一部署在运营商那里。如果面对的是银行、医院等需要非常高数据隔离级别的租户，可以选择这种模式，提高租用的定价。如果定价较低，产品走低价路线，这种方案一般对运营商来说是无法承受的。</p><h4 id="共享数据库，隔离数据架构"><a href="#共享数据库，隔离数据架构" class="headerlink" title="共享数据库，隔离数据架构"></a>共享数据库，隔离数据架构</h4><p>这是第二种方案，即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。<br>优点：<br>为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可支持更多的租户数量。<br>缺点：<br>如果出现故障，数据恢复比较困难，因为恢复数据库将牵涉到其他租户的数据；<br>如果需要跨租户统计数据，存在一定困难。</p><h4 id="共享数据库，共享数据架构"><a href="#共享数据库，共享数据架构" class="headerlink" title="共享数据库，共享数据架构"></a>共享数据库，共享数据架构</h4><p>这是第三种方案，即租户共享同一个Database、同一个Schema，但在表中增加TenantID多租户的数据字段。这是共享程度最高、隔离级别最低的模式。<br>优点：<br>三种方案比较，第三种方案的维护和购置成本最低，允许每个数据库支持的租户数量最多。<br>缺点：<br>隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；<br>数据备份和恢复最困难，需要逐表逐条备份和还原。<br>如果希望以最少的服务器为最多的租户提供服务，并且租户接受牺牲隔离级别换取降低成本，这种方案最适合。</p><h3 id="选择合理的实现模式"><a href="#选择合理的实现模式" class="headerlink" title="选择合理的实现模式"></a>选择合理的实现模式</h3><p>衡量三种模式主要考虑的因素是隔离还是共享。</p><h4 id="成本角度因素"><a href="#成本角度因素" class="headerlink" title="成本角度因素"></a>成本角度因素</h4><p>隔离性越好，设计和实现的难度和成本越高，初始成本越高。共享性越好，同一运营成本下支持的用户越多，运营成本越低。</p><h4 id="安全因素"><a href="#安全因素" class="headerlink" title="安全因素"></a>安全因素</h4><p>要考虑业务和客户的安全方面的要求。安全性要求越高，越要倾向于隔离。</p><h4 id="租户数量因素"><a href="#租户数量因素" class="headerlink" title="租户数量因素"></a>租户数量因素</h4><p>系统要支持多少租户？上百？上千还是上万？可能的租户越多，越倾向于共享。<br>平均每个租户要存储数据需要的空间大小。存贮的数据越多，越倾向于隔离。<br>每个租户的同时访问系统的最终用户数量。需要支持的越多，越倾向于隔离。<br>是否想针对每一租户提供附加的服务，例如数据的备份和恢复等。这方面的需求越多， 越倾向于隔离。</p><h4 id="信息监管因素"><a href="#信息监管因素" class="headerlink" title="信息监管因素"></a>信息监管因素</h4><p>要考虑政府，机关，企业，公司的安全和信息监管相关的一些政策和规定。</p><h3 id="基于laravel框架开发SaaS系统"><a href="#基于laravel框架开发SaaS系统" class="headerlink" title="基于laravel框架开发SaaS系统"></a>基于laravel框架开发SaaS系统</h3><ol><li>利用laravel内置的前置中间件对租户请求域名进行判断，进而区分租户。</li><li>每个租户的密钥来对应请求域名，后端鉴权通过每个租户不同的密钥和请求域名来制造签名，中心API服务器以此鉴权。实现ACL，防止数据遭窃。</li><li>分库分表，实现数据隔离，可以使分库作为本公司master数据库的一个备库扩展库，从而实现读写分离，数据安全，查询优化等功能。</li><li>为saas用户提供服务器前端项目，不提供数据链接，服务器前端项目为可转发请求的服务治理中间件功能的框架（curl，guzzle），租户可以买账号直接使用系统，也可以搭在自己服务器，自行增减配置运维，写前端代码添加个性化的内容比如商标、首页、详情页等等。后端接口维护在本公司的服务器，如果系统有bug可以随时处理而不需要去所有租户的服务器重新部署，实现平滑升级。</li></ol><p>1</p>]]></content>
    
    <summary type="html">
    
      对我们phper来讲，这些概念不难理解
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>简单谈接口设计</title>
    <link href="http://martist.cn/2018/03/20/%E6%9E%B6%E6%9E%84/%E7%AE%80%E5%8D%95%E8%B0%88%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
    <id>http://martist.cn/2018/03/20/架构/简单谈接口设计/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-04-26T11:21:35.998Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>关于接口设计，需要注意区分pc,wap,app不同端的接口请求和通用性，以及实现签名鉴权，访问控制等功能。</p><h2 id="接口参数定义"><a href="#接口参数定义" class="headerlink" title="接口参数定义"></a>接口参数定义</h2><p>接口设计中往可以抽象出一些新的公共参数，从事了近三年的接口开发工作中，我目前能想到了一些较为常见的公共接口参数如下：</p><table><thead><tr><th>公共参数</th><th style="text-align:center">含意</th><th>定义该参数的意义</th></tr></thead><tbody><tr><td>timestamp</td><td style="text-align:center">毫秒级时间戳</td><td>1.客户端的请求时间标示 2.后端可以做请求过期验证 3.该参数参与签名算法增加签名的唯一性</td></tr><tr><td>app_key/source</td><td style="text-align:center">签名公钥(来源)</td><td>签名算法的公钥，后端通过公钥可以得到对应的私钥（也就是来源的意义）</td></tr><tr><td>sign</td><td style="text-align:center">接口签名</td><td>通过请求的参数和定义好的签名算法生成接口签名，作用防止中间人篡改请求参数</td></tr><tr><td>did</td><td style="text-align:center">设备ID</td><td>设备的唯一标示，生成规则例如android的mac地址的md5和ios曾今udid(目前无法获取)的md5, 1:数据收集 2.便于问题追踪 3.消息推送标示</td></tr></tbody></table><h2 id="接口版本化"><a href="#接口版本化" class="headerlink" title="接口版本化"></a>接口版本化</h2><p>我不太习惯把版本号直接放到路由里面去，还有其他方式可以区别版本，比如get、post传参。</p><h2 id="接口安全性"><a href="#接口安全性" class="headerlink" title="接口安全性"></a>接口安全性</h2><h3 id="过期验证"><a href="#过期验证" class="headerlink" title="过期验证"></a>过期验证</h3><p>通过时间戳进行验证</p><pre><code>if (microtime(true)*1000 - $_REQUEST[&apos;timestamp&apos;] &gt; 5000) {    throw new \Exception(401, &apos;Expired request&apos;);}</code></pre><h3 id="签名验证-公钥校验省略，如果是saas，密钥可能不同"><a href="#签名验证-公钥校验省略，如果是saas，密钥可能不同" class="headerlink" title="签名验证(公钥校验省略，如果是saas，密钥可能不同)"></a>签名验证(公钥校验省略，如果是saas，密钥可能不同)</h3><p>通过配对私钥的加密算法产生签名，请求中携带签名进行鉴权。</p><pre><code>$params = ksort($_REQUEST);unset($params[&apos;sign&apos;]);$sign = md5(sha1(implode(&apos;-&apos;, $params) . $_REQUEST[&apos;app_key&apos;]));if ($sign !== $_REQUEST[&apos;sign&apos;]) {    throw new \Exception(401, &apos;Invalid sign&apos;);}</code></pre><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>防止一次相同请求多次攻击API服务器。</p><pre><code> /** @params noise string 随机字符串或随机正整数，与 Timestamp 联合起来, 用于防止重放攻击 例如腾讯云是6位随机正整数 */$key = md5(&quot;{$_REQUEST[&apos;REQUEST_URI&apos;]}-{$_REQUEST[&apos;timestamp&apos;]}-{$_REQUEST[&apos;noise&apos;]}-{$_REQUEST[&apos;did&apos;]}&quot;);if ($redisInstance-&gt;exists($key)) {    throw new \Exception(401, &apos;Repeated request&apos;);}</code></pre><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>防止同一ip频繁访问API服务器。</p><pre><code>$key = md5(&quot;{$_REQUEST[&apos;REQUEST_URI&apos;]}-{$_REQUEST[&apos;REMOTE_ADDR&apos;]}-{$_REQUEST[&apos;did&apos;]}&quot;);if ($redisInstance-&gt;get($key) &gt; 60) {    throw new \Exception(401, &apos;Request limit&apos;);}$redisInstance-&gt;incre($key);</code></pre><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>防止注入，xss等攻击。</p><pre><code>$username = htmlspecialchars($_REQUEST[&apos;username&apos;]);</code></pre><h2 id="接口的解耦设计"><a href="#接口的解耦设计" class="headerlink" title="接口的解耦设计"></a>接口的解耦设计</h2><ol><li>活用中间件、钩子</li><li>借口多用post请求，少用get</li><li>废弃的代码及时删掉，或者注释掉并且标注</li><li>接口文件合理切割（laravel，lumen等有接口文件的框架）</li><li>服务间调用不要私钥公钥相同，免得一破百破</li></ol><h2 id="接口的状态码"><a href="#接口的状态码" class="headerlink" title="接口的状态码"></a>接口的状态码</h2><p>推荐一些公用的，如果还有私信，广播，商城等状态码可以另加。</p><pre><code>200 -&gt; 正常400 -&gt; 缺少公共必传参数或者业务必传参数401 -&gt; 接口校验失败 例如签名403 -&gt; 没有该接口的访问权限499 -&gt; 上游服务响应时间超过接口设置的超时时间500 -&gt; 代码错误501 -&gt; 不支持的接口method502 -&gt; 上游服务返回的数据格式不正确503 -&gt; 上游服务超时504 -&gt; 上游服务不可用</code></pre><p>转自：<a href="http://tigerb.cn/2018/03/13/api/" target="_blank" rel="external">http://tigerb.cn/2018/03/13/api/</a></p><p>1</p>]]></content>
    
    <summary type="html">
    
      接口设计
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
</feed>
