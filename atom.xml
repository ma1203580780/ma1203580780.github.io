<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARTIST</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://martist.cn/"/>
  <updated>2017-10-03T05:33:50.000Z</updated>
  <id>http://martist.cn/</id>
  
  <author>
    <name>martist.cn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>laravel核心概念</title>
    <link href="http://martist.cn/2017/09/27/laravel%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://martist.cn/2017/09/27/laravel核心概念/</id>
    <published>2017-09-26T16:00:00.000Z</published>
    <updated>2017-10-03T05:33:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>本文是基于laravel 5.1项目源码解析的。</p><h1 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h1><p>route.php文件中，</p><pre><code>Class Foo{}//如果没有这个class会报错。Route::get(&apos;/&apos;,function(Foo $foo){  dd($foo);});</code></pre><p>Foo $foo 是依赖注入的写法，</p><p>laravel框架利用反射机制，尝试解释语义Foo $foo，<br>在laravel内核执行实例化</p><pre><code>$foo = new Foo();</code></pre><p>当laravel尝试new依赖的这个类，找不到的话就会报错找不到这个类。</p><p>当laravel找到的依赖的类。这个类本身依赖注入的类不明确时。<br>会爆其他错误：不能解析。</p><p>另一种方式</p><p>当使用App:bind这个方法时，laravel会优先通过这里加载这个类<br>而不是 反射机制 根据命名空间或者require路径去寻找。</p><pre><code>App::bind(&apos;Foo&apos;,function(){    dd(&apos;called here&apos;);    return new Foo();})</code></pre><hr><h1 id="service-provider"><a href="#service-provider" class="headerlink" title="service provider"></a>service provider</h1><p>service provider 的类中，有意义的是register（）方法，</p><p>在index.php里面有$app这个变量，这是框架的核心。</p><pre><code>$this-&gt;app-&gt;sigleton(&apos;files&apos;,functionZ(){    return new Filesystem;})</code></pre><p>在这里的‘files’我们可以看做键名，指向Filesystem这个类的实例化。<br>这样我们可以在路由中试用下看看。</p><pre><code>Route::get(&apos;/&apos;,function(Foo $foo){  $content = app(&apos;files&apos;)-&gt;get(__DIR__.&apos;/kernel.php&apos;);  dd($content);});//打印出来这个文件的内容</code></pre><p>使用service provider中注册并提供一个简明的键名去申明这个类，<br>可以节约代码，易于管理。</p><h1 id="在Ioc容器中添加自己的类"><a href="#在Ioc容器中添加自己的类" class="headerlink" title="在Ioc容器中添加自己的类"></a>在Ioc容器中添加自己的类</h1><p>比如说项目中需要收费的功能，</p><p>app目录下新建目录billing，生成类文件</p><pre><code>Class stripe{  public function pay(){        dd(&apos;I pay&apos;);    }}</code></pre><p>artisan命令：<br>php artisan  make:provider BillingServicePovider</p><p>在 app/Providers目录下生成BillingServicePovider.php文件，<br>里面有意义的就是register（），我们在这里面注册stripe类。</p><pre><code>public function register(){  $this-&gt;app-&gt;bind(&apos;billing&apos;,fintion(){    return new Stripe();    });}</code></pre><p>再把它放到IOC容器中，config/app.php中添加。</p><p>此时，app(‘billing’)就可以相当于new Stripe()了。</p><p>app(‘billing’)-&gt;pay();//输出 I pay</p><h1 id="Facade-门面-运行机制"><a href="#Facade-门面-运行机制" class="headerlink" title="Facade(门面)运行机制"></a>Facade(门面)运行机制</h1><p>config/app.php下  alias数组，</p><p>用IDE的查找类的功能点进去，比如点route,Mail<br>进去一个类是继承的Facade，</p><p>里面有 getFacadeAccessor()函数返回一个字符串，//return ‘mailer’;<br>这个字符串对应MailserviceProvider.php中register()的字符串。</p><p>Facade类里面有__callStatic(),里面有</p><pre><code>$instance = static::getFacadeRoot();//IOC容器生成$instance，可以使用真正类中的方法//看下面pubilic static function getFacadeRoot(){  return static::resolveFacadeInstance(static::getFacadeAccessor());//app(&apos;mailer&apos;);}</code></pre><p>流程：</p><p>app.php下的别名数组的值指向一个类，这个类通过返回给Facade一个字符串实现app（‘name’）,<br>然后通过serviceProvider去注册返回实例化之后的类。</p><hr><h1 id="contract-契约"><a href="#contract-契约" class="headerlink" title="contract (契约)"></a>contract (契约)</h1><p>在项目目录framework/src/Illuminate/Contracts下面定义了很多interface。</p><p>面向接口编程。在依赖注入中很大好处。该目录下的类都是接口类。</p><p>比如：Config真正是新的类，在Illuminate\Contracts\Config\Repository，</p><p>app()方法:</p><pre><code>dd(app(&apos;Illuminate\Contracts\Config\Repository&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysqldd(Config::get());//可以看到laravel的配置dd(app(&apos;config&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysql</code></pre><p>contract给出整个框架给出的扩展接口，比如config类不能满足你的需求，<br>可以自己集成config接口实现这个类。</p><h1 id="Container的背后"><a href="#Container的背后" class="headerlink" title="Container的背后"></a>Container的背后</h1><p>这几种的返回结果都一样</p><pre><code>dd(Hash::make(&apos;pwd&apos;));//dsdsvdrssrbsssret5u4h6l8mdd(app(&apos;Hash&apos;)-&gt;make(&apos;pwd&apos;));dd(app()[&apos;Hash&apos;]-&gt;make(&apos;pwd&apos;));dd(app(&apos;Illuminate\Hashing\BcryptHasher&apos;)-&gt;make(&apos;pwd&apos;));</code></pre><p>想知道laravel单个功能的源代码，比如hash的功能，去serviceProvider去找。</p><pre><code>$this-&gt;app-&gt;singleton(&apos;hash&apos;,function(){  return new BcryptHasher;})</code></pre><p>singleton，bind是在核心的Contianer里面，</p><p>callFunction 是 Clouse ，会在singleton，bind中进行判断。</p><p>singleton，将hash的值保存到container的binding数组。</p><p>make(),build()可以通过serviceProvider、别名实现实例。</p><p>app（）判断传入的是key =&gt; serviceProvider去实现实例</p><p>包含命名空间的类 =&gt; Application.php  中 registerCoreContainerAliases()</p><p>Application.php里面是laravel的核心内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant之Homestead</title>
    <link href="http://martist.cn/2017/09/11/homestead/"/>
    <id>http://martist.cn/2017/09/11/homestead/</id>
    <published>2017-09-10T16:00:00.000Z</published>
    <updated>2017-10-13T12:01:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>[TOC]</p><h2 id="开发环境的需求"><a href="#开发环境的需求" class="headerlink" title="开发环境的需求"></a>开发环境的需求</h2><p>平时自己码代码用laravel框架，laravel 5.5LTS 要求： </p><pre><code>PHP &gt;= 7.0.0PHP OpenSSL 扩展PHP PDO 扩展PHP Mbstring 扩展PHP Tokenizer 扩展PHP XML 扩展</code></pre><p>公司开发目前用tp框架，要求PHP版本和生产环境保持一致，PHP = 5.6.*，php版本不同，怎么解决呢？</p><p>Vagrant 提供了一种简单、优雅的方式来管理和配置虚拟机。</p><h2 id="什么是homestead"><a href="#什么是homestead" class="headerlink" title="什么是homestead"></a>什么是homestead</h2><p>Laravel Homestead 是一个官方预封装的 Vagrant Box<br>（推荐使用macbook或linux环境进行开发， 如果你使用的是 Windows，你可能需要通过 BIOS 来启用硬件虚拟化（VT-x）。如果你在 UEFI 系统上使用 Hyper-V，可能还需要禁用 Hyper-V 才能启用 VT-x。）</p><h2 id="内置软件"><a href="#内置软件" class="headerlink" title="内置软件"></a>内置软件</h2><pre><code>Ubuntu 16.04GitPHP 7.1NginxMySQLMariaDBSqlite3PostgresComposerNode (带有 Yarn、Bower、Grunt 和 Gulp)RedisMemcachedBeanstalkdMailhogngrok</code></pre><p>这是相当丰富的一份清单，如果还有其他的软件需求可以继续安装，定制属于开发团队的box。</p><h2 id="安装与设置"><a href="#安装与设置" class="headerlink" title="安装与设置"></a>安装与设置</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>在启动 Homestead 环境之前，你必须先安装 VirtualBox 5.1， Vagrant。</p><h3 id="安装-Homestead-Vagrant-Box"><a href="#安装-Homestead-Vagrant-Box" class="headerlink" title="安装 Homestead Vagrant Box"></a>安装 Homestead Vagrant Box</h3><pre><code>vagrant box add laravel/homestead</code></pre><p><strong>注：如果上面的命令运行失败，请确保你的 Vagrant 是最新版本的 。</strong></p><h3 id="安装-Homestead"><a href="#安装-Homestead" class="headerlink" title="安装 Homestead"></a>安装 Homestead</h3><p>将代码库克隆到用户「home」目录下的 Homestead 文件夹中。这样 Homestead Box 就可以作为所有 Laravel 项目的主机：</p><pre><code>cd ~git clone https://github.com/laravel/homestead.git Homestead</code></pre><p>由于 Homestead 的 master 分支并不是稳定分支，你应该用打过标签的稳定版本。你可以在 Github 发行页面 上找到最新的稳定版本。</p><pre><code>cd Homestead// Clone the desired release...git checkout v6.1.0</code></pre><p>克隆 Homestead 代码库后，从 Homestead 目录中运行 <code>bash init.sh</code> 命令来创建 Homesstead.yaml 配置文件。 Homesstead.yaml 文件会被放置在你的 Homestead 目录中：</p><pre><code>// Mac / Linux...bash init.sh// Windows...init.bat</code></pre><h3 id="配置-Homestead"><a href="#配置-Homestead" class="headerlink" title="配置 Homestead"></a>配置 Homestead</h3><h4 id="配置提供器"><a href="#配置提供器" class="headerlink" title="配置提供器"></a>配置提供器</h4><p>Homestead.yaml 中的 provider 参数设置决定了你用的是哪一个 Vagrant 提供器：virtualbox、vmware_fusion、vmware_workstation 或者 parallels。你可以根据自己的喜好来设置提供器：</p><pre><code>provider: virtualbox</code></pre><h4 id="配置共享文件夹"><a href="#配置共享文件夹" class="headerlink" title="配置共享文件夹"></a>配置共享文件夹</h4><p>Homestead.yaml 文件的 folders 属性里列出所有与 Homestead 环境共享的文件夹。这些文件夹中的文件若有变更，它们会保持本地机器与 Homestead 环境之间同步。你可以根据需要配置多个共享文件夹：</p><pre><code>folders:    - map: ~/Code      to: /home/vagrant/Code</code></pre><p>若要启动 NFS，只需要在共享的文件夹配置中添加一个简单的标志：</p><pre><code>folders:    - map: ~/Code      to: /home/vagrant/Code      type: &quot;nfs&quot;</code></pre><p>使用 NFS 时，建议你安装 vagrant-bindfs 插件。这个插件会替你处理 Homestead Box 中的文件或目录权限问题。</p><p>你也可以通过在 options 下方列出 Vagrant 的 共享文件夹 支持的任何选项：</p><pre><code>folders:    - map: ~/Code      to: /home/vagrant/Code      type: &quot;rsync&quot;      options:          rsync__args: [&quot;--verbose&quot;, &quot;--archive&quot;, &quot;--delete&quot;, &quot;-zz&quot;]          rsync__exclude: [&quot;node_modules&quot;]</code></pre><h2 id="配置-Nginx-站点"><a href="#配置-Nginx-站点" class="headerlink" title="配置 Nginx 站点"></a>配置 Nginx 站点</h2><h3 id="添加配置信息"><a href="#添加配置信息" class="headerlink" title="添加配置信息"></a>添加配置信息</h3><p>对 Nginx 不熟悉吗？没关系。sites 属性可以帮助你可以轻松地将 域名 映射到 homestead 环境中的文件夹。Homestead.yaml 文件中已包含示例站点配置。同样的，你也可以增加多个站点到你的 Homestead 环境中。 Homestead 可以同时为多个 Laravel 应用提供虚拟化环境：</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public</code></pre><p>增加其他的 Nginx 站点。你可以在单个 Homestead 环境中运行多个 Laravel 程序。要添加其他网站，只需将网站配置信息添加到 Homestead.yaml 文件中：</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public    - map: another.app      to: /home/vagrant/Code/another/public</code></pre><h3 id="配置生效"><a href="#配置生效" class="headerlink" title="配置生效"></a>配置生效</h3><p>如果你在配置 Homestead Box 之后更改了 sites 属性，那么应该重新运行命令来更新虚拟机上的 Nginx 配置</p><pre><code>vagrant reload --provision</code></pre><h3 id="Hosts-文件"><a href="#Hosts-文件" class="headerlink" title="Hosts 文件"></a>Hosts 文件</h3><p>你必须将在 Nginx 站点中所添加的「域名」也添加到你机器的 hosts 上。 hosts 文件会将 Homestead 站点的请求重定向到 Homestead Box 中。在 Mac 或 Linux 上，该文件位于 <code>/etc/hosts</code>。在 Windows 上，它位于 <code>C:\Windows\System32\drivers\etc\hosts</code>。添加的内容如下所示：</p><pre><code>192.168.10.10  homestead.app</code></pre><p>之后再添加其他站点，直接在这行之后加上就可以了，比如：</p><pre><code>192.168.10.10  homestead.app  paper.app  mar.com # ...</code></pre><p>请确保列出的 IP 地址是你 Homestead.yaml 文件中的 IP 地址。将域名设置到 hosts 文件并启动 Vagrant Box后，就可以访问了。</p><h2 id="启动-Vagrant-Box"><a href="#启动-Vagrant-Box" class="headerlink" title="启动 Vagrant Box"></a>启动 Vagrant Box</h2><p>根据你的喜好完成 Homestead.yaml 的编辑后，再从 Homestead 目录运行  </p><pre><code>vagrant up</code></pre><p>Vagrant 将启动虚拟机并自动配置你的共享文件夹和 Nginx 站点。</p><p>你可以通过 Web 浏览器访问该站点：</p><pre><code>http://homestead.app</code></pre><p>如果要删除虚拟机，使用 <code>vagrant destroy --force</code> 命令。</p><h2 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h2><p>如果你想在系统的任何地方都可以使用 vagrant up 命令启动 Homestead，你可以在 Mac / Linux 系统的 Bash 配置文件中添加 Bash 函数。在 Windows 中，你可以通过在 PATH 环境变量中添加一个「批处理」文件来实现。下面这些脚本使你可以从系统的任何地方运行任何 Vagrant 命令，并将自动将该命令指向你的 Homestead 安装路径：</p><h3 id="Mac-Linux"><a href="#Mac-Linux" class="headerlink" title="Mac / Linux"></a>Mac / Linux</h3><pre><code>function homestead() {    ( cd ~/Homestead &amp;&amp; vagrant $* )}</code></pre><p>确保将该功能中的 ~/Homestead 路径是你实际的 Homestead 安装路径。这样你就可以在系统的任何地方运行 <code>homestead up</code>或<code>homestead ssh</code> 等命令。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在系统的任意位置创建一个批处理文件<code>homestead.bat</code>，并添加如下内容：</p><pre><code>@echo offset cwd=%cd%set homesteadVagrant=C:\Homesteadcd /d %homesteadVagrant% &amp;&amp; vagrant %*cd /d %cwd%set cwd=set homesteadVagrant=</code></pre><h2 id="通过-SSH-连接"><a href="#通过-SSH-连接" class="headerlink" title="通过 SSH 连接"></a>通过 SSH 连接</h2><p>你可以通过在 Homestead 目录运行vagrant命令来连接虚拟主机</p><pre><code>vagrant ssh </code></pre><p>配置全局使用后，可以使用homestead命令管理</p><pre><code>homestead uphomestead ssh</code></pre><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>在 Box 中已经为 MySQL 和 Postgres 配置好了一个数据库 homestead。为了更方便的使用它，Laravel 中的 .env 文件将框架配置成默认使用此数据库。</p><p>要从主机的数据库客户端连接到 MySQL 或 Postgres，就连接到 127.0.0.1 和端口 33060 (MySQL) 或 54320 (Postgres)。账号密码分别是 homestead／secret</p><blockquote><p>从主机连接到数据库时，只能使用这些非标准端口。 而 Laravel 在虚拟机中运行时，仍旧使用 Laravel 数据库配置文件中的默认 3306 和 5432 端口</p></blockquote><h2 id="站点类型"><a href="#站点类型" class="headerlink" title="站点类型"></a>站点类型</h2><p>Homestead 支持多种类型的站点，可以让你轻松地运行那些不基于 Laravel 的项目。 例如，我们可以使用 symfony2 站点类型轻松地在 Homestead 中添加 Symfony 应用程序：</p><pre><code>sites:    - map: symfony2.app      to: /home/vagrant/Code/Symfony/web      type: symfony2</code></pre><p>支持的站点类型有： apache、laravel（默认）、proxy、silverstripe、statamic、symfony2 和 symfony4。</p><h2 id="站点参数"><a href="#站点参数" class="headerlink" title="站点参数"></a>站点参数</h2><p>你还可以使用 params 站点指令向你的站点添加其他 Nginx fastcgi_param 值。例如，添加一个值为 BAR 的 FOO 参数。</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public      params:          - key: FOO            value: BAR</code></pre><h2 id="配置-Cron-调度器"><a href="#配置-Cron-调度器" class="headerlink" title="配置 Cron 调度器"></a>配置 Cron 调度器</h2><p>Laravel 提供了便利的方式来 调度 Cron 任务，通过Artisan 命令 schedule:run ，调度便会在每分钟运行一次。schedule:run 命令会检查定义在你 App\Console\Kernel 类中的调度任务，以此判断哪个任务该被运行。</p><p>如果你想对 Homestead 站点使用 schedule:run 命令，你需要在定义站点时将 schedule 选项设置为 true</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public      schedule: true</code></pre><p>该站点的 Cron 任务会被定义在虚拟机的 /etc/cron.d 文件夹中。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>默认情况下，以下端口会被转发至 Homestead 环境：</p><pre><code>SSH: 2222 → 发送到 22HTTP: 8000 → 发送到 80HTTPS: 44300 → 发送到 443MySQL: 33060 → 发送到 3306Postgres: 54320 → 发送到 5432Mailhog: 8025 → 发送到 8025</code></pre><h3 id="转发更多端口"><a href="#转发更多端口" class="headerlink" title="转发更多端口"></a>转发更多端口</h3><p>你可以根据需要转发更多端口给 Vagrant Box，并指定其协议：</p><pre><code>ports:    - send: 50000      to: 5000    - send: 7777      to: 777      protocol: udp</code></pre><h2 id="共享你的环境"><a href="#共享你的环境" class="headerlink" title="共享你的环境"></a>共享你的环境</h2><p>有时候你想跟你的同事或者是客户共享你目前在开展的工作。Vagrant 提供了一个内置方法 vagrant share 来支持。不过，如果你的 Homestead.yaml 文件中配置了多个站点，就无法使用此命令。</p><p>为了解决这个问题，Homestead 提供了自己的 share 命令。开始之前，通过 vagrant ssh SSH 命令连接 Homestead 机器中并运行 share homestead.app。这会从 Homestead.yaml 配置文件中共享 homestead.app 站点。你也可以用其他已经配置的站点来代替 homestead.app。</p><pre><code>share homestead.app</code></pre><p>运行命令后，你可以看到一个 Ngrok 界面，其中包含活动日志和共享站点的可公开访问的 URL。如果要指定自定义地区或者其他 Ngrok 选项，可以将它们添加到 share 命令后面：</p><pre><code>share homestead.app -region=eu -subdomain=laravel</code></pre><blockquote><p>谨记，Vagrant 本质上是不安全的。当你运行 share 命令时，你已经在互联网中暴露了你的虚拟机。</p></blockquote><h2 id="多个-PHP-版本"><a href="#多个-PHP-版本" class="headerlink" title="多个 PHP 版本"></a>多个 PHP 版本</h2><blockquote><p>此功能仅与 Nginx 兼容。</p></blockquote><p>Homestead 6 支持在同一个虚拟机上引入多个版本的 PHP。你可以在 Homestead.yaml 文件中为给定站点指定使用哪个版本的 PHP。 可用的 PHP 版本有：「5.6」、「7.0」、「7.1」</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public      php: &quot;5.6&quot;</code></pre><p>此外，你还可以通过 CLI 使用任何受支持的 PHP 版本：</p><pre><code>php5.6 artisan listphp7.0 artisan listphp7.1 artisan list</code></pre><h2 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h2><p>Homestead.yaml 的 networks 属性为 Homestead 环境配置网络接口。你可以根据需要配置任意数量的接口：</p><pre><code>networks:    - type: &quot;private_network&quot;      ip: &quot;192.168.10.20&quot;</code></pre><p>想启用 桥接 接口，请配置 bridge 设置，并将网络类型更改为 public_network ：</p><pre><code>networks:    - type: &quot;public_network&quot;      ip: &quot;192.168.10.20&quot;      bridge: &quot;en1: Wi-Fi (AirPort)&quot;</code></pre><p>要启用 DHCP，只需从配置中删除 ip 选项：</p><pre><code>networks:    - type: &quot;public_network&quot;      bridge: &quot;en1: Wi-Fi (AirPort)&quot;</code></pre><h2 id="更新-Homestead"><a href="#更新-Homestead" class="headerlink" title="更新 Homestead"></a>更新 Homestead</h2><p>你可以通过两个简单的步骤更新 Homestead。首先，使用 vagrant box update 命令更新 Vgrant Box :</p><pre><code>vagrant box update</code></pre><p>接下来，如果你是通过克隆仓库的方式来安装的 Homestead，你需要更新 Homestead 的源代码。你可以在你最初克隆仓库的位置简单地运行 git pull origin master 命令。</p><p>如果你是通过项目中的 composer.json 文件安装 Homestead ，则应该确认 composer.json 文件中包含 “laravel/homestead: “^6” 并更新依赖：</p><pre><code>composer update</code></pre><h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><pre><code>如果你需要一个旧版本的 PHP，请在尝试使用旧版本的 Homestead 之前，先阅读文档 多个 PHP 版本 上的文档。</code></pre><p>你可以通过添加以下内容添加到 Homestead.yaml 文件中来覆盖 Homestead 使用的 Box 版本:</p><pre><code>version: 0.6.0</code></pre><p>例如：</p><pre><code>box: laravel/homesteadversion: 0.6.0ip: &quot;192.168.20.20&quot;memory: 2048cpus: 4provider: virtualbox</code></pre><p>当你使用较旧版本的 Homestead Box 时，你需要确保将其与 Homestead 源代码的兼容版本进行匹配。下面的图表展示了支持的 Box 版本，使用哪个版本的 Homestead 源代码以及提供的 PHP 版本</p><pre><code>Homestead   Version  Box VersionPHP 7.0     3.1.0      0.6.0PHP 7.1     4.0.0      1.0.0PHP 7.1     5.0.0      2.0.0PHP 7.1     6.0.0      3.0.0</code></pre><h2 id="提供器的特殊设置"><a href="#提供器的特殊设置" class="headerlink" title="提供器的特殊设置"></a>提供器的特殊设置</h2><p>在VirtualBox作为提供器的情况下，Homestead 默认将 natdnshostresolver 设置为 on。这允许 Homestead 使用主机系统中的 DNS 设置。如果你想重写这行为，你可以在你的 Homestead.yaml 文件中添加下面这几行：</p><pre><code>provider: virtualboxnatdnshostresolver: off</code></pre><h2 id="要关注"><a href="#要关注" class="headerlink" title="要关注"></a>要关注</h2><p>具体关于vagrant的安装，使用和项目实践，可以关注我的看云，地址如下</p><p><a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="vagrant" scheme="http://martist.cn/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant之入门</title>
    <link href="http://martist.cn/2017/07/29/Vagrant%E4%B9%8B%E5%85%A5%E9%97%A81/"/>
    <id>http://martist.cn/2017/07/29/Vagrant之入门1/</id>
    <published>2017-07-28T16:00:00.000Z</published>
    <updated>2017-10-13T12:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><pre><code>下载 VirtualBox 虚拟器 : https://www.virtualbox.org/下载安装 Vagrant : http://www.vagrantup.com/下载使用的 box (这里的 box 指的是系统) : http://www.vagrantbox.es/在本地建立一个工作文件夹</code></pre><p>VirtualBox是虚拟机，Vagrant是管理虚拟机的工具，.box文件相当于在虚拟机内构建系统的镜像。</p><p>首先需要下载并安装VirtualBox，Vagrant，准备好镜像文件(.box)。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>查看当前添加进 vagrant 的镜像</p><pre><code>vagrant box list </code></pre><p>一开始是没有添加 box 镜像, 我们执行 <code>vagrant box add 系统名字 box镜像</code>；另一种情况是在线拉取镜像，可以忽略这一步</p><pre><code>vagrant box add hashicorp/precise64</code></pre><p><code>hashicorp/precise64</code> 镜像可以是 <code>add</code> 之前准备好的，放在执行命令的当前目录的，也可以没有准备，在线拉取，是否提前下载镜像，这取决于你的网速。当开发团队统一开发环境而分发给你一个镜像，那就直接<code>add</code>这个镜像文件的文件名就可以了，当你初始化的时候会默认选择list的镜像文件。</p><p>初始化镜像</p><pre><code>vagrant init hashicorp/precise64</code></pre><p>该命令会在当前目录下创建<code>Vagrantfile</code>，并且指定所使用的box为ubuntu/trusty64，该box由Hashicorp官网提供。此时，Vagrant发现box的名字的格式为“用户名/box名”，则会使用 <code>“https://atlas.hashicorp.com/用户名/box名”</code> 来下载该box。对于非官网提供的box，可以通过以下命令创建：</p><pre><code>vagrant init my-box https://boxes.company.com/my.box</code></pre><p>此时你可以通过更改<code>Vagrantfile</code>，来完成你的配置。因为我们虚拟机默认只分配一个访问外网的 IP, 项目使用的 IP 得手动设置打开 Vagrantfile 找到29行(我的配置文件在29行)设置一个私有 IP，默认是192.168.33.10。</p><p>其中，my-box为该box的名字，后面的URL为该box的下载地址。</p><p>启动虚拟机</p><pre><code>vagrant up</code></pre><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>登录到虚拟机</p><pre><code>vagrant ssh</code></pre><p>此时vagrant将使用默认的用户vagrant以及预设的SSH公钥密钥键值对直接登录虚拟机。</p><p>关闭虚拟机：</p><pre><code>vagrant halt</code></pre><p>删除虚拟机：</p><pre><code>vagrant destroy</code></pre><p>请注意，vagrant destroy只会删除虚拟机本身，也即你在Virtualbox将看不到该虚拟机，但是不会删除该虚拟机所使用的box。</p><p>删除某个box的命令</p><pre><code>vagrant box remove box-name</code></pre><p>虚拟机里面的<code>/vagrant</code> 这个文件夹是和当前目录保持同步。是不是很有趣，这样我们以后从服务器拉取下来的项目放在虚拟机中，操作系统的本地保目录持同步，这样关闭虚拟机或者虚拟机异常退出了，项目也不会随之销毁，vagrant的带来的开发优势显而易见。</p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><pre><code>$ vagrant box add NAME URL #添加一个box$ vagrant box list #查看本地已添加的box$ vagrant box remove NAME virtualbox #删除本地已添加的box，如若是版本1.0.x，执行$ vagrant box remove NAME$ vagrant init NAME #初始化，实质应是创建Vagrantfile文件$ vagrant up #启动虚拟机$ vagrant halt #关闭虚拟机$ vagrant destroy #销毁虚拟机$ vagrant reload #重启虚拟机$ vagrant package #当前正在运行的VirtualBox虚拟环境打包成一个可重复使用的box$ vagrant ssh #进入虚拟环境*$ vagrant port #查看ip和端口</code></pre><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>全部vagrant命令请查询 ： <a href="https://www.vagrantup.com/docs/cli/index.html" target="_blank" rel="external">https://www.vagrantup.com/docs/cli/index.html</a></p><h2 id="要关注"><a href="#要关注" class="headerlink" title="要关注"></a>要关注</h2><p>具体关于vagrant的安装，使用和项目实践，可以关注我的看云，地址如下</p><p><a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="vagrant" scheme="http://martist.cn/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>ssh服务为web生产服务器保驾护航</title>
    <link href="http://martist.cn/2017/07/27/ssh/"/>
    <id>http://martist.cn/2017/07/27/ssh/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-10-03T05:40:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们给自己的博客搭建一个站点，配置lnmp/lamp运行环境可以跑起来，差不多就完事了。但是当我们做的是一个中型或者大型项目，在它需要部署到生产服务器上线运营时，账户安全方面需要做些什么？</p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>apt-get install openssh-server</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>/etc/init.d/ssh start  </code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>ssh  martist@192.168.123.3//ssh远程连接服务器，需要输入用户密码</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="主机名管理"><a href="#主机名管理" class="headerlink" title="主机名管理"></a>主机名管理</h3><p>一个中型甚至大型的的项目，往往需要对多台服务器进行管理，如生产服务器，测试服务器，管理服务器等等。因此需要对每一台服务器的主机名进行管理，通过修改各个服务器的/etc/hostname文件修改本地系统名，重启可以看到。</p><h3 id="密钥ssh登录"><a href="#密钥ssh登录" class="headerlink" title="密钥ssh登录"></a>密钥ssh登录</h3><p>linux或Mac下生成密钥的命令是 <code>ssh-keygen -t rsa</code> 默认生成路径在家目录的.ssh目录下。id_rsa 文件保存的是本机的私钥，id_rsa.pub文件保存的是公钥。<br> ifconfig命令查看服务器的IP地址，注意如果你是用的是阿里云ECS，此处查看到的是内网IP而非公网IP。<br>在被登录的服务器的家目录下的.ssh目录（如果不存在就创建一个）创建一个authorized_keys 文件，并将生成的公钥文件的内容放到里面，就可以在本地使用密钥登陆这台服务器了。</p><pre><code>ssh  martist@192.168.123.3//此时不需要输入用户名密码</code></pre><p>如果我们关闭密码登陆，转而使用ssh密钥登录，更可以确保服务安全（注意：关闭密码登陆前，一定要确保能够正常使用ssh密钥登陆）。</p><h3 id="关闭密码登陆"><a href="#关闭密码登陆" class="headerlink" title="关闭密码登陆"></a>关闭密码登陆</h3><p>找到/etc/ssh/sshd_config 修改PasswordAuthentication 属性 yes。<br>在第52行，yes改为no，禁用密码登陆（慎用）。</p><h2 id="详细实战分析"><a href="#详细实战分析" class="headerlink" title="详细实战分析"></a>详细实战分析</h2><p>线上：阿里云ECS云服务器 Ubuntu14.04lts </p><p>Manager服务器生成ssh密钥</p><pre><code>ssh-keygen -t rsa  //一路回车</code></pre><p>生成的密钥保存在家目录下，进入.ssh目录下，</p><pre><code>ls//查看文件id_rsa id_rsa.pub know_hosts </code></pre><p>Manager服务器上在 /etc/hosts 文件里加上重定向的名字，如测试服务器，DB服务器和Manager服务器分别起一个重定向名字便于管理多台web服务器。<br>修改本地定向网络ip（阿里云的内网ip）的文件 </p><pre><code>vi /etc/hosts //写入 10.162.48.184 FWEB1//每次在终端输入‘FWEB1’，就代表‘10.162.48.184’。</code></pre><p>在mannager服务器上，试一下ssh登录web1服务器</p><pre><code>ssh root@FWEB1  </code></pre><p>退出</p><pre><code>exit</code></pre><p>在mannager服务器上，试一下文件上传web1服务器</p><pre><code>scp  ./id_rsa.pub root@FWEB1:/root</code></pre><p>现在还是需要输入密码，不过等一会把密钥加到web服务器上，再从manager登录web服务器，就不需要输入密码了。</p><p>在web1服务器，家目录下创建.ssh目录</p><pre><code>ssh root@FWEB1 // 输入密码mkdir ~/.ssh</code></pre><p>在web1服务器，把id_rsa.pub传递到.ssh/目录下</p><p>   cat id_rsa.pub &gt;&gt; .ssh/id_rsa.pub   </p><p>此时，再从id_rsa.pub设置到web服务器（FWEB1）本地.</p><p>文件改名</p><pre><code>mv id_rsa.pub authorized_keys</code></pre><p>给执行权限</p><pre><code>chmod 600 ./authorized_keys</code></pre><p>退出ssh远程登录</p><pre><code>exit</code></pre><p>此时回到manager服务器</p><pre><code> ssh  root@FWEB1//此时密码不用输就可以进入FWEB1</code></pre><p>随便上传个文件，试试</p><pre><code>scp know_hosts root@FWEB1:/tmp/</code></pre><p>此后，在manager服务器向web服务器，scp传送东西,不需要再输入密码了。</p><p>原理：manager服务器私钥自己留着，把公钥给所有的web，DB，备份服务器，就可以便捷管理了。</p><h3 id="关闭web服务器的密码登陆"><a href="#关闭web服务器的密码登陆" class="headerlink" title="关闭web服务器的密码登陆"></a>关闭web服务器的密码登陆</h3><p>找到/etc/ssh/sshd_config 修改PasswordAuthentication 属性 yes。在第52行，yes改为no，禁用密码登陆。<br>修改sshd_config文件中ssh端口，ssh端口默认为 22. 把端口号改为1000以上的数值。</p><pre><code>默认：Port:22改为：Port 1678</code></pre><p>:wq //退出vi编辑器。</p><pre><code>reboot //重启生效</code></pre><p>ssh登录目的服务器命令</p><p>   root@FWEB1</p><p>有点麻烦？可以创建自己的别名</p><pre><code>vi ~/.bash_profile//写入  alias fewb1=&apos;ssh root@FWEB1 -p 1678&apos;//(-p 为端口号)</code></pre><p>好，:wq 保存退出。</p><p>使他生效</p><pre><code>source .bash_profile </code></pre><p>查看别名</p><pre><code>alias</code></pre><p>在manager服务器下，把某个文件夹下全部文件推送到web服务器。</p><pre><code>scp -p 1678 ./* root@FWEB1:/tmp/ //（需要被传送文件的web服务器有这个文件夹）</code></pre><p>把服务器其上的东西上传上去，是这样写， 把web服务器的东西下载到本地，只要把这俩目录倒过来，就可以了。</p><p>技巧：</p><pre><code>cd ~mkdir sh vi pushcode.sh//在这里写shell脚本</code></pre><p>shell脚本的写法，开头‘#！’，后面是 shell可执行命令的位置。</p><pre><code> #！/bin/shscp -p 1678 ./var/www.machuang.name/* root@FWEB1:/var/www/machuang.name</code></pre><p>好！:wq 保存推出。</p><p>给执行权限</p><pre><code>chmod 755 /root/sh/pushcode.sh</code></pre><p>Ls查看下</p><pre><code>ls /root/sh</code></pre><p>此时看到pushcode.sh变成绿色，就对了。以后敲入这段命令，就可以完成上传代码的功能了。</p><pre><code>/root/sh/pushcode.sh</code></pre><p>就可以执行脚本内的命令了，此时再加一个别名。</p><pre><code>cd ~vi .bash_profile//写入  alias pushcode=&apos;/root/sh/pushcode.sh&apos;//:wq 保存退出</code></pre><p>好，使它生效，否则要重启才能生效。</p><pre><code>source .bash_profile</code></pre><p>上传代码：</p><pre><code>pushcode</code></pre><p>这样一个具备业务逻辑的ssh服务使用就展现在你面前了，单一的使用一个工具并不显得立体，多种linux软件和命令有机结合在一起才能迸发出更大的能量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant-流行的环境部署工具</title>
    <link href="http://martist.cn/2017/07/21/Vagrant/"/>
    <id>http://martist.cn/2017/07/21/Vagrant/</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-10-13T12:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vagrant 是一个基于 Ruby 的工具，用于创建和部署虚拟化开发环境。它使用 Oracle 的开源 VirtualBox 虚拟化系统，使用 Chef 创建自动化虚拟环境。</p><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><pre><code>支持快速新建虚拟机支持快速设置端口转发支持自定义镜像打包（原始镜像方式、增量补丁方式）基本上日常能用到的基础配置都能快速设置支持开机启动自动运行命令可以自己写扩展</code></pre><h2 id="解决实际问题"><a href="#解决实际问题" class="headerlink" title="解决实际问题"></a>解决实际问题</h2><p>在商业化项目的多人协同开发中，统一开发环境是非常重要的，让开发环境尽可能的接近生产环境，对项目的稳定性起着不可忽视的作用。</p><p>我们可以通过 Vagrant 封装一个 Linux 的开发环境，里面是一致的开发环境、软件版本,把它（.box）分发给团队成员。成员可以在自己的操作系统（Mac/Windows/Linux）上开发程序，代码却能统一在封装好的环境里运行，而不受操作系统影响。</p><h2 id="要关注"><a href="#要关注" class="headerlink" title="要关注"></a>要关注</h2><p>具体关于vagrant的安装，使用和项目实践，可以关注我的看云，地址如下</p><p><a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="vagrant" scheme="http://martist.cn/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用消息队列</title>
    <link href="http://martist.cn/2017/05/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://martist.cn/2017/05/13/为什么使用消息队列/</id>
    <published>2017-05-12T16:00:00.000Z</published>
    <updated>2017-10-02T15:39:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h1><p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息队列在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><h1 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h1><p>有时在处理数据的时候处理过程会失败。除非数据被持久化，否则将永远丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在被许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理过程明确的指出该消息已经被处理完毕，确保你的数据被安全的保存直到你使用完毕。</p><h1 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h1><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的；只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p><h1 id="灵活性-amp-峰值处理能力"><a href="#灵活性-amp-峰值处理能力" class="headerlink" title="灵活性 &amp; 峰值处理能力"></a>灵活性 &amp; 峰值处理能力</h1><p>当你的应用上了Hacker News的首页，你将发现访问流量攀升到一个不同寻常的水平。在访问量剧增的情况下，你的应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住增长的访问压力，而不是因为超出负荷的请求而完全崩溃。请查看我们关于峰值处理能力的博客文章了解更多此方面的信息。</p><h1 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h1><p>当体系的一部分组件失效，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。而这种允许重试或者延后处理请求的能力通常是造就一个略感不便的用户和一个沮丧透顶的用户之间的区别。</p><h1 id="送达保证"><a href="#送达保证" class="headerlink" title="送达保证"></a>送达保证</h1><p>消息队列提供的冗余机制保证了消息能被实际的处理，只要一个进程读取了该队列即可。在此基础上，IronMQ提供了一个”只送达一次”保证。无论有多少进程在从队列中领取数据，每一个消息只能被处理一次。这之所以成为可能，是因为获取一个消息只是”预定”了这个消息，暂时把它移出了队列。除非客户端明确的表示已经处理完了这个消息，否则这个消息会被放回队列中去，在一段可配置的时间之后可再次被处理。</p><h1 id="排序保证"><a href="#排序保证" class="headerlink" title="排序保证"></a>排序保证</h1><p>在许多情况下，数据处理的顺序都很重要。消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。IronMO保证消息浆糊通过FIFO（先进先出）的顺序来处理，因此消息在队列中的位置就是从队列中检索他们的位置。</p><h1 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h1><p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如,加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行–写入队列的处理会尽可能的快速，而不受从队列读的预备处理的约束。该缓冲有助于控制和优化数据流经过系统的速度。</p><h1 id="理解数据流"><a href="#理解数据流" class="headerlink" title="理解数据流"></a>理解数据流</h1><p>在一个分布式系统里，要得到一个关于用户操作会用多长时间及其原因的总体印象，是个巨大的挑战。消息系列通过消息被处理的频率，来方便的辅助确定那些表现不佳的处理过程或领域，这些地方的数据流都不够优化。</p><h1 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h1><p>很多时候，你不想也不需要立即处理消息。消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它。你想向队列中放入多少消息就放多少，然后在你乐意的时候再去处理它们。</p><h1 id="多语言通信"><a href="#多语言通信" class="headerlink" title="多语言通信"></a>多语言通信</h1><p>比如用php生产一个job，用python或者其他语言作为消费者来处理</p><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>我这这里推荐一种消息队列Beanstalkd，它是一个轻量级消息中间件。</p><p><a href="http://doc.martist.cn/373251" target="_blank" rel="external">http://doc.martist.cn/373251</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git教程(六)</title>
    <link href="http://martist.cn/2017/04/08/git%E6%95%99%E7%A8%8B6/"/>
    <id>http://martist.cn/2017/04/08/git教程6/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2017-10-02T09:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="一、git-commit提交之后，发现有错误怎么办？"><a href="#一、git-commit提交之后，发现有错误怎么办？" class="headerlink" title="一、git commit提交之后，发现有错误怎么办？"></a>一、git commit提交之后，发现有错误怎么办？</h1><p>当commit之后发现代码有错，简单直接的方法就是进行修改代码，然后第二次commit。</p><blockquote><p>这样git log可以看到两次commit的信息</p></blockquote><h2 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h2><p>如果你commit了之后还没有推到远程仓库，commit信息还在本地，此时可以根据git log的hashid来重置commit版本信息。</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><pre><code>git reset –mixed</code></pre><p>此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息</p><pre><code>git reset –soft</code></pre><p>回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可</p><pre><code>git reset –hard</code></pre><p>彻底回退到某个版本，本地的源码也会变为上一个版本的内容</p><h2 id="修改备注信息"><a href="#修改备注信息" class="headerlink" title="修改备注信息"></a>修改备注信息</h2><pre><code>git commit -amend</code></pre><hr><h1 id="二、怎么在项目开始-项目中正确的添加忽略文件或目录？"><a href="#二、怎么在项目开始-项目中正确的添加忽略文件或目录？" class="headerlink" title="二、怎么在项目开始/项目中正确的添加忽略文件或目录？"></a>二、怎么在项目开始/项目中正确的添加忽略文件或目录？</h1><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><h3 id="git-rm与git-rm-–cache的区别"><a href="#git-rm与git-rm-–cache的区别" class="headerlink" title="git rm与git rm –cache的区别"></a>git rm与git rm –cache的区别</h3><p>当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用</p><pre><code>git rm file_pathgit commit -m &apos;delete somefile&apos;git push</code></pre><p>当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制, 可以使用</p><pre><code>git rm --cached file_pathgit commit -m &apos;delete remote somefile&apos;git push</code></pre><p>忽略一个已经被跟踪的目录（再也不管它了）：</p><pre><code>git rm -r --cached direcho dir/ &gt;&gt; .gitignoregit add .gitignoregit commit -am &apos;ignore dir forever&apos;</code></pre><h1 id="三、怎么给git命令创建快捷方式？"><a href="#三、怎么给git命令创建快捷方式？" class="headerlink" title="三、怎么给git命令创建快捷方式？"></a>三、怎么给git命令创建快捷方式？</h1><p>git alias</p><p>第一种方法：<br>git status<br>可以设置为<br>通过配置git本身，</p><p>  git config –global alias.s status</p><p>从此，git s就是git status</p><p>第二种方法:<br>vim ~/.gitconfig</p><p>第三种方法;<br>vi ~/zssrc</p><p>配置系统的别名</p><h1 id="四、git-stach是什么？"><a href="#四、git-stach是什么？" class="headerlink" title="四、git stach是什么？"></a>四、git stach是什么？</h1><p>git stash 可用来暂存当前正在进行的工作， 比如想pull 最新代码， 又不想加新commit， 或者另外一种情况，为了fix 一个紧急的bug,  先stash, 使返回到自己上一个commit, 改完bug之后再stash pop, 继续原来的工作。</p><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><pre><code>$git stash$do some work$git stash pop</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><pre><code>git stash save &quot;work in progress for foo feature&quot;</code></pre><p>当你多次使用’git stash’命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，</p><p>’git stash list’ 命令可以将当前的Git栈信息打印出来，你只需要将找到对应的版本号，例如使用’git stash apply stash@{1}’就可以将你指定版本号为stash@{1}的工作取出来，当你将所有的栈都应用回来的时候，可以使用’git stash clear’来将栈清空。</p><pre><code>git stash          # save uncommitted changes# pull, edit, etc.git stash list     # list stashed changes in this gitgit show stash@{0} # see the last stash git stash pop      # apply last stash and remove it from the listgit stash --help   # for more info</code></pre><h1 id="五、git-rebase是什么？"><a href="#五、git-rebase是什么？" class="headerlink" title="五、git rebase是什么？"></a>五、git rebase是什么？</h1><p>rebase 的概念/作用其实很简单——就是「变基」。具体来说，就是改变一条分支的「基点」，使原分支从指定的地方（commit）重新长出来。并且，由于是一条新分支，你可以随意修改其中的 commits，也就是——重写分支历史。</p><p>而 rebase 的主要目的即删繁就简。</p><p>下面讲下关键步骤：</p><pre><code>git rebase [-i | --interactive] [options] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]    [&lt;upstream&gt; [&lt;branch&gt;]]git rebase [-i | --interactive] [options] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]    --root [&lt;branch&gt;]git rebase --continue | --skip | --abort | --edit-todo</code></pre><p>所有 rebase 的操作对象都是 commit。（你可以 rebase 一个分支 git rebase -i branchX，但实际上还是作用于该分支最新的 commit。）</p><p>以这个 commit 为「新基点」发起 rebase 后，会打印出一篇 commit 历史让你修改。</p><p>其中最常用的修改就是把 commit 前的 pick 改为 s (squash, /skwɔʃ/, 意为挤压)，作用为保留该 commit 作出的修改，但删去该节点，只给它一个留名的机会。(用专业的话讲就是——不保留待合并分支上的历史信息，也不提交、不移动HEAD。）多个以 s 为前缀的 commit 最终会整合成一个 commit，各个 commit 的描述部分也被整合到一起。</p><p>而最终极的修改就是直接删去 commit(s) ——篡改历史。这也就意味着，对应的改动也一并灰飞烟灭。（所以为什么说 rebase 是个危险的操作，就是因为篡改了历史！想想如果别人基于你国正史 fork 了一条分支，而你日后竟变基了会发生什么吧！）</p><p>改完之后 :x（Vim下的保存退出命令），Git 就去检测冲突了，此时类似于合并。<br>合并将按你留下的 commit(s) 重演历史，你可以修改每一次 commit 的具体代码。而如果你不是为了修改，只是为了简化树……我的办法是只留下一条 commit，用最新工程完全覆盖来解决冲突。（不知有没有更好的方法）</p><p>冲突解决完后 git rebase –continue，你就可以正式「书写」历史啦——撰写新的 commit 描述。这时那真是，想怎么写就怎么写~</p><p>这般本地 rebase 完成后，记得 git push -f，-f 用于强制将新历史推送至远程仓库。<br>至此，rebase 就彻底结束了。</p><p>看看你新造的树吧，是不是特简洁，特优美？（如果不是……你 rebase 干嘛……）</p><p>当一个系统的专有名词（黑话）足够多，就创造了文化。</p><p>在贡献开源代码时，git rebase可以直接把log同步过来，而不会有 git merge 的log。</p><h1 id="怎么打标签，打标签有啥用？"><a href="#怎么打标签，打标签有啥用？" class="headerlink" title="怎么打标签，打标签有啥用？"></a>怎么打标签，打标签有啥用？</h1><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。本节我们一起来学习如何列出所有可用的标签，如何新建标签，以及各种不同类型标签之间的差别。<br>列出已有的标签</p><p>列出现有标签的命令非常简单，直接运行 git tag 即可：</p><pre><code>git tagv0.1v1.3</code></pre><p>显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。</p><p>我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：</p><pre><code>git tag -l &apos;v1.4.2.*&apos;v1.4.2.1v1.4.2.2v1.4.2.3v1.4.2.4</code></pre><h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。<br>含附注的标签</p><p>创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：</p><pre><code>git tag -a v1.4 -m &apos;my version 1.4&apos;git tagv0.1v1.3v1.4</code></pre><p>而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p><p>可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。</p><pre><code>git show push_v1.2tag push_v1.2Tagger: machuang &lt;780@qq.com&gt;Date:   Sun Sep 10 12:06:50 2017 +0800version 1.2 project coding end at 2017-8-23.This tag create at 2017-9-10scommit f1759f45b598611231d9e768Merge: f8f4 saf9Author: XScarletAngel &lt;7369@qq.com&gt;Date:   Wed Aug 23 18:30:27 2017 +0800    Merge branch &apos;branch1.2&apos; of git.du.com:admin/admin into branch1.2    * &apos;branch1.2&apos; of git.du.com:admin/admin:      Test</code></pre><p>我们可以看到在提交对象信息上面，列出了此标签的提交者和提交时间，以及相应的标签说明。</p><h2 id="根据commitid打标签"><a href="#根据commitid打标签" class="headerlink" title="根据commitid打标签"></a>根据commitid打标签</h2><pre><code>git tag -a &lt;tag名&gt; &lt;commit对应的hash码&gt;</code></pre><h2 id="tag推送到远程仓库"><a href="#tag推送到远程仓库" class="headerlink" title="tag推送到远程仓库"></a>tag推送到远程仓库</h2><p>默认情况下，git push并不会把tag标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。<br>1.push单个tag，命令格式为：git push origin [tagname]<br>例如：<br>git push origin v1.0 #将本地v1.0的tag推送到远端服务器<br>2.push所有tag，命令格式为：git push [origin] –tags<br>例如：<br>git push –tags<br>或<br>git push origin –tags</p><p>以上命令经检验通过，如果不起作用，请在Git控制台上确认你的账号是否有权限推送Tag。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="git" scheme="http://martist.cn/categories/git/"/>
    
    
      <category term="git" scheme="http://martist.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>创业公司必经之路（三）</title>
    <link href="http://martist.cn/2017/04/04/%E9%A9%AC%E9%97%AF%EF%BC%9A%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF%5B3%5D/"/>
    <id>http://martist.cn/2017/04/04/马闯：创业公司必经之路[3]/</id>
    <published>2017-04-03T16:00:00.000Z</published>
    <updated>2017-10-02T04:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h3 id="什么是溢价投资？"><a href="#什么是溢价投资？" class="headerlink" title="什么是溢价投资？"></a>什么是溢价投资？</h3><p>没有上市的公司，也是有股份的。<br>为了方便计算，把<strong>股份划分成股权</strong>。<br>先谈估值，原始股份升至估值后的股份额，再谈融资，这样不会稀释掉原始股份。<br>这也印证了投资早，收益高，风险高的特点。<br>每次公司融资之前先谈估值，是溢价投资。</p><h3 id="什么是折价投资？"><a href="#什么是折价投资？" class="headerlink" title="什么是折价投资？"></a>什么是折价投资？</h3><p>比如极客学院这个公司，需要新一轮的融资，现在他的状况是口碑一般不太好，一直亏损，用户量大，估值10亿，<br>此时10亿的估值不太吸引风投，因此会产生这种情况：<br>说极客学院只值  2亿，投资1亿，原来一共有10000股，现在增发5000股，才可以。<br>按照原来情况值10亿，投资1亿，原有10000股， 现在增发1000股，就可以。</p><table><thead><tr><th>折价投资</th><th>溢价投资</th></tr></thead><tbody><tr><td>原股东盈利</td><td>原股东亏损</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="entrepreneurship" scheme="http://martist.cn/categories/entrepreneurship/"/>
    
    
      <category term="entrepreneurship" scheme="http://martist.cn/tags/entrepreneurship/"/>
    
  </entry>
  
  <entry>
    <title>创业公司必经之路（二）</title>
    <link href="http://martist.cn/2017/03/29/%E9%A9%AC%E9%97%AF%EF%BC%9A%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF%5B2%5D/"/>
    <id>http://martist.cn/2017/03/29/马闯：创业公司必经之路[2]/</id>
    <published>2017-03-28T16:00:00.000Z</published>
    <updated>2017-10-02T04:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h2><ul><li>投资人不要股份的年底分红，那才多少啊，更愿意升值后套现。</li><li>地派利润率高，不愿上市分钱。</li><li>天派现金流好，利于做大，然后上市套现。</li><li>上市公司要的就是快速发展。</li><li>京东一年比一年亏损，但是现金流好，足够支持它去抢占市场，这也侧面说明他还在打基础，此时股价可能就是间断的上涨。</li><li>如果有一天京东止损了，说明他想开始赚钱了，这样说明市场不会开阔的更大，可以看到公司发展的极限了，即将走下坡路，所以股价反而会下跌。</li><li>代持股协议，适合中国金融市场。</li></ul><h2 id="兄弟会的模式"><a href="#兄弟会的模式" class="headerlink" title="兄弟会的模式"></a>兄弟会的模式</h2><p>派出开发团队去外包项目，赚的钱是有限的，此时帮助这些创业公司救火，可以要求获得一些股份作为回报。</p><h2 id="中国房地产"><a href="#中国房地产" class="headerlink" title="中国房地产"></a>中国房地产</h2><p>硬着陆 =&gt; 泡沫破裂。<br>软着陆 =&gt; 人民币贬值，房地产泡沫变小，不会太大而破裂。</p><h2 id="对赌协议"><a href="#对赌协议" class="headerlink" title="对赌协议"></a>对赌协议</h2><p>花费两个月左右时间，写一个商业计划书，差不多就可以去找天使轮投资了。天使轮（不超过1000W），也有总资轮，和合伙人投资的说法。<br>此处有一个对赌协议的存在。</p><p>投资人和个人签约，是无限责任公司。<br>投资人和公司签约，是有限责任公司。</p><p>投资人会选择和个人或者母公司签约，更有保障一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="entrepreneurship" scheme="http://martist.cn/categories/entrepreneurship/"/>
    
    
      <category term="entrepreneurship" scheme="http://martist.cn/tags/entrepreneurship/"/>
    
  </entry>
  
  <entry>
    <title>创业公司必经之路（一）</title>
    <link href="http://martist.cn/2017/03/22/%E9%A9%AC%E9%97%AF%EF%BC%9A%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF%5B1%5D/"/>
    <id>http://martist.cn/2017/03/22/马闯：创业公司必经之路[1]/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-10-02T04:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h3 id="一家创业公司比较重要的三张表"><a href="#一家创业公司比较重要的三张表" class="headerlink" title="一家创业公司比较重要的三张表"></a>一家创业公司比较重要的三张表</h3><table><thead><tr><th>现金流表</th><th>利润表</th><th>负债表</th><th>派系</th><th>情况</th><th>预计</th><th>未来适合</th></tr></thead><tbody><tr><td>好</td><td>差</td><td>-</td><td>天派</td><td>发展快</td><td>高估值</td><td>做大-〉IPO上市</td></tr><tr><td>差</td><td>好</td><td>-</td><td>地派</td><td>运营好</td><td>赚钱</td><td>目的并非上市，先发财，不想和别人分钱</td></tr></tbody></table><p><strong>举例：</strong><br>IT兄弟连的现金流表好，利润流表一般。</p><p>股权所有者权益 = 股本 + 利润  </p><p>IPO = 公开募股</p><p>IBM有超过25%的员工变成了自由职业者，即不是常驻扎公司，有需要的时候才来上班。</p><h3 id="创业公司是怎么回事，怎么玩的？"><a href="#创业公司是怎么回事，怎么玩的？" class="headerlink" title="创业公司是怎么回事，怎么玩的？"></a>创业公司是怎么回事，怎么玩的？</h3><h4 id="1-公司资产和股本"><a href="#1-公司资产和股本" class="headerlink" title="1.公司资产和股本"></a>1.公司资产和股本</h4><p>假设：4个人创业注册公司，只有一个idea，想搞一个平台（类似猪八戒网），一人出25W，一共100W的投资额（注册资本），也就是说公司资产100W。此时每个人25W就是<strong>股本</strong>，但是股本不是决定每个股东占有公司多少股份的唯一标准，包括技术，人脉，资源等等都可以评估在内。</p><h4 id="2-资本供给"><a href="#2-资本供给" class="headerlink" title="2.资本供给"></a>2.资本供给</h4><p>中国的法律尚不健全，因此产生了一些具备特定功效的协议来平衡投资和融资之间的关系。<br>比如说，时光机公司里面，龙哥占80%股份，注册资本50W，此时有一家大的风投说要投资500W，按照中国法律来讲，如果时光机接受的话，那么龙哥的股份将剩下不到10%，于是有了这种<strong>处理办法</strong>：<br>500W取出490W作为<strong>资本供给</strong> 给龙哥，打到个人账户，10W去交易股份，得到时光机公司20%的股份。<br><strong>注意</strong>：在公司上市之前，股权，期权是可以用来交易变现的。</p><h4 id="3-代持股协议"><a href="#3-代持股协议" class="headerlink" title="3.代持股协议"></a>3.代持股协议</h4><blockquote><p>代持股协议，指代为持有股份、享有股权的委托协议书。现实生活中，部分公司对认购公司股份者有身份要求，一些投资者就与公司认可的认购股份者签订代持股协议，约定由受托人享有公司工商登记和行使股权等权利，委托人则享有股份应得的红利及其他收益，委托人支付受托人一定的费用。这种协议的法律依据是公司法相关司法解释中有关隐名股东和显名股东的规定。这种协议受法律保护，因涉及较强的专业性，故建议当事人委托专业的律师代为起草，有效预防和控制法律风险。</p></blockquote><p>这种情况下，公司实际掌舵人的持股份额不高，公司有幕后老板持有大量股份，这是大多发生实际控制人和幕后大股东之间的协议。<br>over。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="entrepreneurship" scheme="http://martist.cn/categories/entrepreneurship/"/>
    
    
      <category term="entrepreneurship" scheme="http://martist.cn/tags/entrepreneurship/"/>
    
  </entry>
  
  <entry>
    <title>SEO影响因素</title>
    <link href="http://martist.cn/2017/03/20/SEO%E6%8E%92%E5%90%8D%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0/"/>
    <id>http://martist.cn/2017/03/20/SEO排名的影响因素/</id>
    <published>2017-03-20T04:13:54.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h3 id="一-关键词优化"><a href="#一-关键词优化" class="headerlink" title="(一)关键词优化"></a>(一)关键词优化</h3><p>1.URL中包含要优化的关键词<br>2.网页Title中绝对匹配和相对匹配要优化的关键词<br>3.meta标签中绝对匹配和相对匹配要优化的关键词<br>4.网页核心内容绝对匹配和相对匹配要优化的关键词<br>5.网页内容标题使用〈h1〉标签优化<br>6.网页主体内容第一段以关键词开头<br>7.网页主体内容使用段落格式,每个段落针对不同的组合关键词展开优化,可以的话每个段落都以关键词开头<br>8.相关内容的展示:在网页核心内容下设置相关内容展示区,选择包含关键词的文章标题并给予链接,同时,提供给用户到该优化关键词的专题区(自由设想)<br>9.评论中出现关键词<br>10.对网页中的关键词做适当的特殊处理(加粗、加红、斜体等）<br>11  网页中重点图片(内容区、相关内容区、重点图片等）给予合理的包含关键词的ALT文字<br>12.图片名中包含关键词<br>13.域名中中包含关键词<br>14.目录名中包含关键词<br>15.文件名中包含关键词<br>16.网站频道或栏目名中包含关键词</p><h3 id="二-网站结构优化"><a href="#二-网站结构优化" class="headerlink" title="(二)网站结构优化"></a>(二)网站结构优化</h3><p>1.根据网站定位及内容设计结构<br>2.二极域名与一级目录的选择<br>3.网站物理结构与逻辑结构的吻合<br>4.根据逻辑结构设计网站内容<br>5.合理的面包屑导航设计<br>6.搜索引擎友好的网页布局设计<br>7.网页制作中代码的规范问题(形成有效信息片的标签设计、JS代码的合理使用、CSS文件的嵌入等、代码的精简)<br>8.绝对URL与相对URL的使用规则<br>9.文字链接锚文本的设计<br>10.网页内容如何聚合成网站主题<br>11.让网页核心内容的HTML代码优先执行</p><h3 id="三-反向链接优化"><a href="#三-反向链接优化" class="headerlink" title="(三)反向链接优化"></a>(三)反向链接优化</h3><p>1.反向链接数量:一般而言，数量越多越有利于关键词排名及收录数量<br>2.导入链接网页的信任度高<br>3.导入链接网页的主题内容与链向的网页内容密切相关<br>4.导入链接指向的网页有具体内容<br>5.反向链接的锚文字中有关键词<br>6.反向链接的锚文字周围有以关键词为基础的组合词<br>7.导入链接建立在反向链接网页的核心内容区<br>8.导入链接的时间长度，一般导入链接的存在时间有3-6个月<br>9.单向链接的价值高于互惠链接<br>10.导入链接的网页自身的导出链接小于100个，最佳的反向链接来自于外站的内容页的内容区域<br>11.反向链接最好来自不同IP，切忌同一IP的站点交叉链接<br>12.反向链接的增长频率不要太快，逐步增加，特别是相关性的文字链接</p><h3 id="四-绝对禁止的操作"><a href="#四-绝对禁止的操作" class="headerlink" title="(四)绝对禁止的操作"></a>(四)绝对禁止的操作</h3><p>1.在网页内容区、keywords、alt中堆积关键词<br>2.反向链接和站内链接所有的锚文字都相同<br>3.使用CSS或背景色隐藏内容<br>4.使用JavaScript跳转,建议使用301跳转<br>5.相同ip之下的网页直接进行大量交换链接<br>6.桥页和Cloaking，诱导搜索引擎的爬虫<br>7.放置成人内容，违禁药品，赌博相关内容<br>8.频繁的更换IP地址<br>9.导出链接中包含SEO作弊站点<br>10.加入到Link Farm或则Link交换类网站<br>11.使用被惩罚过的域名<br>12.网站建立在被惩罚的IP上</p><h3 id="五-需要考究的SEO因素"><a href="#五-需要考究的SEO因素" class="headerlink" title="(五)需要考究的SEO因素"></a>(五)需要考究的SEO因素</h3><p>1.网站内每个网页都有不同的title、keywords、description<br>2.首页、栏目页、内容页使用相同的模版<br>3.确保网站中每个网页都只能通过网络上的唯一一个URL访问到<br>4.尽量不要将首页设计为单一图片和Flash<br>5.网站导航条使用文字链接，尽量不要使用FLASH技术或JAVASCRIPT技术<br>6.网站导航条如果用图片记得以关键词为ALT标签<br>7.尽量在区域引用CSS和JS文件，而不将JS代码或样式写在网页内<br>8.只要技术上可以实现并且不会过于麻烦，就不要使用JS来显示网页中的内容，特别是核心内容区及URL列表区<br>9.要能确定网页的主题，而不要夹杂太多与该主题完全不相关的内容<br>10.整理下站点目录，将无用的网页文件清理掉，保持目录干净整洁是一个好站点的前提条件，也是评价该站点是否有人管理的指标<br>11.无论如何，都要放一个robots.txt文件在站点根目录，无论你会不会写，哪怕文件内容是空都可以。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="seo" scheme="http://martist.cn/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="http://martist.cn/2016/12/30/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://martist.cn/2016/12/30/linux常用命令/</id>
    <published>2016-12-30T13:30:50.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><pre><code>解包： tar xvf FileName.tar打包：tar cvf FileName.tar DirName </code></pre><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>svn 删除所有的 .svn文件<br>find . -name .svn -type d -exec rm -fr {} \;</p><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p>使用权限：所有使用者</p><p>使用方式：</p><p>cp [options] source dest</p><p>cp [options] source… directory</p><p>说明：将一个档案拷贝至另一档案，或将数个档案拷贝至另一目录。</p><p>option：</p><pre><code>-a 尽可能将档案状态、权限等资料都照原状予以复制。-r 若 source 中含有目录名，则将目录下之档案亦皆依序拷贝至目的地。-f 若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制。</code></pre><p>范例：</p><p>将档案 aaa 复制(已存在)，并命名为 bbb :</p><p>cp aaa bbb</p><p>将所有的C语言程式拷贝至 Finished 子目录中 :</p><p>cp *.c Finished</p><p>命令：scp</p><p>不同的Linux之间copy文件常用有3种方法：</p><p>第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。</p><p>第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。</p><p>第三种就是利用scp命令来进行文件复制。</p><pre><code>scp是有Security的文件copy，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令。</code></pre><p>scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root</p><p>然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了。</p><pre><code>如果想反过来操作，把文件从远程主机copy到当前系统，也很简单。</code></pre><p>linux之cp/scp命令＋scp命令详解(转) - linmaogan - 独木★不成林scp root@/full.tar.gz 172.19.2.75:/home/root/full.tar.gz home/daisy/full.tar.gz</p><p>linux 的 scp 命令 可以 在 linux 之间复制 文件 和 目录；</p><h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>scp 可以在 2个 linux 主机间复制文件；</p><p>命令基本格式：<br>       scp [可选参数] file_source file_target</p><p>======</p><h1 id="从-本地-复制到-远程"><a href="#从-本地-复制到-远程" class="headerlink" title="从 本地 复制到 远程"></a>从 本地 复制到 远程</h1><ul><li><p>复制文件：</p><pre><code>* 命令格式：        scp local_file remote_username@remote_ip:remote_folder        或者        scp local_file remote_username@remote_ip:remote_file        或者        scp local_file remote_ip:remote_folder        或者        scp local_file remote_ip:remote_file        第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；        第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；* 例子：        scp /home/space/music/1.mp3 root@www.cumt.edu.cn:/home/root/others/music        scp /home/space/music/1.mp3 root@www.cumt.edu.cn:/home/root/others/music/001.mp3        scp /home/space/music/1.mp3 www.cumt.edu.cn:/home/root/others/music        scp /home/space/music/1.mp3 www.cumt.edu.cn:/home/root/others/music/001.mp3</code></pre></li><li><p>复制目录：</p><pre><code>* 命令格式：        scp -r local_folder remote_username@remote_ip:remote_folder        或者        scp -r local_folder remote_ip:remote_folder        第1个指定了用户名，命令执行后需要再输入密码；        第2个没有指定用户名，命令执行后需要输入用户名和密码；* 例子：        scp -r /home/space/music/ root@www.cumt.edu.cn:/home/root/others/        scp -r /home/space/music/ www.cumt.edu.cn:/home/root/others/        上面 命令 将 本地 music 目录 复制 到 远程 others 目录下，即复制后有 远程 有 ../others/music/ 目录</code></pre></li></ul><p>======</p><h1 id="从-远程-复制到-本地"><a href="#从-远程-复制到-本地" class="headerlink" title="从 远程 复制到 本地"></a>从 远程 复制到 本地</h1><p>从 远程 复制到 本地，只要将 从 本地 复制到 远程 的命令 的 后2个参数 调换顺序 即可；</p><p>例如：</p><pre><code>scp root@www.cumt.edu.cn:/home/root/others/music /home/space/music/1.mp3scp -r www.cumt.edu.cn:/home/root/others/ /home/space/music/</code></pre><p>最简单的应用如下 :</p><p>scp 本地用户名 @IP 地址 : 文件名 1 远程用户名 @IP 地址 : 文件名 2</p><p>[ 本地用户名 @IP 地址 :] 可以不输入 , 可能需要输入远程用户名所对应的密码 .</p><p>可能有用的几个参数 :</p><p>-v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 .</p><p>-C 使能压缩选项 .</p><p>-P 选择端口 . 注意 -p 已经被 rcp 使用 .</p><p>-4 强行使用 IPV4 地址 .</p><p>-6 强行使用 IPV6 地址 .</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>关于数据迁移的方法，步骤和心得</title>
    <link href="http://martist.cn/2016/12/03/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E6%AD%A5%E9%AA%A4%E5%92%8C%E5%BF%83%E5%BE%97/"/>
    <id>http://martist.cn/2016/12/03/关于数据迁移的方法、步骤和心得/</id>
    <published>2016-12-02T16:00:00.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>在项目中经常会遇到系统完全更换后的历史数据迁移问题，以示对客户历史工作的尊重，何况很多数据仍有保留的必要。<br>那怎么做历史数据迁移呢？</p><h2 id="系统分析："><a href="#系统分析：" class="headerlink" title="系统分析："></a><strong>系统分析：</strong></h2><h3 id="1、分析原有的业务系统"><a href="#1、分析原有的业务系统" class="headerlink" title="1、分析原有的业务系统"></a>1、分析原有的业务系统</h3><p>精确到大致的系统功能模块、大致的处理流程即可</p><h3 id="2、分析现有的业务系统"><a href="#2、分析现有的业务系统" class="headerlink" title="2、分析现有的业务系统"></a>2、分析现有的业务系统</h3><p>精确到大致的系统功能模块、大致的处理流程即可</p><h3 id="3、分析两者自己的区别和差异"><a href="#3、分析两者自己的区别和差异" class="headerlink" title="3、分析两者自己的区别和差异"></a>3、分析两者自己的区别和差异</h3><p>大致分析一下两个业务系统之间的区别，有助于确定工作量和工作进度</p><h3 id="4、分析用户对旧有数据的需求"><a href="#4、分析用户对旧有数据的需求" class="headerlink" title="4、分析用户对旧有数据的需求"></a>4、分析用户对旧有数据的需求</h3><p>分析对旧有数据的需求，才不至于盲目的全部性的进行迁移</p><h3 id="5、分析用户对旧有数据的处理规则"><a href="#5、分析用户对旧有数据的处理规则" class="headerlink" title="5、分析用户对旧有数据的处理规则"></a>5、分析用户对旧有数据的处理规则</h3><p><strong>旧有数据的处理规则，一般分为以下几类：</strong><br>1、基础数据，通常这一类容易迁移，数据格式简单，但是会影响所有的相关业务数据，关注点为数据的主键和唯一键的方式。<br>2、纯历史数据的导入，仅供参考用的，这一类数据导入容易<br> 2.1 纯历史数据<br> 这一类数据处理起来会比较容易，一次性导入即可，后续采用增量数据导入。<br> 2.2 流程性数据<br> 这一类数据只有在记录完全关闭后才能结束，需要进行增量导入和数据更新，同时还要进行相关查询界面的开发，以保证旧有数据能够在新系统中查询的到。<br>3、新老系统表结构变化较大的历史数据<br> 这一类数据的工作量是最重的，就需要仔细去研究新老业务系统的数据结构了。<br> 1、尽量通过甲方单位来收集齐全相关原系统的相关设计文档，这一点对数据分析很有帮助，通过人的感觉和对数据的观察来分析毕竟不太靠谱。<br> 2、在原系统上进行相关数据的观察，了解数据的变化和数据表数据的关系（对于比较难以理解的相关字段很有帮助）<br> 3、比较新老系统数据的差异，如果实在很不靠谱的话，建议按2.2去处理。</p><p><strong>系统设计：</strong><br>1、做完系统分析之后，对相关数据进行归类，基础数据、纯历史数据、变化较大的历史数据<br>2、先从简单的入手，给自己点信心<br>3、在excel表中进行相关表的数据字典对照，勾画出对应字段、转换逻辑、依赖关系、必要时在新系统表上做相应的冗余，等数据迁移完毕后再清除。<br>关键点：<br>不同数据库的字段类型的匹配问题，比如SQLServer的text，在Oracle应该对应clob，但是宁愿转换成几个varchar2，从实现角度相对容易些。<br>关于主键的问题，一致的数据类型尽量维持现有状态，不一致的尽量采用oracle的序列或sqlserver的identity int，但是迁移完毕后，要注意序列值的更新</p><p><strong>系统实现：</strong><br>1、PL/SQL或T-SQL，DTS、SSIS或者PowerBuilder的管道作为数据迁移的方式<br>2、相关业务逻辑的迁移，与数据完整性和业务相关的存储过程、触发器、函数的改写，甚至SQL的改写<br>3、业务查询页面的编写</p><p><strong>后话：</strong><br>1、数据迁移没有特别或高级的方法<br>2、对业务数据的分析最为关键，需要不断的尝试在新系统上不断的测试<br>3、数据迁移技术，主要通过SQL、存储过程、甚至游标来实现，优先级也如上</p><p>还有一种数据迁移仅仅是数据库的平迁或异构数据库迁移：<br>数据库平迁，即为了性能扩展需要从一台服务器迁移到另外一台服务器上，用数据库的导出导入或备份恢复工具处理即可，当然也要考虑迁移后的一些序列字段的初始值。<br>异构数据迁移，即从一个数据库平台迁移到另外一个数据库平台，用ETL工具或SQL均可实现，不过要注意业务逻辑的迁移，即存储过程、函数、触发器之类的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>laravel优化之路</title>
    <link href="http://martist.cn/2016/11/15/%E3%80%90%E4%BC%98%E5%8C%96%E3%80%91Laravel/"/>
    <id>http://martist.cn/2016/11/15/【优化】Laravel/</id>
    <published>2016-11-14T16:00:00.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>性能一直是 Laravel 框架为人诟病的一个点，所以调优 Laravel 程序算是一个必学的技能。</p><p>接下来分享一些开发的最佳实践，还有调优技巧，大家有别的建议也欢迎留言讨论。</p><h1 id="二、策略"><a href="#二、策略" class="headerlink" title="二、策略"></a>二、策略</h1><pre><code>配置信息缓存 artisan config:cache路由缓存 artisan route:cache类映射加载优化 artisan optimize自动加载优化 composer dumpautoload使用 Memcached 来存储会话 config/session.php使用专业缓存驱动器 config/cache.php数据库请求优化为数据集书写缓存逻辑使用即时编译器（JIT），如：HHVM、OpCache前端资源合并 Elixir</code></pre><p>##1. 配置信息缓存<br>使用以下 Artisan 自带命令，把 config 文件夹里所有配置信息合并到一个文件里，减少运行时文件的载入数量：</p><p>php artisan config:cache<br>上面命令会生成文件 bootstrap/cache/config.php，可以使用以下命令来取消配置信息缓存：</p><p>php artisan config:clear<br>此命令做的事情就是把 bootstrap/cache/config.php 文件删除。</p><p>注意：配置信息缓存不会随着更新而自动重载，所以，开发时候建议关闭配置信息缓存，一般在生产环境中使用，可以配合 Envoy 任务运行器 一起使用。</p><p>##2. 路由缓存<br>路由缓存可以有效的提高路由器的注册效率，在大型应用程序中效果越加明显，可以使用以下命令：</p><pre><code>php artisan route:cache</code></pre><p>以上命令会生成 bootstrap/cache/routes.php 文件，需要注意的是，路由缓存不支持路由匿名函数编写逻辑。</p><p>可以使用下面命令清除路由缓存：</p><pre><code>php artisan route:clear    </code></pre><p>此命令做的事情就是把 bootstrap/cache/routes.php 文件删除。</p><p>注意：路由缓存不会随着更新而自动重载，所以，开发时候建议关闭路由缓存，一般在生产环境中使用，可以配合 Envoy 任务运行器 一起使用。</p><p>##3. 类映射加载优化<br>optimize 命令把常用加载的类合并到一个文件里，通过减少文件的加载，来提高运行效率：</p><pre><code>php artisan optimize --force</code></pre><p>会生成 bootstrap/cache/compiled.php 和 bootstrap/cache/services.json 两个文件。</p><p>你可以可以通过修改 config/compile.php 文件来添加要合并的类。</p><p>在 production 环境中，参数 –force 不需要指定，文件就会自动生成。</p><p>要清除类映射加载优化，请运行以下命令：</p><pre><code>php artisan clear-compiled</code></pre><p>此命令会删除上面 optimize 生成的两个文件。</p><p>注意：此命令要运行在 php artisan config:cache 后，因为 optimize 命令是根据配置信息（如：config/app.php 文件的 providers 数组）来生成文件的。</p><p>##4. 自动加载优化<br>此命令不止针对于 Laravel 程序，适用于所有使用 composer 来构建的程序。此命令会把 PSR-0 和 PSR-4 转换为一个类映射表，来提高类的加载速度。</p><pre><code>composer dumpautoload -o</code></pre><p>注意：php artisan optimize –force 命令里已经做了这个操作。</p><p>##5. 使用 Memcached 来存储会话<br>每一个 Laravel 的请求，都会产生会话，修改会话的存储方式能有效提高程序效率，会话的配置信息是 config/session.php，建议修改为 Memcached 或者 Redis 等专业的缓存软件：</p><pre><code>&apos;driver&apos; =&gt; &apos;memcached&apos;,</code></pre><p>##6. 使用专业缓存驱动器<br>「缓存」是提高应用程序运行效率的法宝之一，默认缓存驱动是 file 文件缓存，建议切换到专业的缓存系统，如 Redis 或者 Memcached，不建议使用数据库缓存。</p><pre><code>&apos;default&apos; =&gt; &apos;redis&apos;,</code></pre><p>##7. 数据库请求优化</p><p>数据关联模型读取时使用 延迟预加载 和 预加载 ；<br>使用 Laravel Debugbar 或者 Clockwork 留意每一个页面的总数据库请求数量；<br>这里的篇幅只写到与 Laravel 相关的，其他关于数据优化的内容，请自行查阅其他资料。</p><p>##8. 为数据集书写缓存逻辑<br>合理的使用 Laravel 提供的缓存层操作，把从数据库里面拿出来的数据集合进行缓存，减少数据库的压力，运行在内存上的专业缓存软件对数据的读取也远远快于数据库。</p><pre><code>$posts = Cache::remember(&apos;index.posts&apos;, $minutes = 30, function(){return Post::with(&apos;comments&apos;, &apos;tags&apos;, &apos;author&apos;, &apos;seo&apos;)-&gt;whereHidden(0)-&gt;get();});</code></pre><p>remember 甚至连数据关联模型也都一并缓存了，多么方便呀。</p><p>##9. 使用即时编译器<br>HHVM 和 OpCache 都能轻轻松松的让你的应用程序在不用做任何修改的情况下，直接提高 50% 或者更高的性能，PHPhub 之前做个一个实验，具体请见：使用 OpCache 提升 PHP 5.5+ 程序性能。</p><p>##10. 前端资源合并<br>作为优化的标准，一个页面只应该加载一个 CSS 和 一个 JS 文件，并且文件要能方便走 CDN，需要文件名随着修改而变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>如何增肌</title>
    <link href="http://martist.cn/2016/11/03/%E5%A6%82%E4%BD%95%E5%A2%9E%E8%82%8C/"/>
    <id>http://martist.cn/2016/11/03/如何增肌/</id>
    <published>2016-11-03T13:30:50.000Z</published>
    <updated>2017-10-03T05:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h3 id="增大肌肉块的14大秘诀："><a href="#增大肌肉块的14大秘诀：" class="headerlink" title="增大肌肉块的14大秘诀："></a>增大肌肉块的14大秘诀：</h3><p>大重量、低次数、多组数、长位移、慢速度、高密度、念动一致、顶峰收缩、持续紧张、组间放松、多练大肌群、训练后进食蛋白质、休息48小时、宁轻勿假。   </p><h4 id="1．大重量、低次数"><a href="#1．大重量、低次数" class="headerlink" title="1．大重量、低次数"></a>1．大重量、低次数</h4><p>健美理论中用RM表示某个负荷量能连续做的最高重复次数。比如，练习者对一个重量只能连续举起5次，则该重量就是5RM。研究表明：1-5RM的负荷训练能使肌肉增粗，发展力量和速度；6-10RM的负荷训练能使肌肉粗大，力量速度提高，但耐力增长不明显；10-15RM的负荷训练肌纤维增粗不明显，但力量、速度、耐力均有长进；30RM的负荷训练肌肉内毛细血管增多，耐久力提高，但力量、速度提高不明显。可见，5-10RM的负荷重量适用于增大肌肉体积的健美训练。</p><h4 id="2．多组数"><a href="#2．多组数" class="headerlink" title="2．多组数"></a>2．多组数</h4><p> 什么时候想起来要锻炼了，就做上2～3组，这其实是浪费时间，根本不能长肌肉。必须专门抽出60～90分钟的时间集中锻炼某个部位，每个动作都做8～10组，才能充分刺激肌肉，同时肌肉需要的恢复时间越长。一直做到肌肉饱和为止，”饱和度”要自我感受，其适度的标准是：酸、胀、发麻、坚实、饱满、扩张，以及肌肉外形上的明显粗壮等。</p><h4 id="3-长位移"><a href="#3-长位移" class="headerlink" title="3.长位移"></a>3.长位移</h4><p>不管是划船、卧推、推举、弯举，都要首先把哑铃放得尽量低，以充分拉伸肌肉，再举得尽量高。这一条与”持续紧张”有时会矛盾，解决方法是快速地通过”锁定”状态。不过，我并不否认大重量的半程运动的作用。</p><h4 id="4-慢速度"><a href="#4-慢速度" class="headerlink" title="4.慢速度"></a>4.慢速度</h4><p>慢慢地举起，在慢慢地放下，对肌肉的刺激更深。特别是，在放下哑铃时，要控制好速度，做退让性练习，能够充分刺激肌肉。很多人忽视了退让性练习，把哑铃举起来就算完成了任务，很快地放下，浪费了增大肌肉的大好时机。</p><h4 id="5-高密度"><a href="#5-高密度" class="headerlink" title="5.高密度"></a>5.高密度</h4><p> “密度”指的是两组之间的休息时间，只休息1分钟或更少时间称为高密度。要使肌肉块迅速增大，就要少休息，频繁地刺激肌肉。”多组数”也是建立在”高密度”的基础上的。锻炼时，要象打仗一样，全神贯注地投入训练，不去想别的事。</p><h4 id="6．念动一致"><a href="#6．念动一致" class="headerlink" title="6．念动一致"></a>6．念动一致</h4><p>肌肉的工作是受神经支配的，注意力密度集中就能动员更多的肌纤维参加工作。练某一动作时，就应有意识地使意念和动作一致起来，即练什么就想什么肌肉工作。例如：练立式弯举，就要低头用双眼注视自已的双臂，看肱二头肌在慢慢地收缩。</p><h4 id="7．顶峰收缩"><a href="#7．顶峰收缩" class="headerlink" title="7．顶峰收缩"></a>7．顶峰收缩</h4><p>这是使肌肉线条练得十分明显的一项主要法则。它要求当某个动作做到肌肉收缩最紧张的位置时，保持一下这种收缩最紧张的状态，做静力性练习，然后慢慢回复到动作的开始位置。我的方法是感觉肌肉最紧张时，数1～6，再放下来。</p><h4 id="8．持续紧张"><a href="#8．持续紧张" class="headerlink" title="8．持续紧张"></a>8．持续紧张</h4><p>应在整个一组中保持肌肉持续紧张，不论在动作的开头还是结尾，都不要让它松弛（不处于”锁定”状态），总是达到彻底力竭。</p><h4 id="9．组间放松"><a href="#9．组间放松" class="headerlink" title="9．组间放松"></a>9．组间放松</h4><p>每做完一组动作都要伸展放松。这样能增加肌肉的血流量，还有助于排除沉积在肌肉里的废物，加快肌肉的恢复，迅速补充营养。</p><h4 id="10-多练大肌群"><a href="#10-多练大肌群" class="headerlink" title="10.多练大肌群"></a>10.多练大肌群</h4><p>多练胸、背、腰臀、腿部的大肌群，不仅能使身体强壮，还能够促进其他部位肌肉的生长。有的人为了把胳膊练粗，只练胳膊而不练其他部位，反而会使二头肌的生长十分缓慢。建议你安排一些使用大重量的大型复合动作练习，如大重量的深蹲练习，它们能促进所有其他部位肌肉的生长。这一点极其重要，可悲的是至少有90％的人都没有足够重视，以致不能达到期望的效果。因此，在训练计划里要多安排硬拉、深蹲、卧推、推举、引体向上这5个经典复合动作。</p><h4 id="11．训练后进食蛋白质"><a href="#11．训练后进食蛋白质" class="headerlink" title="11．训练后进食蛋白质"></a>11．训练后进食蛋白质</h4><p>  在训练后的30～90分钟里，蛋白质的需求达高峰期，此时补充蛋白质效果最佳。但不要训练完马上吃东西，至少要隔20分钟。</p><h4 id="12．休息48小时"><a href="#12．休息48小时" class="headerlink" title="12．休息48小时"></a>12．休息48小时</h4><p>局部肌肉训练一次后需要休息48～72小时才能进行第二次训练。如果进行高强度力量训练，则局部肌肉两次训练的间隔72小时也不够，尤其是大肌肉块。不过腹肌例外，腹肌不同于其他肌群，必须经常对其进行刺激，每星期至少要练4次，每次约15分钟；选三个对你最有效的练习，只做3组，每组20—25次，均做到力竭；每组间隔时间要短，不能超过1分钟。</p><h4 id="13．宁轻勿假"><a href="#13．宁轻勿假" class="headerlink" title="13．宁轻勿假"></a>13．宁轻勿假</h4><p>这是一个不是秘诀的秘诀。许多初学健美的人特别重视练习重量和动作次数，不太注意动作是否变形。健美训练的效果不仅仅取决于负重的重量和动作次数，而且还要看所练肌肉是否直接受力和受刺激的程度。如果动作变形或不到位，要练的肌肉没有或只是部分受力，训练效果就不大，甚至出偏差。事实上，在所有的法则中，动作的正确性永远是第一重要的。宁可用正确的动作举起比较轻的重量，也不要用不标准的动作举起更重的重量。  </p><p>不要与人攀比，也不要把健身房的嘲笑挂在心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="生活" scheme="http://martist.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>SEO初步优化</title>
    <link href="http://martist.cn/2016/10/12/SEO%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96/"/>
    <id>http://martist.cn/2016/10/12/SEO简单优化/</id>
    <published>2016-10-11T16:00:00.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>个人总结六条<strong>SEO</strong>简单优化执行方案  以前自己没有写过一份比较正规的优化方案，是因为没有必要写的那么认真，但是现在不同了，来到了正规公司上班，优化方案必须认真对待，要不客户丢失的责任我可担不起!下边是自己整理的一个优化提纲，大家可以参考一下! </p><h2 id="一、title和meta的优化"><a href="#一、title和meta的优化" class="headerlink" title="一、title和meta的优化"></a>一、title和meta的优化</h2><p>网站页面的Title和Meta与搜索引擎中搜索结果的表现是一一对应的，如果你网站页面没有填写meta中的description内容，那么搜索引擎会根据抓取的页面的文字信息来显示，当然一些flash类的网页是不可能抓取到这些信息的。<br>一般来说，对于Title和Meta内容的撰写要求如下：<br><strong>准确</strong>：每个页面有不同的标题(title)，和最能够体现页面信息的描述信息(Meta Description);<br><strong>简短</strong>：Title中的文字尽量不要超过33个中文字;Meta Description中的文字尽量不要超过100个中文字;<br><strong>包含关键词</strong>：Title和Meta中都必须合理的包含页面上所需要强调的关键词。<br>对于Title来说，最重要的关键词应该靠左。<br>频道页的tilte和meta信息优化格式，以下为引用的内容：</p><pre><code>&lt;title&gt;(频道名称)-网站名-(品牌宣传语)&lt;/title&gt;&lt;meta name=”keywords” content=”(频道名称),网站名,(频道相关关键词)” /&gt;&lt;meta name=”Description” content=”(频道相关描述文字)” /&gt; 网站更多内页Title和Meta完善&lt;title&gt;(文章名称)-(频道名称)-网站名&lt;/title&gt; &lt;meta name=”keywords” content=”(文章名称),(频道名称),网站名,(频道相关关键词)” /&gt; &lt;meta name=”Description” content=”(文章正文前100字)” /&gt;</code></pre><h2 id="二、图片链接文本化"><a href="#二、图片链接文本化" class="headerlink" title="二、图片链接文本化"></a>二、图片链接文本化</h2><p>查看网站是否有图片有没有做优化，指出并截图提示给客户，并对这些优化加以解释。    网站中图片显示不要太多，尤其是网站的导航部分，对于搜索引擎抓取页面不利，建议优化为纯文本文字的导航链接。    如果非要坚持用一些图片做修饰的话，建议加alt属性。  </p><h2 id="三、搜索引擎权重标签的使用"><a href="#三、搜索引擎权重标签的使用" class="headerlink" title="三、搜索引擎权重标签的使用"></a>三、搜索引擎权重标签的使用</h2><p>搜索引擎对网站页面的处理主要的依据是页面的源代码，在源代码中，根据W3C标准，部分HTML标签天然具有特殊的属性，而这些HTML标签，也是搜索引擎所关注的。 </p><h3 id="1、合理的使用-lt-h1-gt-标签-需要给客户截图指出"><a href="#1、合理的使用-lt-h1-gt-标签-需要给客户截图指出" class="headerlink" title="1、合理的使用&lt;h1&gt;标签(需要给客户截图指出)"></a>1、合理的使用<code>&lt;h1&gt;</code>标签(需要给客户截图指出)</h3><p><code>&lt;h1&gt;</code>标签是标题标签，它表明了这个页面的主标题是什么，通常情况下，<code>&lt;h1&gt;</code>标签中的标题、关键词都具有非常高的权重。同写文章一样，一个文章只有一个标题，一个页面也最多使用一个<code>&lt;h1&gt;</code>标签。</p><h3 id="2、适当使用-lt-strong-gt-标签-需要给客户截图指出"><a href="#2、适当使用-lt-strong-gt-标签-需要给客户截图指出" class="headerlink" title="2、适当使用&lt;strong&gt;标签(需要给客户截图指出)"></a>2、适当使用<code>&lt;strong&gt;</code>标签(需要给客户截图指出)</h3><p><code>&lt;strong&gt;</code>标签是关键词强调标签，用于对需要突出的关键词作为特殊显示。对于新奥集团网站来说，主要针对网站上的新闻、媒体报道、业务介绍等页面正文部分出现的前3-5个核心关键词使用<code>&lt;strong&gt;</code>标签。 </p><h2 id="四、网页中js链接的使用"><a href="#四、网页中js链接的使用" class="headerlink" title="四、网页中js链接的使用"></a>四、网页中js链接的使用</h2><p>指出客户网站中使用js链接的地方，告诉客户js链接无法被搜索引擎识别，搜索引擎不能抓取到所有的列表页面，最终看不到更多的信息，所以，建议将js链接换成文本链接。  </p><h2 id="五、网站url优化"><a href="#五、网站url优化" class="headerlink" title="五、网站url优化"></a>五、网站url优化</h2><p>现在有很多个客户，他们在做网站的时候都没有相当以后会做优化，这样网站建设公司当然在做网站的时候也不去注意优化，尤其是程序方面，都是怎么方便怎么来!其中最麻烦的应该就是url的优化，url为三级目录最佳，很多网站的url目录都比较深，都需要变成三级，甚至二级，像的助企网就是二级目录，把所有的页面都放在了根目录下边!这样对于一些小企业站来说是挺不错的!    在这里，你应该给客户指出他的url目录是几级目录，应该变成怎样的，举一个例子最好! </p><h2 id="六、添加robots-txt和sitemap-xml文件"><a href="#六、添加robots-txt和sitemap-xml文件" class="headerlink" title="六、添加robots.txt和sitemap.xml文件"></a>六、添加robots.txt和sitemap.xml文件</h2><h3 id="1、sitemap-xml文件的增加"><a href="#1、sitemap-xml文件的增加" class="headerlink" title="1、sitemap.xml文件的增加"></a>1、sitemap.xml文件的增加</h3><p>Sitemap.xml文件是一个重要的优化，它告诉搜索引擎网站上的URL结构、权重表现和更新时间。例如：某网站的sitemap.xml文件内容如下：    我们会制作相应的sitemap.xml文件，放在网站的域名根目录下，使得/sitemap.xml文件可访问。</p><h3 id="2、robots-txt文件的增加"><a href="#2、robots-txt文件的增加" class="headerlink" title="2、robots.txt文件的增加"></a>2、robots.txt文件的增加</h3><p>Robots.txt文件主要对网站一些隐私频道、JS和CSS目录进行屏蔽;以及对sitemap.xml文件地址进行广播，例如，某网站的robots.txt内容：    因此，我们也制作了网站的robots.txt文件，需要将文件放在网站的根域名下，使得/robots.txt文件可访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>大并发高负载网站的前期准备</title>
    <link href="http://martist.cn/2016/08/02/%E5%A4%A7%E8%B4%9F%E8%BD%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99%E7%9A%84%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"/>
    <id>http://martist.cn/2016/08/02/大负载高并发网站的前期准备/</id>
    <published>2016-08-01T16:00:00.000Z</published>
    <updated>2017-10-03T05:40:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>对互联网有了解的人都有自己的想法，有人就把想法付诸实现，做个网站然后开始运营。其实从纯网站技术上来说，因为开源模式的发展，现在建一个小网站 已经很简单也很便宜。当访问量到达一定数量级的时候成本就开始飙升了，问题也开始显现了。因为带宽的增加、硬件的扩展、人员的扩张所带来的成本提高是显而 易见的，而还有相当大的一部分成本是因为代码重构、架构重构，甚至底层开发语言更换引起的，最惨的就是数据丢失，辛辛苦苦好几年，一夜回到创业前。</p><p>减少成本就是增加利润。很多事情，我们在一开始就可以避免，先打好基础，往后可以省很多精力，少操很多心。</p><p>假设你是一个参与创业的技术人员，当前一穷二白，什么都要自己做，自己出钱，初期几十万的资金，做一个应用不是特别复杂的网站，那么就要注意以下几点：</p><h2 id="一、开发语言"><a href="#一、开发语言" class="headerlink" title="一、开发语言"></a>一、开发语言</h2><p>一般来说，技术人员（程序员）创业都是根据自己技术背景选择自己最熟悉的语言，不过考虑到不可能永远是您一个人写程序，这点还得仔细想想。无论用什么语言，最终代码质量是看管理，所以我们还是从纯语言层面来说实际一点。现在流行的java、php、.net、python、ruby都 有自己的优劣，python和ruby，现在人员还是相对难招一些，性能优化也会费些力气，.net平台买不起windows server。java、php用的还是最多。对于初期，应用几乎都是靠前端支撑的网站来说，php的优势稍大一些，入门简单、设计模式简单、写起来快、 性能足够等，不过不注重设计模式也是它的劣势，容易变得松散，隐藏bug稍多、难以维护。java的优势在于整套管理流程已经有很多成熟工具来辅助，强类 型也能避免一些弱智BUG，大多数JAVA程序员比较注重设计模式，别管实不实际，代码格式看起来还是不错的。这也是个劣势，初学者可能太注重模式而很难 解决实际需求。</p><p>前端不只是html、css这类。整个负责跟用户交互的部分都是前端，包括处理程序。这类程序还是建议用php，主要原因就是开发迅速、从业人员广泛。至于后端例如行为分析、银行接口、异步消息处理等，随便用什么程序，那个只能是根据不同业务需求来选择不同语言了。</p><h2 id="二、代码版本管理"><a href="#二、代码版本管理" class="headerlink" title="二、代码版本管理"></a>二、代码版本管理</h2><p>如果开发人员之间的网络速度差不多，就SVN；比较分散例如跨国，就hg。大多数人还是svn的.</p><p>假设选了svn，那么有几点考虑。一是采用什么树结构。初期可能只有一条主干，往后就需要建立分支，例如一条开发分支，一条上线分支，再往后，可能 要每个小组一个分支。建议一开始人少时选择两条分支，开发和线上，每个功能本地测试无误后提交到开发分支，最后统一测试，可以上线时合并到上线分支。如果 喜欢把svn当做移动硬盘用，写一点就commit一次也无所谓，就是合并的时候头大一些，这些人可以自己建个分支甚至建立个本地代码仓库，随便往自己的 分支提交，测试完毕后再提交到开发分支上。</p><p>部署，可以手工部署也可以自动部署。手工部署相对简单，一般是直接在服务器上svn update，或者找个新目录svn checkout，再把web root给ln -s过去。应用越复杂，部署越复杂，没有什么统一标准，只要别再用ftp上传那种形式就好，一是上传时文件引用不一致错误率增加，二是很容易出现开发人员 的版本跟线上版本不一致，导致本来想改个错字结果变成回滚的杯具。如果有多台服务器还是建议自动部署，更换代码的机器从当前服务池中临时撤出，更新完毕后 再重新加入。</p><p>不管项目多小，养成使用版本管理的好习惯，最起码还可以当做你的备份，我的 <a href="http://zhiyi.us" target="_blank" rel="external">http://zhiyi.us</a> 虽然就是一个wordpress，可还是svn了，只改动一两句css那也是劳动成果。</p><h2 id="三、服务器硬件"><a href="#三、服务器硬件" class="headerlink" title="三、服务器硬件"></a>三、服务器硬件</h2><p>别羡慕大客户和有钱人，看看机房散户区，一台服务器孤独的支撑的网站数不清。如果资金稍微充足，建议至少三台的标准配置，分别用作web处理、数据 库、备份。web服务器至少要8G内存，双sata raid1，如果经济稍微宽松，或静态文件或图片多，则15k sas raid1+0。数据库至少16G内存，15k sas raid 1+0。备份服务器最好跟数据库服务器同等配置。硬件可以自己买品牌的底板，也就是机箱配主板和硬盘盒，CPU内存硬盘都自己配，也可以上整套品牌，也可 以兼容机。三台机器，市场行情6、7万也就配齐了。</p><p>web服务器可以既跑程序又当内存缓存，数据库服务器则只跑主数据库（假如是MySQL的话），备份服务器干的活就相对多一些，web配置、缓存配置、数据库配置都要跟前两台一致，这样WEB和数据库任意一台出问题，把备份服务器换个ip就切换上去了。备份策略，可以drbd，可以rsync，或者其他的很多很多的开源备份方案可选择。rsync最简单，放cron里自己跑就行。备份和切换，建议多做测试，选最安全最适合业务的，并且尽可能异地备份。</p><h2 id="四、机房"><a href="#四、机房" class="headerlink" title="四、机房"></a>四、机房</h2><p>三种机房尽量不要选：联通访问特别慢的电信机房、电信访问特别慢的联通机房、电信联通访问特别慢的移动或铁通机房。那网通机房呢？亲，网通联通N久 以前合并改叫联通了。多多寻找，实地参观，多多测试，多方打探，北京、上海、广州等各个主节点城市，还是有很多优质机房的，找个网络质量好，管理严格的机 房，特别是管理要严格，千万别网站无法访问了，打个电话过去才知道别人维护时把你网线碰掉了，这比DOS都头疼。自己扯了几根光纤就称为机房的，看您抗风 险程度和心理素质了。机房可以说是非常重要，直接关系到网站访问速度，网站访问速度直接关系到用户体验，我可以翻墙看风景，但买个网游vpn才能打开你这 个还不怎么知名的网站就有难度了。或许您网站的ajax很出色，可是document怎么也不ready，一些代码永远绝缘于用户。</p><h2 id="五、架构"><a href="#五、架构" class="headerlink" title="五、架构"></a>五、架构</h2><p>初期架构一般比较简单，web负载均衡+数据库主从+缓存+分布式存储+队列。大方向上也确实就这几样东西，细节上也无数文章都重复过了，按照将来 会有N多WEB，N多主从关系，N多缓存，N多xxx设计就行，基本方案都是现成的，只是您比其他人厉害之处就在于设计上考虑到缓存失效时的雪崩效应、主 从同步的数据一致性和时间差、队列的稳定性和失败后的重试策略、文件存储的效率和备份方式等等意外情况。缓存总有一天会失效，数据库复制总有一天会断掉， 队列总有一天会写不进去，电源总有一天会烧坏。根据墨菲定律，如果不考虑这些，网站早晚会成为茶几。</p><h2 id="六、服务器软件"><a href="#六、服务器软件" class="headerlink" title="六、服务器软件"></a>六、服务器软件</h2><p>Linux、nginx、php、mysql，几乎是标配，我们除了看名字，还得选版本。Linux发行版众多，只要没特殊要求，就选个用的人最多的，社区最活跃的，配置最方便的，软件包最全最新的，例如debian、ubuntu。 至于RHEL之类的嘛，你用只能在RHEL上才能运行的软件么？剩下的nginx、php、mysql、activemq、其他的等等，除非你改过这些软 件或你的程序真的不兼容新版本，否则尽量版本越新越好，版本新，意味着新特性增多、BUG减少、性能增加。总有些道听途说的人跟你说老的版本稳定。所谓稳 定，是相对于特殊业务来说的，而就一个php写的网站，大多数人都没改过任何服务器软件源代码，绝大多数情况是能平稳的升级到新版本的。类似于jdk5到 jdk6，python2到python3这类变动比较大的升级还是比较少见的。看看ChangeLog，看看升级说明，结合自己情况评估一下，越早升级 越好，别人家都用php6写程序了这边还php4的逛游呢。优秀的开源程序升级还是很负责任的，看好文档，别怕。</p><p>以上这六点准备完毕，现在我们有了运行环境，有了基本架构骨架，有了备份和切换方案，应该开始着手设计开发方面的事情了。开发方面的事情无数，下一篇会先说一些重点。<br>原文地址</p><h2 id="七、数据库"><a href="#七、数据库" class="headerlink" title="七、数据库"></a>七、数据库</h2><p>几乎所有操作最后都要落到数据库身上，它又最难扩展（存储也挺难）。对于mysql，什么样的表用myisam，什么样的表用innodb，在开发 之前要确定。复制策略、分片策略，也要确定。表引擎方面，一般，更新不多、不需要事务的表可以用myisam，需要行锁定、事务支持的，用innodb。 myisam的锁表不一定是性能低下的根源，innodb也不一定全是行锁，具体细节要多看相关的文档，熟悉了引擎特性才能用的更好。现代WEB应用越来 越复杂了，我们设计表结构时常常设计很多冗余，虽然不符合传统范式，但为了速度考虑还是值得的，要求高的情况下甚至要杜绝联合查询。编程时得多注意数据一 致性。</p><p>复制策略方面，多主多从结构也最好一开始就设计好，代码直接按照多主多从来编写，用一些小技巧来避免复制延时问题，并且还要解决多数据库数据是否一致，可以自己写或者找现成的运维工具。</p><p>分片策略。总会有那么几个表数据量超大，这时分片必不可免。分片有很多策略，从简单的分区到根据热度自动调整，依照具体业务选择一个适合自己的。避免自增ID作为主键，不利于分片。</p><p>用存储过程是比较难扩展的，这种情形多发生于传统C/S，特别是OA系统转换过来的开发人员。低成本网站不是一两台小型机跑一个数据库处理所有业务的模式，是机海作战。方便水平扩展比那点预分析时间和网络传输流量要重要的多的多。</p><p>NoSQL。这只是一个概念。实际应用中，网站有着越来越多的密集写操作、上亿的简单关系数据读取、热备等，这都不是传统关系数据库所擅长的，于是 就产生了很多非关系型数据库，比如Redis/TC&amp;TT/MongoDB/Memcachedb等，在测试中，这些几乎都达到了每秒至少一万次 的写操作，内存型的甚至5万以上。例如MongoDB，几句配置就可以组建一个复制+自动分片+failover的环境，文档化的存储也简化了传统设计库 结构再开发的模式。很多业务是可以用这类数据库来替代mysql的。</p><h2 id="八、缓存"><a href="#八、缓存" class="headerlink" title="八、缓存"></a>八、缓存</h2><p>数据库很脆弱，一定要有缓存在前面挡着，其实我们优化速度，几乎就是优化缓存，能用缓存的地方，就不要再跑到后端数据库那折腾。缓存有持久化缓存、 内存缓存，生成静态页面是最容易理解的持久化缓存了，还有很多比如varnish的分块缓存、前面提到的memcachedb等，内存缓 存，memcached首当其冲。缓存更新可用被动更新和主动更新。被动更新的好处是设计简单，缓存空了就自动去数据库取数据再把缓存填上，但容易引发雪 崩效应，一旦缓存大面积失效，数据库的压力直线上升很可能挂掉。主动缓存可避免这点但是可能引发程序取不到数据的问题。这两者之间如何配合，程序设计要多 动脑筋。</p><h2 id="九、队列"><a href="#九、队列" class="headerlink" title="九、队列"></a>九、队列</h2><p>用户一个操作很可能引发一系列资源和功能的调动，这些调动如果同时发生，压力无法控制，用户体验也不好，可以把这样一些操作放入队列，由另几个模块 去异步执行，例如发送邮件，发送手机短信。开源队列服务器很多，性能要求不高用数据库当做队列也可以，只要保证程序读写队列的接口不变，底层队列服务可随 时更换就可以，类似Zend Framework里的Zend_Queue类，java.util.Queue接口等。</p><h2 id="十、文件存储"><a href="#十、文件存储" class="headerlink" title="十、文件存储"></a>十、文件存储</h2><p>除了结构化数据，我们经常要存放其他的数据，像图片之类的。这类数据数量繁多、访问量大。典型的就是图片，从用户头像到用户上传的照片，还要生成不 同的缩略图尺寸。存储的分布几乎跟数据库扩展一样艰难。不使用专业存储的情况下，基本都是靠自己的NAS。这就涉及到结构。拿图片存储举例，图片是非常容 易产生热点的，有些图片上传后就不再有人看，有些可能每天被访问数十万次，而且大量小文件的异步备份也很耗费时间。</p><p>为了将来图片走cdn做准备，一开始最好就将图片的域名分开，且不用主域名。很多网站都将cookie设置到了.domain.ltd，如果图片也在这个域名下，很可能因为cookie而造成缓存失效，并且占多余流量，还可能因为浏览器并发线程限制造成访问缓慢。</p><p>如果用普通的文件系统存储图片，有一个简单的方法。计算文件的hash值，比如md5，以结果第一位作为第一级目录，这样第一级有16个目录。从0 到F，可以把这个字母作为域名，0.yourimg.com到f.yourimg.com（客户端dns压力会增大），还可以扩展到最多16个NAS集群 上。第二级可用年月例如，201011，第三级用日，第四级可选，根据上传量，比如am/pm，甚至小时。最终的目录结构可能会是 e/201008/25/am/e43ae391c839d82801920cf.jpg。rsync备份时可以用脚本只同步某年某日某时的文件，避免计 算大量文件带来的开销。当然最好是能用专门的分布式文件系统或更专业点的存储解决方案。</p><p>下面，我们要谈谈代码了。</p><p>这一系列的最后一篇写给普通编程人员，如果不感兴趣可直接看本文最后几段。开始设计代码结构之前，先回顾一下之前准备过的事情：我们有负载均衡的 WEB服务器，有主从DB服务器并可能分片，有缓存，有可扩展的存储。在组织代码的各个方面，跟这些准备息息相关，我一二三的列出来分别说，并且每一条都 以“前面讲到”这个经典句式开头，为了方便对照。</p><p>别着急看经典句式，我思维跳跃了，插一段。实际开发中，我们总会在性能和代码优雅性上作折中。对于当今的计算机和语言解释器，多几层少几层对象调 用、声明变量为Map还是HashMap这种问题是最后才需要考虑的问题，永远要考虑系统最慢的部分，从最慢的部分解决。例如看看你用的ORM是不是做了 很多你用不到的事情，是不是有重复的数据调用。我们做的是web应用开发，不是底层框架API，代码易读易懂是保证质量很重要的一方面。</p><p>前面讲到，WEB 服务器是要做负载均衡的，图片服务器是要分开的。对于这点，代码在处理客户端状态时，不要把状态放到单机上，举例，不要用文件session，嗯，常识。 如果有可能，最好在一开始就做好用户单点认证的统一接口，包括跨域如何判断状态、静态页面如何判断状态，需要登录时的跳转和返回参数定义，底层给好接口， 应用层直接就用（可参考GAE的 user服务）。登录方面的设计要考虑移动设备的特性，比如电脑可以用浮动层窗口，但NOKIA自带的浏览器或UCWEB就无法处理这种表现形式，程序一 定既能处理AJAX请求又能直接通过URL来处理请求。图片服务器分开，资源文件最好也布局到图片服务器，也就是WEB服务器只服务动态程序。虽然开发测 试时稍微复杂（因为需要绝对URI才能访问），但将来页面前端优化上会轻松许多，并且你的WEB服务器IO优化也轻松许多。程序引用资源文件时，要有一个 统一的处理方法，在方法内部可以自动完成很多事情，例如将css/js根据组合，拼成一个文件，或者自动在生成的URI后面加上QUERYSTRING， 如果将来前端用了缓存服务，那生成QUERYSTRING是最简单的刷新服务端缓存和客户端缓存的办法。</p><p>前面讲到， 数据库会有复制，可能会多主多从，可能会分片。我们程序在处理数据的过程中，最好能抽象出来单独放做一层。拿现在流行的MVC模式来说，就是在M层下方再 放一个数据层，这个数据层不是通常所说的JDBC/PDO/ActiveRecord等，而是你自己的存取数据层，仅对外暴露方法，隐藏数据存取细节。这 个数据层内部不要怕写的难看，但一定要提供所有的数据存储功能，其他任何层次不要看到跟数据库打交道的字眼。之所以这样做，是因为在单关系数据库的情况 下，可能会SELECT…JOIN…或直接INSERT…INTO…，可你可能会将一些表放到key-value数据库里存储，或者分片，这么做之后原来 的语句和方式要全部改变，如果过于分散，则移植时会耗费很大精力，或得到一个很大的Model。在数据层面的设计上，尽量避免JOIN查询，我们可以多做 冗余，多做缓存，每种数据尽量只需要一次查询，然后在你的程序里面进行组合。对于比较复杂的数据组合，在实时性要求不高的情况下，可采用异步处理，用户访 问时只取处理后的结果。在对于主键的处理上，避免使用自增ID，可以用一定规则生成的唯一值当做主键，这种主键是最简单的分片分布策略。即使用自增ID， 也最好用一个自增ID发生器，否则从数据库不小心被写了一下，那主键很容易冲突。</p><p>前面讲到，咱数据库前面还有某些缓存挡着。别把 mysql的query cache当缓存，应用稍复杂的时候QUERY CACHE反而会成为累赘。缓存跟数据库和业务结合的很紧密，正因为跟业务关系紧密，所以这点没有放之四海而皆准的方法。但我们还是有一些规则可参照。规 则一：越接近前端，缓存的颗粒度越大。例如在WEB最前端缓存整个页面，再往后一层缓存部分页面区域，再往后缓存区域内的单条记录。因为越靠近后端，我们 的可操作性越灵活，并且变化最多的前端代码也比较方便编写。在实践中，因为产品需求变化速度非常快，迭代周期越来越短，有时很难将Controller和 Model分的那么清楚，Controller层面处理部分缓存必不可免，但要保证如果出现这种情况，Controller所操作的缓存一定不要影响其他 数据需求方，也就是要保证这个缓存数据只有这一个Controller在用。规则二：没有缓存时程序不能出错。在不考虑缓存失效引发的雪崩效应时，你的程 序要有缓存跟没缓存一个样，不能像新浪微博一样，缓存一失效，粉丝微博全空，整个应用都乱套了。在缓存必不可少的情况下，给用户出错信息都比给一个让人误 解的信息强。规则三，缓存更新要保证原子性或称作线程安全，特别是采用被动缓存的方式时，很可能两个用户访问时导致同一个缓存被更新，通常情况这不是大问 题，可缓存失效后重建时很可能是引发连锁反应的原因之一。规则四：缓存也是有成本的。不只是技术成本，还有人工时间成本。如果一个功能使用缓存和不使用， 在可预见的访问量情况下区别微小，但使用缓存会使复杂度增加，那就不用，我们可以加个TODO标注，在下次迭代的时候加上缓存处理。</p><p>前 面讲到，文件存储是独立的，那么所有的文件操作就都是远程调用。可以在文件服务器上提供一个很简单的RESTful接口，也可以提供xmlrpc 或json serveice，WEB服务器端所生成和处理的文件，全部通过接口通知文件服务器去处理，WEB服务器本身不要提供任何文件存储。你会发现很多大网站的 上传图片跟保存文章是分两步完成的，就是基于这个原因。</p><p>以上几条“前面讲到”，其实无数人都讲过，我也只是结合前几篇文章用自己的话重 复了一遍，真正分析起来精髓很简单——除了良好的功能逻辑分层，我们 还要为数据库存储、缓存、队列、文件服务等程序外层资源调用单独设计接口，你可以把你的程序想象成是运行在 Amazon EC2 上并用他的所有web service服务，你的数据库就是它的SimpleDB，你的队列就是他的SQS，你的存储就是他的S3，唯一不同是amazon的接口是远程调用，你的是内部调用。</p><p>将支撑服务接口化，意味着将MySQL更换到PostgreSQL不需要更改业务处理程序，移植团队甚至不需要跟业务开发团队过多沟通；意味着业务开发团队是对接口编程而不是对数据库编程；意味着不会因为某个业务开发人员的失误而拖垮性能。</p><p>对程序扫盲不感兴趣的直接看这里——</p><p>产品设计完了，程序框架搭完了，可能有矛盾在这个节骨眼儿产生了。不断有产品设计抱怨说他的创意没实现到预期效果，有程序员抱怨说产品设计不切实 际。这种抱怨多缘于产品人员不懂技术，技术人员不理解产品。从广义上来讲，产品包含市场策略、营销手段、功能设计，产品和技术在争论时往往把焦点放在功能 上，而实际重点是，实现这个功能所消耗的成本跟能这个功能带来的利益能否换算，能否取其轻重。若可以，争议解决。若不能，则抛硬币看运气。因为一个功能的 加强而引发指标井喷，或因项目拖延而导致贻误战机的例子比比皆是。激进的决策者注重利益，保守的决策者注重损失，聪明的决策者会考虑这个问题是否真的那么 严重。</p><p>关系到未来的事情谁都说不准，要不怎么说创业一半靠运气呢。不过总有能说的准的事情，那就得靠数据说话。</p><p>没有100%也有99.9%的网站安装了访问统计代码，连我的 <a href="http://zhiyi.us" target="_blank" rel="external">http://zhiyi.us</a> 也不例外，新闻联播也总说科学决策科学发展的。有了统计，能确定的事情就很多了。例如，可以根据来源-目标转化率来分析哪类渠道的人均获取成本低，根据来 源-内容访问猜测用户跳出率原因，根据用户点击行为判断链接位置是否合理等。将数据以不同方式组合起来，找到内在联系，分析内因外因，制定对应策略，减少 拍脑门决策。靠数据支撑运营是个非常专业的事情，虽然不懂深奥的数学模型不会复杂的公式计算，渐渐学会因为A所以B，因为A和B所以C还是相对简单的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>文件上传OSS三部曲（三）</title>
    <link href="http://martist.cn/2016/08/02/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0OSS%20%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://martist.cn/2016/08/02/文件上传OSS 三部曲（三）/</id>
    <published>2016-08-01T16:00:00.000Z</published>
    <updated>2017-10-03T05:40:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>最近在做这个新闻模块，编辑新闻的实现采用了ueditor富文本编辑器。<br>因为ueditor支持服务器本地存储上传文件（在新闻主题中插入的图片），和七牛云OSS存储，并不支持阿里云OSS存储，由于项目依托在阿里云的各种服务上，便于一个账号管理使用的阿里云OSS，没有使用七牛云，此时就需要我们的一些动手能力，给ueditor集成上对aliyunOSS的支持。<br>首先下载<a href="http://ueditor.baidu.com" target="_blank" rel="external">ueditor</a>。<br>在这里没有使用组件化开发，因为富文本编辑器一般不会有什么巨大的漏洞，用户能实现常用的编辑文字和添加样式的功能即可。只需在页面引入几个js文件即可使用。<br><strong>示例：</strong></p><h3 id="1-blade模板载入编辑器"><a href="#1-blade模板载入编辑器" class="headerlink" title="1.blade模板载入编辑器"></a>1.blade模板载入编辑器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123;asset(&apos;ueditor/ueditor.config.js&apos;)&#125;&#125;&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123;asset(&apos;ueditor/ueditor.all.min.js&apos;)&#125;&#125;&quot;&gt; &lt;/script&gt;</div><div class="line">&lt;script id=&quot;content&quot; name=&quot;content&quot; type=&quot;text/plain&quot;&gt;</div><div class="line">@if(!empty($new))</div><div class="line">&#123;!! $new-&gt;content !!&#125;</div><div class="line">@endif</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;!-- 实例化编辑器 --&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">UE.getEditor(&apos;content&apos;,&#123;</div><div class="line">initialFrameWidth : 800,</div><div class="line">initialFrameHeight : 400,</div><div class="line"></div><div class="line">&#125;);</div><div class="line">var ue = UE.getEditor(&apos;content&apos;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>将你编辑后需要保存的的内容添加name属性在id=content的<code>&lt;script&gt;</code>标签内。   </p><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>查看ueditor的./php/目录可知Uploader.class.php是它的上传文件工具类。对其进行改造。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line">     * 上传文件的主处理方法</div><div class="line">     * @return mixed</div><div class="line">     */</div><div class="line">    private function upFile()</div><div class="line">    &#123;</div><div class="line">        $file = $this-&gt;file = $_FILES[$this-&gt;fileField];</div><div class="line">        if (!$file) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_FILE_NOT_FOUND&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if ($this-&gt;file[&apos;error&apos;]) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo($file[&apos;error&apos;]);</div><div class="line">            return;</div><div class="line">        &#125; else if (!file_exists($file[&apos;tmp_name&apos;])) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_TMP_FILE_NOT_FOUND&quot;);</div><div class="line">            return;</div><div class="line">        &#125; else if (!is_uploaded_file($file[&apos;tmp_name&apos;])) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_TMPFILE&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $this-&gt;oriName = $file[&apos;name&apos;];</div><div class="line">        $this-&gt;fileSize = $file[&apos;size&apos;];</div><div class="line">        $this-&gt;fileType = $this-&gt;getFileExt();</div><div class="line">//        $this-&gt;fullName = $this-&gt;getFullName();</div><div class="line">        $this-&gt;filePath = $this-&gt;getFilePath();</div><div class="line">        $this-&gt;fileName = $this-&gt;getFileName();</div><div class="line">        $dirname = dirname($this-&gt;filePath);</div><div class="line"></div><div class="line">        //检查文件大小是否超出限制</div><div class="line">        if (!$this-&gt;checkSize()) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_SIZE_EXCEED&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //检查是否不允许的文件格式</div><div class="line">        if (!$this-&gt;checkType()) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_TYPE_NOT_ALLOWED&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // //创建目录失败</div><div class="line">        // if (!file_exists($dirname) &amp;&amp; !mkdir($dirname, 0777, true)) &#123;</div><div class="line">        //     $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_CREATE_DIR&quot;);</div><div class="line">        //     return;</div><div class="line">        // &#125; else if (!is_writeable($dirname)) &#123;</div><div class="line">        //     $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_DIR_NOT_WRITEABLE&quot;);</div><div class="line">        //     return;</div><div class="line">        // &#125;</div><div class="line">        //</div><div class="line">        // //移动文件</div><div class="line">        // if (!(move_uploaded_file($file[&quot;tmp_name&quot;], $this-&gt;filePath) &amp;&amp; file_exists($this-&gt;filePath))) &#123; //移动失败</div><div class="line">        //     $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_FILE_MOVE&quot;);</div><div class="line">        // &#125; else &#123; //移动成功</div><div class="line">        //     $this-&gt;stateInfo = $this-&gt;stateMap[0];</div><div class="line">        // &#125;</div><div class="line">        //        include_once(&apos;../../../app/Services/oss.php&apos;);</div><div class="line">        //        \App\Services\OSS::upload($osspath, $serverpath);</div><div class="line">        include_once(&quot;oss.php&quot;);</div><div class="line">        //取得临时地址</div><div class="line">        $serverpath = $file[&quot;tmp_name&quot;];</div><div class="line">        //获得文件类型</div><div class="line">        $titles = $this-&gt;fileType;</div><div class="line">        //拼接文件名</div><div class="line">        $key = time() . rand(10000, 99999999) .$titles;</div><div class="line">        //上传文件夹路径</div><div class="line">        $osspath = &quot;news/content/&quot; . $key;</div><div class="line">        //上传结果</div><div class="line">        $result = OSS::upload($osspath, $serverpath);</div><div class="line">        //拼接url</div><div class="line">        $this-&gt;fullName = &apos;http://yourself-bucket-name.oss-cn-beijing.aliyuncs.com/&apos;.$osspath;</div><div class="line">        //判断结果，给定返回值。</div><div class="line">        if ($result) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;stateMap[0];</div><div class="line">            &#125; else &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_FILE_MOVE&quot;);</div><div class="line">        &#125;</div><div class="line">//上传后，删除临时文件</div><div class="line">       /* @unlink($file[&quot;tmp_name&quot;]);*/</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>此处要注意修改并维持页面回调当前上传文件的各项信息getFileInfo()方法内的参数。</p><h3 id="3-添加oss-php"><a href="#3-添加oss-php" class="headerlink" title="3.添加oss.php"></a>3.添加oss.php</h3><p>在php的目录下新建oss.php文件，给ueditor添加阿里云oss的支持。  </p><pre><code>&lt;?php/*  time: 2016-12-30  author: 马闯  blog: martist.cn*/require_once(&apos;../../../vendor/autoload.php&apos;);use JohnLui\AliyunOSS\AliyunOSS;class OSS{    private $ossClient;    private static $bucketName;    public $ossServer = &apos;http://oss-cn-beijing.aliyuncs.com&apos;;                   // 外网    public $ossServerInternal = &apos;http://oss-cn-beijing-internal.aliyuncs.com&apos;;       // 内网    public $AccessKeyId = &apos;wwwwwwwwwwww&apos;;                      // key    public $AccessKeySecret = &apos;wwwwwwwwwwwww&apos;;          // secret    public $BucketName = &apos;bucket&apos;;                // bucket    public function __construct($isInternal = false)    {        $serverAddress = $isInternal ? $this -&gt; ossServerInternal : $this -&gt; ossServer;        $this-&gt;ossClient = AliyunOSS::boot(            $serverAddress,            $this -&gt; AccessKeyId,            $this -&gt; AccessKeySecret        );    }    public static function upload($ossKey, $filePath)    {        $oss = new OSS(false); // 上传文件使用内网，免流量费        $oss-&gt;ossClient-&gt;setBucket(&apos;weiyuyan&apos;);        $res = $oss-&gt;ossClient-&gt;uploadFile($ossKey, $filePath);        return $res;    }    /**     * 直接把变量内容上传到oss     * @param $osskey     * @param $content     */    public static function uploadContent($osskey, $content)    {        $oss = new OSS(false); // 上传文件使用内网，免流量费        $oss-&gt;ossClient-&gt;setBucket($this -&gt; BucketName);        $oss-&gt;ossClient-&gt;uploadContent($osskey, $content);    }    /**     * 删除存储在oss中的文件     *     * @param string $ossKey 存储的key（文件路径和文件名）     * @return     */    public static function deleteObject($ossKey)    {        $oss = new OSS(false); // 上传文件使用内网，免流量费        return $oss-&gt;ossClient-&gt;deleteObject($this -&gt; BucketName, $ossKey);    }    /**     * 复制存储在阿里云OSS中的Object     *     * @param string $sourceBuckt 复制的源Bucket     * @param string $sourceKey - 复制的的源Object的Key     * @param string $destBucket - 复制的目的Bucket     * @param string $destKey - 复制的目的Object的Key     * @return Models\CopyObjectResult     */    public function copyObject($sourceBuckt, $sourceKey, $destBucket, $destKey)    {        $oss = new OSS(true); // 上传文件使用内网，免流量费        return $oss-&gt;ossClient-&gt;copyObject($sourceBuckt, $sourceKey, $destBucket, $destKey);    }    /**     * 移动存储在阿里云OSS中的Object     *     * @param string $sourceBuckt 复制的源Bucket     * @param string $sourceKey - 复制的的源Object的Key     * @param string $destBucket - 复制的目的Bucket     * @param string $destKey - 复制的目的Object的Key     * @return Models\CopyObjectResult     */    public function moveObject($sourceBuckt, $sourceKey, $destBucket, $destKey)    {        $oss = new OSS(true); // 上传文件使用内网，免流量费        return $oss-&gt;ossClient-&gt;moveObject($sourceBuckt, $sourceKey, $destBucket, $destKey);    }    public static function getUrl($ossKey)    {        $oss = new OSS();        $oss-&gt;ossClient-&gt;setBucket($this -&gt; BucketName);        return $oss-&gt;ossClient-&gt;getUrl($ossKey, new \DateTime(&quot;+1 day&quot;));    }    public static function createBucket($bucketName)    {        $oss = new OSS();        return $oss-&gt;ossClient-&gt;createBucket($bucketName);    }    public static function getAllObjectKey($bucketName)    {        $oss = new OSS();        return $oss-&gt;ossClient-&gt;getAllObjectKey($bucketName);    }    /**     * 获取指定Object的元信息     *     * @param  string $bucketName 源Bucket名称     * @param  string $key 存储的key（文件路径和文件名）     * @return object 元信息     */    public static function getObjectMeta($bucketName, $osskey)    {        $oss = new OSS();        return $oss-&gt;ossClient-&gt;getObjectMeta($bucketName, $osskey);    }}</code></pre><p>ok ! 这样便实现了在ueditor中集成阿里云oss文件上传的功能。<br><strong>Thanks</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>创业圈，什么事天派和地派</title>
    <link href="http://martist.cn/2016/08/01/%E5%88%9B%E4%B8%9A%E5%9C%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%A4%A9%E6%B4%BE%E2%80%9D%E2%80%9C%E5%9C%B0%E6%B4%BE%E2%80%9D%EF%BC%9F/"/>
    <id>http://martist.cn/2016/08/01/创业圈，什么是“天派”“地派”？/</id>
    <published>2016-07-31T16:00:00.000Z</published>
    <updated>2017-10-02T04:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="天派"><a href="#天派" class="headerlink" title="天派"></a>天派</h2><p>就是基本是融资能力大于赚钱能力，但他知道用户很重要，商业模式很重要，要快速发展，所以要快速的，不赚钱也可以上市，不赚钱也能成功，只要用户多，所以互联网的这种思维，我们叫“天派”，叫天马行空一样。  </p><h2 id="地派"><a href="#地派" class="headerlink" title="地派"></a>地派</h2><p>的传统企业我们认为他们脚踏实地，能够让企业持久、稳健增长，但是爆发力不够。  </p><p>“天派”是爆发力很够，但是他的这种稳健性不够。后来我就慢慢的把这个黑马营的两种人总结为“天派”和“地派”，我们后来开玩笑说黑马营就是天地汇，汇是汇合的汇。希望互联网思维和传统企业的产业理解能够融合在一起，他们同学之间互相取长补短、互相学习。   </p><p>最后我发现到一期毕业的时候他们彼此之间互相学习很多，融合很好，到现在我们就发现都分不清楚哪是纯粹的“天派”，哪是纯粹的“地派”了。比如戴赛鹰理论上讲他是“地派”，但是他的三个爸爸是融资最成功的一家公司，而且他的发展最快，他完全用互联网的方式做了一个智能硬件的公司，三个爸爸的净化器。然后现在又做了一个儿童的机器人，他的速度在一年多时间融资很快，你感觉戴赛鹰不再是一个卖东西的人，是一个会做用户的人。我们另外几个“天派”的高大上的，他们都高大上，但是他们企业发展都很稳健，都没有说下一步财融不到就会有问题，他们的这个经营思路我觉得更像今天中国这几种特色。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="entrepreneurship" scheme="http://martist.cn/categories/entrepreneurship/"/>
    
    
      <category term="entrepreneurship" scheme="http://martist.cn/tags/entrepreneurship/"/>
    
  </entry>
  
  <entry>
    <title>同步与异步，阻塞和非阻塞</title>
    <link href="http://martist.cn/2016/07/24/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://martist.cn/2016/07/24/同步与异步，阻塞与非阻塞/</id>
    <published>2016-07-24T01:28:51.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="老张喝茶-教你同步异步-阻塞与非阻塞"><a href="#老张喝茶-教你同步异步-阻塞与非阻塞" class="headerlink" title="老张喝茶 教你同步异步 阻塞与非阻塞"></a>老张喝茶 教你同步异步 阻塞与非阻塞</h1><p>老张爱喝茶，废话不说，煮开水。</p><p>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p><h4 id="1-老张把水壶放到火上，立等水开。（同步阻塞）"><a href="#1-老张把水壶放到火上，立等水开。（同步阻塞）" class="headerlink" title="1 老张把水壶放到火上，立等水开。（同步阻塞）"></a>1 老张把水壶放到火上，立等水开。（同步阻塞）</h4><p>老张觉得自己有点傻</p><h4 id="2-老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）"><a href="#2-老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）" class="headerlink" title="2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）"></a>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</h4><p>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀 ~ ~ ~ ~ 的噪音。</p><h4 id="3-老张把响水壶放到火上，立等水开。（异步阻塞）"><a href="#3-老张把响水壶放到火上，立等水开。（异步阻塞）" class="headerlink" title="3 老张把响水壶放到火上，立等水开。（异步阻塞）"></a>3 老张把响水壶放到火上，立等水开。（异步阻塞）</h4><p>老张觉得这样傻等意义不大</p><h4 id="4-老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）"><a href="#4-老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）" class="headerlink" title="4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）"></a>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</h4><p>老张觉得自己<strong> 聪明 </strong>了。  </p><p>所谓同步异步，只是对于水壶而言。</p><p>普通水壶，同步；响水壶，异步。</p><p>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。</p><p>同步只能让调用者去轮询自己，造成老张效率的低下。   </p><p>所谓阻塞非阻塞，仅仅对于老张而言。         </p><p><table></table></p><p><tr><td>情景</td><td>状态</td></tr></p><p><tr><td>立等的老张</td><td>阻塞</td></tr></p><p><tr><td>看电视的老张</td><td>非阻塞</td></tr><br><br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。<br>程序员写程序，很多情况下，老张和水壶都要涉及，即调用者与被调用者。四种组合模式各有所长。</p><p>这个例子和银行排队有异曲同工之妙，可是我觉得这个会比较容易理解一些。</p><p>老张一次比一次聪明，我承认跟老张很像。刚开始的情况逻辑比较简单，但效率低下。随着慢慢的提高，效率也提高了。所以个人认为，程序的效率和简单程度是成反比的。</p><p>但不是说异步非阻塞就一定是最好的，有的情况下更适合使用同步或者阻塞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
</feed>
