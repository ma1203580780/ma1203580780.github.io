<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARTIST</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://martist.cn/"/>
  <updated>2018-03-13T07:59:01.274Z</updated>
  <id>http://martist.cn/</id>
  
  <author>
    <name>martist.cn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于php的单例模式</title>
    <link href="http://martist.cn/2018/03/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://martist.cn/2018/03/12/单例模式的理解/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-13T07:59:01.274Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><blockquote><p>单例模式(Singleton Pattern)：顾名思义，就是只有一个实例。作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p></blockquote><h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><p>1、PHP语言本身的局限性<br>PHP语言是一种解释型的脚本语言，这种运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收。也就是说，PHP在语言级别上没有办法让某个对象常驻内存，这和asp.NET、Java等编译型是不同的，比如在Java中单例会一直存在于整个应用程序的生命周期里，变量是跨页面级的，真正可以做到这个实例在应用程序生命周期中的唯一性。然而在PHP中，所有的变量无论是全局变量还是类的静态成员，都是页面级的，每次页面被执行时，都会重新建立新的对象，都会在页面执行完毕后被清空，这样似乎PHP单例模式就没有什么意义了，所以PHP单例模式我觉得只是针对单次页面级请求时出现多个应用场景并需要共享同一对象资源时是非常有意义的。</p><p>2、应用场景<br>一个应用中会存在大量的数据库操作，比如过数据库句柄来连接数据库这一行为，使用单例模式可以避免大量的new操作，因为每一次new操作都会消耗内存资源和系统资源。<br>如果系统中需要有一个类来全局控制某些配置信息,那么使用单例模式可以很方便的实现.</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>一个类只能有一个对象</li><li>必须是自行创建这个类的对象</li><li>要想整个系统提供这一个对象</li></ol><h2 id="具体实现的重点"><a href="#具体实现的重点" class="headerlink" title="具体实现的重点"></a>具体实现的重点</h2><ol><li>单例模式的类只提供私有的构造函数，</li><li>类定义中含有一个该类的静态私有对象，</li><li>该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>class Singleton{        //存放实例        private static $_instance = null;        //私有化构造方法、        private function __construct(){            echo &quot;单例模式的实例被构造了&quot;;        }        //私有化克隆方法        private function __clone(){        }        //公有化获取实例方法        public static function getInstance(){            if (!(self::$_instance instanceof Singleton)){                self::$_instance = new Singleton();            }            return self::$_instance;        }    }    $singleton=Singleton::getInstance();</code></pre><h2 id="OOP知识补习"><a href="#OOP知识补习" class="headerlink" title="OOP知识补习"></a>OOP知识补习</h2><h3 id="类型运算符instanceof"><a href="#类型运算符instanceof" class="headerlink" title="类型运算符instanceof"></a>类型运算符instanceof</h3><pre><code>&lt;?phpclass MyClass{}class NotMyClass{}$a = new MyClass;var_dump($a instanceof MyClass);var_dump($a instanceof NotMyClass);?&gt;</code></pre><p>以上例程会输出：</p><pre><code>bool(true)bool(false)</code></pre><p>instanceof用于确定一个变量是不是实现了某个类，继承类，接口的对象的实例。<br>如果被检测的变量不是对象，instanceof 并不发出任何错误信息而是返回 FALSE。不允许用来检测常量。</p><h3 id="魔术方法-construct"><a href="#魔术方法-construct" class="headerlink" title="魔术方法__construct()"></a>魔术方法__construct()</h3><p>构造方法声明为private，防止直接创建对象 ，这样new Singleton() 会报错。</p><p>  private function __construct()<br>  {<br>      echo ‘Iam constructed’;<br>  }</p><h3 id="魔术方法-clone"><a href="#魔术方法-clone" class="headerlink" title="魔术方法__clone()"></a>魔术方法__clone()</h3><p>当类的复制完成时，如果定义了<strong>clone()方法，则新创建的对象（复制生成的对象）中的</strong>clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。私有化<strong>clone可以防止克隆该类的对象。<br>注意一点：clone的对象不执行</strong>construct里的方法</p><p>所以我们在防止单例模式的 $singleton对象被clone，有两种方法可以做到。</p><p>第一种方法:设置魔术方法<strong>clone();访问权限为private<br>第二种方法:若</strong>clone()为公用方法，则在函数中加上自定义错误。</p><pre><code>// 阻止用户复制对象实例public function __clone(){    trigger_error(&apos;Clone is not allowed.&apos;,E_USER_ERROR);}</code></pre><blockquote><p>关于 <strong>clone() , PHP官方的文档： Once the cloing is complete, if a </strong>clone() method is defined, then the newly created object’s __clone() method will be called, to allow any necessary properties that need to be changed.</p></blockquote><h3 id="关键字clone和赋值"><a href="#关键字clone和赋值" class="headerlink" title="关键字clone和赋值"></a>关键字clone和赋值</h3><pre><code>class foo {    public $bar = &apos;php&apos;;}$foo = new foo();$a = $foo; // 标识符赋值(把$a赋值为null,原来的$foo并不会变成null,但通过$a能够修改$foo的成员$bar)$a = &amp;$foo; // 引用赋值(把$a赋值为null,原来的$foo也会跟着变成null)$a = clone $foo; // 值赋值(赋值后互不影响，在计算机内存上的体现属于浅复制)</code></pre><h3 id="对象复制"><a href="#对象复制" class="headerlink" title="对象复制"></a>对象复制</h3><p>在PHP中， 对象间的赋值操作实际上是引用操作 （事实上，绝大部分的编程语言都是如此! 主要原因是内存及性能的问题) ， 比如 :</p><pre><code>class myclass {public $data;}$obj1 = new myclass();$obj1-&gt;data = &quot;aaa&quot;；$obj2 = $obj1;$obj2-&gt;data =&quot;bbb&quot;;     //$obj1-&gt;data的值也会变成&quot;bbb&quot;</code></pre><p>因为$obj1和$obj2都是指向同一个内存区的引用，所以修改任何一个对象都会同时修改另外一个对象。</p><p>在有些时候，我们其实不希望这种reference式的赋值方式， 我们希望能完全复制一个对象，这是侯就需要用到 Php中的clone (对象复制）。</p><pre><code>class myclass {public $data;}$obj1 = new myclass();$obj1-&gt;data =&quot;aaa&quot;;$obj2 = clone $obj1;$obj2-&gt;data =&quot;bbb&quot;;     // $obj1-&gt;data的值仍然为&quot;aaa&quot;</code></pre><p>因为clone的方式实际上是对整个对象的内存区域进行了一次复制并用新的对象变量指向新的内存， 因此赋值后的对象和源对象相互之间是基本来说独立的。</p><h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p>什么？ 基本独立？！这是什么意思？ 因为PHP的object clone采用的是浅复制(shallow copy)的方法, 如果对象里的属性成员本身就是reference类型的，clone以后这些成员并没有被真正复制，仍然是引用的。 （事实上，其他大部分语言也是这样实现的， 如果你对C++的内存，拷贝，copy constructor等概念比较熟悉，就很容易理解这个概念）, 下面是一个例子来说明：</p><pre><code>class myClass{public $data;}$sss =&quot;aaa&quot;;$obj1 = new myClass();$obj1-&gt;data =&amp;$sss;   //注意，这里是个reference!$obj2 = clone $obj1;$obj2-&gt;data=&quot;bbb&quot;;  //这时，$obj1-&gt;data的值变成了&quot;bbb&quot; 而不是&quot;aaa&quot;!var_dump($obj1);var_dump($obj2);</code></pre><p>我们再举一个更实用的例子来说明一下PHP clone这种浅复制带来的后果：</p><pre><code>class testClass{   public $str_data;   public $obj_data;}$dateTimeObj = new DateTime(&quot;2014-07-05&quot;, new DateTimeZone(&quot;UTC&quot;));$obj1 = new testClass();$obj1-&gt;str_data =&quot;aaa&quot;;$obj1-&gt;obj_data = $dateTimeObj;$obj2 = clone $obj1;var_dump($obj1);    // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;var_dump($obj2);    // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;$obj2-&gt;str_data =&quot;bbb&quot;;$obj2-&gt;obj_data-&gt;add(new DateInterval(&apos;P10D&apos;));      //给$obj2-&gt;obj_date 的时间增加了10天var_dump($obj1);     // str_data：&quot;aaa&quot;   obj_data：&quot;2014-07-15 00:00:00&quot;  !!!!var_dump($obj2);     // str_data：&quot;bbb&quot;   obj_data：&quot;2014-07-15 00:00:00&quot;var_dump($dateTimeObj)  // 2014-07-15 00:00:00&quot;</code></pre><p>这一下可以更加清楚的看到问题了吧。 一般来讲，你用clone来复制对象，希望是把两个对象彻底分开，不希望他们之间有任何关联， 但由于clone的shallow copy的特性， 有时候会出现非你期望的结果.</p><h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>1) $obj1-&gt;obj_data =$dateTimeObj 这句话实际上是个引用类型的赋值. 还记得前面提到的PHP中对象直接的赋值是引用操作么？除非你用$obj1-&gt;obj_dat = clone $dataTimeObj!</p><p>2) $obj2 = clone $obj1 这句话生成了一个obj1对象的浅复制对象，并赋给obj2. 由于是浅复制，obj2中的obj_data也是对$dateTimeObj的引用！</p><p>3）$dateTimeObj, $obj1-&gt;obj_data, $obj2-&gt;obj_data 实际上是同一个内存区对象数据的引用，因此修改其中任何一个都会影响其他两个！</p><p>如何解决这个问题呢？ 采用PHP中的 __clone方法 把浅复制转换为深复制（这个方法给C++中的copy constructor概念上有些相似，但执行流程并不一样）</p><pre><code>class testClass{ public $str_data; public $obj_data; public function __clone() {   $this-&gt;obj_data = clone $this-&gt;obj_data;}$dateTimeObj = new DateTime(&quot;2014-07-05&quot;, new DateTimeZone(&quot;UTC&quot;));$obj1 = new testClass();$obj1-&gt;str_data =&quot;aaa&quot;;$obj1-&gt;obj_data = $dateTimeObj;$obj2 = clone $obj1;var_dump($obj1);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;var_dump($obj2);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;$obj2-&gt;str_data =&quot;bbb&quot;;$obj2-&gt;obj_data-&gt;add(new DateInterval(&apos;P10D&apos;));var_dump($obj1);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;var_dump($obj2);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-15 00:00:00&quot;var_dump($dateTimeObj);  //&quot;2014-07-05 00:00:00&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>PHPstorm快捷键 for Mac</title>
    <link href="http://martist.cn/2018/02/11/PHPstorm%E5%BF%AB%E6%8D%B7%E9%94%AE%20for%20Mac/"/>
    <id>http://martist.cn/2018/02/11/PHPstorm快捷键 for Mac/</id>
    <published>2018-02-11T07:30:16.000Z</published>
    <updated>2018-02-11T07:14:40.093Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>对应键</p><pre><code>⌘——Command⌃ ——Control⌥——Option/Alt⇧——Shift⇪——Caps Lockfn——功能键就是fn</code></pre><p>编辑</p><pre><code>Command+alt+T 用 (if..else, try..catch, for, etc.)包住Command+/ 注释/取消注释的行注释Command+alt+/ 注释/取消注释与块注释alt+↑ 向上选取代码块alt+↓ 向下选取代码块Command+alt+L 格式化代码tab,shift+tab 调整缩进Control+alt+I 快速调整缩进Command+C 复制Command+X 剪切Command+V 粘贴Command+shift+V 从剪贴板里选择粘贴Command+D 复制代码副本Command+delete 删除当前行Control+Shift+J 清除缩进变成单行shift+回车 快速换行Command+回车 换行光标还在原先位置Command+shift+U 大小写转换Command+shift+[,Command+shift+] 文件选项卡快速切换Command+加号,Command+减号 收缩代码块Command+shift+加号，Command+shift+减号 收缩整个文档的代码块Command+W 关闭当前文件选项卡alt+单击 光标在多处定位Control+shift+J 把下面行的缩进收上来shift + F6 高级修改，可快速修改光标所在的标签、变量、函数等alt+/ 代码补全</code></pre><p>调试</p><pre><code>Control+alt+R 运行项目Command+Control+R 运行DebugCommand+F8 添加断点Command+shift+F8 打开断点列表</code></pre><p>导航</p><pre><code>Command+O 跳转到某个类Command+shift+O 跳转到某个文件Command+alt+O 跳转到某个符号Control+←,Control+→ 转到上/下一个编辑器选项卡F12 打开之前打开的工具窗口（TODO、终端等）Command+L 跳转行Command+E 弹出最近文件Command+alt+←,Command+alt+→ 向前向后导航到代码块交接处（一般是空行处）Command+shift+delete 导航到上一个编辑位置的位置Command+B 跳转到变量声明处Control+J 获取变量相关信息（类型、注释等，注释是拿上一行的注释）Command+Y 小浮窗显示变量声明时的行Command+[,Command+] 光标现在的位置和之前的位置切换Command+F12 文件结构弹出式菜单alt+H 类的层次结构F2,shift+F2 切换到上\下一个突出错误的位置Command+↑ 跳转到导航栏F3 添加书签alt+F3 添加带助记的书签alt+1,alt+2… 切换到相应助记的书签位置Command+F3 打开书签列表VCS/本地历史记录control+V 打开VST小浮窗Command+K 提交项目Command+T 更新项目alt+shift+C 打开最近修改列表</code></pre><p>搜索和替换</p><pre><code>Command+F 搜索Command+R 替换Command+G 查找下一个Command+shift+G 查找下一个Command+shift+F 按路径搜索Command+shift+R 按路径替换</code></pre><p>选中文字的搜索</p><pre><code>Command+F7 向声明的地方搜索并选中Command+shift+F7 打开搜索框进行搜索Command+alt+F7 打开小浮窗显示搜索列表</code></pre><p>对项目文件的操作（重构）</p><pre><code>F5 复制文件到某个目录F6 移动文件到某个目录Command+delete 安全删除shift+F6 重命名</code></pre><p>全局的</p><pre><code>双击shift 弹出小浮窗搜索所有Command+~切换项目 Command+shift+~ 反向切换项目 (在打开的不同项目中切换)Command+shift+A 整个工程的查找操作Command+1,Command+2… 打开各种工具窗口alt+shift+F 把文件添加到收藏夹alt+shift+I 打开项目描述alt+~ 快速切换当前计划Command+, 设置编辑器Control+Tab 选项卡和工具窗口之间进行切换alert+回车 显示npm版本升级列表</code></pre>]]></content>
    
    <summary type="html">
    
      生产力提升
    
    </summary>
    
      <category term="常识" scheme="http://martist.cn/categories/%E5%B8%B8%E8%AF%86/"/>
    
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux管理之进程管理</title>
    <link href="http://martist.cn/2018/01/01/linux%E7%AE%A1%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://martist.cn/2018/01/01/linux管理之进程管理/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-01-02T08:22:16.860Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="linux服务器治理之进程管理-进程优先级"><a href="#linux服务器治理之进程管理-进程优先级" class="headerlink" title="linux服务器治理之进程管理[进程优先级]"></a>linux服务器治理之进程管理[进程优先级]</h1><p>Linux系统是一个多用户，多任务的操作系统，linux中同时运行这非常多的进程，但是cpu同一个时钟周期，只能运算一个指令。进程优先级决定了每个进程处理的先后顺序。</p><h2 id="如何查看进程优先级"><a href="#如何查看进程优先级" class="headerlink" title="如何查看进程优先级"></a>如何查看进程优先级</h2><p>ps -le 命令打印系统进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">machuangdeMacBook-Pro:~ machuang$ ps -le</div><div class="line">  UID   PID  PPID        F CPU PRI NI       SZ    RSS WCHAN     S             ADDR TTY           TIME CMD</div><div class="line">    0     1     0     4004   0  37  0  4375272  15616 -      Ss                  0 ??         0:08.51 /sbin/launchd</div><div class="line">    0    50     1     4004   0   4  0  4351128   1640 -      Ss                  0 ??         0:00.50 /usr/sbin/syslog</div><div class="line">    0    51     1     4004   0  37  0  4383328  16944 -      Ss                  0 ??         0:00.69 /usr/libexec/Use</div><div class="line">    0    54     1     4004   0  20  0  4341096   8404 -      Ss                  0 ??         0:00.06 /System/Library/</div><div class="line">    0    55     1     4004   0  37  0  4387652  21496 -      Ss                  0 ??         0:02.84 /usr/libexec/kex</div><div class="line">    0    56     1  1004004   0  50  0  4357408  10660 -      Ss                  0 ??         0:00.91 /System/Library/</div><div class="line">    0    58     1     4004   0   4  0  4376372  18332 -      Ss                  0 ??         0:00.11 /System/Library/</div><div class="line">    0    59     1     4004   0  20  0  4448588  12940 -      Ss                  0 ??         0:00.14 /usr/local/opt/p</div><div class="line">   55    61     1     4004   0   4  0  4379836  10364 -      Ss                  0 ??         0:00.31 /System/Library/</div><div class="line">    0    62     1     4004   0   4  0  4381992  14872 -      Ss                  0 ??         0:00.37 /usr/sbin/system</div><div class="line">    0    64     1     400c   0  37  0  4382632  12472 -      Ss                  0 ??         0:00.96 /usr/libexec/con</div><div class="line">    0    65     1     4004   0  37  0  4376736  10276 -      Ss                  0 ??         0:00.88 /System/Library/</div><div class="line">    0    66     1     4004   0  20  0  4330896   4128 -      Ss                  0 ??         0:00.02 nginx: master pr</div><div class="line">    0    70     1     4004   0  37  0  4429136  13136 -      Ss                  0 ??         0:01.04 /usr/libexec/log</div></pre></td></tr></table></figure><p>pri和ni都代表优先级，数字越小优先级越高。<br>pri :priority<br>Ni:nice</p><h2 id="修改NI值注意事项"><a href="#修改NI值注意事项" class="headerlink" title="修改NI值注意事项"></a>修改NI值注意事项</h2><ul><li>NI值的范围是-20到19；</li><li>普通用户调整NI范围是0到19，而且只能调整自己的进程；</li><li>普通用户只能调高NI值，而不能降低。则原本NI值等于0，则只能调整为大于0；</li><li>root用户才能设定进程NI为负值，而且可以调整所有用户的进程。</li><li>PRI（最终值） = PRI（原始值）+NI</li><li>用户只能修改该NI的值，不能直接修改PRI</li></ul><h2 id="nice命令"><a href="#nice命令" class="headerlink" title="nice命令"></a>nice命令</h2><p>Nice可以给新执行的命令直接赋予NI值，但是不能修改已存在进程的NI值<br>nice -n NI值 命令，例如：</p><pre><code>nice -n -5 service httpd start</code></pre><h2 id="renice命令"><a href="#renice命令" class="headerlink" title="renice命令"></a>renice命令</h2><p>renice命令修改已经存在进程的NI值,renice [优先级] PID<br>例如：<br>renice -10 2125</p><p>更多请关注我的看云：<a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      linux
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="进程" scheme="http://martist.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux之进程</title>
    <link href="http://martist.cn/2017/12/31/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A10/"/>
    <id>http://martist.cn/2017/12/31/定时任务0/</id>
    <published>2017-12-30T16:00:00.000Z</published>
    <updated>2018-01-02T09:24:09.453Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><p>程序是为了完成某种任务而设计的软件，比如OpenOffice是程序。什么是进程呢？进程就是运行中的程序。</p><p>一个运行着的程序，可能有多个进程。 比如apache服务器，许多用户同时请求httpd服务，apache服务器将会创建有多个httpd进程来对其进行服务。</p><h3 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h3><p>进程一般分为交互进程、批处理进程和守护进程三类。</p><p>值得一提的是守护进程总是活跃的，一般是后台运行，守护进程一般是由系统在开机时通过脚本自动激活启动或超级管理用户root来启动。比如在Fedora或Redhat中，我们可以定义httpd 服务器的启动脚本的运行级别，此文件位于/etc/init.d目录下，文件名是httpd，/etc/init.d/httpd 就是httpd服务器的守护程序，当把它的运行级别设置为3和5时，当系统启动时，它会跟着启动。</p><pre><code>[root@localhost ~]# chkconfig  --level 35  httpd on</code></pre><p>由于守护进程是一直运行着的，所以它所处的状态是等待请求处理任务。比如，我们是不是访问服务器，http才运行，而是httpd服务器都在运行，等待着用户来访问，也就是等待着任务处理。</p><h3 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h3><p>进程ID（PID)：是唯一的数值，用来区分进程；<br>父进程和父进程的ID（PPID)；<br>启动进程的用户ID（UID）和所归属的组（GID）；<br>进程状态：状态分为运行R、休眠S、僵尸Z；<br>进程执行的优先级；<br>进程所连接的终端名；<br>进程资源占用：比如占用资源大小（内存、CPU占用量）；</p><h3 id="父进程和子进程"><a href="#父进程和子进程" class="headerlink" title="父进程和子进程"></a>父进程和子进程</h3><p>他们的关系是管理和被管理的关系，当父进程终止时，子进程也随之而终止。但子进程终止，父进程并不一定终止。比如httpd服务器运行时，我们可以杀掉其子进程，父进程并不会因为子进程的终止而终止。</p><p>在进程管理中，当我们发现占用资源过多，或无法控制的进程时，应该杀死它，以保护系统的稳定安全运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="http://martist.cn/2017/12/30/xml/"/>
    <id>http://martist.cn/2017/12/30/xml/</id>
    <published>2017-12-29T16:00:00.000Z</published>
    <updated>2018-02-11T08:18:10.512Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面是 John 写给 George 的便签，存储为 XML：</p><pre><code>&lt;note&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;</code></pre><h2 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML"></a>什么是 XML</h2><pre><code>XML 指可扩展标记语言（EXtensible Markup Language）XML 是一种标记语言，很类似 HTMLXML 的设计宗旨是传输数据，而非显示数据XML 标签没有被预定义。您需要自行定义标签。XML 被设计为具有自我描述性。XML 是 W3C 的推荐标准</code></pre><h3 id="对-XML-最好的描述"><a href="#对-XML-最好的描述" class="headerlink" title="对 XML 最好的描述"></a>对 XML 最好的描述</h3><p>XML 是独立于软件和硬件的信息传输工具。</p><h2 id="XML-与-HTML-的主要差异"><a href="#XML-与-HTML-的主要差异" class="headerlink" title="XML 与 HTML 的主要差异"></a>XML 与 HTML 的主要差异</h2><pre><code>XML 不是 HTML 的替代。XML 和 HTML 为不同的目的而设计：XML 被设计为传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息，而 XML 旨在传输信息。</code></pre><h2 id="一句话概括xml和html的区别"><a href="#一句话概括xml和html的区别" class="headerlink" title="一句话概括xml和html的区别"></a>一句话概括xml和html的区别</h2><pre><code>XML 被设计用来传输和存储数据。HTML 被设计用来显示数据。</code></pre><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol><li>没有任何行为的 XML，XML 是不作为的。</li><li>XML 仅仅是纯文本</li><li>可以发明自己的标签</li><li>XML 不是对 HTML 的替代，XML 是对 HTML 的补充。<br>XML 不会替代 HTML，理解这一点很重要。<br>在大多数 web 应用程序中，XML 用于传输数据，而 HTML 用于格式化并显示数据。</li></ol><h1 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h1><p>XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。<br>XML 文档必须包含根元素。该元素是所有其他元素的父元素。</p><p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p><p>所有元素均可拥有子元素：</p><pre><code>&lt;root&gt;  &lt;child&gt;    &lt;subchild&gt;.....&lt;/subchild&gt;  &lt;/child&gt;&lt;/root&gt;</code></pre><p>父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ol><li>所有 XML 元素都须有关闭标签</li><li>XML 标签对大小写敏感</li><li>XML 必须正确地嵌套</li><li>XML 文档必须有根元素</li><li>XML 的属性值须加引号</li><li><p>实体引用</p><p> &lt;     &lt;     小于<br> &gt;     &gt;     大于<br> &amp;     &amp;     和号<br> &apos;     ‘     单引号<br> &quot;     “     引号</p></li><li><p>编写注释的语法与 HTML 的语法很相似</p> <!-- This is a comment --></li><li><p>空格会被保留</p></li><li>XML 以 LF 存储换行</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>gitlab</title>
    <link href="http://martist.cn/2017/12/27/gitlab%E6%90%AD%E5%BB%BA/"/>
    <id>http://martist.cn/2017/12/27/gitlab搭建/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-01-05T10:28:50.027Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="GitLab-简介"><a href="#GitLab-简介" class="headerlink" title="GitLab 简介"></a>GitLab 简介</h2><p>GitLab 是利用 Ruby On Rails 一个开源的版本管理系统，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与 GitHub 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序( Wall )进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。</p><p>GitHub 它是一个开源的社区, 如果你想把你们公司的项目放在上面就得交钱, 如果不交钱就得开源, 而 GitLab 是一个本地的项目管理仓库, 既然是本地那么想怎么玩就怎么玩儿。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>社区版基于 MIT License 开源完全免费</li><li>无用户，协作和仓库限制</li><li>保护项目源码安全</li><li>管理仓库，用户与访问权限</li></ul><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><pre><code>官网 : https://about.gitlab.com/features/国内镜像 : https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-安装和配置必要的依赖"><a href="#1-安装和配置必要的依赖" class="headerlink" title="1). 安装和配置必要的依赖"></a>1). 安装和配置必要的依赖</h3><p>如果你安装 PostFix 发送邮件，如果你不需要邮件发送,可以跳过直接看第二步,请选择 网站设置 中。而不是使用后缀也可以使用道具或配置自定义 SMTP 服务器和它配置为 SMTP 服务器。在 CentOS 的 6 和 7，下面的命令将在系统防火墙打开 HTTP 和 SSH 访问。</p><p>  sudo apt-get install curl openssh-server ca-certificates postfix  </p><h3 id="2-切换清华大学镜像"><a href="#2-切换清华大学镜像" class="headerlink" title="2). 切换清华大学镜像"></a>2). 切换清华大学镜像</h3><p>首先信任 GitLab 的 GPG 公钥</p><p>  curl <a href="https://packages.gitlab.com/gpg.key" target="_blank" rel="external">https://packages.gitlab.com/gpg.key</a> 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null  </p><p>再选择你的 Debian/Ubuntu 版本，文本框中内容写进 /etc/apt/sources.list.d/gitlab-ce.list ubuntu14.04 如下 其他版本请跳转 国内镜像 查看 /etc/apt/sources.list.d/gitlab-ce.list 这个文件默认不存在 你需要创建并添加下面配置 vim /etc/apt/sources.list.d/gitlab-ce.list 把下面内容添加进去</p><p>  deb <a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu</a> trusty main  </p><p>添加完成后更新源, 并且安装 GitLab</p><p>  sudo apt-get update<br>  sudo apt-get install gitlab-ce  </p><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3). 配置"></a>3). 配置</h3><p>配置文件</p><p>  /etc/gitlab/gitlab.rb</p><p>修改域名</p><p>  vim /etc/gitlab/gitlab.rb 文件<br>  // 找到这一行, 填写你的域名<br>  external_url ‘你的域名’  </p><p>配置通知邮箱  </p><p>  vim /etc/gitlab/gitlab.rb</p><p>  #Sending application email via SMTP<br>  gitlab_rails[‘smtp_enable’] = true<br>  gitlab_rails[‘smtp_address’] = “smtp.163.com”<br>  gitlab_rails[‘smtp_port’] = 25<br>  gitlab_rails[‘smtp_user_name’] = “xxuser@163.com”<br>  gitlab_rails[‘smtp_password’] = “xxpassword”<br>  gitlab_rails[‘smtp_domain’] = “163.com”<br>  gitlab_rails[‘smtp_authentication’] = :login<br>  gitlab_rails[‘smtp_enable_starttls_auto’] = true</p><p>修改gitlab配置的发信人</p><p>  gitlab_rails[‘gitlab_email_from’] = “xxuser@163.com”<br>  user[“git_user_email”] = “xxuser@163.com”</p><p>如果执行不成功, 请检查配置和内存, 并且执行 gitlab-ctl reconfigure 重新编译启动</p><h3 id="4-网页配置"><a href="#4-网页配置" class="headerlink" title="4). 网页配置"></a>4). 网页配置</h3><p>apt-get 安装默认继承了 Nginx 如果你需要服务器在跑其他环境, 你需要修改你的 GitLab Nginx 的端口, 基础配置不需要改配置文件网站上就能直接修改</p><h3 id="5-查看更多命令"><a href="#5-查看更多命令" class="headerlink" title="5).查看更多命令"></a>5).查看更多命令</h3><p>  gitlab-ctl help</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>文档地址 : http://docs.gitlab.com/omnibus/转载请注明出处 : https://laravel-china.org/topics/2568友情链接 : http://blog.rooyun.com/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="git" scheme="http://martist.cn/categories/git/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="git" scheme="http://martist.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>githook实践</title>
    <link href="http://martist.cn/2017/12/21/webhook/"/>
    <id>http://martist.cn/2017/12/21/webhook/</id>
    <published>2017-12-20T16:00:00.000Z</published>
    <updated>2017-12-21T03:26:04.809Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h3><p>GitLab 是基于 GIT 实现的现代化的开发者协作平台，它将 issues, code review, CI 和 CD 整合到独立的网站UI，弥补了 GIT 在可视化操作方面的不足。</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>分别部署你的项目和gitlab。</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>分别解析你的gitlab和被hook触发的项目。</p><h3 id="服务端执行脚本（php，shell）"><a href="#服务端执行脚本（php，shell）" class="headerlink" title="服务端执行脚本（php，shell）"></a>服务端执行脚本（php，shell）</h3><p>php脚本用来接受githook的请求，shell脚本用来执行git pull等命令。</p><h2 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h2><p>本文的目的是配置实现在 GitLab 平台上的代码自动部署。想要达到的效果是这样子的，当客户端向 GitLab 服务器的特定分支（如：master）提交代码时，GitLab 服务器会发送通知给线上代码服务器，代码服务器收到通知之后再拉取 GitLab 服务器上该分支的最新代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">客户端 --&gt; git push                                                                              </div><div class="line">                   -                                                                                  </div><div class="line">                     -                                                                                  </div><div class="line">                        -                                                                                </div><div class="line">                          -&gt;                                                                         </div><div class="line">                               -----------------   -- http通知 --&gt;     -----------------                         </div><div class="line">客户端  --&gt; git push      ---&gt;  |  gitlab服务器  | -                 -  |   代码服务器    |</div><div class="line">                               -----------------   &lt;- git pull --     -----------------                         </div><div class="line">                          -&gt;                                                                         </div><div class="line">                        -                                                                                      </div><div class="line">                      -</div><div class="line">                   -</div><div class="line">客户端 --&gt; git push</div></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在项目的setting里面设置webhook，点击webhook链接可以查看具体的使用方法。设置的域名是公网域名，gitlab管理的指定项目被push后会立即请求设定的网址，触发服务器的钩子，之后 git pull。</p><h2 id="php脚本"><a href="#php脚本" class="headerlink" title="php脚本"></a>php脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">$access_token = &apos;your-gitlab-webhook-token&apos;;</div><div class="line">$access_ip = [&apos;123.4.5.6&apos;];</div><div class="line"></div><div class="line">/* get user token and ip address */</div><div class="line">$client_token = $_SERVER[&apos;HTTP_X_GITLAB_TOKEN&apos;];</div><div class="line">$client_ip = $_SERVER[&apos;REMOTE_ADDR&apos;];</div><div class="line"></div><div class="line">/* create open log */</div><div class="line">$fs = fopen(&apos;./gitlab/webhook.log&apos;, &apos;a&apos;);</div><div class="line">fwrite($fs, &apos;Request on [&apos;.date(&quot;Y-m-d H:i:s&quot;).&apos;] from [&apos;.$client_ip.&apos;]&apos;.PHP_EOL);</div><div class="line"></div><div class="line">/* test token */</div><div class="line">if ($client_token !== $access_token)</div><div class="line">&#123;</div><div class="line">    echo &quot;error 403&quot;;</div><div class="line">    fwrite($fs, &quot;Invalid token [&#123;$client_token&#125;]&quot;.PHP_EOL);</div><div class="line">    exit(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* test ip */</div><div class="line">if ( ! in_array($client_ip, $access_ip))</div><div class="line">&#123;</div><div class="line">    echo &quot;error 503&quot;;</div><div class="line">    fwrite($fs, &quot;Invalid ip [&#123;$client_ip&#125;]&quot;.PHP_EOL);</div><div class="line">    exit(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* get json data */</div><div class="line">$json = file_get_contents(&apos;php://input&apos;);</div><div class="line">$data = json_decode($json, true);</div><div class="line"></div><div class="line">/* get branch */</div><div class="line">$branch = $data[&quot;ref&quot;];</div><div class="line">//fwrite($fs, &apos;=======================================================================&apos;.PHP_EOL);</div><div class="line"></div><div class="line">/* if you need get full json input */</div><div class="line">//fwrite($fs, &apos;DATA: &apos;.print_r($data, true).PHP_EOL);</div><div class="line"></div><div class="line">/* branch filter */</div><div class="line">if ($branch === &apos;refs/heads/master&apos;))</div><div class="line">&#123;</div><div class="line">    fwrite($fs, &apos;BRANCH: &apos;.print_r($branch, true).PHP_EOL);</div><div class="line">    exec(&quot;/var/www/api/public/gitlab/deploy.sh&quot;);</div><div class="line">    fwrite($fs, &apos;=================项目已更新==================&apos;.PHP_EOL);</div><div class="line">    $fs and fclose($fs);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &apos;-------begin-----&apos;&gt;&gt; /var/www/your-project-path/gitlab/webhook.log</div><div class="line">cd /var/www/your-project-path</div><div class="line">git checkout test</div><div class="line">git pull origin master &gt;&gt; /var/www/your-project-path/gitlab/webhook.log</div><div class="line">echo &apos;-------end-------&apos;&gt;&gt; /var/www/your-project-path/gitlab/webhook.log</div></pre></td></tr></table></figure><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>如果你的gitlab请求报绿色200，而且shell脚本可以执行到，但就是git执行不了，那就是权限出问题了。</p><h3 id="配置服务器git的用户和邮箱需要和gitlab的一致"><a href="#配置服务器git的用户和邮箱需要和gitlab的一致" class="headerlink" title="配置服务器git的用户和邮箱需要和gitlab的一致"></a>配置服务器git的用户和邮箱需要和gitlab的一致</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo -Hu www git config --global credential.helper store # 永久保存</div><div class="line">sudo -Hu www git config --global user.name &quot;Bantes&quot;</div><div class="line">sudo -Hu www git config --global user.email &quot;admin@xsooo.com&quot; # 邮箱请与conding上一致</div></pre></td></tr></table></figure><h3 id="查看nginx或者apache的执行用户"><a href="#查看nginx或者apache的执行用户" class="headerlink" title="查看nginx或者apache的执行用户"></a>查看nginx或者apache的执行用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo ps aux | grep php</div><div class="line">www      22131  0.0  0.2  42872 23096 ?        S    02:13   0:03 nginx: worker process</div><div class="line">www      22132  0.0  0.2  42900 23352 ?        S    02:13   0:01 nginx: worker process</div><div class="line"></div><div class="line">$sudo ps aux | grep php-fpm</div><div class="line">www      22347  0.0  0.1 163832  9008 ?        S    02:13   0:00 php-fpm: pool www</div></pre></td></tr></table></figure><p>确认是www用户在运行，也即是说gitlab中的Webhooks的所有请求都是以www用户在执行。再次查看我们的hook for php脚本。</p><p>此请求默认以www 用户去访问gitlab.php，然后执行master_deploy.sh脚本。因此，需要给www用户设置 Public Key Authentication</p><h3 id="建立用户目录"><a href="#建立用户目录" class="headerlink" title="建立用户目录"></a>建立用户目录</h3><p>sudo mkdir /home/www</p><h3 id="部署公钥"><a href="#部署公钥" class="headerlink" title="部署公钥"></a>部署公钥</h3><p>sudo -Hu www ssh-keygen -t rsa # 请选择 “no passphrase”，一直回车下去</p><h3 id="将此公钥加入gitlab中的SSH-KEYS中"><a href="#将此公钥加入gitlab中的SSH-KEYS中" class="headerlink" title="将此公钥加入gitlab中的SSH KEYS中"></a>将此公钥加入gitlab中的SSH KEYS中</h3><p>cat /home/www/.ssh/id_rsa.pub</p><h3 id="设置项目的文件夹用户与用户组为www"><a href="#设置项目的文件夹用户与用户组为www" class="headerlink" title="设置项目的文件夹用户与用户组为www"></a>设置项目的文件夹用户与用户组为www</h3><p>$ sudo chown -R www:www /mnt/www/project</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>tail命令输出日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail -f 5 webhook.log</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      linux
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="gitlab" scheme="http://martist.cn/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Mac 升级你的开发环境</title>
    <link href="http://martist.cn/2017/11/27/Mac%20%E5%8D%87%E7%BA%A7%E4%BD%A0%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://martist.cn/2017/11/27/Mac 升级你的开发环境/</id>
    <published>2017-11-27T13:30:50.000Z</published>
    <updated>2017-11-27T14:54:51.905Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>Mac系统自带php开发环境，但是版本低，Apache较为落伍，所以我们要紧跟潮流，走在技术的最前线。</p><h2 id="本地原环境"><a href="#本地原环境" class="headerlink" title="本地原环境"></a>本地原环境</h2><p>Apache2.4；PHP5.6</p><h2 id="1-安装Nginx"><a href="#1-安装Nginx" class="headerlink" title="1. 安装Nginx"></a>1. 安装Nginx</h2><pre><code>brew install nginx</code></pre><p>现象：一直显示updating homebrew，没有任何反应，我就给终止掉，再次执行brew install nginx，这次安装成功。</p><h3 id="1-1-安装成功"><a href="#1-1-安装成功" class="headerlink" title="1.1 安装成功"></a>1.1 安装成功</h3><p>新目录：/usr/local/etc/nginx<br>主要文件：nginx.conf<br>主要目录：servers(配置虚拟主机时使用)</p><h3 id="1-2-启动"><a href="#1-2-启动" class="headerlink" title="1.2 启动"></a>1.2 启动</h3><p>由于本地Apache一直在运行，所以先关闭Apache的运行：</p><pre><code>ps aux | grep apachekill -9 apached的PIDsudo nginx -s reload</code></pre><h3 id="1-3-配置server"><a href="#1-3-配置server" class="headerlink" title="1.3 配置server"></a>1.3 配置server</h3><p>cd servers,在此目录下创建xxx.conf文件</p><pre><code>server {      listen 80;      server_name phpadmin.com; // 配置本地域名      root /Users/xxx/xxx/phpmyadmin; // 本地项目路径      index index.php;      location / {              try_files $uri $uri/ /index.php?$args;      }      location ~ \.php$ {              fastcgi_split_path_info ^(.+\.php)(/.+)$;//如果是php文件，就让php-fpm去工作              # With php-fpm:              fastcgi_pass unix:/var/run/php71-fpm.sock;  //也可以写成127.0.0.1:9000，如果想使用sock需要 vi php71/php-fpm.d/www.conf 修改listen的设置              fastcgi_index index.php;                      fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;              include fastcgi_params;      }      access_log /var/log/nginx/xxx.log zqaccess; // zqaccess命名需要与上级目录  nginx.conf 中的log_format命名保持一致      error_log /var/log/nginx/xxx.err.log;  }</code></pre><h2 id="2-升级PHP到7-1和安装7-1的php-fpm"><a href="#2-升级PHP到7-1和安装7-1的php-fpm" class="headerlink" title="2. 升级PHP到7.1和安装7.1的php-fpm"></a>2. 升级PHP到7.1和安装7.1的php-fpm</h2><pre><code>brew install --without-apache --with-fpm --with-mssql php71</code></pre><p>如果你只是想升级php到7.1，而且还想用Apache，这里需要执行brew install –with-http22 或者 –with-http24 –with-mssql php71,这个要根据你Apache的版本了，具体你可以执行brew options php71命令进行查看。如果没有写–with-http24,安装后是不会有libexec/apache2/libphp7.so的。</p><h3 id="2-1-安装成功"><a href="#2-1-安装成功" class="headerlink" title="2.1 安装成功"></a>2.1 安装成功</h3><p>新目录：</p><pre><code>/usr/local/etc/php/7.1 配置php-fpm/usr/local/opt/php71/sbin目录下启动php-fpm：sudo ./php71-fpm restart</code></pre><p>启动php71-fpm如果失败，需要将原来的php-fpm给杀掉，mac原本有低版本的php-fpm。</p><h2 id="3-细节（用户权限问题）"><a href="#3-细节（用户权限问题）" class="headerlink" title="3. 细节（用户权限问题）"></a>3. 细节（用户权限问题）</h2><h3 id="3-1-验证Nginx是否生效"><a href="#3-1-验证Nginx是否生效" class="headerlink" title="3.1 验证Nginx是否生效"></a>3.1 验证Nginx是否生效</h3><p>配置好虚拟主机后，在指定目录下，创建一个html文件，如果浏览器能正常显示这个文件，则说明nginx生效。</p><h3 id="3-2-验证php能否正常运行"><a href="#3-2-验证php能否正常运行" class="headerlink" title="3.2 验证php能否正常运行"></a>3.2 验证php能否正常运行</h3><p>nginx server配置的是php71-fpm.sock，遇到了502错误，查看日志提示，用户权限不足。<br>nginx server配置修改成127.0.0.1:9000，www.conf的listen也修改成127.0.0.1:9000是可以正常执行php的。<br>解决502</p><pre><code>ll 查看生成的php71-fpm.sock文件，所属用户不是_www，vi /usr/local/etc/nginx/nginx.conf 文件，修改user为_wwwvi /usr/local/etc/php/7.1/php-fpm.d/www.conf，修改user = _wwwgroup = _www listen.owner = _www listen.group = _www</code></pre><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><p>有很多方法，此处我推荐使用brew安装。</p><pre><code>brew install php71-redis</code></pre><p>一切就搞好了，可以命令查看下。</p><pre><code>php -m |grep redis</code></pre><h2 id="配置laravel项目"><a href="#配置laravel项目" class="headerlink" title="配置laravel项目"></a>配置laravel项目</h2><p>nginx server{} 需要加的代码:</p><pre><code>location / {try_files $uri $uri/ /index.php?$query_string;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="Mac" scheme="http://martist.cn/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://martist.cn/tags/Mac/"/>
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack学习笔记</title>
    <link href="http://martist.cn/2017/11/13/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://martist.cn/2017/11/13/OpenStack学习笔记/</id>
    <published>2017-11-12T16:00:00.000Z</published>
    <updated>2017-11-17T04:56:34.268Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h3 id="什么是openstack？"><a href="#什么是openstack？" class="headerlink" title="什么是openstack？"></a>什么是openstack？</h3><p>它是Rackspace和NASA共同发起的开源项目，本身是一系列开源软件项目的组合，它的功能是基础设施资源的系统管理平台。它可以有效的管理cpu，硬盘等资源。</p><h3 id="OpenStack-可以干嘛？"><a href="#OpenStack-可以干嘛？" class="headerlink" title="OpenStack 可以干嘛？"></a>OpenStack 可以干嘛？</h3><p>它就是一个IaaS的云平台软件。实际应用场景非常多，凡是IaaS可以应用的地方Openstack都可以做到。比如虚拟主机，出售计算资源，公司内部IT云计算解决方案等等。</p><h3 id="OpenStack的镜像一般用哪个？"><a href="#OpenStack的镜像一般用哪个？" class="headerlink" title="OpenStack的镜像一般用哪个？"></a>OpenStack的镜像一般用哪个？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CirrOS</div><div class="line">http://download.cirros-cloud.net/</div><div class="line">user:cirros     password:cubswin:)</div><div class="line">glance image-create --name cirros --disk-format qcow2 --container-format bare &lt; cirros-0.3.4-x86_64-disk.img</div></pre></td></tr></table></figure><p>测试 OpenStack 服务是否完好一般都用 CIRROS，体积小巧，只有 10M，上面是我做的笔记，最后一个是 GLANCE 的上传命令。</p><h3 id="OpenStack-是用什么语言开发的？"><a href="#OpenStack-是用什么语言开发的？" class="headerlink" title="OpenStack 是用什么语言开发的？"></a>OpenStack 是用什么语言开发的？</h3><p>一般就是 Python  、Java，你要知道 OpenStack是一个软件包，它整合了其他的开源软件，所以还有其他语言。</p><h1 id="主要功能组件"><a href="#主要功能组件" class="headerlink" title="主要功能组件"></a>主要功能组件</h1><p>Horizon：UI模块</p><p>keystone： 身份服务模块</p><p>service：即 服务，如Nova，Swift等， 需要在keystone注册</p><p>endpoint：可以理解为一个服务暴露出来的访问点</p><p>identify： 服务验证身份凭证</p><p>token：访问资源的令牌。</p><p>Catalog：提供可供与断电发现的服务注册表。</p><p>policy：暴露了一个基于规则的身份验证引擎</p><h1 id="易购环境集成"><a href="#易购环境集成" class="headerlink" title="易购环境集成"></a>易购环境集成</h1><p>不同的组件集成到keystone中</p><h1 id="open-stack组件介绍"><a href="#open-stack组件介绍" class="headerlink" title="open-stack组件介绍"></a>open-stack组件介绍</h1><h2 id="nova组件"><a href="#nova组件" class="headerlink" title="nova组件"></a>nova组件</h2><p>主要功能包括：<br>    实例生命周期管理<br>    计算资源管理<br>    向外提供rest风格api<br><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack1.png" alt=""></p><h2 id="Glance组件"><a href="#Glance组件" class="headerlink" title="Glance组件"></a>Glance组件</h2><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack2.png" alt=""></p><h2 id="swift组件"><a href="#swift组件" class="headerlink" title="swift组件"></a>swift组件</h2><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack3.png" alt=""></p><h2 id="cinder组件"><a href="#cinder组件" class="headerlink" title="cinder组件"></a>cinder组件</h2><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack4.png" alt=""></p><h2 id="neutron组件"><a href="#neutron组件" class="headerlink" title="neutron组件"></a>neutron组件</h2><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack5.png" alt=""></p><h1 id="组件关系"><a href="#组件关系" class="headerlink" title="组件关系"></a>组件关系</h1><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack6.png" alt=""></p><h1 id="访问控制流程"><a href="#访问控制流程" class="headerlink" title="访问控制流程"></a>访问控制流程</h1><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack7.png" alt=""></p><p>参考文章：<a href="http://www.imooc.com/article/8989" target="_blank" rel="external">我的自学 OpenStack 云平台 之路（一）_慕课手记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://martist.cn/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="云服务，docker" scheme="http://martist.cn/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%EF%BC%8Cdocker/"/>
    
      <category term="OpenStack" scheme="http://martist.cn/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>清洗html标签和css样式</title>
    <link href="http://martist.cn/2017/11/12/html%E6%A0%87%E7%AD%BE%E5%8E%BB%E6%8E%89/"/>
    <id>http://martist.cn/2017/11/12/html标签去掉/</id>
    <published>2017-11-11T16:00:00.000Z</published>
    <updated>2017-11-17T04:09:55.432Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><pre><code>$content = preg_replace(&quot;/&lt;a[^&gt;]*&gt;/i&quot;, &quot;&quot;, $content);  $content = preg_replace(&quot;/&lt;\/a&gt;/i&quot;, &quot;&quot;, $content);   $content = preg_replace(&quot;/&lt;div[^&gt;]*&gt;/i&quot;, &quot;&quot;, $content);  $content = preg_replace(&quot;/&lt;\/div&gt;/i&quot;, &quot;&quot;, $content);      $content = preg_replace(&quot;/&lt;!--[^&gt;]*--&gt;/i&quot;, &quot;&quot;, $content);//注释内容  $content = preg_replace(&quot;/style=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式  $content = preg_replace(&quot;/class=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式  $content = preg_replace(&quot;/id=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式     $content = preg_replace(&quot;/lang=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式      $content = preg_replace(&quot;/width=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式   $content = preg_replace(&quot;/height=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式   $content = preg_replace(&quot;/border=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式   $content = preg_replace(&quot;/face=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式   $content = preg_replace(&quot;/face=.+?[&apos;|\&quot;]/&quot;,&apos;&apos;,$content);//去除样式 只允许小写 正则匹配没有</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>微信开发笔记</title>
    <link href="http://martist.cn/2017/11/10/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://martist.cn/2017/11/10/微信开发笔记/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2017-11-17T07:32:33.758Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="laravel-5-5-20框架"><a href="#laravel-5-5-20框架" class="headerlink" title="laravel 5.5.20框架"></a>laravel 5.5.20框架</h2><p>可以用artisan命令查看框架版本：</p><pre><code>php artisan -V</code></pre><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/wx1.png" alt=""></p><h2 id="composer组件easywechat"><a href="#composer组件easywechat" class="headerlink" title="composer组件easywechat"></a>composer组件easywechat</h2><p>此处要注意版本，我用的是3.0，组件版本不确定会坑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer require &quot;overtrue/laravel-wechat:~3.0&quot;</div></pre></td></tr></table></figure><p>在laravel中配置：</p><p>注册 ServiceProvider:</p><p>Overtrue\LaravelWechat\ServiceProvider::class,</p><pre><code>创建配置文件：</code></pre><p>php artisan vendor:publish –provider=”Overtrue\LaravelWechat\ServiceProvider”</p><pre><code>请修改应用根目录下的 config/wechat.php 中对应的项即可；（可选）添加外观到 config/app.php 中的 aliases 部分:</code></pre><p>‘EasyWeChat’ =&gt; Overtrue\LaravelWechat\Facade::class,</p><p>参考：<a href="https://github.com/overtrue/laravel-wechat/tree/3.1.10" target="_blank" rel="external">GitHub - overtrue/laravel-wechat at 3.1.10</a> 配置OAuth 中间件部分。</p><h2 id="vagrant-homestead运行环境"><a href="#vagrant-homestead运行环境" class="headerlink" title="vagrant - homestead运行环境"></a>vagrant - homestead运行环境</h2><h3 id="Homestead-yaml文件部分配置"><a href="#Homestead-yaml文件部分配置" class="headerlink" title="Homestead.yaml文件部分配置"></a>Homestead.yaml文件部分配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ip: &quot;192.168.10.10&quot;</div><div class="line">memory: 2048</div><div class="line">cpus: 1</div><div class="line">provider: virtualbox</div><div class="line"></div><div class="line">authorize: ~/.ssh/id_rsa.pub</div><div class="line"></div><div class="line">keys:</div><div class="line">- ~/.ssh/id_rsa</div><div class="line"></div><div class="line">folders:</div><div class="line">- map: /Users/machuang/Code</div><div class="line">to: /home/vagrant/Code</div><div class="line"></div><div class="line">sites:</div><div class="line"># - map: homestead.app</div><div class="line">#   to: /home/vagrant/Code</div><div class="line"># - map: paper.app</div><div class="line">#   to: /home/vagrant/Code/paper/public</div><div class="line">- map: test.app</div><div class="line">to: /home/vagrant/Code/laravel/public</div></pre></td></tr></table></figure><h2 id="内网穿透工具-ngrok"><a href="#内网穿透工具-ngrok" class="headerlink" title="内网穿透工具-ngrok"></a>内网穿透工具-ngrok</h2><p>作为一个Web开发者，我们有时候会需要临时地将一个本地的Web网站部署到外网，以供他人体验评价或协助调试等等，通常我们会这么做：</p><pre><code>找到一台运行于外网的Web服务器服务器上有网站所需要的环境，否则自行搭建将网站部署到服务器上调试结束后，再将网站从服务器上删除</code></pre><p>只不过是想向朋友展示一下网站而已，要不要这么麻烦,使用ngrok，免费的服务就足够实现将一个本地的Web网站临时部署到外网了。</p><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/wx2.png" alt=""></p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://ngrok.com/" target="_blank" rel="external">ngrok</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p> <a href="https://tenten.co/blog/how-to-use-ngrok-to-connect-your-localhost/" target="_blank" rel="external">怎麼將內網的 localhost 讓外面的人都看得到呢？用用 ngrok 吧！ - Startup Incubator Asia</a></p><p>去官网下载下来，然后解压，当前目录的 ./ngrok文件就是启动文件了，</p><p>我在/etc/profile 写了下别名，来简化操作</p><pre><code>alias ngrok=&apos;/Users/machuang/Desktop/ngrok&apos;</code></pre><p>免费的注册，激活ngrok<br><a href="https://dashboard.ngrok.com/get-started" target="_blank" rel="external">ngrok - secure introspectable tunnels to localhost</a></p><p>根据官网页面给的命令去激活你的ngrok。</p><p>好，回到页面来启动它，映射到我的homestead虚拟机的ip和端口号。命令：</p><pre><code>ngrok http 192.168.10.10:80</code></pre><p>如果没有报错,说明运行正常,这个时候,终端会出现下面的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Session Status                online                                            </div><div class="line">Account                       马 闯  (Plan: Free)                               </div><div class="line">Version                       2.2.8                                             </div><div class="line">Region                        United States (us)                                </div><div class="line">Web Interface                 http://127.0.0.1:4040                             </div><div class="line">Forwarding                    http://c7971ad2.ngrok.io -&gt; 192.168.10.10:80      </div><div class="line">Forwarding                    https://c7971ad2.ngrok.io -&gt; 192.168.10.10:80     </div><div class="line">                                                                                </div><div class="line">Connections                   ttl     opn     rt1     rt5     p50     p90       </div><div class="line">                              138     0       0.00    0.00    3.47    66.13     </div><div class="line">                                                                                </div><div class="line">HTTP Requests                                                                   </div><div class="line">-------------                                                                   </div><div class="line">                                                                                </div><div class="line">GET  /userInfo                 200 OK                                           </div><div class="line">POST /wechat                   200 OK                                           </div><div class="line">POST /wechat                   200 OK</div></pre></td></tr></table></figure><p>3、 浏览器打开 Web入口<a href="http://127.0.0.1:4040" target="_blank" rel="external">http://127.0.0.1:4040</a>.  页面上面查看到当前访问的请求细节.</p><h2 id="微信公众平台测试账号申请"><a href="#微信公众平台测试账号申请" class="headerlink" title="微信公众平台测试账号申请"></a>微信公众平台测试账号申请</h2><p>微信公众平测试号申请地址：<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index" target="_blank" rel="external">微信公众平台</a></p><p>需要配置的地方</p><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/wx3.png" alt=""></p><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/wx4.png" alt=""></p><p>laravel以外的用法参考：</p><p><a href="http://www.thinkphp.cn/code/3553.html" target="_blank" rel="external">Thinkphp5和EasyWeChat进行网页授权登录 - ThinkPHP框架</a></p><h1 id="👌，开发"><a href="#👌，开发" class="headerlink" title="👌，开发"></a>👌，开发</h1><h2 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?php</div><div class="line"></div><div class="line">Route::any(&apos;/wechat&apos;, &apos;WeChatController@serve&apos;);</div><div class="line"></div><div class="line">Route::get(&apos;/users&apos;, &apos;WeChatController@users&apos;);</div><div class="line"></div><div class="line">Route::get(&apos;/menu&apos;, &apos;WeChatController@menu&apos;);</div><div class="line"></div><div class="line">Route::get(&apos;/addMenu&apos;, &apos;WeChatController@addMenu&apos;);</div></pre></td></tr></table></figure><h2 id="处理微信的请求消息"><a href="#处理微信的请求消息" class="headerlink" title="处理微信的请求消息"></a>处理微信的请求消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">/**</div><div class="line"> * User: maChuang</div><div class="line"> * blog: martist.cn</div><div class="line"> * Date: 2017/11/8</div><div class="line"> * Time: 下午5:42</div><div class="line"> */</div><div class="line"></div><div class="line">namespace App\Http\Controllers;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">use EasyWeChat\Foundation\Application;</div><div class="line"></div><div class="line">class WeChatController extends Controller</div><div class="line">&#123;</div><div class="line">    public $wechat;</div><div class="line"></div><div class="line">    public function __construct(Application $wechat)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;wechat = $wechat;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 处理微信的请求消息</div><div class="line">     *</div><div class="line">     * @return string</div><div class="line">     */</div><div class="line">    public function serve()</div><div class="line">    &#123;</div><div class="line">        $wechat = app(&apos;wechat&apos;);</div><div class="line">//        $wechat-&gt;server-&gt;setMessageHandler(function($message)&#123;</div><div class="line">//            return &quot;wocou!!!！&quot;;</div><div class="line">//        &#125;);</div><div class="line">        $userApi = $wechat-&gt;user;</div><div class="line">        $wechat-&gt;server-&gt;setMessageHandler(function ($message) use ($userApi) &#123;</div><div class="line">            switch ($message-&gt;MsgType) &#123;</div><div class="line">                case &apos;event&apos;:</div><div class="line">                    return &apos;收到事件消息&apos;;</div><div class="line">                    break;</div><div class="line">                case &apos;text&apos;:</div><div class="line">                    return $userApi-&gt;get($message-&gt;FromUserName)-&gt;headimgurl;</div><div class="line">                    break;</div><div class="line">                case &apos;image&apos;:</div><div class="line">                    return &apos;收到图片消息&apos;;</div><div class="line">                    break;</div><div class="line">                case &apos;voice&apos;:</div><div class="line">                    return &apos;收到语音消息&apos;;</div><div class="line">                    break;</div><div class="line">                case &apos;video&apos;:</div><div class="line">                    return &apos;收到视频消息&apos;;</div><div class="line">                    break;</div><div class="line">                case &apos;location&apos;:</div><div class="line">                    return &apos;收到坐标消息&apos;;</div><div class="line">                    break;</div><div class="line">                case &apos;link&apos;:</div><div class="line">                    return &apos;收到链接消息&apos;;</div><div class="line">                    break;</div><div class="line">                // ... 其它消息</div><div class="line">                default:</div><div class="line">                    return &apos;收到其它消息&apos;;</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        return $wechat-&gt;server-&gt;serve();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * User: maChuang</div><div class="line">     * @return \EasyWeChat\Support\Collection</div><div class="line">     * 当前公众号的关注者列表</div><div class="line">     */</div><div class="line">    public function users()</div><div class="line">    &#123;</div><div class="line">        return $this-&gt;wechat-&gt;user-&gt;lists();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * User: maChuang</div><div class="line">     * 展示菜单</div><div class="line">     */</div><div class="line">    public function menu()</div><div class="line">    &#123;</div><div class="line">        $app = $this-&gt;wechat;</div><div class="line">        $menu = $app-&gt;menu;</div><div class="line">        $menus = $menu-&gt;all();</div><div class="line">        dd($menus);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * User: maChuang</div><div class="line">     * @return \EasyWeChat\Support\Collection</div><div class="line">     * 添加菜单</div><div class="line">     */</div><div class="line">    public function addMenu()</div><div class="line">    &#123;</div><div class="line">        $app = $this-&gt;wechat;</div><div class="line">        $menu = $app-&gt;menu;</div><div class="line">        $buttons = [</div><div class="line">            [</div><div class="line">                &quot;type&quot; =&gt; &quot;view&quot;,</div><div class="line">                &quot;name&quot; =&gt; &quot;授权&quot;,</div><div class="line">                &quot;url&quot;  =&gt; &quot;http://c7971ad2.ngrok.io/scopes&quot;</div><div class="line">            ],</div><div class="line">            [</div><div class="line">                &quot;name&quot;       =&gt; &quot;二级菜单&quot;,</div><div class="line">                &quot;sub_button&quot; =&gt; [</div><div class="line">                    [</div><div class="line">                        &quot;type&quot; =&gt; &quot;view&quot;,</div><div class="line">                        &quot;name&quot; =&gt; &quot;我的信息&quot;,</div><div class="line">                        &quot;url&quot;  =&gt; &quot;http://c7971ad2.ngrok.io/userInfo&quot;,</div><div class="line">                    ],</div><div class="line">                    [</div><div class="line">                        &quot;type&quot; =&gt; &quot;view&quot;,</div><div class="line">                        &quot;name&quot; =&gt; &quot;大大大&quot;,</div><div class="line">                        &quot;url&quot;  =&gt; &quot;http://c7971ad2.ngrok.io/large&quot;,</div><div class="line">                    ],</div><div class="line">                    [</div><div class="line">                        &quot;type&quot; =&gt; &quot;click&quot;,</div><div class="line">                        &quot;name&quot; =&gt; &quot;小小小&quot;,</div><div class="line">                        &quot;key&quot; =&gt; &quot;ASDZFE&quot;</div><div class="line">                    ],</div><div class="line">                ],</div><div class="line">            ],</div><div class="line">        ];</div><div class="line">        $res = $menu-&gt;add($buttons);</div><div class="line">        return $res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此时，你可以在公众号发现添加自定义菜单，查看菜单，查看公众号关注者，回复信息等功能已经简单的实现了。</p><h2 id="获取用户的openid和微信信息"><a href="#获取用户的openid和微信信息" class="headerlink" title="获取用户的openid和微信信息"></a>获取用户的openid和微信信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Route::group([&apos;middleware&apos; =&gt; [&apos;wechat.oauth&apos;]], function () &#123;</div><div class="line"></div><div class="line">    Route::get(&apos;/userInfo&apos;, function () &#123;</div><div class="line">        $user = session(&apos;wechat.oauth_user&apos;); // 拿到授权用户资料</div><div class="line">        dd($user);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;subscribe&quot;: 1,</div><div class="line">    &quot;openid&quot;: &quot;oCf0jw4DhUXmv6ZhITtBRFn3yLM4&quot;,</div><div class="line">    &quot;nickname&quot;: &quot;🎗martist.cn马闯🎗&quot;,</div><div class="line">    &quot;sex&quot;: 1,</div><div class="line">    &quot;language&quot;: &quot;zh_CN&quot;,</div><div class="line">    &quot;city&quot;: &quot;石家庄&quot;,</div><div class="line">    &quot;province&quot;: &quot;河北&quot;,</div><div class="line">    &quot;country&quot;: &quot;中国&quot;,</div><div class="line">    &quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/9VvH5ZWanZUKiaGbMrMsWeyl1E4yFWJCic5iblA5FSyVcYSPjkUElLsHO697rFgv81DibzNjeVicpTUEruEg3Nbfn7YTDWoquz78f/0&quot;,</div><div class="line">    &quot;subscribe_time&quot;: 1510198660,</div><div class="line">    &quot;remark&quot;: &quot;&quot;,</div><div class="line">    &quot;groupid&quot;: 0,</div><div class="line">    &quot;tagid_list&quot;: []</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其他操作可以具体参见微信公众号官方文档，我在做微信开发和微信支付都是基于eastWeChat这个组件完成的，节省了很多时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>记一次部署node项目到centos服务器经历</title>
    <link href="http://martist.cn/2017/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%83%A8%E7%BD%B2node%E9%A1%B9%E7%9B%AE%E5%88%B0centos%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%8F%E5%8E%86/"/>
    <id>http://martist.cn/2017/11/07/记一次部署node项目到centos服务器经历/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2017-11-17T06:20:03.212Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="服务器安装运行环境"><a href="#服务器安装运行环境" class="headerlink" title="服务器安装运行环境"></a>服务器安装运行环境</h1><p>先从网上随便搜了个contos安装node的教程，大概就是这样。<br>准备命令：</p><pre><code>yum -y install gcc make gcc-c++ openssl-devel wget</code></pre><p>下载源码及解压：</p><pre><code>wget http://nodejs.org/dist/v0.10.26/node-v0.10.26.tar.gztar -zvxf node-v0.10.26.tar.gz</code></pre><p>编译及安装：</p><pre><code>cd node-v0.10.26make &amp;&amp; make install</code></pre><p>验证是否安装配置成功：</p><pre><code>node -v</code></pre><p>安装完了， 运行项目，报错，嗯？？原来开发版本是8.4.0，版本差距太大了，怎么办，删node重新安？我选择升级。</p><p>首先安装n模块：</p><pre><code>npm install -g n</code></pre><p>第二步：</p><p>升级node.js到最新稳定版</p><pre><code>n stable</code></pre><p>是不是很简单？！</p><p>此处无升级到了9.0.0，又超过开发版本，不过好在实际项目运行起来了，没问题，附可以指定版本的命令。</p><p>n后面也可以跟随版本号比如：</p><pre><code>n v0.10.26</code></pre><p>或</p><pre><code>n 0.10.26</code></pre><p>npm的常用命令</p><pre><code>npm -v          #显示版本，检查npm 是否正确安装。  npm install express   #安装express模块  npm install -g express  #全局安装express模块  npm list         #列出已安装模块  npm show express     #显示模块详情  npm update        #升级当前目录下的项目的所有模块  npm update express    #升级当前目录下的项目的指定模块  npm update -g express  #升级全局安装的express模块  npm uninstall express  #删除指定的模块</code></pre><h1 id="打包代码发到服务器"><a href="#打包代码发到服务器" class="headerlink" title="打包代码发到服务器"></a>打包代码发到服务器</h1><p>打包发送可以选择ftp工具，比如filezilla，比较好用，我是用的是命令行，scp传输命令。</p><pre><code>sudo scp -r -P port ./Desktop/musics/ root@1.1.1.1:/tmp</code></pre><p>把我桌面的music目录传输到了服务器的tmp目录下，打包之后更快一些。</p><h1 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h1><p>运行命令</p><pre><code>node index.js</code></pre><p>推荐使用forever工具。</p><pre><code>sudo npm install forever -g   #安装forever start app.js          #启动forever stop app.js           #关闭forever start -l forever.log -o out.log -e err.log app.js   #输出日志和错误</code></pre><p>命令语法及使用： <a href="https://github.com/nodejitsu/forever" target="_blank" rel="external">https://github.com/nodejitsu/forever</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="nodejs" scheme="http://martist.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>MAC OS查看端口占用情况及杀死进程</title>
    <link href="http://martist.cn/2017/11/02/MAC%20OS%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%E5%8F%8A%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B/"/>
    <id>http://martist.cn/2017/11/02/MAC OS查看端口占用情况及杀死进程/</id>
    <published>2017-11-02T07:30:16.000Z</published>
    <updated>2017-11-17T06:28:57.306Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h2><pre><code>sudo lsof -i :9000</code></pre><p>返回：</p><pre><code>COMMAND   PID    USER   FD      TYPE             DEVICE                      SIZE/OFF      NODE       NAMEjava              716      a           313u   IPv6               0x1111111111111     0t0                    TCP        *:cslistener (LISTEN)</code></pre><p>然后根据PID杀进程：</p><pre><code>sudo kill -9 716</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="Mac" scheme="http://martist.cn/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://martist.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>常见的企业管理系统软件</title>
    <link href="http://martist.cn/2017/10/19/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://martist.cn/2017/10/19/常见的企业管理软件系统/</id>
    <published>2017-10-18T16:00:00.000Z</published>
    <updated>2017-10-19T03:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><ul><li>ERP进销存管理系统</li><li>OA协同办公管理系统</li><li>CRM客户关系管理系统</li><li>HRM人力资源管理系统</li><li>EAM资产管理系统</li><li>绩效管理系统</li><li>成本管理系统</li><li>设备管理系统</li><li>质量管理系统</li></ul><h2 id="ERP进销存管理系统"><a href="#ERP进销存管理系统" class="headerlink" title="ERP进销存管理系统"></a>ERP进销存管理系统</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓ERP（Enterprise Resource Planning）企业资源规划，顾名思义，也就是将企业内部各个部门，包括财务、会计、生产、物料管理、品质管理、销售与分销、人力资源管理等，利用信息科技整合、连结在一起。    </p><p>传统上，企业的各个部门大都各自为政，使用不同的计算机系统，业务与生产部门互不相关，生产部门的人无法直接从计算机上直接查到订单的数量，更不用谈信息共享与整合。</p><h3 id="实际作用"><a href="#实际作用" class="headerlink" title="实际作用"></a>实际作用</h3><p>ERP所扮演的角色便是将各部门连贯起来，让所有信息在在线揭露，所有人只要有账号、密码，在一定权限范围内，便可轻易从计算机上得知各部门的相关数据，例如订单及出货的情形，避免资源与人事上不必要的浪费，经理人也可以从这些迅速而正确的数据中，做出最好的决策。政大信息管理系副教授季延平指出，由于信息的透明化、实时化，企业更有条件达到立即反应、整体规划的目标。</p><h3 id="最佳实务范例"><a href="#最佳实务范例" class="headerlink" title="最佳实务范例"></a>最佳实务范例</h3><p>除此之外，ERP软件的独特处在于提供最佳实务典范（Best Practice）。所谓最佳实务范例，是经由研究全世界知名厂商的企业流程所累积而成，所以ERP所提供给厂商的，是一套经过时间证明的标准作业流程。因此，很多企业拿它来做流程改造的凭借，其好处是不但可以节省企业自己做流程改造的时间，并能以创新的想法弥补传统产业的局限处。</p><p>对外而言，单打独斗的时代已经逐渐过去了，企业间的合作联盟逐渐成型。ERP可以使得企业内部的信息通行无阻，如果再加上供应链管理（Supply Chain Management），透过网络与系统的有效结合，可以使客户与厂商间形成水平或垂直整合，真正达到全球运筹管理的模式。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li><a href="https://gitee.com/crm8000/PSI" target="_blank" rel="external">PSI</a></li><li><a href="https://www.odoo.com/zh_CN/" target="_blank" rel="external">odoo</a></li></ol><h2 id="OA协同办公管理系统"><a href="#OA协同办公管理系统" class="headerlink" title="OA协同办公管理系统"></a>OA协同办公管理系统</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>办公自动化（Office Automation，简称OA）是将现代化办公和计算机技术结合起来的一种新型的办公方式。办公自动化没有统一的定义，凡是在传统的办公室中采用各种新技术、新机器、新设备从事办公业务，都属于办公自动化的领域。通过实现办公自动化，或者说实现数字化办公，可以优化现有的管理组织结构，调整管理体制，在提高效率的基础上，增加协同办公能力，强化决策的一致性 。</p><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>OA软件的核心应用是：流程审批、协同工作、公文管理(国企和政府机关)、沟通工具、文档管理、信息中心、电子论坛、计划管理、项目管理、任务管理、会议管理、关联人员、系统集成、门户定制、通讯录、工作便签、问卷调查、常用工具(计算器、万年历等)。<br>OA管理平台基于“框架+应用组件+功能定制平台”的架构模型，主体部分由30多个子系统组成，包括信息门户、协同工作、工作流程、表单中心、公文流转、公共信息、论坛管理、问卷调查、计划管理、会务管理、任务管理、关联项目、关联人员、文档管理、外部邮件、在线考试、车辆管理、物品管理、设备管理、常用工具、办理中心、在线消息、督办系统、短信平台、常用工具、人事管理、功能定制平台、集成平台、系统管理等，近万个功能点。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>OA强调办公的便捷方便，提高效率，作为办公软件就应具备几大特性：易用性、健壮性、开放性、严密性、实用性。</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p><a href="https://gitee.com/kalcaddle/KODExplorer" target="_blank" rel="external">可道云</a><br><a href="https://gitee.com/aagagagag/R3-Query" target="_blank" rel="external">R3 Query</a></p><h2 id="CRM客户关系管理系统"><a href="#CRM客户关系管理系统" class="headerlink" title="CRM客户关系管理系统"></a>CRM客户关系管理系统</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>CRM即客户关系管理，是指企业用CRM技术来管理与客户之间的关系。在不同场合下，CRM可能是一个管理学术语，可能是一个软件系统。通常所指的CRM，指用计算机自动化分析销售、市场营销、客户服务以及应用等流程的软件系统。它的目标是通过提高客户的价值、满意度、赢利性和忠实度来缩减销售周期和销售成本、增加收入、寻找扩展业务所需的新的市场和渠道。CRM是选择和管理有价值客户及其关系的一种商业策略，CRM要求以客户为中心的企业文化来支持有效的市场营销、销售与服务流程。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MBA、CEO必读12篇及EMBA等商管教育对CRM的定义是：企业利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，从而提升其管理方式，向客户提供创新式的个性化的客户交互和服务的过程。其最终目标是吸引新客户、保留旧客户以及将已有客户转为忠实客户。</p><p>开源项目可搜索<a href="https://gitee.com/explore/recommend" target="_blank" rel="external">码云</a></p><h2 id="OA、CRM、ERP之间的区别和联系"><a href="#OA、CRM、ERP之间的区别和联系" class="headerlink" title="OA、CRM、ERP之间的区别和联系"></a>OA、CRM、ERP之间的区别和联系</h2><p>简单地说OA 是负责组织行为管理的，相对柔性；CRM负责客户经营的；ERP更多的负责业务处理地，相对刚性。</p><p>（1）OA -Office Automation 办公自动化<br>多用在内部行政上的一些表单及流程的的电子化，如：请假单，派车单，公司通告，公司内部主页，投票等等功能。<br>（2）CRM-Customer Relationship Management 客户关系管理<br>多用在公司业务体系中，如：记录客户的联系方式，客户的需求，客户的交易记录，等等和客户相关的功能。<br>（3）ERP-enterpriseresourceplanning 企业资源计划<br>多用在公司整个管理的整合，如：销售管理，采购管理 ，仓库管理，生产管理，财务管理，计划管理等。<br>三个没有具体的联系，非要说有的话，可能是一些ERP会含有一定的OA或CRM的功能。</p><p>可以参考<a href="https://www.zhihu.com/question/20931870" target="_blank" rel="external">知乎问答</a></p><p>典型的OA：</p><pre><code>https://www.jiandaoyun.com/a/59018c38d147571e2d21f55chttps://www.jiandaoyun.com/a/59018adf5c185ab8645e0d53</code></pre><p>典型的CRM：</p><pre><code>https://www.jiandaoyun.com/a/59018b45d147571e2d21e44bhttps://www.jiandaoyun.com/a/59018b62375ddec3631d92c2</code></pre><p>典型的ERP：</p><pre><code>https://www.jiandaoyun.com/a/59014f4ca24a45575f1a564fhttps://www.jiandaoyun.com/a/59018b7f375ddec3631d94c0</code></pre><h2 id="原文地址-我的看云"><a href="#原文地址-我的看云" class="headerlink" title="原文地址 - 我的看云"></a>原文地址 - 我的看云</h2><p><a href="http://doc.martist.cn/427308" target="_blank" rel="external">http://doc.martist.cn/427308</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>林书豪</title>
    <link href="http://martist.cn/2017/10/18/%E6%9E%97%E4%B9%A6%E8%B1%AA/"/>
    <id>http://martist.cn/2017/10/18/林书豪/</id>
    <published>2017-10-17T16:00:00.000Z</published>
    <updated>2017-10-18T07:24:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="来自另一个弱势群体的抨击"><a href="#来自另一个弱势群体的抨击" class="headerlink" title="来自另一个弱势群体的抨击"></a>来自另一个弱势群体的抨击</h2><p>前NBA球员肯扬-马丁近日就林书豪的发型一事做出评论,林给予回应。</p><p>马丁在Instagram上说道：</p><blockquote><p>“这是我今天发的最后一条状态，我是否需要提醒一下这个男孩姓‘林’？拜托了，停止这些行为吧，就算你再怎么弄脏辫，也不是黑人的样子，我明白你想弄成黑人的样子，但是你姓林。”</p></blockquote><p>林书豪在这条状态底下很有礼貌地进行了回复，他说道：</p><blockquote><p>“嘿老哥，你不喜欢我的发型完全没有关系，你有权发表自己的观点，实际上，我很感激你说出了内心的想法。归根结底，我很欣赏自己的脏辫，我也很欣赏你的中文文身，因为我认为这是一种尊重的标志。我认为作为少数群体，我们越去欣赏彼此的文化，我们就越能够影响主流群体。感谢你为篮网和篮球所做的一切，小时候墙上曾贴着你的海报。”</p></blockquote><h2 id="种族歧视"><a href="#种族歧视" class="headerlink" title="种族歧视"></a>种族歧视</h2><p>自马丁路德金在万人演讲的历史时刻喊出：”我有一个梦想“，”黑人运动的斗争和抗议行为开始在西方世界如火如荼的展开了。黑人反抗来自白人的歧视和不公正待遇。<br>需要知道的是，华人在美国地位还不如黑人，更不用提以黑人球员为主的NBA。当某些黑人开始有意的排斥和歧视黄种人，从某种意义上，他们是种族主义的受害者的同时也是施暴者。<br>林书豪在NBA会受到不公正的待遇和轻视，这种情况并不少见，我们很多人从没在美国亲身感受这种感觉，林书豪就是一个替身，透过他的人生经历，我们可以了解真实存在的种族歧视。</p><h2 id="真硬汉or小混混"><a href="#真硬汉or小混混" class="headerlink" title="真硬汉or小混混"></a>真硬汉or小混混</h2><blockquote><p>“林没有拿马丁有中文纹身这事恶心马丁，他是拿它当论据，证明双方都尊重并欣赏对方的文化”–美国论坛网友评论</p></blockquote><p>林书豪在马丁对他的这盘评论后，回了一些和善的话。林的讲话旨在希望少数群体求同存异，团结一致。我们可以从这些话里面感受到林书豪的胸怀和领袖气质。没错，林现在就是篮网的领袖，而相反，马丁好像在装硬汉，觉得自己是混道上的。马丁身上都有中文纹身【患得患失】，然后他还觉得林书豪扎脏辫是为了成为黑人？？更糟糕的是，他那个中文纹身根本不是他想要的意思。他觉得那意味着永不满足。</p><p>一轮交锋下来，马丁输得一败涂地，而且林书豪保持了自己的风度。</p><h2 id="“林书豪是美国人不是中国人，为什么粉他-”。"><a href="#“林书豪是美国人不是中国人，为什么粉他-”。" class="headerlink" title="“林书豪是美国人不是中国人，为什么粉他?”。"></a>“林书豪是美国人不是中国人，为什么粉他?”。</h2><blockquote><p>在中国人们把林看做外国人，忽视他和我们的血脉关联。殊不知，美国的白人黑人也没把他这个华人当地道的美国人，而是与亚洲人同类。林书豪是在美国的华人华侨心目中不折不扣的华人之光。</p></blockquote><p>拜托，这些球迷喜欢的乔丹、科比、麦迪、詹姆斯他们难道是中国人么？<br>时下库里在中国的人气可谓如日中天，克莱，詹姆斯等球星中国行无不粉丝簇拥；2008北京奥运会当镜头扫到科比，整个体育场的气氛瞬间燃烧，但他们和中国国籍沾边么。<br>林书豪祖籍是浙江省嘉兴市平湖，祖辈移居台湾彰化，父母70年代移民到美国。毕业于哈佛大学，主修经济学，副修社会学。<br>林的大学生涯是毕业，而非肄业。这区别于大多数nba球员，也许你会想到蒂姆邓肯也有大学学业【心理学学士】，你会感觉到有完整大学经历的球员，情商智商不会低。<br>林这种高情商且不卑不亢的言行举止会吸粉，你不觉得么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="生活" scheme="http://martist.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>laravel核心概念</title>
    <link href="http://martist.cn/2017/09/27/laravel%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://martist.cn/2017/09/27/laravel核心概念/</id>
    <published>2017-09-26T16:00:00.000Z</published>
    <updated>2017-10-03T05:33:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>本文是基于laravel 5.1项目源码解析的。</p><h1 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h1><p>route.php文件中，</p><pre><code>Class Foo{}//如果没有这个class会报错。Route::get(&apos;/&apos;,function(Foo $foo){  dd($foo);});</code></pre><p>Foo $foo 是依赖注入的写法，</p><p>laravel框架利用反射机制，尝试解释语义Foo $foo，<br>在laravel内核执行实例化</p><pre><code>$foo = new Foo();</code></pre><p>当laravel尝试new依赖的这个类，找不到的话就会报错找不到这个类。</p><p>当laravel找到的依赖的类。这个类本身依赖注入的类不明确时。<br>会爆其他错误：不能解析。</p><p>另一种方式</p><p>当使用App:bind这个方法时，laravel会优先通过这里加载这个类<br>而不是 反射机制 根据命名空间或者require路径去寻找。</p><pre><code>App::bind(&apos;Foo&apos;,function(){    dd(&apos;called here&apos;);    return new Foo();})</code></pre><hr><h1 id="service-provider"><a href="#service-provider" class="headerlink" title="service provider"></a>service provider</h1><p>service provider 的类中，有意义的是register（）方法，</p><p>在index.php里面有$app这个变量，这是框架的核心。</p><pre><code>$this-&gt;app-&gt;sigleton(&apos;files&apos;,functionZ(){    return new Filesystem;})</code></pre><p>在这里的‘files’我们可以看做键名，指向Filesystem这个类的实例化。<br>这样我们可以在路由中试用下看看。</p><pre><code>Route::get(&apos;/&apos;,function(Foo $foo){  $content = app(&apos;files&apos;)-&gt;get(__DIR__.&apos;/kernel.php&apos;);  dd($content);});//打印出来这个文件的内容</code></pre><p>使用service provider中注册并提供一个简明的键名去申明这个类，<br>可以节约代码，易于管理。</p><h1 id="在Ioc容器中添加自己的类"><a href="#在Ioc容器中添加自己的类" class="headerlink" title="在Ioc容器中添加自己的类"></a>在Ioc容器中添加自己的类</h1><p>比如说项目中需要收费的功能，</p><p>app目录下新建目录billing，生成类文件</p><pre><code>Class stripe{  public function pay(){        dd(&apos;I pay&apos;);    }}</code></pre><p>artisan命令：<br>php artisan  make:provider BillingServicePovider</p><p>在 app/Providers目录下生成BillingServicePovider.php文件，<br>里面有意义的就是register（），我们在这里面注册stripe类。</p><pre><code>public function register(){  $this-&gt;app-&gt;bind(&apos;billing&apos;,fintion(){    return new Stripe();    });}</code></pre><p>再把它放到IOC容器中，config/app.php中添加。</p><p>此时，app(‘billing’)就可以相当于new Stripe()了。</p><p>app(‘billing’)-&gt;pay();//输出 I pay</p><h1 id="Facade-门面-运行机制"><a href="#Facade-门面-运行机制" class="headerlink" title="Facade(门面)运行机制"></a>Facade(门面)运行机制</h1><p>config/app.php下  alias数组，</p><p>用IDE的查找类的功能点进去，比如点route,Mail<br>进去一个类是继承的Facade，</p><p>里面有 getFacadeAccessor()函数返回一个字符串，//return ‘mailer’;<br>这个字符串对应MailserviceProvider.php中register()的字符串。</p><p>Facade类里面有__callStatic(),里面有</p><pre><code>$instance = static::getFacadeRoot();//IOC容器生成$instance，可以使用真正类中的方法//看下面pubilic static function getFacadeRoot(){  return static::resolveFacadeInstance(static::getFacadeAccessor());//app(&apos;mailer&apos;);}</code></pre><p>流程：</p><p>app.php下的别名数组的值指向一个类，这个类通过返回给Facade一个字符串实现app（‘name’）,<br>然后通过serviceProvider去注册返回实例化之后的类。</p><hr><h1 id="contract-契约"><a href="#contract-契约" class="headerlink" title="contract (契约)"></a>contract (契约)</h1><p>在项目目录framework/src/Illuminate/Contracts下面定义了很多interface。</p><p>面向接口编程。在依赖注入中很大好处。该目录下的类都是接口类。</p><p>比如：Config真正是新的类，在Illuminate\Contracts\Config\Repository，</p><p>app()方法:</p><pre><code>dd(app(&apos;Illuminate\Contracts\Config\Repository&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysqldd(Config::get());//可以看到laravel的配置dd(app(&apos;config&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysql</code></pre><p>contract给出整个框架给出的扩展接口，比如config类不能满足你的需求，<br>可以自己集成config接口实现这个类。</p><h1 id="Container的背后"><a href="#Container的背后" class="headerlink" title="Container的背后"></a>Container的背后</h1><p>这几种的返回结果都一样</p><pre><code>dd(Hash::make(&apos;pwd&apos;));//dsdsvdrssrbsssret5u4h6l8mdd(app(&apos;Hash&apos;)-&gt;make(&apos;pwd&apos;));dd(app()[&apos;Hash&apos;]-&gt;make(&apos;pwd&apos;));dd(app(&apos;Illuminate\Hashing\BcryptHasher&apos;)-&gt;make(&apos;pwd&apos;));</code></pre><p>想知道laravel单个功能的源代码，比如hash的功能，去serviceProvider去找。</p><pre><code>$this-&gt;app-&gt;singleton(&apos;hash&apos;,function(){  return new BcryptHasher;})</code></pre><p>singleton，bind是在核心的Contianer里面，</p><p>callFunction 是 Clouse ，会在singleton，bind中进行判断。</p><p>singleton，将hash的值保存到container的binding数组。</p><p>make(),build()可以通过serviceProvider、别名实现实例。</p><p>app（）判断传入的是key =&gt; serviceProvider去实现实例</p><p>包含命名空间的类 =&gt; Application.php  中 registerCoreContainerAliases()</p><p>Application.php里面是laravel的核心内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant之Homestead</title>
    <link href="http://martist.cn/2017/09/11/homestead/"/>
    <id>http://martist.cn/2017/09/11/homestead/</id>
    <published>2017-09-10T16:00:00.000Z</published>
    <updated>2017-10-13T12:01:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>[TOC]</p><h2 id="开发环境的需求"><a href="#开发环境的需求" class="headerlink" title="开发环境的需求"></a>开发环境的需求</h2><p>平时自己码代码用laravel框架，laravel 5.5LTS 要求： </p><pre><code>PHP &gt;= 7.0.0PHP OpenSSL 扩展PHP PDO 扩展PHP Mbstring 扩展PHP Tokenizer 扩展PHP XML 扩展</code></pre><p>公司开发目前用tp框架，要求PHP版本和生产环境保持一致，PHP = 5.6.*，php版本不同，怎么解决呢？</p><p>Vagrant 提供了一种简单、优雅的方式来管理和配置虚拟机。</p><h2 id="什么是homestead"><a href="#什么是homestead" class="headerlink" title="什么是homestead"></a>什么是homestead</h2><p>Laravel Homestead 是一个官方预封装的 Vagrant Box<br>（推荐使用macbook或linux环境进行开发， 如果你使用的是 Windows，你可能需要通过 BIOS 来启用硬件虚拟化（VT-x）。如果你在 UEFI 系统上使用 Hyper-V，可能还需要禁用 Hyper-V 才能启用 VT-x。）</p><h2 id="内置软件"><a href="#内置软件" class="headerlink" title="内置软件"></a>内置软件</h2><pre><code>Ubuntu 16.04GitPHP 7.1NginxMySQLMariaDBSqlite3PostgresComposerNode (带有 Yarn、Bower、Grunt 和 Gulp)RedisMemcachedBeanstalkdMailhogngrok</code></pre><p>这是相当丰富的一份清单，如果还有其他的软件需求可以继续安装，定制属于开发团队的box。</p><h2 id="安装与设置"><a href="#安装与设置" class="headerlink" title="安装与设置"></a>安装与设置</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>在启动 Homestead 环境之前，你必须先安装 VirtualBox 5.1， Vagrant。</p><h3 id="安装-Homestead-Vagrant-Box"><a href="#安装-Homestead-Vagrant-Box" class="headerlink" title="安装 Homestead Vagrant Box"></a>安装 Homestead Vagrant Box</h3><pre><code>vagrant box add laravel/homestead</code></pre><p><strong>注：如果上面的命令运行失败，请确保你的 Vagrant 是最新版本的 。</strong></p><h3 id="安装-Homestead"><a href="#安装-Homestead" class="headerlink" title="安装 Homestead"></a>安装 Homestead</h3><p>将代码库克隆到用户「home」目录下的 Homestead 文件夹中。这样 Homestead Box 就可以作为所有 Laravel 项目的主机：</p><pre><code>cd ~git clone https://github.com/laravel/homestead.git Homestead</code></pre><p>由于 Homestead 的 master 分支并不是稳定分支，你应该用打过标签的稳定版本。你可以在 Github 发行页面 上找到最新的稳定版本。</p><pre><code>cd Homestead// Clone the desired release...git checkout v6.1.0</code></pre><p>克隆 Homestead 代码库后，从 Homestead 目录中运行 <code>bash init.sh</code> 命令来创建 Homesstead.yaml 配置文件。 Homesstead.yaml 文件会被放置在你的 Homestead 目录中：</p><pre><code>// Mac / Linux...bash init.sh// Windows...init.bat</code></pre><h3 id="配置-Homestead"><a href="#配置-Homestead" class="headerlink" title="配置 Homestead"></a>配置 Homestead</h3><h4 id="配置提供器"><a href="#配置提供器" class="headerlink" title="配置提供器"></a>配置提供器</h4><p>Homestead.yaml 中的 provider 参数设置决定了你用的是哪一个 Vagrant 提供器：virtualbox、vmware_fusion、vmware_workstation 或者 parallels。你可以根据自己的喜好来设置提供器：</p><pre><code>provider: virtualbox</code></pre><h4 id="配置共享文件夹"><a href="#配置共享文件夹" class="headerlink" title="配置共享文件夹"></a>配置共享文件夹</h4><p>Homestead.yaml 文件的 folders 属性里列出所有与 Homestead 环境共享的文件夹。这些文件夹中的文件若有变更，它们会保持本地机器与 Homestead 环境之间同步。你可以根据需要配置多个共享文件夹：</p><pre><code>folders:    - map: ~/Code      to: /home/vagrant/Code</code></pre><p>若要启动 NFS，只需要在共享的文件夹配置中添加一个简单的标志：</p><pre><code>folders:    - map: ~/Code      to: /home/vagrant/Code      type: &quot;nfs&quot;</code></pre><p>使用 NFS 时，建议你安装 vagrant-bindfs 插件。这个插件会替你处理 Homestead Box 中的文件或目录权限问题。</p><p>你也可以通过在 options 下方列出 Vagrant 的 共享文件夹 支持的任何选项：</p><pre><code>folders:    - map: ~/Code      to: /home/vagrant/Code      type: &quot;rsync&quot;      options:          rsync__args: [&quot;--verbose&quot;, &quot;--archive&quot;, &quot;--delete&quot;, &quot;-zz&quot;]          rsync__exclude: [&quot;node_modules&quot;]</code></pre><h2 id="配置-Nginx-站点"><a href="#配置-Nginx-站点" class="headerlink" title="配置 Nginx 站点"></a>配置 Nginx 站点</h2><h3 id="添加配置信息"><a href="#添加配置信息" class="headerlink" title="添加配置信息"></a>添加配置信息</h3><p>对 Nginx 不熟悉吗？没关系。sites 属性可以帮助你可以轻松地将 域名 映射到 homestead 环境中的文件夹。Homestead.yaml 文件中已包含示例站点配置。同样的，你也可以增加多个站点到你的 Homestead 环境中。 Homestead 可以同时为多个 Laravel 应用提供虚拟化环境：</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public</code></pre><p>增加其他的 Nginx 站点。你可以在单个 Homestead 环境中运行多个 Laravel 程序。要添加其他网站，只需将网站配置信息添加到 Homestead.yaml 文件中：</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public    - map: another.app      to: /home/vagrant/Code/another/public</code></pre><h3 id="配置生效"><a href="#配置生效" class="headerlink" title="配置生效"></a>配置生效</h3><p>如果你在配置 Homestead Box 之后更改了 sites 属性，那么应该重新运行命令来更新虚拟机上的 Nginx 配置</p><pre><code>vagrant reload --provision</code></pre><h3 id="Hosts-文件"><a href="#Hosts-文件" class="headerlink" title="Hosts 文件"></a>Hosts 文件</h3><p>你必须将在 Nginx 站点中所添加的「域名」也添加到你机器的 hosts 上。 hosts 文件会将 Homestead 站点的请求重定向到 Homestead Box 中。在 Mac 或 Linux 上，该文件位于 <code>/etc/hosts</code>。在 Windows 上，它位于 <code>C:\Windows\System32\drivers\etc\hosts</code>。添加的内容如下所示：</p><pre><code>192.168.10.10  homestead.app</code></pre><p>之后再添加其他站点，直接在这行之后加上就可以了，比如：</p><pre><code>192.168.10.10  homestead.app  paper.app  mar.com # ...</code></pre><p>请确保列出的 IP 地址是你 Homestead.yaml 文件中的 IP 地址。将域名设置到 hosts 文件并启动 Vagrant Box后，就可以访问了。</p><h2 id="启动-Vagrant-Box"><a href="#启动-Vagrant-Box" class="headerlink" title="启动 Vagrant Box"></a>启动 Vagrant Box</h2><p>根据你的喜好完成 Homestead.yaml 的编辑后，再从 Homestead 目录运行  </p><pre><code>vagrant up</code></pre><p>Vagrant 将启动虚拟机并自动配置你的共享文件夹和 Nginx 站点。</p><p>你可以通过 Web 浏览器访问该站点：</p><pre><code>http://homestead.app</code></pre><p>如果要删除虚拟机，使用 <code>vagrant destroy --force</code> 命令。</p><h2 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h2><p>如果你想在系统的任何地方都可以使用 vagrant up 命令启动 Homestead，你可以在 Mac / Linux 系统的 Bash 配置文件中添加 Bash 函数。在 Windows 中，你可以通过在 PATH 环境变量中添加一个「批处理」文件来实现。下面这些脚本使你可以从系统的任何地方运行任何 Vagrant 命令，并将自动将该命令指向你的 Homestead 安装路径：</p><h3 id="Mac-Linux"><a href="#Mac-Linux" class="headerlink" title="Mac / Linux"></a>Mac / Linux</h3><pre><code>function homestead() {    ( cd ~/Homestead &amp;&amp; vagrant $* )}</code></pre><p>确保将该功能中的 ~/Homestead 路径是你实际的 Homestead 安装路径。这样你就可以在系统的任何地方运行 <code>homestead up</code>或<code>homestead ssh</code> 等命令。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在系统的任意位置创建一个批处理文件<code>homestead.bat</code>，并添加如下内容：</p><pre><code>@echo offset cwd=%cd%set homesteadVagrant=C:\Homesteadcd /d %homesteadVagrant% &amp;&amp; vagrant %*cd /d %cwd%set cwd=set homesteadVagrant=</code></pre><h2 id="通过-SSH-连接"><a href="#通过-SSH-连接" class="headerlink" title="通过 SSH 连接"></a>通过 SSH 连接</h2><p>你可以通过在 Homestead 目录运行vagrant命令来连接虚拟主机</p><pre><code>vagrant ssh </code></pre><p>配置全局使用后，可以使用homestead命令管理</p><pre><code>homestead uphomestead ssh</code></pre><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>在 Box 中已经为 MySQL 和 Postgres 配置好了一个数据库 homestead。为了更方便的使用它，Laravel 中的 .env 文件将框架配置成默认使用此数据库。</p><p>要从主机的数据库客户端连接到 MySQL 或 Postgres，就连接到 127.0.0.1 和端口 33060 (MySQL) 或 54320 (Postgres)。账号密码分别是 homestead／secret</p><blockquote><p>从主机连接到数据库时，只能使用这些非标准端口。 而 Laravel 在虚拟机中运行时，仍旧使用 Laravel 数据库配置文件中的默认 3306 和 5432 端口</p></blockquote><h2 id="站点类型"><a href="#站点类型" class="headerlink" title="站点类型"></a>站点类型</h2><p>Homestead 支持多种类型的站点，可以让你轻松地运行那些不基于 Laravel 的项目。 例如，我们可以使用 symfony2 站点类型轻松地在 Homestead 中添加 Symfony 应用程序：</p><pre><code>sites:    - map: symfony2.app      to: /home/vagrant/Code/Symfony/web      type: symfony2</code></pre><p>支持的站点类型有： apache、laravel（默认）、proxy、silverstripe、statamic、symfony2 和 symfony4。</p><h2 id="站点参数"><a href="#站点参数" class="headerlink" title="站点参数"></a>站点参数</h2><p>你还可以使用 params 站点指令向你的站点添加其他 Nginx fastcgi_param 值。例如，添加一个值为 BAR 的 FOO 参数。</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public      params:          - key: FOO            value: BAR</code></pre><h2 id="配置-Cron-调度器"><a href="#配置-Cron-调度器" class="headerlink" title="配置 Cron 调度器"></a>配置 Cron 调度器</h2><p>Laravel 提供了便利的方式来 调度 Cron 任务，通过Artisan 命令 schedule:run ，调度便会在每分钟运行一次。schedule:run 命令会检查定义在你 App\Console\Kernel 类中的调度任务，以此判断哪个任务该被运行。</p><p>如果你想对 Homestead 站点使用 schedule:run 命令，你需要在定义站点时将 schedule 选项设置为 true</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public      schedule: true</code></pre><p>该站点的 Cron 任务会被定义在虚拟机的 /etc/cron.d 文件夹中。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>默认情况下，以下端口会被转发至 Homestead 环境：</p><pre><code>SSH: 2222 → 发送到 22HTTP: 8000 → 发送到 80HTTPS: 44300 → 发送到 443MySQL: 33060 → 发送到 3306Postgres: 54320 → 发送到 5432Mailhog: 8025 → 发送到 8025</code></pre><h3 id="转发更多端口"><a href="#转发更多端口" class="headerlink" title="转发更多端口"></a>转发更多端口</h3><p>你可以根据需要转发更多端口给 Vagrant Box，并指定其协议：</p><pre><code>ports:    - send: 50000      to: 5000    - send: 7777      to: 777      protocol: udp</code></pre><h2 id="共享你的环境"><a href="#共享你的环境" class="headerlink" title="共享你的环境"></a>共享你的环境</h2><p>有时候你想跟你的同事或者是客户共享你目前在开展的工作。Vagrant 提供了一个内置方法 vagrant share 来支持。不过，如果你的 Homestead.yaml 文件中配置了多个站点，就无法使用此命令。</p><p>为了解决这个问题，Homestead 提供了自己的 share 命令。开始之前，通过 vagrant ssh SSH 命令连接 Homestead 机器中并运行 share homestead.app。这会从 Homestead.yaml 配置文件中共享 homestead.app 站点。你也可以用其他已经配置的站点来代替 homestead.app。</p><pre><code>share homestead.app</code></pre><p>运行命令后，你可以看到一个 Ngrok 界面，其中包含活动日志和共享站点的可公开访问的 URL。如果要指定自定义地区或者其他 Ngrok 选项，可以将它们添加到 share 命令后面：</p><pre><code>share homestead.app -region=eu -subdomain=laravel</code></pre><blockquote><p>谨记，Vagrant 本质上是不安全的。当你运行 share 命令时，你已经在互联网中暴露了你的虚拟机。</p></blockquote><h2 id="多个-PHP-版本"><a href="#多个-PHP-版本" class="headerlink" title="多个 PHP 版本"></a>多个 PHP 版本</h2><blockquote><p>此功能仅与 Nginx 兼容。</p></blockquote><p>Homestead 6 支持在同一个虚拟机上引入多个版本的 PHP。你可以在 Homestead.yaml 文件中为给定站点指定使用哪个版本的 PHP。 可用的 PHP 版本有：「5.6」、「7.0」、「7.1」</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public      php: &quot;5.6&quot;</code></pre><p>此外，你还可以通过 CLI 使用任何受支持的 PHP 版本：</p><pre><code>php5.6 artisan listphp7.0 artisan listphp7.1 artisan list</code></pre><h2 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h2><p>Homestead.yaml 的 networks 属性为 Homestead 环境配置网络接口。你可以根据需要配置任意数量的接口：</p><pre><code>networks:    - type: &quot;private_network&quot;      ip: &quot;192.168.10.20&quot;</code></pre><p>想启用 桥接 接口，请配置 bridge 设置，并将网络类型更改为 public_network ：</p><pre><code>networks:    - type: &quot;public_network&quot;      ip: &quot;192.168.10.20&quot;      bridge: &quot;en1: Wi-Fi (AirPort)&quot;</code></pre><p>要启用 DHCP，只需从配置中删除 ip 选项：</p><pre><code>networks:    - type: &quot;public_network&quot;      bridge: &quot;en1: Wi-Fi (AirPort)&quot;</code></pre><h2 id="更新-Homestead"><a href="#更新-Homestead" class="headerlink" title="更新 Homestead"></a>更新 Homestead</h2><p>你可以通过两个简单的步骤更新 Homestead。首先，使用 vagrant box update 命令更新 Vgrant Box :</p><pre><code>vagrant box update</code></pre><p>接下来，如果你是通过克隆仓库的方式来安装的 Homestead，你需要更新 Homestead 的源代码。你可以在你最初克隆仓库的位置简单地运行 git pull origin master 命令。</p><p>如果你是通过项目中的 composer.json 文件安装 Homestead ，则应该确认 composer.json 文件中包含 “laravel/homestead: “^6” 并更新依赖：</p><pre><code>composer update</code></pre><h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><pre><code>如果你需要一个旧版本的 PHP，请在尝试使用旧版本的 Homestead 之前，先阅读文档 多个 PHP 版本 上的文档。</code></pre><p>你可以通过添加以下内容添加到 Homestead.yaml 文件中来覆盖 Homestead 使用的 Box 版本:</p><pre><code>version: 0.6.0</code></pre><p>例如：</p><pre><code>box: laravel/homesteadversion: 0.6.0ip: &quot;192.168.20.20&quot;memory: 2048cpus: 4provider: virtualbox</code></pre><p>当你使用较旧版本的 Homestead Box 时，你需要确保将其与 Homestead 源代码的兼容版本进行匹配。下面的图表展示了支持的 Box 版本，使用哪个版本的 Homestead 源代码以及提供的 PHP 版本</p><pre><code>Homestead   Version  Box VersionPHP 7.0     3.1.0      0.6.0PHP 7.1     4.0.0      1.0.0PHP 7.1     5.0.0      2.0.0PHP 7.1     6.0.0      3.0.0</code></pre><h2 id="提供器的特殊设置"><a href="#提供器的特殊设置" class="headerlink" title="提供器的特殊设置"></a>提供器的特殊设置</h2><p>在VirtualBox作为提供器的情况下，Homestead 默认将 natdnshostresolver 设置为 on。这允许 Homestead 使用主机系统中的 DNS 设置。如果你想重写这行为，你可以在你的 Homestead.yaml 文件中添加下面这几行：</p><pre><code>provider: virtualboxnatdnshostresolver: off</code></pre><h2 id="要关注"><a href="#要关注" class="headerlink" title="要关注"></a>要关注</h2><p>具体关于vagrant的安装，使用和项目实践，可以关注我的看云，地址如下</p><p><a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="vagrant" scheme="http://martist.cn/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant之入门</title>
    <link href="http://martist.cn/2017/07/29/Vagrant%E4%B9%8B%E5%85%A5%E9%97%A81/"/>
    <id>http://martist.cn/2017/07/29/Vagrant之入门1/</id>
    <published>2017-07-28T16:00:00.000Z</published>
    <updated>2017-10-13T12:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><pre><code>下载 VirtualBox 虚拟器 : https://www.virtualbox.org/下载安装 Vagrant : http://www.vagrantup.com/下载使用的 box (这里的 box 指的是系统) : http://www.vagrantbox.es/在本地建立一个工作文件夹</code></pre><p>VirtualBox是虚拟机，Vagrant是管理虚拟机的工具，.box文件相当于在虚拟机内构建系统的镜像。</p><p>首先需要下载并安装VirtualBox，Vagrant，准备好镜像文件(.box)。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>查看当前添加进 vagrant 的镜像</p><pre><code>vagrant box list </code></pre><p>一开始是没有添加 box 镜像, 我们执行 <code>vagrant box add 系统名字 box镜像</code>；另一种情况是在线拉取镜像，可以忽略这一步</p><pre><code>vagrant box add hashicorp/precise64</code></pre><p><code>hashicorp/precise64</code> 镜像可以是 <code>add</code> 之前准备好的，放在执行命令的当前目录的，也可以没有准备，在线拉取，是否提前下载镜像，这取决于你的网速。当开发团队统一开发环境而分发给你一个镜像，那就直接<code>add</code>这个镜像文件的文件名就可以了，当你初始化的时候会默认选择list的镜像文件。</p><p>初始化镜像</p><pre><code>vagrant init hashicorp/precise64</code></pre><p>该命令会在当前目录下创建<code>Vagrantfile</code>，并且指定所使用的box为ubuntu/trusty64，该box由Hashicorp官网提供。此时，Vagrant发现box的名字的格式为“用户名/box名”，则会使用 <code>“https://atlas.hashicorp.com/用户名/box名”</code> 来下载该box。对于非官网提供的box，可以通过以下命令创建：</p><pre><code>vagrant init my-box https://boxes.company.com/my.box</code></pre><p>此时你可以通过更改<code>Vagrantfile</code>，来完成你的配置。因为我们虚拟机默认只分配一个访问外网的 IP, 项目使用的 IP 得手动设置打开 Vagrantfile 找到29行(我的配置文件在29行)设置一个私有 IP，默认是192.168.33.10。</p><p>其中，my-box为该box的名字，后面的URL为该box的下载地址。</p><p>启动虚拟机</p><pre><code>vagrant up</code></pre><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>登录到虚拟机</p><pre><code>vagrant ssh</code></pre><p>此时vagrant将使用默认的用户vagrant以及预设的SSH公钥密钥键值对直接登录虚拟机。</p><p>关闭虚拟机：</p><pre><code>vagrant halt</code></pre><p>删除虚拟机：</p><pre><code>vagrant destroy</code></pre><p>请注意，vagrant destroy只会删除虚拟机本身，也即你在Virtualbox将看不到该虚拟机，但是不会删除该虚拟机所使用的box。</p><p>删除某个box的命令</p><pre><code>vagrant box remove box-name</code></pre><p>虚拟机里面的<code>/vagrant</code> 这个文件夹是和当前目录保持同步。是不是很有趣，这样我们以后从服务器拉取下来的项目放在虚拟机中，操作系统的本地保目录持同步，这样关闭虚拟机或者虚拟机异常退出了，项目也不会随之销毁，vagrant的带来的开发优势显而易见。</p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><pre><code>$ vagrant box add NAME URL #添加一个box$ vagrant box list #查看本地已添加的box$ vagrant box remove NAME virtualbox #删除本地已添加的box，如若是版本1.0.x，执行$ vagrant box remove NAME$ vagrant init NAME #初始化，实质应是创建Vagrantfile文件$ vagrant up #启动虚拟机$ vagrant halt #关闭虚拟机$ vagrant destroy #销毁虚拟机$ vagrant reload #重启虚拟机$ vagrant package #当前正在运行的VirtualBox虚拟环境打包成一个可重复使用的box$ vagrant ssh #进入虚拟环境*$ vagrant port #查看ip和端口</code></pre><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>全部vagrant命令请查询 ： <a href="https://www.vagrantup.com/docs/cli/index.html" target="_blank" rel="external">https://www.vagrantup.com/docs/cli/index.html</a></p><h2 id="要关注"><a href="#要关注" class="headerlink" title="要关注"></a>要关注</h2><p>具体关于vagrant的安装，使用和项目实践，可以关注我的看云，地址如下</p><p><a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="vagrant" scheme="http://martist.cn/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>ssh服务为web生产服务器保驾护航</title>
    <link href="http://martist.cn/2017/07/27/ssh/"/>
    <id>http://martist.cn/2017/07/27/ssh/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-10-03T05:40:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们给自己的博客搭建一个站点，配置lnmp/lamp运行环境可以跑起来，差不多就完事了。但是当我们做的是一个中型或者大型项目，在它需要部署到生产服务器上线运营时，账户安全方面需要做些什么？</p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>apt-get install openssh-server</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>/etc/init.d/ssh start  </code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>ssh  martist@192.168.123.3//ssh远程连接服务器，需要输入用户密码</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="主机名管理"><a href="#主机名管理" class="headerlink" title="主机名管理"></a>主机名管理</h3><p>一个中型甚至大型的的项目，往往需要对多台服务器进行管理，如生产服务器，测试服务器，管理服务器等等。因此需要对每一台服务器的主机名进行管理，通过修改各个服务器的/etc/hostname文件修改本地系统名，重启可以看到。</p><h3 id="密钥ssh登录"><a href="#密钥ssh登录" class="headerlink" title="密钥ssh登录"></a>密钥ssh登录</h3><p>linux或Mac下生成密钥的命令是 <code>ssh-keygen -t rsa</code> 默认生成路径在家目录的.ssh目录下。id_rsa 文件保存的是本机的私钥，id_rsa.pub文件保存的是公钥。<br> ifconfig命令查看服务器的IP地址，注意如果你是用的是阿里云ECS，此处查看到的是内网IP而非公网IP。<br>在被登录的服务器的家目录下的.ssh目录（如果不存在就创建一个）创建一个authorized_keys 文件，并将生成的公钥文件的内容放到里面，就可以在本地使用密钥登陆这台服务器了。</p><pre><code>ssh  martist@192.168.123.3//此时不需要输入用户名密码</code></pre><p>如果我们关闭密码登陆，转而使用ssh密钥登录，更可以确保服务安全（注意：关闭密码登陆前，一定要确保能够正常使用ssh密钥登陆）。</p><h3 id="关闭密码登陆"><a href="#关闭密码登陆" class="headerlink" title="关闭密码登陆"></a>关闭密码登陆</h3><p>找到/etc/ssh/sshd_config 修改PasswordAuthentication 属性 yes。<br>在第52行，yes改为no，禁用密码登陆（慎用）。</p><h2 id="详细实战分析"><a href="#详细实战分析" class="headerlink" title="详细实战分析"></a>详细实战分析</h2><p>线上：阿里云ECS云服务器 Ubuntu14.04lts </p><p>Manager服务器生成ssh密钥</p><pre><code>ssh-keygen -t rsa  //一路回车</code></pre><p>生成的密钥保存在家目录下，进入.ssh目录下，</p><pre><code>ls//查看文件id_rsa id_rsa.pub know_hosts </code></pre><p>Manager服务器上在 /etc/hosts 文件里加上重定向的名字，如测试服务器，DB服务器和Manager服务器分别起一个重定向名字便于管理多台web服务器。<br>修改本地定向网络ip（阿里云的内网ip）的文件 </p><pre><code>vi /etc/hosts //写入 10.162.48.184 FWEB1//每次在终端输入‘FWEB1’，就代表‘10.162.48.184’。</code></pre><p>在mannager服务器上，试一下ssh登录web1服务器</p><pre><code>ssh root@FWEB1  </code></pre><p>退出</p><pre><code>exit</code></pre><p>在mannager服务器上，试一下文件上传web1服务器</p><pre><code>scp  ./id_rsa.pub root@FWEB1:/root</code></pre><p>现在还是需要输入密码，不过等一会把密钥加到web服务器上，再从manager登录web服务器，就不需要输入密码了。</p><p>在web1服务器，家目录下创建.ssh目录</p><pre><code>ssh root@FWEB1 // 输入密码mkdir ~/.ssh</code></pre><p>在web1服务器，把id_rsa.pub传递到.ssh/目录下</p><p>   cat id_rsa.pub &gt;&gt; .ssh/id_rsa.pub   </p><p>此时，再从id_rsa.pub设置到web服务器（FWEB1）本地.</p><p>文件改名</p><pre><code>mv id_rsa.pub authorized_keys</code></pre><p>给执行权限</p><pre><code>chmod 600 ./authorized_keys</code></pre><p>退出ssh远程登录</p><pre><code>exit</code></pre><p>此时回到manager服务器</p><pre><code> ssh  root@FWEB1//此时密码不用输就可以进入FWEB1</code></pre><p>随便上传个文件，试试</p><pre><code>scp know_hosts root@FWEB1:/tmp/</code></pre><p>此后，在manager服务器向web服务器，scp传送东西,不需要再输入密码了。</p><p>原理：manager服务器私钥自己留着，把公钥给所有的web，DB，备份服务器，就可以便捷管理了。</p><h3 id="关闭web服务器的密码登陆"><a href="#关闭web服务器的密码登陆" class="headerlink" title="关闭web服务器的密码登陆"></a>关闭web服务器的密码登陆</h3><p>找到/etc/ssh/sshd_config 修改PasswordAuthentication 属性 yes。在第52行，yes改为no，禁用密码登陆。<br>修改sshd_config文件中ssh端口，ssh端口默认为 22. 把端口号改为1000以上的数值。</p><pre><code>默认：Port:22改为：Port 1678</code></pre><p>:wq //退出vi编辑器。</p><pre><code>reboot //重启生效</code></pre><p>ssh登录目的服务器命令</p><p>   root@FWEB1</p><p>有点麻烦？可以创建自己的别名</p><pre><code>vi ~/.bash_profile//写入  alias fewb1=&apos;ssh root@FWEB1 -p 1678&apos;//(-p 为端口号)</code></pre><p>好，:wq 保存退出。</p><p>使他生效</p><pre><code>source .bash_profile </code></pre><p>查看别名</p><pre><code>alias</code></pre><p>在manager服务器下，把某个文件夹下全部文件推送到web服务器。</p><pre><code>scp -p 1678 ./* root@FWEB1:/tmp/ //（需要被传送文件的web服务器有这个文件夹）</code></pre><p>把服务器其上的东西上传上去，是这样写， 把web服务器的东西下载到本地，只要把这俩目录倒过来，就可以了。</p><p>技巧：</p><pre><code>cd ~mkdir sh vi pushcode.sh//在这里写shell脚本</code></pre><p>shell脚本的写法，开头‘#！’，后面是 shell可执行命令的位置。</p><pre><code> #！/bin/shscp -p 1678 ./var/www.machuang.name/* root@FWEB1:/var/www/machuang.name</code></pre><p>好！:wq 保存推出。</p><p>给执行权限</p><pre><code>chmod 755 /root/sh/pushcode.sh</code></pre><p>Ls查看下</p><pre><code>ls /root/sh</code></pre><p>此时看到pushcode.sh变成绿色，就对了。以后敲入这段命令，就可以完成上传代码的功能了。</p><pre><code>/root/sh/pushcode.sh</code></pre><p>就可以执行脚本内的命令了，此时再加一个别名。</p><pre><code>cd ~vi .bash_profile//写入  alias pushcode=&apos;/root/sh/pushcode.sh&apos;//:wq 保存退出</code></pre><p>好，使它生效，否则要重启才能生效。</p><pre><code>source .bash_profile</code></pre><p>上传代码：</p><pre><code>pushcode</code></pre><p>这样一个具备业务逻辑的ssh服务使用就展现在你面前了，单一的使用一个工具并不显得立体，多种linux软件和命令有机结合在一起才能迸发出更大的能量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant-流行的环境部署工具</title>
    <link href="http://martist.cn/2017/07/21/Vagrant/"/>
    <id>http://martist.cn/2017/07/21/Vagrant/</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-10-13T12:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vagrant 是一个基于 Ruby 的工具，用于创建和部署虚拟化开发环境。它使用 Oracle 的开源 VirtualBox 虚拟化系统，使用 Chef 创建自动化虚拟环境。</p><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><pre><code>支持快速新建虚拟机支持快速设置端口转发支持自定义镜像打包（原始镜像方式、增量补丁方式）基本上日常能用到的基础配置都能快速设置支持开机启动自动运行命令可以自己写扩展</code></pre><h2 id="解决实际问题"><a href="#解决实际问题" class="headerlink" title="解决实际问题"></a>解决实际问题</h2><p>在商业化项目的多人协同开发中，统一开发环境是非常重要的，让开发环境尽可能的接近生产环境，对项目的稳定性起着不可忽视的作用。</p><p>我们可以通过 Vagrant 封装一个 Linux 的开发环境，里面是一致的开发环境、软件版本,把它（.box）分发给团队成员。成员可以在自己的操作系统（Mac/Windows/Linux）上开发程序，代码却能统一在封装好的环境里运行，而不受操作系统影响。</p><h2 id="要关注"><a href="#要关注" class="headerlink" title="要关注"></a>要关注</h2><p>具体关于vagrant的安装，使用和项目实践，可以关注我的看云，地址如下</p><p><a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="vagrant" scheme="http://martist.cn/tags/vagrant/"/>
    
  </entry>
  
</feed>
