<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARTIST</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://martist.cn/"/>
  <updated>2017-11-17T04:56:34.268Z</updated>
  <id>http://martist.cn/</id>
  
  <author>
    <name>martist.cn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenStack学习笔记</title>
    <link href="http://martist.cn/2017/11/13/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://martist.cn/2017/11/13/OpenStack学习笔记/</id>
    <published>2017-11-12T16:00:00.000Z</published>
    <updated>2017-11-17T04:56:34.268Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h3 id="什么是openstack？"><a href="#什么是openstack？" class="headerlink" title="什么是openstack？"></a>什么是openstack？</h3><p>它是Rackspace和NASA共同发起的开源项目，本身是一系列开源软件项目的组合，它的功能是基础设施资源的系统管理平台。它可以有效的管理cpu，硬盘等资源。</p><h3 id="OpenStack-可以干嘛？"><a href="#OpenStack-可以干嘛？" class="headerlink" title="OpenStack 可以干嘛？"></a>OpenStack 可以干嘛？</h3><p>它就是一个IaaS的云平台软件。实际应用场景非常多，凡是IaaS可以应用的地方Openstack都可以做到。比如虚拟主机，出售计算资源，公司内部IT云计算解决方案等等。</p><h3 id="OpenStack的镜像一般用哪个？"><a href="#OpenStack的镜像一般用哪个？" class="headerlink" title="OpenStack的镜像一般用哪个？"></a>OpenStack的镜像一般用哪个？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CirrOS</div><div class="line">http://download.cirros-cloud.net/</div><div class="line">user:cirros     password:cubswin:)</div><div class="line">glance image-create --name cirros --disk-format qcow2 --container-format bare &lt; cirros-0.3.4-x86_64-disk.img</div></pre></td></tr></table></figure><p>测试 OpenStack 服务是否完好一般都用 CIRROS，体积小巧，只有 10M，上面是我做的笔记，最后一个是 GLANCE 的上传命令。</p><h3 id="OpenStack-是用什么语言开发的？"><a href="#OpenStack-是用什么语言开发的？" class="headerlink" title="OpenStack 是用什么语言开发的？"></a>OpenStack 是用什么语言开发的？</h3><p>一般就是 Python  、Java，你要知道 OpenStack是一个软件包，它整合了其他的开源软件，所以还有其他语言。</p><h1 id="主要功能组件"><a href="#主要功能组件" class="headerlink" title="主要功能组件"></a>主要功能组件</h1><p>Horizon：UI模块</p><p>keystone： 身份服务模块</p><p>service：即 服务，如Nova，Swift等， 需要在keystone注册</p><p>endpoint：可以理解为一个服务暴露出来的访问点</p><p>identify： 服务验证身份凭证</p><p>token：访问资源的令牌。</p><p>Catalog：提供可供与断电发现的服务注册表。</p><p>policy：暴露了一个基于规则的身份验证引擎</p><h1 id="易购环境集成"><a href="#易购环境集成" class="headerlink" title="易购环境集成"></a>易购环境集成</h1><p>不同的组件集成到keystone中</p><h1 id="open-stack组件介绍"><a href="#open-stack组件介绍" class="headerlink" title="open-stack组件介绍"></a>open-stack组件介绍</h1><h2 id="nova组件"><a href="#nova组件" class="headerlink" title="nova组件"></a>nova组件</h2><p>主要功能包括：<br>    实例生命周期管理<br>    计算资源管理<br>    向外提供rest风格api<br><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack1.png" alt=""></p><h2 id="Glance组件"><a href="#Glance组件" class="headerlink" title="Glance组件"></a>Glance组件</h2><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack2.png" alt=""></p><h2 id="swift组件"><a href="#swift组件" class="headerlink" title="swift组件"></a>swift组件</h2><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack3.png" alt=""></p><h2 id="cinder组件"><a href="#cinder组件" class="headerlink" title="cinder组件"></a>cinder组件</h2><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack4.png" alt=""></p><h2 id="neutron组件"><a href="#neutron组件" class="headerlink" title="neutron组件"></a>neutron组件</h2><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack5.png" alt=""></p><h1 id="组件关系"><a href="#组件关系" class="headerlink" title="组件关系"></a>组件关系</h1><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack6.png" alt=""></p><h1 id="访问控制流程"><a href="#访问控制流程" class="headerlink" title="访问控制流程"></a>访问控制流程</h1><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/openstack7.png" alt=""></p><p>参考文章：<a href="http://www.imooc.com/article/8989" target="_blank" rel="external">我的自学 OpenStack 云平台 之路（一）_慕课手记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://martist.cn/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="云服务，docker" scheme="http://martist.cn/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%EF%BC%8Cdocker/"/>
    
      <category term="OpenStack" scheme="http://martist.cn/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>清洗html标签和css样式</title>
    <link href="http://martist.cn/2017/11/12/html%E6%A0%87%E7%AD%BE%E5%8E%BB%E6%8E%89/"/>
    <id>http://martist.cn/2017/11/12/html标签去掉/</id>
    <published>2017-11-11T16:00:00.000Z</published>
    <updated>2017-11-17T04:09:55.432Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><pre><code>$content = preg_replace(&quot;/&lt;a[^&gt;]*&gt;/i&quot;, &quot;&quot;, $content);  $content = preg_replace(&quot;/&lt;\/a&gt;/i&quot;, &quot;&quot;, $content);   $content = preg_replace(&quot;/&lt;div[^&gt;]*&gt;/i&quot;, &quot;&quot;, $content);  $content = preg_replace(&quot;/&lt;\/div&gt;/i&quot;, &quot;&quot;, $content);      $content = preg_replace(&quot;/&lt;!--[^&gt;]*--&gt;/i&quot;, &quot;&quot;, $content);//注释内容  $content = preg_replace(&quot;/style=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式  $content = preg_replace(&quot;/class=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式  $content = preg_replace(&quot;/id=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式     $content = preg_replace(&quot;/lang=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式      $content = preg_replace(&quot;/width=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式   $content = preg_replace(&quot;/height=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式   $content = preg_replace(&quot;/border=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式   $content = preg_replace(&quot;/face=.+?[&apos;|\&quot;]/i&quot;,&apos;&apos;,$content);//去除样式   $content = preg_replace(&quot;/face=.+?[&apos;|\&quot;]/&quot;,&apos;&apos;,$content);//去除样式 只允许小写 正则匹配没有</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>记一次部署node项目到centos服务器经历</title>
    <link href="http://martist.cn/2017/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%83%A8%E7%BD%B2node%E9%A1%B9%E7%9B%AE%E5%88%B0centos%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%8F%E5%8E%86/"/>
    <id>http://martist.cn/2017/11/07/记一次部署node项目到centos服务器经历/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2017-11-17T06:20:03.212Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="服务器安装运行环境"><a href="#服务器安装运行环境" class="headerlink" title="服务器安装运行环境"></a>服务器安装运行环境</h1><p>先从网上随便搜了个contos安装node的教程，大概就是这样。<br>准备命令：</p><pre><code>yum -y install gcc make gcc-c++ openssl-devel wget</code></pre><p>下载源码及解压：</p><pre><code>wget http://nodejs.org/dist/v0.10.26/node-v0.10.26.tar.gztar -zvxf node-v0.10.26.tar.gz</code></pre><p>编译及安装：</p><pre><code>cd node-v0.10.26make &amp;&amp; make install</code></pre><p>验证是否安装配置成功：</p><pre><code>node -v</code></pre><p>安装完了， 运行项目，报错，嗯？？原来开发版本是8.4.0，版本差距太大了，怎么办，删node重新安？我选择升级。</p><p>首先安装n模块：</p><pre><code>npm install -g n</code></pre><p>第二步：</p><p>升级node.js到最新稳定版</p><pre><code>n stable</code></pre><p>是不是很简单？！</p><p>此处无升级到了9.0.0，又超过开发版本，不过好在实际项目运行起来了，没问题，附可以指定版本的命令。</p><p>n后面也可以跟随版本号比如：</p><pre><code>n v0.10.26</code></pre><p>或</p><pre><code>n 0.10.26</code></pre><p>npm的常用命令</p><pre><code>npm -v          #显示版本，检查npm 是否正确安装。  npm install express   #安装express模块  npm install -g express  #全局安装express模块  npm list         #列出已安装模块  npm show express     #显示模块详情  npm update        #升级当前目录下的项目的所有模块  npm update express    #升级当前目录下的项目的指定模块  npm update -g express  #升级全局安装的express模块  npm uninstall express  #删除指定的模块</code></pre><h1 id="打包代码发到服务器"><a href="#打包代码发到服务器" class="headerlink" title="打包代码发到服务器"></a>打包代码发到服务器</h1><p>打包发送可以选择ftp工具，比如filezilla，比较好用，我是用的是命令行，scp传输命令。</p><pre><code>sudo scp -r -P port ./Desktop/musics/ root@1.1.1.1:/tmp</code></pre><p>把我桌面的music目录传输到了服务器的tmp目录下，打包之后更快一些。</p><h1 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h1><p>运行命令</p><pre><code>node index.js</code></pre><p>推荐使用forever工具。</p><pre><code>sudo npm install forever -g   #安装forever start app.js          #启动forever stop app.js           #关闭forever start -l forever.log -o out.log -e err.log app.js   #输出日志和错误</code></pre><p>命令语法及使用： <a href="https://github.com/nodejitsu/forever" target="_blank" rel="external">https://github.com/nodejitsu/forever</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="nodejs" scheme="http://martist.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>常见的企业管理系统软件</title>
    <link href="http://martist.cn/2017/10/19/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://martist.cn/2017/10/19/常见的企业管理软件系统/</id>
    <published>2017-10-18T16:00:00.000Z</published>
    <updated>2017-10-19T03:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><ul><li>ERP进销存管理系统</li><li>OA协同办公管理系统</li><li>CRM客户关系管理系统</li><li>HRM人力资源管理系统</li><li>EAM资产管理系统</li><li>绩效管理系统</li><li>成本管理系统</li><li>设备管理系统</li><li>质量管理系统</li></ul><h2 id="ERP进销存管理系统"><a href="#ERP进销存管理系统" class="headerlink" title="ERP进销存管理系统"></a>ERP进销存管理系统</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓ERP（Enterprise Resource Planning）企业资源规划，顾名思义，也就是将企业内部各个部门，包括财务、会计、生产、物料管理、品质管理、销售与分销、人力资源管理等，利用信息科技整合、连结在一起。    </p><p>传统上，企业的各个部门大都各自为政，使用不同的计算机系统，业务与生产部门互不相关，生产部门的人无法直接从计算机上直接查到订单的数量，更不用谈信息共享与整合。</p><h3 id="实际作用"><a href="#实际作用" class="headerlink" title="实际作用"></a>实际作用</h3><p>ERP所扮演的角色便是将各部门连贯起来，让所有信息在在线揭露，所有人只要有账号、密码，在一定权限范围内，便可轻易从计算机上得知各部门的相关数据，例如订单及出货的情形，避免资源与人事上不必要的浪费，经理人也可以从这些迅速而正确的数据中，做出最好的决策。政大信息管理系副教授季延平指出，由于信息的透明化、实时化，企业更有条件达到立即反应、整体规划的目标。</p><h3 id="最佳实务范例"><a href="#最佳实务范例" class="headerlink" title="最佳实务范例"></a>最佳实务范例</h3><p>除此之外，ERP软件的独特处在于提供最佳实务典范（Best Practice）。所谓最佳实务范例，是经由研究全世界知名厂商的企业流程所累积而成，所以ERP所提供给厂商的，是一套经过时间证明的标准作业流程。因此，很多企业拿它来做流程改造的凭借，其好处是不但可以节省企业自己做流程改造的时间，并能以创新的想法弥补传统产业的局限处。</p><p>对外而言，单打独斗的时代已经逐渐过去了，企业间的合作联盟逐渐成型。ERP可以使得企业内部的信息通行无阻，如果再加上供应链管理（Supply Chain Management），透过网络与系统的有效结合，可以使客户与厂商间形成水平或垂直整合，真正达到全球运筹管理的模式。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li><a href="https://gitee.com/crm8000/PSI" target="_blank" rel="external">PSI</a></li><li><a href="https://www.odoo.com/zh_CN/" target="_blank" rel="external">odoo</a></li></ol><h2 id="OA协同办公管理系统"><a href="#OA协同办公管理系统" class="headerlink" title="OA协同办公管理系统"></a>OA协同办公管理系统</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>办公自动化（Office Automation，简称OA）是将现代化办公和计算机技术结合起来的一种新型的办公方式。办公自动化没有统一的定义，凡是在传统的办公室中采用各种新技术、新机器、新设备从事办公业务，都属于办公自动化的领域。通过实现办公自动化，或者说实现数字化办公，可以优化现有的管理组织结构，调整管理体制，在提高效率的基础上，增加协同办公能力，强化决策的一致性 。</p><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>OA软件的核心应用是：流程审批、协同工作、公文管理(国企和政府机关)、沟通工具、文档管理、信息中心、电子论坛、计划管理、项目管理、任务管理、会议管理、关联人员、系统集成、门户定制、通讯录、工作便签、问卷调查、常用工具(计算器、万年历等)。<br>OA管理平台基于“框架+应用组件+功能定制平台”的架构模型，主体部分由30多个子系统组成，包括信息门户、协同工作、工作流程、表单中心、公文流转、公共信息、论坛管理、问卷调查、计划管理、会务管理、任务管理、关联项目、关联人员、文档管理、外部邮件、在线考试、车辆管理、物品管理、设备管理、常用工具、办理中心、在线消息、督办系统、短信平台、常用工具、人事管理、功能定制平台、集成平台、系统管理等，近万个功能点。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>OA强调办公的便捷方便，提高效率，作为办公软件就应具备几大特性：易用性、健壮性、开放性、严密性、实用性。</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p><a href="https://gitee.com/kalcaddle/KODExplorer" target="_blank" rel="external">可道云</a><br><a href="https://gitee.com/aagagagag/R3-Query" target="_blank" rel="external">R3 Query</a></p><h2 id="CRM客户关系管理系统"><a href="#CRM客户关系管理系统" class="headerlink" title="CRM客户关系管理系统"></a>CRM客户关系管理系统</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>CRM即客户关系管理，是指企业用CRM技术来管理与客户之间的关系。在不同场合下，CRM可能是一个管理学术语，可能是一个软件系统。通常所指的CRM，指用计算机自动化分析销售、市场营销、客户服务以及应用等流程的软件系统。它的目标是通过提高客户的价值、满意度、赢利性和忠实度来缩减销售周期和销售成本、增加收入、寻找扩展业务所需的新的市场和渠道。CRM是选择和管理有价值客户及其关系的一种商业策略，CRM要求以客户为中心的企业文化来支持有效的市场营销、销售与服务流程。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MBA、CEO必读12篇及EMBA等商管教育对CRM的定义是：企业利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，从而提升其管理方式，向客户提供创新式的个性化的客户交互和服务的过程。其最终目标是吸引新客户、保留旧客户以及将已有客户转为忠实客户。</p><p>开源项目可搜索<a href="https://gitee.com/explore/recommend" target="_blank" rel="external">码云</a></p><h2 id="OA、CRM、ERP之间的区别和联系"><a href="#OA、CRM、ERP之间的区别和联系" class="headerlink" title="OA、CRM、ERP之间的区别和联系"></a>OA、CRM、ERP之间的区别和联系</h2><p>简单地说OA 是负责组织行为管理的，相对柔性；CRM负责客户经营的；ERP更多的负责业务处理地，相对刚性。</p><p>（1）OA -Office Automation 办公自动化<br>多用在内部行政上的一些表单及流程的的电子化，如：请假单，派车单，公司通告，公司内部主页，投票等等功能。<br>（2）CRM-Customer Relationship Management 客户关系管理<br>多用在公司业务体系中，如：记录客户的联系方式，客户的需求，客户的交易记录，等等和客户相关的功能。<br>（3）ERP-enterpriseresourceplanning 企业资源计划<br>多用在公司整个管理的整合，如：销售管理，采购管理 ，仓库管理，生产管理，财务管理，计划管理等。<br>三个没有具体的联系，非要说有的话，可能是一些ERP会含有一定的OA或CRM的功能。</p><p>可以参考<a href="https://www.zhihu.com/question/20931870" target="_blank" rel="external">知乎问答</a></p><p>典型的OA：</p><pre><code>https://www.jiandaoyun.com/a/59018c38d147571e2d21f55chttps://www.jiandaoyun.com/a/59018adf5c185ab8645e0d53</code></pre><p>典型的CRM：</p><pre><code>https://www.jiandaoyun.com/a/59018b45d147571e2d21e44bhttps://www.jiandaoyun.com/a/59018b62375ddec3631d92c2</code></pre><p>典型的ERP：</p><pre><code>https://www.jiandaoyun.com/a/59014f4ca24a45575f1a564fhttps://www.jiandaoyun.com/a/59018b7f375ddec3631d94c0</code></pre><h2 id="原文地址-我的看云"><a href="#原文地址-我的看云" class="headerlink" title="原文地址 - 我的看云"></a>原文地址 - 我的看云</h2><p><a href="http://doc.martist.cn/427308" target="_blank" rel="external">http://doc.martist.cn/427308</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>林书豪</title>
    <link href="http://martist.cn/2017/10/18/%E6%9E%97%E4%B9%A6%E8%B1%AA/"/>
    <id>http://martist.cn/2017/10/18/林书豪/</id>
    <published>2017-10-17T16:00:00.000Z</published>
    <updated>2017-10-18T07:24:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="来自另一个弱势群体的抨击"><a href="#来自另一个弱势群体的抨击" class="headerlink" title="来自另一个弱势群体的抨击"></a>来自另一个弱势群体的抨击</h2><p>前NBA球员肯扬-马丁近日就林书豪的发型一事做出评论,林给予回应。</p><p>马丁在Instagram上说道：</p><blockquote><p>“这是我今天发的最后一条状态，我是否需要提醒一下这个男孩姓‘林’？拜托了，停止这些行为吧，就算你再怎么弄脏辫，也不是黑人的样子，我明白你想弄成黑人的样子，但是你姓林。”</p></blockquote><p>林书豪在这条状态底下很有礼貌地进行了回复，他说道：</p><blockquote><p>“嘿老哥，你不喜欢我的发型完全没有关系，你有权发表自己的观点，实际上，我很感激你说出了内心的想法。归根结底，我很欣赏自己的脏辫，我也很欣赏你的中文文身，因为我认为这是一种尊重的标志。我认为作为少数群体，我们越去欣赏彼此的文化，我们就越能够影响主流群体。感谢你为篮网和篮球所做的一切，小时候墙上曾贴着你的海报。”</p></blockquote><h2 id="种族歧视"><a href="#种族歧视" class="headerlink" title="种族歧视"></a>种族歧视</h2><p>自马丁路德金在万人演讲的历史时刻喊出：”我有一个梦想“，”黑人运动的斗争和抗议行为开始在西方世界如火如荼的展开了。黑人反抗来自白人的歧视和不公正待遇。<br>需要知道的是，华人在美国地位还不如黑人，更不用提以黑人球员为主的NBA。当某些黑人开始有意的排斥和歧视黄种人，从某种意义上，他们是种族主义的受害者的同时也是施暴者。<br>林书豪在NBA会受到不公正的待遇和轻视，这种情况并不少见，我们很多人从没在美国亲身感受这种感觉，林书豪就是一个替身，透过他的人生经历，我们可以了解真实存在的种族歧视。</p><h2 id="真硬汉or小混混"><a href="#真硬汉or小混混" class="headerlink" title="真硬汉or小混混"></a>真硬汉or小混混</h2><blockquote><p>“林没有拿马丁有中文纹身这事恶心马丁，他是拿它当论据，证明双方都尊重并欣赏对方的文化”–美国论坛网友评论</p></blockquote><p>林书豪在马丁对他的这盘评论后，回了一些和善的话。林的讲话旨在希望少数群体求同存异，团结一致。我们可以从这些话里面感受到林书豪的胸怀和领袖气质。没错，林现在就是篮网的领袖，而相反，马丁好像在装硬汉，觉得自己是混道上的。马丁身上都有中文纹身【患得患失】，然后他还觉得林书豪扎脏辫是为了成为黑人？？更糟糕的是，他那个中文纹身根本不是他想要的意思。他觉得那意味着永不满足。</p><p>一轮交锋下来，马丁输得一败涂地，而且林书豪保持了自己的风度。</p><h2 id="“林书豪是美国人不是中国人，为什么粉他-”。"><a href="#“林书豪是美国人不是中国人，为什么粉他-”。" class="headerlink" title="“林书豪是美国人不是中国人，为什么粉他?”。"></a>“林书豪是美国人不是中国人，为什么粉他?”。</h2><blockquote><p>在中国人们把林看做外国人，忽视他和我们的血脉关联。殊不知，美国的白人黑人也没把他这个华人当地道的美国人，而是与亚洲人同类。林书豪是在美国的华人华侨心目中不折不扣的华人之光。</p></blockquote><p>拜托，这些球迷喜欢的乔丹、科比、麦迪、詹姆斯他们难道是中国人么？<br>时下库里在中国的人气可谓如日中天，克莱，詹姆斯等球星中国行无不粉丝簇拥；2008北京奥运会当镜头扫到科比，整个体育场的气氛瞬间燃烧，但他们和中国国籍沾边么。<br>林书豪祖籍是浙江省嘉兴市平湖，祖辈移居台湾彰化，父母70年代移民到美国。毕业于哈佛大学，主修经济学，副修社会学。<br>林的大学生涯是毕业，而非肄业。这区别于大多数nba球员，也许你会想到蒂姆邓肯也有大学学业【心理学学士】，你会感觉到有完整大学经历的球员，情商智商不会低。<br>林这种高情商且不卑不亢的言行举止会吸粉，你不觉得么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="生活" scheme="http://martist.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>laravel核心概念</title>
    <link href="http://martist.cn/2017/09/27/laravel%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://martist.cn/2017/09/27/laravel核心概念/</id>
    <published>2017-09-26T16:00:00.000Z</published>
    <updated>2017-10-03T05:33:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>本文是基于laravel 5.1项目源码解析的。</p><h1 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h1><p>route.php文件中，</p><pre><code>Class Foo{}//如果没有这个class会报错。Route::get(&apos;/&apos;,function(Foo $foo){  dd($foo);});</code></pre><p>Foo $foo 是依赖注入的写法，</p><p>laravel框架利用反射机制，尝试解释语义Foo $foo，<br>在laravel内核执行实例化</p><pre><code>$foo = new Foo();</code></pre><p>当laravel尝试new依赖的这个类，找不到的话就会报错找不到这个类。</p><p>当laravel找到的依赖的类。这个类本身依赖注入的类不明确时。<br>会爆其他错误：不能解析。</p><p>另一种方式</p><p>当使用App:bind这个方法时，laravel会优先通过这里加载这个类<br>而不是 反射机制 根据命名空间或者require路径去寻找。</p><pre><code>App::bind(&apos;Foo&apos;,function(){    dd(&apos;called here&apos;);    return new Foo();})</code></pre><hr><h1 id="service-provider"><a href="#service-provider" class="headerlink" title="service provider"></a>service provider</h1><p>service provider 的类中，有意义的是register（）方法，</p><p>在index.php里面有$app这个变量，这是框架的核心。</p><pre><code>$this-&gt;app-&gt;sigleton(&apos;files&apos;,functionZ(){    return new Filesystem;})</code></pre><p>在这里的‘files’我们可以看做键名，指向Filesystem这个类的实例化。<br>这样我们可以在路由中试用下看看。</p><pre><code>Route::get(&apos;/&apos;,function(Foo $foo){  $content = app(&apos;files&apos;)-&gt;get(__DIR__.&apos;/kernel.php&apos;);  dd($content);});//打印出来这个文件的内容</code></pre><p>使用service provider中注册并提供一个简明的键名去申明这个类，<br>可以节约代码，易于管理。</p><h1 id="在Ioc容器中添加自己的类"><a href="#在Ioc容器中添加自己的类" class="headerlink" title="在Ioc容器中添加自己的类"></a>在Ioc容器中添加自己的类</h1><p>比如说项目中需要收费的功能，</p><p>app目录下新建目录billing，生成类文件</p><pre><code>Class stripe{  public function pay(){        dd(&apos;I pay&apos;);    }}</code></pre><p>artisan命令：<br>php artisan  make:provider BillingServicePovider</p><p>在 app/Providers目录下生成BillingServicePovider.php文件，<br>里面有意义的就是register（），我们在这里面注册stripe类。</p><pre><code>public function register(){  $this-&gt;app-&gt;bind(&apos;billing&apos;,fintion(){    return new Stripe();    });}</code></pre><p>再把它放到IOC容器中，config/app.php中添加。</p><p>此时，app(‘billing’)就可以相当于new Stripe()了。</p><p>app(‘billing’)-&gt;pay();//输出 I pay</p><h1 id="Facade-门面-运行机制"><a href="#Facade-门面-运行机制" class="headerlink" title="Facade(门面)运行机制"></a>Facade(门面)运行机制</h1><p>config/app.php下  alias数组，</p><p>用IDE的查找类的功能点进去，比如点route,Mail<br>进去一个类是继承的Facade，</p><p>里面有 getFacadeAccessor()函数返回一个字符串，//return ‘mailer’;<br>这个字符串对应MailserviceProvider.php中register()的字符串。</p><p>Facade类里面有__callStatic(),里面有</p><pre><code>$instance = static::getFacadeRoot();//IOC容器生成$instance，可以使用真正类中的方法//看下面pubilic static function getFacadeRoot(){  return static::resolveFacadeInstance(static::getFacadeAccessor());//app(&apos;mailer&apos;);}</code></pre><p>流程：</p><p>app.php下的别名数组的值指向一个类，这个类通过返回给Facade一个字符串实现app（‘name’）,<br>然后通过serviceProvider去注册返回实例化之后的类。</p><hr><h1 id="contract-契约"><a href="#contract-契约" class="headerlink" title="contract (契约)"></a>contract (契约)</h1><p>在项目目录framework/src/Illuminate/Contracts下面定义了很多interface。</p><p>面向接口编程。在依赖注入中很大好处。该目录下的类都是接口类。</p><p>比如：Config真正是新的类，在Illuminate\Contracts\Config\Repository，</p><p>app()方法:</p><pre><code>dd(app(&apos;Illuminate\Contracts\Config\Repository&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysqldd(Config::get());//可以看到laravel的配置dd(app(&apos;config&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysql</code></pre><p>contract给出整个框架给出的扩展接口，比如config类不能满足你的需求，<br>可以自己集成config接口实现这个类。</p><h1 id="Container的背后"><a href="#Container的背后" class="headerlink" title="Container的背后"></a>Container的背后</h1><p>这几种的返回结果都一样</p><pre><code>dd(Hash::make(&apos;pwd&apos;));//dsdsvdrssrbsssret5u4h6l8mdd(app(&apos;Hash&apos;)-&gt;make(&apos;pwd&apos;));dd(app()[&apos;Hash&apos;]-&gt;make(&apos;pwd&apos;));dd(app(&apos;Illuminate\Hashing\BcryptHasher&apos;)-&gt;make(&apos;pwd&apos;));</code></pre><p>想知道laravel单个功能的源代码，比如hash的功能，去serviceProvider去找。</p><pre><code>$this-&gt;app-&gt;singleton(&apos;hash&apos;,function(){  return new BcryptHasher;})</code></pre><p>singleton，bind是在核心的Contianer里面，</p><p>callFunction 是 Clouse ，会在singleton，bind中进行判断。</p><p>singleton，将hash的值保存到container的binding数组。</p><p>make(),build()可以通过serviceProvider、别名实现实例。</p><p>app（）判断传入的是key =&gt; serviceProvider去实现实例</p><p>包含命名空间的类 =&gt; Application.php  中 registerCoreContainerAliases()</p><p>Application.php里面是laravel的核心内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant之Homestead</title>
    <link href="http://martist.cn/2017/09/11/homestead/"/>
    <id>http://martist.cn/2017/09/11/homestead/</id>
    <published>2017-09-10T16:00:00.000Z</published>
    <updated>2017-10-13T12:01:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>[TOC]</p><h2 id="开发环境的需求"><a href="#开发环境的需求" class="headerlink" title="开发环境的需求"></a>开发环境的需求</h2><p>平时自己码代码用laravel框架，laravel 5.5LTS 要求： </p><pre><code>PHP &gt;= 7.0.0PHP OpenSSL 扩展PHP PDO 扩展PHP Mbstring 扩展PHP Tokenizer 扩展PHP XML 扩展</code></pre><p>公司开发目前用tp框架，要求PHP版本和生产环境保持一致，PHP = 5.6.*，php版本不同，怎么解决呢？</p><p>Vagrant 提供了一种简单、优雅的方式来管理和配置虚拟机。</p><h2 id="什么是homestead"><a href="#什么是homestead" class="headerlink" title="什么是homestead"></a>什么是homestead</h2><p>Laravel Homestead 是一个官方预封装的 Vagrant Box<br>（推荐使用macbook或linux环境进行开发， 如果你使用的是 Windows，你可能需要通过 BIOS 来启用硬件虚拟化（VT-x）。如果你在 UEFI 系统上使用 Hyper-V，可能还需要禁用 Hyper-V 才能启用 VT-x。）</p><h2 id="内置软件"><a href="#内置软件" class="headerlink" title="内置软件"></a>内置软件</h2><pre><code>Ubuntu 16.04GitPHP 7.1NginxMySQLMariaDBSqlite3PostgresComposerNode (带有 Yarn、Bower、Grunt 和 Gulp)RedisMemcachedBeanstalkdMailhogngrok</code></pre><p>这是相当丰富的一份清单，如果还有其他的软件需求可以继续安装，定制属于开发团队的box。</p><h2 id="安装与设置"><a href="#安装与设置" class="headerlink" title="安装与设置"></a>安装与设置</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>在启动 Homestead 环境之前，你必须先安装 VirtualBox 5.1， Vagrant。</p><h3 id="安装-Homestead-Vagrant-Box"><a href="#安装-Homestead-Vagrant-Box" class="headerlink" title="安装 Homestead Vagrant Box"></a>安装 Homestead Vagrant Box</h3><pre><code>vagrant box add laravel/homestead</code></pre><p><strong>注：如果上面的命令运行失败，请确保你的 Vagrant 是最新版本的 。</strong></p><h3 id="安装-Homestead"><a href="#安装-Homestead" class="headerlink" title="安装 Homestead"></a>安装 Homestead</h3><p>将代码库克隆到用户「home」目录下的 Homestead 文件夹中。这样 Homestead Box 就可以作为所有 Laravel 项目的主机：</p><pre><code>cd ~git clone https://github.com/laravel/homestead.git Homestead</code></pre><p>由于 Homestead 的 master 分支并不是稳定分支，你应该用打过标签的稳定版本。你可以在 Github 发行页面 上找到最新的稳定版本。</p><pre><code>cd Homestead// Clone the desired release...git checkout v6.1.0</code></pre><p>克隆 Homestead 代码库后，从 Homestead 目录中运行 <code>bash init.sh</code> 命令来创建 Homesstead.yaml 配置文件。 Homesstead.yaml 文件会被放置在你的 Homestead 目录中：</p><pre><code>// Mac / Linux...bash init.sh// Windows...init.bat</code></pre><h3 id="配置-Homestead"><a href="#配置-Homestead" class="headerlink" title="配置 Homestead"></a>配置 Homestead</h3><h4 id="配置提供器"><a href="#配置提供器" class="headerlink" title="配置提供器"></a>配置提供器</h4><p>Homestead.yaml 中的 provider 参数设置决定了你用的是哪一个 Vagrant 提供器：virtualbox、vmware_fusion、vmware_workstation 或者 parallels。你可以根据自己的喜好来设置提供器：</p><pre><code>provider: virtualbox</code></pre><h4 id="配置共享文件夹"><a href="#配置共享文件夹" class="headerlink" title="配置共享文件夹"></a>配置共享文件夹</h4><p>Homestead.yaml 文件的 folders 属性里列出所有与 Homestead 环境共享的文件夹。这些文件夹中的文件若有变更，它们会保持本地机器与 Homestead 环境之间同步。你可以根据需要配置多个共享文件夹：</p><pre><code>folders:    - map: ~/Code      to: /home/vagrant/Code</code></pre><p>若要启动 NFS，只需要在共享的文件夹配置中添加一个简单的标志：</p><pre><code>folders:    - map: ~/Code      to: /home/vagrant/Code      type: &quot;nfs&quot;</code></pre><p>使用 NFS 时，建议你安装 vagrant-bindfs 插件。这个插件会替你处理 Homestead Box 中的文件或目录权限问题。</p><p>你也可以通过在 options 下方列出 Vagrant 的 共享文件夹 支持的任何选项：</p><pre><code>folders:    - map: ~/Code      to: /home/vagrant/Code      type: &quot;rsync&quot;      options:          rsync__args: [&quot;--verbose&quot;, &quot;--archive&quot;, &quot;--delete&quot;, &quot;-zz&quot;]          rsync__exclude: [&quot;node_modules&quot;]</code></pre><h2 id="配置-Nginx-站点"><a href="#配置-Nginx-站点" class="headerlink" title="配置 Nginx 站点"></a>配置 Nginx 站点</h2><h3 id="添加配置信息"><a href="#添加配置信息" class="headerlink" title="添加配置信息"></a>添加配置信息</h3><p>对 Nginx 不熟悉吗？没关系。sites 属性可以帮助你可以轻松地将 域名 映射到 homestead 环境中的文件夹。Homestead.yaml 文件中已包含示例站点配置。同样的，你也可以增加多个站点到你的 Homestead 环境中。 Homestead 可以同时为多个 Laravel 应用提供虚拟化环境：</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public</code></pre><p>增加其他的 Nginx 站点。你可以在单个 Homestead 环境中运行多个 Laravel 程序。要添加其他网站，只需将网站配置信息添加到 Homestead.yaml 文件中：</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public    - map: another.app      to: /home/vagrant/Code/another/public</code></pre><h3 id="配置生效"><a href="#配置生效" class="headerlink" title="配置生效"></a>配置生效</h3><p>如果你在配置 Homestead Box 之后更改了 sites 属性，那么应该重新运行命令来更新虚拟机上的 Nginx 配置</p><pre><code>vagrant reload --provision</code></pre><h3 id="Hosts-文件"><a href="#Hosts-文件" class="headerlink" title="Hosts 文件"></a>Hosts 文件</h3><p>你必须将在 Nginx 站点中所添加的「域名」也添加到你机器的 hosts 上。 hosts 文件会将 Homestead 站点的请求重定向到 Homestead Box 中。在 Mac 或 Linux 上，该文件位于 <code>/etc/hosts</code>。在 Windows 上，它位于 <code>C:\Windows\System32\drivers\etc\hosts</code>。添加的内容如下所示：</p><pre><code>192.168.10.10  homestead.app</code></pre><p>之后再添加其他站点，直接在这行之后加上就可以了，比如：</p><pre><code>192.168.10.10  homestead.app  paper.app  mar.com # ...</code></pre><p>请确保列出的 IP 地址是你 Homestead.yaml 文件中的 IP 地址。将域名设置到 hosts 文件并启动 Vagrant Box后，就可以访问了。</p><h2 id="启动-Vagrant-Box"><a href="#启动-Vagrant-Box" class="headerlink" title="启动 Vagrant Box"></a>启动 Vagrant Box</h2><p>根据你的喜好完成 Homestead.yaml 的编辑后，再从 Homestead 目录运行  </p><pre><code>vagrant up</code></pre><p>Vagrant 将启动虚拟机并自动配置你的共享文件夹和 Nginx 站点。</p><p>你可以通过 Web 浏览器访问该站点：</p><pre><code>http://homestead.app</code></pre><p>如果要删除虚拟机，使用 <code>vagrant destroy --force</code> 命令。</p><h2 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h2><p>如果你想在系统的任何地方都可以使用 vagrant up 命令启动 Homestead，你可以在 Mac / Linux 系统的 Bash 配置文件中添加 Bash 函数。在 Windows 中，你可以通过在 PATH 环境变量中添加一个「批处理」文件来实现。下面这些脚本使你可以从系统的任何地方运行任何 Vagrant 命令，并将自动将该命令指向你的 Homestead 安装路径：</p><h3 id="Mac-Linux"><a href="#Mac-Linux" class="headerlink" title="Mac / Linux"></a>Mac / Linux</h3><pre><code>function homestead() {    ( cd ~/Homestead &amp;&amp; vagrant $* )}</code></pre><p>确保将该功能中的 ~/Homestead 路径是你实际的 Homestead 安装路径。这样你就可以在系统的任何地方运行 <code>homestead up</code>或<code>homestead ssh</code> 等命令。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在系统的任意位置创建一个批处理文件<code>homestead.bat</code>，并添加如下内容：</p><pre><code>@echo offset cwd=%cd%set homesteadVagrant=C:\Homesteadcd /d %homesteadVagrant% &amp;&amp; vagrant %*cd /d %cwd%set cwd=set homesteadVagrant=</code></pre><h2 id="通过-SSH-连接"><a href="#通过-SSH-连接" class="headerlink" title="通过 SSH 连接"></a>通过 SSH 连接</h2><p>你可以通过在 Homestead 目录运行vagrant命令来连接虚拟主机</p><pre><code>vagrant ssh </code></pre><p>配置全局使用后，可以使用homestead命令管理</p><pre><code>homestead uphomestead ssh</code></pre><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>在 Box 中已经为 MySQL 和 Postgres 配置好了一个数据库 homestead。为了更方便的使用它，Laravel 中的 .env 文件将框架配置成默认使用此数据库。</p><p>要从主机的数据库客户端连接到 MySQL 或 Postgres，就连接到 127.0.0.1 和端口 33060 (MySQL) 或 54320 (Postgres)。账号密码分别是 homestead／secret</p><blockquote><p>从主机连接到数据库时，只能使用这些非标准端口。 而 Laravel 在虚拟机中运行时，仍旧使用 Laravel 数据库配置文件中的默认 3306 和 5432 端口</p></blockquote><h2 id="站点类型"><a href="#站点类型" class="headerlink" title="站点类型"></a>站点类型</h2><p>Homestead 支持多种类型的站点，可以让你轻松地运行那些不基于 Laravel 的项目。 例如，我们可以使用 symfony2 站点类型轻松地在 Homestead 中添加 Symfony 应用程序：</p><pre><code>sites:    - map: symfony2.app      to: /home/vagrant/Code/Symfony/web      type: symfony2</code></pre><p>支持的站点类型有： apache、laravel（默认）、proxy、silverstripe、statamic、symfony2 和 symfony4。</p><h2 id="站点参数"><a href="#站点参数" class="headerlink" title="站点参数"></a>站点参数</h2><p>你还可以使用 params 站点指令向你的站点添加其他 Nginx fastcgi_param 值。例如，添加一个值为 BAR 的 FOO 参数。</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public      params:          - key: FOO            value: BAR</code></pre><h2 id="配置-Cron-调度器"><a href="#配置-Cron-调度器" class="headerlink" title="配置 Cron 调度器"></a>配置 Cron 调度器</h2><p>Laravel 提供了便利的方式来 调度 Cron 任务，通过Artisan 命令 schedule:run ，调度便会在每分钟运行一次。schedule:run 命令会检查定义在你 App\Console\Kernel 类中的调度任务，以此判断哪个任务该被运行。</p><p>如果你想对 Homestead 站点使用 schedule:run 命令，你需要在定义站点时将 schedule 选项设置为 true</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public      schedule: true</code></pre><p>该站点的 Cron 任务会被定义在虚拟机的 /etc/cron.d 文件夹中。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>默认情况下，以下端口会被转发至 Homestead 环境：</p><pre><code>SSH: 2222 → 发送到 22HTTP: 8000 → 发送到 80HTTPS: 44300 → 发送到 443MySQL: 33060 → 发送到 3306Postgres: 54320 → 发送到 5432Mailhog: 8025 → 发送到 8025</code></pre><h3 id="转发更多端口"><a href="#转发更多端口" class="headerlink" title="转发更多端口"></a>转发更多端口</h3><p>你可以根据需要转发更多端口给 Vagrant Box，并指定其协议：</p><pre><code>ports:    - send: 50000      to: 5000    - send: 7777      to: 777      protocol: udp</code></pre><h2 id="共享你的环境"><a href="#共享你的环境" class="headerlink" title="共享你的环境"></a>共享你的环境</h2><p>有时候你想跟你的同事或者是客户共享你目前在开展的工作。Vagrant 提供了一个内置方法 vagrant share 来支持。不过，如果你的 Homestead.yaml 文件中配置了多个站点，就无法使用此命令。</p><p>为了解决这个问题，Homestead 提供了自己的 share 命令。开始之前，通过 vagrant ssh SSH 命令连接 Homestead 机器中并运行 share homestead.app。这会从 Homestead.yaml 配置文件中共享 homestead.app 站点。你也可以用其他已经配置的站点来代替 homestead.app。</p><pre><code>share homestead.app</code></pre><p>运行命令后，你可以看到一个 Ngrok 界面，其中包含活动日志和共享站点的可公开访问的 URL。如果要指定自定义地区或者其他 Ngrok 选项，可以将它们添加到 share 命令后面：</p><pre><code>share homestead.app -region=eu -subdomain=laravel</code></pre><blockquote><p>谨记，Vagrant 本质上是不安全的。当你运行 share 命令时，你已经在互联网中暴露了你的虚拟机。</p></blockquote><h2 id="多个-PHP-版本"><a href="#多个-PHP-版本" class="headerlink" title="多个 PHP 版本"></a>多个 PHP 版本</h2><blockquote><p>此功能仅与 Nginx 兼容。</p></blockquote><p>Homestead 6 支持在同一个虚拟机上引入多个版本的 PHP。你可以在 Homestead.yaml 文件中为给定站点指定使用哪个版本的 PHP。 可用的 PHP 版本有：「5.6」、「7.0」、「7.1」</p><pre><code>sites:    - map: homestead.app      to: /home/vagrant/Code/Laravel/public      php: &quot;5.6&quot;</code></pre><p>此外，你还可以通过 CLI 使用任何受支持的 PHP 版本：</p><pre><code>php5.6 artisan listphp7.0 artisan listphp7.1 artisan list</code></pre><h2 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h2><p>Homestead.yaml 的 networks 属性为 Homestead 环境配置网络接口。你可以根据需要配置任意数量的接口：</p><pre><code>networks:    - type: &quot;private_network&quot;      ip: &quot;192.168.10.20&quot;</code></pre><p>想启用 桥接 接口，请配置 bridge 设置，并将网络类型更改为 public_network ：</p><pre><code>networks:    - type: &quot;public_network&quot;      ip: &quot;192.168.10.20&quot;      bridge: &quot;en1: Wi-Fi (AirPort)&quot;</code></pre><p>要启用 DHCP，只需从配置中删除 ip 选项：</p><pre><code>networks:    - type: &quot;public_network&quot;      bridge: &quot;en1: Wi-Fi (AirPort)&quot;</code></pre><h2 id="更新-Homestead"><a href="#更新-Homestead" class="headerlink" title="更新 Homestead"></a>更新 Homestead</h2><p>你可以通过两个简单的步骤更新 Homestead。首先，使用 vagrant box update 命令更新 Vgrant Box :</p><pre><code>vagrant box update</code></pre><p>接下来，如果你是通过克隆仓库的方式来安装的 Homestead，你需要更新 Homestead 的源代码。你可以在你最初克隆仓库的位置简单地运行 git pull origin master 命令。</p><p>如果你是通过项目中的 composer.json 文件安装 Homestead ，则应该确认 composer.json 文件中包含 “laravel/homestead: “^6” 并更新依赖：</p><pre><code>composer update</code></pre><h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><pre><code>如果你需要一个旧版本的 PHP，请在尝试使用旧版本的 Homestead 之前，先阅读文档 多个 PHP 版本 上的文档。</code></pre><p>你可以通过添加以下内容添加到 Homestead.yaml 文件中来覆盖 Homestead 使用的 Box 版本:</p><pre><code>version: 0.6.0</code></pre><p>例如：</p><pre><code>box: laravel/homesteadversion: 0.6.0ip: &quot;192.168.20.20&quot;memory: 2048cpus: 4provider: virtualbox</code></pre><p>当你使用较旧版本的 Homestead Box 时，你需要确保将其与 Homestead 源代码的兼容版本进行匹配。下面的图表展示了支持的 Box 版本，使用哪个版本的 Homestead 源代码以及提供的 PHP 版本</p><pre><code>Homestead   Version  Box VersionPHP 7.0     3.1.0      0.6.0PHP 7.1     4.0.0      1.0.0PHP 7.1     5.0.0      2.0.0PHP 7.1     6.0.0      3.0.0</code></pre><h2 id="提供器的特殊设置"><a href="#提供器的特殊设置" class="headerlink" title="提供器的特殊设置"></a>提供器的特殊设置</h2><p>在VirtualBox作为提供器的情况下，Homestead 默认将 natdnshostresolver 设置为 on。这允许 Homestead 使用主机系统中的 DNS 设置。如果你想重写这行为，你可以在你的 Homestead.yaml 文件中添加下面这几行：</p><pre><code>provider: virtualboxnatdnshostresolver: off</code></pre><h2 id="要关注"><a href="#要关注" class="headerlink" title="要关注"></a>要关注</h2><p>具体关于vagrant的安装，使用和项目实践，可以关注我的看云，地址如下</p><p><a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="vagrant" scheme="http://martist.cn/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant之入门</title>
    <link href="http://martist.cn/2017/07/29/Vagrant%E4%B9%8B%E5%85%A5%E9%97%A81/"/>
    <id>http://martist.cn/2017/07/29/Vagrant之入门1/</id>
    <published>2017-07-28T16:00:00.000Z</published>
    <updated>2017-10-13T12:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><pre><code>下载 VirtualBox 虚拟器 : https://www.virtualbox.org/下载安装 Vagrant : http://www.vagrantup.com/下载使用的 box (这里的 box 指的是系统) : http://www.vagrantbox.es/在本地建立一个工作文件夹</code></pre><p>VirtualBox是虚拟机，Vagrant是管理虚拟机的工具，.box文件相当于在虚拟机内构建系统的镜像。</p><p>首先需要下载并安装VirtualBox，Vagrant，准备好镜像文件(.box)。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>查看当前添加进 vagrant 的镜像</p><pre><code>vagrant box list </code></pre><p>一开始是没有添加 box 镜像, 我们执行 <code>vagrant box add 系统名字 box镜像</code>；另一种情况是在线拉取镜像，可以忽略这一步</p><pre><code>vagrant box add hashicorp/precise64</code></pre><p><code>hashicorp/precise64</code> 镜像可以是 <code>add</code> 之前准备好的，放在执行命令的当前目录的，也可以没有准备，在线拉取，是否提前下载镜像，这取决于你的网速。当开发团队统一开发环境而分发给你一个镜像，那就直接<code>add</code>这个镜像文件的文件名就可以了，当你初始化的时候会默认选择list的镜像文件。</p><p>初始化镜像</p><pre><code>vagrant init hashicorp/precise64</code></pre><p>该命令会在当前目录下创建<code>Vagrantfile</code>，并且指定所使用的box为ubuntu/trusty64，该box由Hashicorp官网提供。此时，Vagrant发现box的名字的格式为“用户名/box名”，则会使用 <code>“https://atlas.hashicorp.com/用户名/box名”</code> 来下载该box。对于非官网提供的box，可以通过以下命令创建：</p><pre><code>vagrant init my-box https://boxes.company.com/my.box</code></pre><p>此时你可以通过更改<code>Vagrantfile</code>，来完成你的配置。因为我们虚拟机默认只分配一个访问外网的 IP, 项目使用的 IP 得手动设置打开 Vagrantfile 找到29行(我的配置文件在29行)设置一个私有 IP，默认是192.168.33.10。</p><p>其中，my-box为该box的名字，后面的URL为该box的下载地址。</p><p>启动虚拟机</p><pre><code>vagrant up</code></pre><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>登录到虚拟机</p><pre><code>vagrant ssh</code></pre><p>此时vagrant将使用默认的用户vagrant以及预设的SSH公钥密钥键值对直接登录虚拟机。</p><p>关闭虚拟机：</p><pre><code>vagrant halt</code></pre><p>删除虚拟机：</p><pre><code>vagrant destroy</code></pre><p>请注意，vagrant destroy只会删除虚拟机本身，也即你在Virtualbox将看不到该虚拟机，但是不会删除该虚拟机所使用的box。</p><p>删除某个box的命令</p><pre><code>vagrant box remove box-name</code></pre><p>虚拟机里面的<code>/vagrant</code> 这个文件夹是和当前目录保持同步。是不是很有趣，这样我们以后从服务器拉取下来的项目放在虚拟机中，操作系统的本地保目录持同步，这样关闭虚拟机或者虚拟机异常退出了，项目也不会随之销毁，vagrant的带来的开发优势显而易见。</p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><pre><code>$ vagrant box add NAME URL #添加一个box$ vagrant box list #查看本地已添加的box$ vagrant box remove NAME virtualbox #删除本地已添加的box，如若是版本1.0.x，执行$ vagrant box remove NAME$ vagrant init NAME #初始化，实质应是创建Vagrantfile文件$ vagrant up #启动虚拟机$ vagrant halt #关闭虚拟机$ vagrant destroy #销毁虚拟机$ vagrant reload #重启虚拟机$ vagrant package #当前正在运行的VirtualBox虚拟环境打包成一个可重复使用的box$ vagrant ssh #进入虚拟环境*$ vagrant port #查看ip和端口</code></pre><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>全部vagrant命令请查询 ： <a href="https://www.vagrantup.com/docs/cli/index.html" target="_blank" rel="external">https://www.vagrantup.com/docs/cli/index.html</a></p><h2 id="要关注"><a href="#要关注" class="headerlink" title="要关注"></a>要关注</h2><p>具体关于vagrant的安装，使用和项目实践，可以关注我的看云，地址如下</p><p><a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="vagrant" scheme="http://martist.cn/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>ssh服务为web生产服务器保驾护航</title>
    <link href="http://martist.cn/2017/07/27/ssh/"/>
    <id>http://martist.cn/2017/07/27/ssh/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-10-03T05:40:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们给自己的博客搭建一个站点，配置lnmp/lamp运行环境可以跑起来，差不多就完事了。但是当我们做的是一个中型或者大型项目，在它需要部署到生产服务器上线运营时，账户安全方面需要做些什么？</p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>apt-get install openssh-server</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>/etc/init.d/ssh start  </code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>ssh  martist@192.168.123.3//ssh远程连接服务器，需要输入用户密码</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="主机名管理"><a href="#主机名管理" class="headerlink" title="主机名管理"></a>主机名管理</h3><p>一个中型甚至大型的的项目，往往需要对多台服务器进行管理，如生产服务器，测试服务器，管理服务器等等。因此需要对每一台服务器的主机名进行管理，通过修改各个服务器的/etc/hostname文件修改本地系统名，重启可以看到。</p><h3 id="密钥ssh登录"><a href="#密钥ssh登录" class="headerlink" title="密钥ssh登录"></a>密钥ssh登录</h3><p>linux或Mac下生成密钥的命令是 <code>ssh-keygen -t rsa</code> 默认生成路径在家目录的.ssh目录下。id_rsa 文件保存的是本机的私钥，id_rsa.pub文件保存的是公钥。<br> ifconfig命令查看服务器的IP地址，注意如果你是用的是阿里云ECS，此处查看到的是内网IP而非公网IP。<br>在被登录的服务器的家目录下的.ssh目录（如果不存在就创建一个）创建一个authorized_keys 文件，并将生成的公钥文件的内容放到里面，就可以在本地使用密钥登陆这台服务器了。</p><pre><code>ssh  martist@192.168.123.3//此时不需要输入用户名密码</code></pre><p>如果我们关闭密码登陆，转而使用ssh密钥登录，更可以确保服务安全（注意：关闭密码登陆前，一定要确保能够正常使用ssh密钥登陆）。</p><h3 id="关闭密码登陆"><a href="#关闭密码登陆" class="headerlink" title="关闭密码登陆"></a>关闭密码登陆</h3><p>找到/etc/ssh/sshd_config 修改PasswordAuthentication 属性 yes。<br>在第52行，yes改为no，禁用密码登陆（慎用）。</p><h2 id="详细实战分析"><a href="#详细实战分析" class="headerlink" title="详细实战分析"></a>详细实战分析</h2><p>线上：阿里云ECS云服务器 Ubuntu14.04lts </p><p>Manager服务器生成ssh密钥</p><pre><code>ssh-keygen -t rsa  //一路回车</code></pre><p>生成的密钥保存在家目录下，进入.ssh目录下，</p><pre><code>ls//查看文件id_rsa id_rsa.pub know_hosts </code></pre><p>Manager服务器上在 /etc/hosts 文件里加上重定向的名字，如测试服务器，DB服务器和Manager服务器分别起一个重定向名字便于管理多台web服务器。<br>修改本地定向网络ip（阿里云的内网ip）的文件 </p><pre><code>vi /etc/hosts //写入 10.162.48.184 FWEB1//每次在终端输入‘FWEB1’，就代表‘10.162.48.184’。</code></pre><p>在mannager服务器上，试一下ssh登录web1服务器</p><pre><code>ssh root@FWEB1  </code></pre><p>退出</p><pre><code>exit</code></pre><p>在mannager服务器上，试一下文件上传web1服务器</p><pre><code>scp  ./id_rsa.pub root@FWEB1:/root</code></pre><p>现在还是需要输入密码，不过等一会把密钥加到web服务器上，再从manager登录web服务器，就不需要输入密码了。</p><p>在web1服务器，家目录下创建.ssh目录</p><pre><code>ssh root@FWEB1 // 输入密码mkdir ~/.ssh</code></pre><p>在web1服务器，把id_rsa.pub传递到.ssh/目录下</p><p>   cat id_rsa.pub &gt;&gt; .ssh/id_rsa.pub   </p><p>此时，再从id_rsa.pub设置到web服务器（FWEB1）本地.</p><p>文件改名</p><pre><code>mv id_rsa.pub authorized_keys</code></pre><p>给执行权限</p><pre><code>chmod 600 ./authorized_keys</code></pre><p>退出ssh远程登录</p><pre><code>exit</code></pre><p>此时回到manager服务器</p><pre><code> ssh  root@FWEB1//此时密码不用输就可以进入FWEB1</code></pre><p>随便上传个文件，试试</p><pre><code>scp know_hosts root@FWEB1:/tmp/</code></pre><p>此后，在manager服务器向web服务器，scp传送东西,不需要再输入密码了。</p><p>原理：manager服务器私钥自己留着，把公钥给所有的web，DB，备份服务器，就可以便捷管理了。</p><h3 id="关闭web服务器的密码登陆"><a href="#关闭web服务器的密码登陆" class="headerlink" title="关闭web服务器的密码登陆"></a>关闭web服务器的密码登陆</h3><p>找到/etc/ssh/sshd_config 修改PasswordAuthentication 属性 yes。在第52行，yes改为no，禁用密码登陆。<br>修改sshd_config文件中ssh端口，ssh端口默认为 22. 把端口号改为1000以上的数值。</p><pre><code>默认：Port:22改为：Port 1678</code></pre><p>:wq //退出vi编辑器。</p><pre><code>reboot //重启生效</code></pre><p>ssh登录目的服务器命令</p><p>   root@FWEB1</p><p>有点麻烦？可以创建自己的别名</p><pre><code>vi ~/.bash_profile//写入  alias fewb1=&apos;ssh root@FWEB1 -p 1678&apos;//(-p 为端口号)</code></pre><p>好，:wq 保存退出。</p><p>使他生效</p><pre><code>source .bash_profile </code></pre><p>查看别名</p><pre><code>alias</code></pre><p>在manager服务器下，把某个文件夹下全部文件推送到web服务器。</p><pre><code>scp -p 1678 ./* root@FWEB1:/tmp/ //（需要被传送文件的web服务器有这个文件夹）</code></pre><p>把服务器其上的东西上传上去，是这样写， 把web服务器的东西下载到本地，只要把这俩目录倒过来，就可以了。</p><p>技巧：</p><pre><code>cd ~mkdir sh vi pushcode.sh//在这里写shell脚本</code></pre><p>shell脚本的写法，开头‘#！’，后面是 shell可执行命令的位置。</p><pre><code> #！/bin/shscp -p 1678 ./var/www.machuang.name/* root@FWEB1:/var/www/machuang.name</code></pre><p>好！:wq 保存推出。</p><p>给执行权限</p><pre><code>chmod 755 /root/sh/pushcode.sh</code></pre><p>Ls查看下</p><pre><code>ls /root/sh</code></pre><p>此时看到pushcode.sh变成绿色，就对了。以后敲入这段命令，就可以完成上传代码的功能了。</p><pre><code>/root/sh/pushcode.sh</code></pre><p>就可以执行脚本内的命令了，此时再加一个别名。</p><pre><code>cd ~vi .bash_profile//写入  alias pushcode=&apos;/root/sh/pushcode.sh&apos;//:wq 保存退出</code></pre><p>好，使它生效，否则要重启才能生效。</p><pre><code>source .bash_profile</code></pre><p>上传代码：</p><pre><code>pushcode</code></pre><p>这样一个具备业务逻辑的ssh服务使用就展现在你面前了，单一的使用一个工具并不显得立体，多种linux软件和命令有机结合在一起才能迸发出更大的能量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant-流行的环境部署工具</title>
    <link href="http://martist.cn/2017/07/21/Vagrant/"/>
    <id>http://martist.cn/2017/07/21/Vagrant/</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-10-13T12:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vagrant 是一个基于 Ruby 的工具，用于创建和部署虚拟化开发环境。它使用 Oracle 的开源 VirtualBox 虚拟化系统，使用 Chef 创建自动化虚拟环境。</p><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><pre><code>支持快速新建虚拟机支持快速设置端口转发支持自定义镜像打包（原始镜像方式、增量补丁方式）基本上日常能用到的基础配置都能快速设置支持开机启动自动运行命令可以自己写扩展</code></pre><h2 id="解决实际问题"><a href="#解决实际问题" class="headerlink" title="解决实际问题"></a>解决实际问题</h2><p>在商业化项目的多人协同开发中，统一开发环境是非常重要的，让开发环境尽可能的接近生产环境，对项目的稳定性起着不可忽视的作用。</p><p>我们可以通过 Vagrant 封装一个 Linux 的开发环境，里面是一致的开发环境、软件版本,把它（.box）分发给团队成员。成员可以在自己的操作系统（Mac/Windows/Linux）上开发程序，代码却能统一在封装好的环境里运行，而不受操作系统影响。</p><h2 id="要关注"><a href="#要关注" class="headerlink" title="要关注"></a>要关注</h2><p>具体关于vagrant的安装，使用和项目实践，可以关注我的看云，地址如下</p><p><a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="vagrant" scheme="http://martist.cn/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用消息队列</title>
    <link href="http://martist.cn/2017/05/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://martist.cn/2017/05/13/为什么使用消息队列/</id>
    <published>2017-05-12T16:00:00.000Z</published>
    <updated>2017-10-02T15:39:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h1><p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息队列在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><h1 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h1><p>有时在处理数据的时候处理过程会失败。除非数据被持久化，否则将永远丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在被许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理过程明确的指出该消息已经被处理完毕，确保你的数据被安全的保存直到你使用完毕。</p><h1 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h1><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的；只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p><h1 id="灵活性-amp-峰值处理能力"><a href="#灵活性-amp-峰值处理能力" class="headerlink" title="灵活性 &amp; 峰值处理能力"></a>灵活性 &amp; 峰值处理能力</h1><p>当你的应用上了Hacker News的首页，你将发现访问流量攀升到一个不同寻常的水平。在访问量剧增的情况下，你的应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住增长的访问压力，而不是因为超出负荷的请求而完全崩溃。请查看我们关于峰值处理能力的博客文章了解更多此方面的信息。</p><h1 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h1><p>当体系的一部分组件失效，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。而这种允许重试或者延后处理请求的能力通常是造就一个略感不便的用户和一个沮丧透顶的用户之间的区别。</p><h1 id="送达保证"><a href="#送达保证" class="headerlink" title="送达保证"></a>送达保证</h1><p>消息队列提供的冗余机制保证了消息能被实际的处理，只要一个进程读取了该队列即可。在此基础上，IronMQ提供了一个”只送达一次”保证。无论有多少进程在从队列中领取数据，每一个消息只能被处理一次。这之所以成为可能，是因为获取一个消息只是”预定”了这个消息，暂时把它移出了队列。除非客户端明确的表示已经处理完了这个消息，否则这个消息会被放回队列中去，在一段可配置的时间之后可再次被处理。</p><h1 id="排序保证"><a href="#排序保证" class="headerlink" title="排序保证"></a>排序保证</h1><p>在许多情况下，数据处理的顺序都很重要。消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。IronMO保证消息浆糊通过FIFO（先进先出）的顺序来处理，因此消息在队列中的位置就是从队列中检索他们的位置。</p><h1 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h1><p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如,加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行–写入队列的处理会尽可能的快速，而不受从队列读的预备处理的约束。该缓冲有助于控制和优化数据流经过系统的速度。</p><h1 id="理解数据流"><a href="#理解数据流" class="headerlink" title="理解数据流"></a>理解数据流</h1><p>在一个分布式系统里，要得到一个关于用户操作会用多长时间及其原因的总体印象，是个巨大的挑战。消息系列通过消息被处理的频率，来方便的辅助确定那些表现不佳的处理过程或领域，这些地方的数据流都不够优化。</p><h1 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h1><p>很多时候，你不想也不需要立即处理消息。消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它。你想向队列中放入多少消息就放多少，然后在你乐意的时候再去处理它们。</p><h1 id="多语言通信"><a href="#多语言通信" class="headerlink" title="多语言通信"></a>多语言通信</h1><p>比如用php生产一个job，用python或者其他语言作为消费者来处理</p><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>我这这里推荐一种消息队列Beanstalkd，它是一个轻量级消息中间件。</p><p><a href="http://doc.martist.cn/373251" target="_blank" rel="external">http://doc.martist.cn/373251</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git教程(六)</title>
    <link href="http://martist.cn/2017/04/08/git%E6%95%99%E7%A8%8B6/"/>
    <id>http://martist.cn/2017/04/08/git教程6/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2017-10-02T09:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="一、git-commit提交之后，发现有错误怎么办？"><a href="#一、git-commit提交之后，发现有错误怎么办？" class="headerlink" title="一、git commit提交之后，发现有错误怎么办？"></a>一、git commit提交之后，发现有错误怎么办？</h1><p>当commit之后发现代码有错，简单直接的方法就是进行修改代码，然后第二次commit。</p><blockquote><p>这样git log可以看到两次commit的信息</p></blockquote><h2 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h2><p>如果你commit了之后还没有推到远程仓库，commit信息还在本地，此时可以根据git log的hashid来重置commit版本信息。</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><pre><code>git reset –mixed</code></pre><p>此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息</p><pre><code>git reset –soft</code></pre><p>回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可</p><pre><code>git reset –hard</code></pre><p>彻底回退到某个版本，本地的源码也会变为上一个版本的内容</p><h2 id="修改备注信息"><a href="#修改备注信息" class="headerlink" title="修改备注信息"></a>修改备注信息</h2><pre><code>git commit -amend</code></pre><hr><h1 id="二、怎么在项目开始-项目中正确的添加忽略文件或目录？"><a href="#二、怎么在项目开始-项目中正确的添加忽略文件或目录？" class="headerlink" title="二、怎么在项目开始/项目中正确的添加忽略文件或目录？"></a>二、怎么在项目开始/项目中正确的添加忽略文件或目录？</h1><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><h3 id="git-rm与git-rm-–cache的区别"><a href="#git-rm与git-rm-–cache的区别" class="headerlink" title="git rm与git rm –cache的区别"></a>git rm与git rm –cache的区别</h3><p>当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用</p><pre><code>git rm file_pathgit commit -m &apos;delete somefile&apos;git push</code></pre><p>当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制, 可以使用</p><pre><code>git rm --cached file_pathgit commit -m &apos;delete remote somefile&apos;git push</code></pre><p>忽略一个已经被跟踪的目录（再也不管它了）：</p><pre><code>git rm -r --cached direcho dir/ &gt;&gt; .gitignoregit add .gitignoregit commit -am &apos;ignore dir forever&apos;</code></pre><h1 id="三、怎么给git命令创建快捷方式？"><a href="#三、怎么给git命令创建快捷方式？" class="headerlink" title="三、怎么给git命令创建快捷方式？"></a>三、怎么给git命令创建快捷方式？</h1><p>git alias</p><p>第一种方法：<br>git status<br>可以设置为<br>通过配置git本身，</p><p>  git config –global alias.s status</p><p>从此，git s就是git status</p><p>第二种方法:<br>vim ~/.gitconfig</p><p>第三种方法;<br>vi ~/zssrc</p><p>配置系统的别名</p><h1 id="四、git-stach是什么？"><a href="#四、git-stach是什么？" class="headerlink" title="四、git stach是什么？"></a>四、git stach是什么？</h1><p>git stash 可用来暂存当前正在进行的工作， 比如想pull 最新代码， 又不想加新commit， 或者另外一种情况，为了fix 一个紧急的bug,  先stash, 使返回到自己上一个commit, 改完bug之后再stash pop, 继续原来的工作。</p><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><pre><code>$git stash$do some work$git stash pop</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><pre><code>git stash save &quot;work in progress for foo feature&quot;</code></pre><p>当你多次使用’git stash’命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，</p><p>’git stash list’ 命令可以将当前的Git栈信息打印出来，你只需要将找到对应的版本号，例如使用’git stash apply stash@{1}’就可以将你指定版本号为stash@{1}的工作取出来，当你将所有的栈都应用回来的时候，可以使用’git stash clear’来将栈清空。</p><pre><code>git stash          # save uncommitted changes# pull, edit, etc.git stash list     # list stashed changes in this gitgit show stash@{0} # see the last stash git stash pop      # apply last stash and remove it from the listgit stash --help   # for more info</code></pre><h1 id="五、git-rebase是什么？"><a href="#五、git-rebase是什么？" class="headerlink" title="五、git rebase是什么？"></a>五、git rebase是什么？</h1><p>rebase 的概念/作用其实很简单——就是「变基」。具体来说，就是改变一条分支的「基点」，使原分支从指定的地方（commit）重新长出来。并且，由于是一条新分支，你可以随意修改其中的 commits，也就是——重写分支历史。</p><p>而 rebase 的主要目的即删繁就简。</p><p>下面讲下关键步骤：</p><pre><code>git rebase [-i | --interactive] [options] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]    [&lt;upstream&gt; [&lt;branch&gt;]]git rebase [-i | --interactive] [options] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]    --root [&lt;branch&gt;]git rebase --continue | --skip | --abort | --edit-todo</code></pre><p>所有 rebase 的操作对象都是 commit。（你可以 rebase 一个分支 git rebase -i branchX，但实际上还是作用于该分支最新的 commit。）</p><p>以这个 commit 为「新基点」发起 rebase 后，会打印出一篇 commit 历史让你修改。</p><p>其中最常用的修改就是把 commit 前的 pick 改为 s (squash, /skwɔʃ/, 意为挤压)，作用为保留该 commit 作出的修改，但删去该节点，只给它一个留名的机会。(用专业的话讲就是——不保留待合并分支上的历史信息，也不提交、不移动HEAD。）多个以 s 为前缀的 commit 最终会整合成一个 commit，各个 commit 的描述部分也被整合到一起。</p><p>而最终极的修改就是直接删去 commit(s) ——篡改历史。这也就意味着，对应的改动也一并灰飞烟灭。（所以为什么说 rebase 是个危险的操作，就是因为篡改了历史！想想如果别人基于你国正史 fork 了一条分支，而你日后竟变基了会发生什么吧！）</p><p>改完之后 :x（Vim下的保存退出命令），Git 就去检测冲突了，此时类似于合并。<br>合并将按你留下的 commit(s) 重演历史，你可以修改每一次 commit 的具体代码。而如果你不是为了修改，只是为了简化树……我的办法是只留下一条 commit，用最新工程完全覆盖来解决冲突。（不知有没有更好的方法）</p><p>冲突解决完后 git rebase –continue，你就可以正式「书写」历史啦——撰写新的 commit 描述。这时那真是，想怎么写就怎么写~</p><p>这般本地 rebase 完成后，记得 git push -f，-f 用于强制将新历史推送至远程仓库。<br>至此，rebase 就彻底结束了。</p><p>看看你新造的树吧，是不是特简洁，特优美？（如果不是……你 rebase 干嘛……）</p><p>当一个系统的专有名词（黑话）足够多，就创造了文化。</p><p>在贡献开源代码时，git rebase可以直接把log同步过来，而不会有 git merge 的log。</p><h1 id="怎么打标签，打标签有啥用？"><a href="#怎么打标签，打标签有啥用？" class="headerlink" title="怎么打标签，打标签有啥用？"></a>怎么打标签，打标签有啥用？</h1><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。本节我们一起来学习如何列出所有可用的标签，如何新建标签，以及各种不同类型标签之间的差别。<br>列出已有的标签</p><p>列出现有标签的命令非常简单，直接运行 git tag 即可：</p><pre><code>git tagv0.1v1.3</code></pre><p>显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。</p><p>我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：</p><pre><code>git tag -l &apos;v1.4.2.*&apos;v1.4.2.1v1.4.2.2v1.4.2.3v1.4.2.4</code></pre><h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。<br>含附注的标签</p><p>创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：</p><pre><code>git tag -a v1.4 -m &apos;my version 1.4&apos;git tagv0.1v1.3v1.4</code></pre><p>而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p><p>可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。</p><pre><code>git show push_v1.2tag push_v1.2Tagger: machuang &lt;780@qq.com&gt;Date:   Sun Sep 10 12:06:50 2017 +0800version 1.2 project coding end at 2017-8-23.This tag create at 2017-9-10scommit f1759f45b598611231d9e768Merge: f8f4 saf9Author: XScarletAngel &lt;7369@qq.com&gt;Date:   Wed Aug 23 18:30:27 2017 +0800    Merge branch &apos;branch1.2&apos; of git.du.com:admin/admin into branch1.2    * &apos;branch1.2&apos; of git.du.com:admin/admin:      Test</code></pre><p>我们可以看到在提交对象信息上面，列出了此标签的提交者和提交时间，以及相应的标签说明。</p><h2 id="根据commitid打标签"><a href="#根据commitid打标签" class="headerlink" title="根据commitid打标签"></a>根据commitid打标签</h2><pre><code>git tag -a &lt;tag名&gt; &lt;commit对应的hash码&gt;</code></pre><h2 id="tag推送到远程仓库"><a href="#tag推送到远程仓库" class="headerlink" title="tag推送到远程仓库"></a>tag推送到远程仓库</h2><p>默认情况下，git push并不会把tag标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。<br>1.push单个tag，命令格式为：git push origin [tagname]<br>例如：<br>git push origin v1.0 #将本地v1.0的tag推送到远端服务器<br>2.push所有tag，命令格式为：git push [origin] –tags<br>例如：<br>git push –tags<br>或<br>git push origin –tags</p><p>以上命令经检验通过，如果不起作用，请在Git控制台上确认你的账号是否有权限推送Tag。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="git" scheme="http://martist.cn/categories/git/"/>
    
    
      <category term="git" scheme="http://martist.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>创业公司必经之路（三）</title>
    <link href="http://martist.cn/2017/04/04/%E9%A9%AC%E9%97%AF%EF%BC%9A%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF%5B3%5D/"/>
    <id>http://martist.cn/2017/04/04/马闯：创业公司必经之路[3]/</id>
    <published>2017-04-03T16:00:00.000Z</published>
    <updated>2017-10-02T04:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h3 id="什么是溢价投资？"><a href="#什么是溢价投资？" class="headerlink" title="什么是溢价投资？"></a>什么是溢价投资？</h3><p>没有上市的公司，也是有股份的。<br>为了方便计算，把<strong>股份划分成股权</strong>。<br>先谈估值，原始股份升至估值后的股份额，再谈融资，这样不会稀释掉原始股份。<br>这也印证了投资早，收益高，风险高的特点。<br>每次公司融资之前先谈估值，是溢价投资。</p><h3 id="什么是折价投资？"><a href="#什么是折价投资？" class="headerlink" title="什么是折价投资？"></a>什么是折价投资？</h3><p>比如极客学院这个公司，需要新一轮的融资，现在他的状况是口碑一般不太好，一直亏损，用户量大，估值10亿，<br>此时10亿的估值不太吸引风投，因此会产生这种情况：<br>说极客学院只值  2亿，投资1亿，原来一共有10000股，现在增发5000股，才可以。<br>按照原来情况值10亿，投资1亿，原有10000股， 现在增发1000股，就可以。</p><table><thead><tr><th>折价投资</th><th>溢价投资</th></tr></thead><tbody><tr><td>原股东盈利</td><td>原股东亏损</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="entrepreneurship" scheme="http://martist.cn/categories/entrepreneurship/"/>
    
    
      <category term="entrepreneurship" scheme="http://martist.cn/tags/entrepreneurship/"/>
    
  </entry>
  
  <entry>
    <title>创业公司必经之路（二）</title>
    <link href="http://martist.cn/2017/03/29/%E9%A9%AC%E9%97%AF%EF%BC%9A%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF%5B2%5D/"/>
    <id>http://martist.cn/2017/03/29/马闯：创业公司必经之路[2]/</id>
    <published>2017-03-28T16:00:00.000Z</published>
    <updated>2017-10-02T04:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h2><ul><li>投资人不要股份的年底分红，那才多少啊，更愿意升值后套现。</li><li>地派利润率高，不愿上市分钱。</li><li>天派现金流好，利于做大，然后上市套现。</li><li>上市公司要的就是快速发展。</li><li>京东一年比一年亏损，但是现金流好，足够支持它去抢占市场，这也侧面说明他还在打基础，此时股价可能就是间断的上涨。</li><li>如果有一天京东止损了，说明他想开始赚钱了，这样说明市场不会开阔的更大，可以看到公司发展的极限了，即将走下坡路，所以股价反而会下跌。</li><li>代持股协议，适合中国金融市场。</li></ul><h2 id="兄弟会的模式"><a href="#兄弟会的模式" class="headerlink" title="兄弟会的模式"></a>兄弟会的模式</h2><p>派出开发团队去外包项目，赚的钱是有限的，此时帮助这些创业公司救火，可以要求获得一些股份作为回报。</p><h2 id="中国房地产"><a href="#中国房地产" class="headerlink" title="中国房地产"></a>中国房地产</h2><p>硬着陆 =&gt; 泡沫破裂。<br>软着陆 =&gt; 人民币贬值，房地产泡沫变小，不会太大而破裂。</p><h2 id="对赌协议"><a href="#对赌协议" class="headerlink" title="对赌协议"></a>对赌协议</h2><p>花费两个月左右时间，写一个商业计划书，差不多就可以去找天使轮投资了。天使轮（不超过1000W），也有总资轮，和合伙人投资的说法。<br>此处有一个对赌协议的存在。</p><p>投资人和个人签约，是无限责任公司。<br>投资人和公司签约，是有限责任公司。</p><p>投资人会选择和个人或者母公司签约，更有保障一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="entrepreneurship" scheme="http://martist.cn/categories/entrepreneurship/"/>
    
    
      <category term="entrepreneurship" scheme="http://martist.cn/tags/entrepreneurship/"/>
    
  </entry>
  
  <entry>
    <title>https证书搭建</title>
    <link href="http://martist.cn/2017/03/29/https%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://martist.cn/2017/03/29/https环境搭建/</id>
    <published>2017-03-28T16:00:00.000Z</published>
    <updated>2017-10-18T07:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><blockquote><p>本服务器使用的环境是apache，系统是Ubuntu<br>使用的阿里云的服务器，所以在阿里云中下载证书。<br>当然你还可以去CA认证服务机构官网或七牛云存储中下载证书</p></blockquote><h2 id="第一步：在阿里云官网下载CA证书"><a href="#第一步：在阿里云官网下载CA证书" class="headerlink" title="第一步：在阿里云官网下载CA证书"></a>第一步：在阿里云官网下载CA证书</h2><p>1.在阿里云官网里的云盾中CA服务证书选项里进行下载证书<br><img src="http://img.blog.csdn.net/20161215004055862?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlsaWFuMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="CA证书下载入口"></p><p>2.选择并购买证书，本人选的是DV SSL，1年内保护一个域名</p><p><img src="http://img.blog.csdn.net/20161215004354986?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlsaWFuMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3.支付成功后，去云盾控制台–&gt;选择证书服务–&gt;补全证书信息–&gt;绑定一个域名(如www.limingxia.com)–&gt;填写个人信息–&gt;系统生成CSR，点击创建按钮–&gt;提交审核</p><p>4.审核成功后我们可以得到一条主机记录和主机记录值。会发送到您绑定的邮箱里。</p><p>5.到指定域名(如www.limingxia.com)下解析DNS，记录类型选择“CNAME“，根据邮箱里收到的上述两个值分别填写后进行解析。<br><img src="http://img.blog.csdn.net/20161215201432752?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlsaWFuMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="DNS 解析"></p><p>6.下载证书到本地后，上传到自己的服务器上。因为我的服务器是Apache，所以我对应下载的是针对apache服务器的证书。当然你也可以选择nginx、tomcat或其他的证书。在证书下载页，有关于安装证书及如何配置ssl的说明。<br><img src="http://img.blog.csdn.net/20161215202059414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlsaWFuMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="下载服务证书"></p><p>##第二步 配置服务器</p><blockquote><p>添加 SSL 协议支持语句,关闭不安全的协议和加密套件</p></blockquote><p>1.启用有关SSL的模块，ssl.conf，ssl.load，socache_shmcb.load<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@laravel:~# cd /etc/apache2/mods-enabled/</div><div class="line">root@laravel:~# ln /etc/apache2/mods-enabled/ssl.conf ./</div><div class="line">root@laravel:~# ln /etc/apache2/mods-enabled/ssl.load ./</div><div class="line">root@laravel:~# ln /etc/apache2/mods-enabled/socache_shmcb.load ./</div></pre></td></tr></table></figure></p><p>2.检查apachectl配置文件是否正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@laravel:~# apachectl configtest</div></pre></td></tr></table></figure></p><p>自动检查配置文件,以确保Apache不会死掉</p><p>3.重启apache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@laravel:~# apachectl restart</div></pre></td></tr></table></figure></p><p>4.上传之前下载的证书到服务器，新建一个新命令窗口用scp上传，并解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@laravel:~# scp /.../ssl.zip root@120.27.100.197:/etc/apache2/</div></pre></td></tr></table></figure></p><p>5.修改ssl配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@laravel:~# cd /etc/apache2/mods-enabled/</div><div class="line">root@laravel:~# sudo vim ssl.conf</div></pre></td></tr></table></figure></p><p><em>-77行 添加 SSL 协议支持语句-</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">77         SSLProtocol all -SSLv2 -SSLv3</div></pre></td></tr></table></figure></p><p>6.修改加密套件   default-ssl.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@laravel:~# cd /etc/apache2/sites-available/</div><div class="line">root@laravel:~# sudo vim default-ssl.conf</div></pre></td></tr></table></figure></p><p><em>- 32行 将服务器证书公钥配置到该路径下-</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">32   SSLCertificateFile      /etc/apache2/ssl/213974406010850.pem</div></pre></td></tr></table></figure></p><p><em>- 33行 将服务器证书私钥配置到该路径下-</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">33   SSLCertificateKeyFile /etc/apache2/ssl/213974406010850.key</div></pre></td></tr></table></figure></p><p><em>- 42行 将服务器证书链配置到该路径下,打开42行注释  -</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">42   SSLCertificateChainFile /etc/apache2/ssl/chain.pem</div></pre></td></tr></table></figure></p><p>7.开启ssl站点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@laravel:~# ln /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-enabled/</div></pre></td></tr></table></figure></p><p>8.重启apache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apachectl restart</div></pre></td></tr></table></figure></p><p>####执行上述步骤，服务器HTTPS环境搭建成功。现在去浏览器地址在你的域名前面加上https试试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>创业公司必经之路（一）</title>
    <link href="http://martist.cn/2017/03/22/%E9%A9%AC%E9%97%AF%EF%BC%9A%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF%5B1%5D/"/>
    <id>http://martist.cn/2017/03/22/马闯：创业公司必经之路[1]/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-10-02T04:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h3 id="一家创业公司比较重要的三张表"><a href="#一家创业公司比较重要的三张表" class="headerlink" title="一家创业公司比较重要的三张表"></a>一家创业公司比较重要的三张表</h3><table><thead><tr><th>现金流表</th><th>利润表</th><th>负债表</th><th>派系</th><th>情况</th><th>预计</th><th>未来适合</th></tr></thead><tbody><tr><td>好</td><td>差</td><td>-</td><td>天派</td><td>发展快</td><td>高估值</td><td>做大-〉IPO上市</td></tr><tr><td>差</td><td>好</td><td>-</td><td>地派</td><td>运营好</td><td>赚钱</td><td>目的并非上市，先发财，不想和别人分钱</td></tr></tbody></table><p><strong>举例：</strong><br>IT兄弟连的现金流表好，利润流表一般。</p><p>股权所有者权益 = 股本 + 利润  </p><p>IPO = 公开募股</p><p>IBM有超过25%的员工变成了自由职业者，即不是常驻扎公司，有需要的时候才来上班。</p><h3 id="创业公司是怎么回事，怎么玩的？"><a href="#创业公司是怎么回事，怎么玩的？" class="headerlink" title="创业公司是怎么回事，怎么玩的？"></a>创业公司是怎么回事，怎么玩的？</h3><h4 id="1-公司资产和股本"><a href="#1-公司资产和股本" class="headerlink" title="1.公司资产和股本"></a>1.公司资产和股本</h4><p>假设：4个人创业注册公司，只有一个idea，想搞一个平台（类似猪八戒网），一人出25W，一共100W的投资额（注册资本），也就是说公司资产100W。此时每个人25W就是<strong>股本</strong>，但是股本不是决定每个股东占有公司多少股份的唯一标准，包括技术，人脉，资源等等都可以评估在内。</p><h4 id="2-资本供给"><a href="#2-资本供给" class="headerlink" title="2.资本供给"></a>2.资本供给</h4><p>中国的法律尚不健全，因此产生了一些具备特定功效的协议来平衡投资和融资之间的关系。<br>比如说，时光机公司里面，龙哥占80%股份，注册资本50W，此时有一家大的风投说要投资500W，按照中国法律来讲，如果时光机接受的话，那么龙哥的股份将剩下不到10%，于是有了这种<strong>处理办法</strong>：<br>500W取出490W作为<strong>资本供给</strong> 给龙哥，打到个人账户，10W去交易股份，得到时光机公司20%的股份。<br><strong>注意</strong>：在公司上市之前，股权，期权是可以用来交易变现的。</p><h4 id="3-代持股协议"><a href="#3-代持股协议" class="headerlink" title="3.代持股协议"></a>3.代持股协议</h4><blockquote><p>代持股协议，指代为持有股份、享有股权的委托协议书。现实生活中，部分公司对认购公司股份者有身份要求，一些投资者就与公司认可的认购股份者签订代持股协议，约定由受托人享有公司工商登记和行使股权等权利，委托人则享有股份应得的红利及其他收益，委托人支付受托人一定的费用。这种协议的法律依据是公司法相关司法解释中有关隐名股东和显名股东的规定。这种协议受法律保护，因涉及较强的专业性，故建议当事人委托专业的律师代为起草，有效预防和控制法律风险。</p></blockquote><p>这种情况下，公司实际掌舵人的持股份额不高，公司有幕后老板持有大量股份，这是大多发生实际控制人和幕后大股东之间的协议。<br>over。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="entrepreneurship" scheme="http://martist.cn/categories/entrepreneurship/"/>
    
    
      <category term="entrepreneurship" scheme="http://martist.cn/tags/entrepreneurship/"/>
    
  </entry>
  
  <entry>
    <title>SEO影响因素</title>
    <link href="http://martist.cn/2017/03/20/SEO%E6%8E%92%E5%90%8D%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0/"/>
    <id>http://martist.cn/2017/03/20/SEO排名的影响因素/</id>
    <published>2017-03-20T04:13:54.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h3 id="一-关键词优化"><a href="#一-关键词优化" class="headerlink" title="(一)关键词优化"></a>(一)关键词优化</h3><p>1.URL中包含要优化的关键词<br>2.网页Title中绝对匹配和相对匹配要优化的关键词<br>3.meta标签中绝对匹配和相对匹配要优化的关键词<br>4.网页核心内容绝对匹配和相对匹配要优化的关键词<br>5.网页内容标题使用〈h1〉标签优化<br>6.网页主体内容第一段以关键词开头<br>7.网页主体内容使用段落格式,每个段落针对不同的组合关键词展开优化,可以的话每个段落都以关键词开头<br>8.相关内容的展示:在网页核心内容下设置相关内容展示区,选择包含关键词的文章标题并给予链接,同时,提供给用户到该优化关键词的专题区(自由设想)<br>9.评论中出现关键词<br>10.对网页中的关键词做适当的特殊处理(加粗、加红、斜体等）<br>11  网页中重点图片(内容区、相关内容区、重点图片等）给予合理的包含关键词的ALT文字<br>12.图片名中包含关键词<br>13.域名中中包含关键词<br>14.目录名中包含关键词<br>15.文件名中包含关键词<br>16.网站频道或栏目名中包含关键词</p><h3 id="二-网站结构优化"><a href="#二-网站结构优化" class="headerlink" title="(二)网站结构优化"></a>(二)网站结构优化</h3><p>1.根据网站定位及内容设计结构<br>2.二极域名与一级目录的选择<br>3.网站物理结构与逻辑结构的吻合<br>4.根据逻辑结构设计网站内容<br>5.合理的面包屑导航设计<br>6.搜索引擎友好的网页布局设计<br>7.网页制作中代码的规范问题(形成有效信息片的标签设计、JS代码的合理使用、CSS文件的嵌入等、代码的精简)<br>8.绝对URL与相对URL的使用规则<br>9.文字链接锚文本的设计<br>10.网页内容如何聚合成网站主题<br>11.让网页核心内容的HTML代码优先执行</p><h3 id="三-反向链接优化"><a href="#三-反向链接优化" class="headerlink" title="(三)反向链接优化"></a>(三)反向链接优化</h3><p>1.反向链接数量:一般而言，数量越多越有利于关键词排名及收录数量<br>2.导入链接网页的信任度高<br>3.导入链接网页的主题内容与链向的网页内容密切相关<br>4.导入链接指向的网页有具体内容<br>5.反向链接的锚文字中有关键词<br>6.反向链接的锚文字周围有以关键词为基础的组合词<br>7.导入链接建立在反向链接网页的核心内容区<br>8.导入链接的时间长度，一般导入链接的存在时间有3-6个月<br>9.单向链接的价值高于互惠链接<br>10.导入链接的网页自身的导出链接小于100个，最佳的反向链接来自于外站的内容页的内容区域<br>11.反向链接最好来自不同IP，切忌同一IP的站点交叉链接<br>12.反向链接的增长频率不要太快，逐步增加，特别是相关性的文字链接</p><h3 id="四-绝对禁止的操作"><a href="#四-绝对禁止的操作" class="headerlink" title="(四)绝对禁止的操作"></a>(四)绝对禁止的操作</h3><p>1.在网页内容区、keywords、alt中堆积关键词<br>2.反向链接和站内链接所有的锚文字都相同<br>3.使用CSS或背景色隐藏内容<br>4.使用JavaScript跳转,建议使用301跳转<br>5.相同ip之下的网页直接进行大量交换链接<br>6.桥页和Cloaking，诱导搜索引擎的爬虫<br>7.放置成人内容，违禁药品，赌博相关内容<br>8.频繁的更换IP地址<br>9.导出链接中包含SEO作弊站点<br>10.加入到Link Farm或则Link交换类网站<br>11.使用被惩罚过的域名<br>12.网站建立在被惩罚的IP上</p><h3 id="五-需要考究的SEO因素"><a href="#五-需要考究的SEO因素" class="headerlink" title="(五)需要考究的SEO因素"></a>(五)需要考究的SEO因素</h3><p>1.网站内每个网页都有不同的title、keywords、description<br>2.首页、栏目页、内容页使用相同的模版<br>3.确保网站中每个网页都只能通过网络上的唯一一个URL访问到<br>4.尽量不要将首页设计为单一图片和Flash<br>5.网站导航条使用文字链接，尽量不要使用FLASH技术或JAVASCRIPT技术<br>6.网站导航条如果用图片记得以关键词为ALT标签<br>7.尽量在区域引用CSS和JS文件，而不将JS代码或样式写在网页内<br>8.只要技术上可以实现并且不会过于麻烦，就不要使用JS来显示网页中的内容，特别是核心内容区及URL列表区<br>9.要能确定网页的主题，而不要夹杂太多与该主题完全不相关的内容<br>10.整理下站点目录，将无用的网页文件清理掉，保持目录干净整洁是一个好站点的前提条件，也是评价该站点是否有人管理的指标<br>11.无论如何，都要放一个robots.txt文件在站点根目录，无论你会不会写，哪怕文件内容是空都可以。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="seo" scheme="http://martist.cn/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="http://martist.cn/2016/12/30/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://martist.cn/2016/12/30/linux常用命令/</id>
    <published>2016-12-30T13:30:50.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><pre><code>解包： tar xvf FileName.tar打包：tar cvf FileName.tar DirName </code></pre><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>svn 删除所有的 .svn文件<br>find . -name .svn -type d -exec rm -fr {} \;</p><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p>使用权限：所有使用者</p><p>使用方式：</p><p>cp [options] source dest</p><p>cp [options] source… directory</p><p>说明：将一个档案拷贝至另一档案，或将数个档案拷贝至另一目录。</p><p>option：</p><pre><code>-a 尽可能将档案状态、权限等资料都照原状予以复制。-r 若 source 中含有目录名，则将目录下之档案亦皆依序拷贝至目的地。-f 若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制。</code></pre><p>范例：</p><p>将档案 aaa 复制(已存在)，并命名为 bbb :</p><p>cp aaa bbb</p><p>将所有的C语言程式拷贝至 Finished 子目录中 :</p><p>cp *.c Finished</p><p>命令：scp</p><p>不同的Linux之间copy文件常用有3种方法：</p><p>第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。</p><p>第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。</p><p>第三种就是利用scp命令来进行文件复制。</p><pre><code>scp是有Security的文件copy，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令。</code></pre><p>scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root</p><p>然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了。</p><pre><code>如果想反过来操作，把文件从远程主机copy到当前系统，也很简单。</code></pre><p>linux之cp/scp命令＋scp命令详解(转) - linmaogan - 独木★不成林scp root@/full.tar.gz 172.19.2.75:/home/root/full.tar.gz home/daisy/full.tar.gz</p><p>linux 的 scp 命令 可以 在 linux 之间复制 文件 和 目录；</p><h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>scp 可以在 2个 linux 主机间复制文件；</p><p>命令基本格式：<br>       scp [可选参数] file_source file_target</p><p>======</p><h1 id="从-本地-复制到-远程"><a href="#从-本地-复制到-远程" class="headerlink" title="从 本地 复制到 远程"></a>从 本地 复制到 远程</h1><ul><li><p>复制文件：</p><pre><code>* 命令格式：        scp local_file remote_username@remote_ip:remote_folder        或者        scp local_file remote_username@remote_ip:remote_file        或者        scp local_file remote_ip:remote_folder        或者        scp local_file remote_ip:remote_file        第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；        第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；* 例子：        scp /home/space/music/1.mp3 root@www.cumt.edu.cn:/home/root/others/music        scp /home/space/music/1.mp3 root@www.cumt.edu.cn:/home/root/others/music/001.mp3        scp /home/space/music/1.mp3 www.cumt.edu.cn:/home/root/others/music        scp /home/space/music/1.mp3 www.cumt.edu.cn:/home/root/others/music/001.mp3</code></pre></li><li><p>复制目录：</p><pre><code>* 命令格式：        scp -r local_folder remote_username@remote_ip:remote_folder        或者        scp -r local_folder remote_ip:remote_folder        第1个指定了用户名，命令执行后需要再输入密码；        第2个没有指定用户名，命令执行后需要输入用户名和密码；* 例子：        scp -r /home/space/music/ root@www.cumt.edu.cn:/home/root/others/        scp -r /home/space/music/ www.cumt.edu.cn:/home/root/others/        上面 命令 将 本地 music 目录 复制 到 远程 others 目录下，即复制后有 远程 有 ../others/music/ 目录</code></pre></li></ul><p>======</p><h1 id="从-远程-复制到-本地"><a href="#从-远程-复制到-本地" class="headerlink" title="从 远程 复制到 本地"></a>从 远程 复制到 本地</h1><p>从 远程 复制到 本地，只要将 从 本地 复制到 远程 的命令 的 后2个参数 调换顺序 即可；</p><p>例如：</p><pre><code>scp root@www.cumt.edu.cn:/home/root/others/music /home/space/music/1.mp3scp -r www.cumt.edu.cn:/home/root/others/ /home/space/music/</code></pre><p>最简单的应用如下 :</p><p>scp 本地用户名 @IP 地址 : 文件名 1 远程用户名 @IP 地址 : 文件名 2</p><p>[ 本地用户名 @IP 地址 :] 可以不输入 , 可能需要输入远程用户名所对应的密码 .</p><p>可能有用的几个参数 :</p><p>-v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 .</p><p>-C 使能压缩选项 .</p><p>-P 选择端口 . 注意 -p 已经被 rcp 使用 .</p><p>-4 强行使用 IPV4 地址 .</p><p>-6 强行使用 IPV6 地址 .</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>关于数据迁移的方法，步骤和心得</title>
    <link href="http://martist.cn/2016/12/03/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E6%AD%A5%E9%AA%A4%E5%92%8C%E5%BF%83%E5%BE%97/"/>
    <id>http://martist.cn/2016/12/03/关于数据迁移的方法、步骤和心得/</id>
    <published>2016-12-02T16:00:00.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>在项目中经常会遇到系统完全更换后的历史数据迁移问题，以示对客户历史工作的尊重，何况很多数据仍有保留的必要。<br>那怎么做历史数据迁移呢？</p><h2 id="系统分析："><a href="#系统分析：" class="headerlink" title="系统分析："></a><strong>系统分析：</strong></h2><h3 id="1、分析原有的业务系统"><a href="#1、分析原有的业务系统" class="headerlink" title="1、分析原有的业务系统"></a>1、分析原有的业务系统</h3><p>精确到大致的系统功能模块、大致的处理流程即可</p><h3 id="2、分析现有的业务系统"><a href="#2、分析现有的业务系统" class="headerlink" title="2、分析现有的业务系统"></a>2、分析现有的业务系统</h3><p>精确到大致的系统功能模块、大致的处理流程即可</p><h3 id="3、分析两者自己的区别和差异"><a href="#3、分析两者自己的区别和差异" class="headerlink" title="3、分析两者自己的区别和差异"></a>3、分析两者自己的区别和差异</h3><p>大致分析一下两个业务系统之间的区别，有助于确定工作量和工作进度</p><h3 id="4、分析用户对旧有数据的需求"><a href="#4、分析用户对旧有数据的需求" class="headerlink" title="4、分析用户对旧有数据的需求"></a>4、分析用户对旧有数据的需求</h3><p>分析对旧有数据的需求，才不至于盲目的全部性的进行迁移</p><h3 id="5、分析用户对旧有数据的处理规则"><a href="#5、分析用户对旧有数据的处理规则" class="headerlink" title="5、分析用户对旧有数据的处理规则"></a>5、分析用户对旧有数据的处理规则</h3><p><strong>旧有数据的处理规则，一般分为以下几类：</strong><br>1、基础数据，通常这一类容易迁移，数据格式简单，但是会影响所有的相关业务数据，关注点为数据的主键和唯一键的方式。<br>2、纯历史数据的导入，仅供参考用的，这一类数据导入容易<br> 2.1 纯历史数据<br> 这一类数据处理起来会比较容易，一次性导入即可，后续采用增量数据导入。<br> 2.2 流程性数据<br> 这一类数据只有在记录完全关闭后才能结束，需要进行增量导入和数据更新，同时还要进行相关查询界面的开发，以保证旧有数据能够在新系统中查询的到。<br>3、新老系统表结构变化较大的历史数据<br> 这一类数据的工作量是最重的，就需要仔细去研究新老业务系统的数据结构了。<br> 1、尽量通过甲方单位来收集齐全相关原系统的相关设计文档，这一点对数据分析很有帮助，通过人的感觉和对数据的观察来分析毕竟不太靠谱。<br> 2、在原系统上进行相关数据的观察，了解数据的变化和数据表数据的关系（对于比较难以理解的相关字段很有帮助）<br> 3、比较新老系统数据的差异，如果实在很不靠谱的话，建议按2.2去处理。</p><p><strong>系统设计：</strong><br>1、做完系统分析之后，对相关数据进行归类，基础数据、纯历史数据、变化较大的历史数据<br>2、先从简单的入手，给自己点信心<br>3、在excel表中进行相关表的数据字典对照，勾画出对应字段、转换逻辑、依赖关系、必要时在新系统表上做相应的冗余，等数据迁移完毕后再清除。<br>关键点：<br>不同数据库的字段类型的匹配问题，比如SQLServer的text，在Oracle应该对应clob，但是宁愿转换成几个varchar2，从实现角度相对容易些。<br>关于主键的问题，一致的数据类型尽量维持现有状态，不一致的尽量采用oracle的序列或sqlserver的identity int，但是迁移完毕后，要注意序列值的更新</p><p><strong>系统实现：</strong><br>1、PL/SQL或T-SQL，DTS、SSIS或者PowerBuilder的管道作为数据迁移的方式<br>2、相关业务逻辑的迁移，与数据完整性和业务相关的存储过程、触发器、函数的改写，甚至SQL的改写<br>3、业务查询页面的编写</p><p><strong>后话：</strong><br>1、数据迁移没有特别或高级的方法<br>2、对业务数据的分析最为关键，需要不断的尝试在新系统上不断的测试<br>3、数据迁移技术，主要通过SQL、存储过程、甚至游标来实现，优先级也如上</p><p>还有一种数据迁移仅仅是数据库的平迁或异构数据库迁移：<br>数据库平迁，即为了性能扩展需要从一台服务器迁移到另外一台服务器上，用数据库的导出导入或备份恢复工具处理即可，当然也要考虑迁移后的一些序列字段的初始值。<br>异构数据迁移，即从一个数据库平台迁移到另外一个数据库平台，用ETL工具或SQL均可实现，不过要注意业务逻辑的迁移，即存储过程、函数、触发器之类的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>laravel优化之路</title>
    <link href="http://martist.cn/2016/11/15/%E3%80%90%E4%BC%98%E5%8C%96%E3%80%91Laravel/"/>
    <id>http://martist.cn/2016/11/15/【优化】Laravel/</id>
    <published>2016-11-14T16:00:00.000Z</published>
    <updated>2017-10-02T02:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>性能一直是 Laravel 框架为人诟病的一个点，所以调优 Laravel 程序算是一个必学的技能。</p><p>接下来分享一些开发的最佳实践，还有调优技巧，大家有别的建议也欢迎留言讨论。</p><h1 id="二、策略"><a href="#二、策略" class="headerlink" title="二、策略"></a>二、策略</h1><pre><code>配置信息缓存 artisan config:cache路由缓存 artisan route:cache类映射加载优化 artisan optimize自动加载优化 composer dumpautoload使用 Memcached 来存储会话 config/session.php使用专业缓存驱动器 config/cache.php数据库请求优化为数据集书写缓存逻辑使用即时编译器（JIT），如：HHVM、OpCache前端资源合并 Elixir</code></pre><p>##1. 配置信息缓存<br>使用以下 Artisan 自带命令，把 config 文件夹里所有配置信息合并到一个文件里，减少运行时文件的载入数量：</p><p>php artisan config:cache<br>上面命令会生成文件 bootstrap/cache/config.php，可以使用以下命令来取消配置信息缓存：</p><p>php artisan config:clear<br>此命令做的事情就是把 bootstrap/cache/config.php 文件删除。</p><p>注意：配置信息缓存不会随着更新而自动重载，所以，开发时候建议关闭配置信息缓存，一般在生产环境中使用，可以配合 Envoy 任务运行器 一起使用。</p><p>##2. 路由缓存<br>路由缓存可以有效的提高路由器的注册效率，在大型应用程序中效果越加明显，可以使用以下命令：</p><pre><code>php artisan route:cache</code></pre><p>以上命令会生成 bootstrap/cache/routes.php 文件，需要注意的是，路由缓存不支持路由匿名函数编写逻辑。</p><p>可以使用下面命令清除路由缓存：</p><pre><code>php artisan route:clear    </code></pre><p>此命令做的事情就是把 bootstrap/cache/routes.php 文件删除。</p><p>注意：路由缓存不会随着更新而自动重载，所以，开发时候建议关闭路由缓存，一般在生产环境中使用，可以配合 Envoy 任务运行器 一起使用。</p><p>##3. 类映射加载优化<br>optimize 命令把常用加载的类合并到一个文件里，通过减少文件的加载，来提高运行效率：</p><pre><code>php artisan optimize --force</code></pre><p>会生成 bootstrap/cache/compiled.php 和 bootstrap/cache/services.json 两个文件。</p><p>你可以可以通过修改 config/compile.php 文件来添加要合并的类。</p><p>在 production 环境中，参数 –force 不需要指定，文件就会自动生成。</p><p>要清除类映射加载优化，请运行以下命令：</p><pre><code>php artisan clear-compiled</code></pre><p>此命令会删除上面 optimize 生成的两个文件。</p><p>注意：此命令要运行在 php artisan config:cache 后，因为 optimize 命令是根据配置信息（如：config/app.php 文件的 providers 数组）来生成文件的。</p><p>##4. 自动加载优化<br>此命令不止针对于 Laravel 程序，适用于所有使用 composer 来构建的程序。此命令会把 PSR-0 和 PSR-4 转换为一个类映射表，来提高类的加载速度。</p><pre><code>composer dumpautoload -o</code></pre><p>注意：php artisan optimize –force 命令里已经做了这个操作。</p><p>##5. 使用 Memcached 来存储会话<br>每一个 Laravel 的请求，都会产生会话，修改会话的存储方式能有效提高程序效率，会话的配置信息是 config/session.php，建议修改为 Memcached 或者 Redis 等专业的缓存软件：</p><pre><code>&apos;driver&apos; =&gt; &apos;memcached&apos;,</code></pre><p>##6. 使用专业缓存驱动器<br>「缓存」是提高应用程序运行效率的法宝之一，默认缓存驱动是 file 文件缓存，建议切换到专业的缓存系统，如 Redis 或者 Memcached，不建议使用数据库缓存。</p><pre><code>&apos;default&apos; =&gt; &apos;redis&apos;,</code></pre><p>##7. 数据库请求优化</p><p>数据关联模型读取时使用 延迟预加载 和 预加载 ；<br>使用 Laravel Debugbar 或者 Clockwork 留意每一个页面的总数据库请求数量；<br>这里的篇幅只写到与 Laravel 相关的，其他关于数据优化的内容，请自行查阅其他资料。</p><p>##8. 为数据集书写缓存逻辑<br>合理的使用 Laravel 提供的缓存层操作，把从数据库里面拿出来的数据集合进行缓存，减少数据库的压力，运行在内存上的专业缓存软件对数据的读取也远远快于数据库。</p><pre><code>$posts = Cache::remember(&apos;index.posts&apos;, $minutes = 30, function(){return Post::with(&apos;comments&apos;, &apos;tags&apos;, &apos;author&apos;, &apos;seo&apos;)-&gt;whereHidden(0)-&gt;get();});</code></pre><p>remember 甚至连数据关联模型也都一并缓存了，多么方便呀。</p><p>##9. 使用即时编译器<br>HHVM 和 OpCache 都能轻轻松松的让你的应用程序在不用做任何修改的情况下，直接提高 50% 或者更高的性能，PHPhub 之前做个一个实验，具体请见：使用 OpCache 提升 PHP 5.5+ 程序性能。</p><p>##10. 前端资源合并<br>作为优化的标准，一个页面只应该加载一个 CSS 和 一个 JS 文件，并且文件要能方便走 CDN，需要文件名随着修改而变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
</feed>
