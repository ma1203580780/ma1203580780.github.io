<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARTIST</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://martist.cn/"/>
  <updated>2018-06-26T13:40:19.545Z</updated>
  <id>http://martist.cn/</id>
  
  <author>
    <name>马闯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式的原则</title>
    <link href="http://martist.cn/2018/06/26/PHP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/"/>
    <id>http://martist.cn/2018/06/26/PHP/设计模式的原则/</id>
    <published>2018-06-25T16:00:00.000Z</published>
    <updated>2018-06-26T13:40:19.545Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a><br>列举下常见设计模式和原则</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><pre><code>1、Abstract Factory (抽象工厂模式)2、Adapter 适配器模式3、Bridge:桥梁模式4、Builder:建筑者模式5、Chain of Responsibility:职责链模式6、Command 命令模式7、Composite:组合模式8、Decorator:装饰模式9、Facade:外观模式10、Factory Method:工厂模式11、Flyweight:享元模式12、Interpreter:解释器模式13、Iterator:迭代器模式14、Mediator:中介模式15、Memento:备忘录模式16、观察者模式（搞懂这个，对搞懂.net规范下的委托很重要，个人理解）17、Prototype:原型模式18、Proxy:代理模式19、Singleton:单例模式20、State:状态模式21、Strategy:策略模式22、Template Method:模板方法模式23、Visitor:访问者模式</code></pre><h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><pre><code>1、单一原则2、里氏替换原则3、依赖倒置原则4、接口隔离原则5、迪米特法则6、开闭原则</code></pre><h3 id="细则"><a href="#细则" class="headerlink" title="细则"></a>细则</h3><h4 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h4><blockquote><p>应该有且只有一个原因引起类的变化</p></blockquote><p>注意 : 这里的类不光指类,也适用于方法和接口,比如我们常说的一个方法实现一个功能</p><h4 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h4><blockquote><p>只要父类出现的地方子类就一定可以出现,而且替换为子类也不会出现任何异常或错误,使用者不需要知道是父类还是子类.但是返回来就不行了,有子类出现的地方,</p></blockquote><p>不一定能使用父类</p><p>使用规范 : </p><pre><code>子类必须完全实现父类的方法,如果子类无法完全实现父类的方法,则建议断开父子继承关系,采用依赖 | 聚集 | 组合 等关系来代替子类可以有自己的个性覆盖或实现父类的方法时,输入参数可以被放大,比如父类中有一个方法的输入参数是 HashMap,子类的参数可以是 Map 类型,这样父类就可以被子类替换,如果反过来,则违背了里氏替换原则,所以子类中方法的前置条件必须与父类的被覆写的方法的前置条件相同或者更宽松覆写或实现父类的方法时,输出结果可以被缩小,也就是说如果父类方法返回的类型 T,子类的相同方法(重载或覆写)的返回值类型 S,S 和 T 要么同类型,要么 S 是 T 的子类;跟上面的道理一样    </code></pre><p>注意 : 采用里氏替换原则时,尽量避免子类的”个性”,一旦子类有了”个性”,子类和父类的关系就会变得不好调和</p><h4 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h4><blockquote><p>依赖倒置原则包含三个含义</p></blockquote><pre><code>高层模块不应该依赖低层模块,两者都应该依赖其抽象抽象不应该依赖细节细节应该依赖抽象</code></pre><p>高层模块和低层模块比较好理解,每一个逻辑都是由原子逻辑组成的,不可分割的原子逻辑是低层模块,原子逻辑再组装就是高层模块;<br>抽象指的是接口或者抽象类,两者都不能直接实例化;<br>细节就是实现类,实现接口或继承抽象类而产生的类就是细节,其特点是可以被实例化;</p><p>依赖倒置原则在 Java 中的实现是表现是:</p><pre><code>模块间的依赖通过抽象发生,实现类之间不发生直接的依赖关系,其依赖关系是通过接口或抽象类产生的;接口或抽象类不依赖于实现类实现类依赖接口或抽象类</code></pre><p>这也是面向接口编程的精髓之一</p><p>遵循的规则 : </p><pre><code>每个类尽量都有接口或抽象类,或者两者都有变量的表面类型尽量是接口或者抽象类任何类都不应该从具体类派生尽量不要覆写基类的方法,如果基类是一个抽象类,而且这个方法已经实现了,子类尽量不要覆写结合里氏替换原则使用接口负责定义 public 属性和方法,并且声明与其他对象的依赖关系,抽象类负责公共构造部分的实现,实现类准确的实现业务逻辑</code></pre><h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><blockquote><p>实例接口在 Java 中声明一个类,然后用 new 关键字产生一个实例,它是对一类事物的描述,可以看成是一个接口；类接口使用 interface 定义的接口</p></blockquote><p>隔离的的理解 : </p><pre><code>客户端不应该依赖它不需要的接口类之间的依赖关系应该建立在最小的接口上概括 : 建立单一接口,不要建立臃肿庞大的接口,也就是接口尽量细化,接口中的方法尽量少</code></pre><p>这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p>接口隔离原则的约束条件 : </p><pre><code>接口要高内聚,意思就是提高接口,类,模块的处理能力,减少对外的交互,再具体一点就是在接口中尽量减少对外的 public 方法,通过业务逻辑压缩接口中的 public 方法定制服务,就是单独为一个个体提供优良的服务,比如我们写用户模块的时候,需要给用户提供查询信息,修改密码,注册用户等信息,当管理员执行相同操作的时候,一般人会复用这些方法,  然后在这个的基础上再增加管理员自己的方法,这种设计方法肯定是有问题的,这样设计,当你修改了普通用户调用的接口实现时,管理员的实现也会发生不可预测的改变,我们应该为管理  员单独写一个接口接口设计是有限度的,接口的设计粒度越小,系统越灵活,这是肯定的,但灵活的同时带来的问题是 结构复杂化,开发难度增加, 可维护性降低一个接口只服务于一个子模块或业务逻辑已经被污染了的接口,尽量去修改 ,若修改的风险较大,则采用适配器模式进行转化处理了解环境,拒绝盲从,不要一味的去套设计模式,有的时候不用比用了更好,也不要去照搬别人的设计方法,他的方法到你这不一定效果就好,毕竟业务逻辑不一样</code></pre><h4 id="迪米特法则（Demeter-Principle）"><a href="#迪米特法则（Demeter-Principle）" class="headerlink" title="迪米特法则（Demeter Principle）"></a>迪米特法则（Demeter Principle）</h4><blockquote><p>迪米特法则也叫最少知识原则,含义是 一个对象应该对其他对象有最少的了解,这个应该很好理解,就是降低各模块之间的耦合</p></blockquote><h4 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h4><blockquote><p>一个软件实体如类,模块和函数应该对扩展开放,对修改关闭,开闭原则也是其他五个原则的基石</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/kafeibuku/p/5671394.html" target="_blank" rel="external">https://www.cnblogs.com/kafeibuku/p/5671394.html</a><br><a href="https://www.jianshu.com/p/a489dd5ad1fe" target="_blank" rel="external">https://www.jianshu.com/p/a489dd5ad1fe</a><br><a href="https://www.cnblogs.com/lina520/p/7993478.html" target="_blank" rel="external">https://www.cnblogs.com/lina520/p/7993478.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>网络协议须知</title>
    <link href="http://martist.cn/2018/06/25/WEB/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E9%A1%BB%E7%9F%A5/"/>
    <id>http://martist.cn/2018/06/25/WEB/网络协议须知/</id>
    <published>2018-06-24T16:00:00.000Z</published>
    <updated>2018-06-26T13:39:42.176Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><pre><code>OSI七层模型是万能的国际标准化组织(ISO)提出的一个试图使各种计算机在世界范围内互连的理想标准，说白了理想和现实的差距就是七层模型和五层模型的差距。具体分类如下表：</code></pre><table><thead><tr><th>七层模型</th><th style="text-align:center">五层模型</th><th style="text-align:right">四层模型</th></tr></thead><tbody><tr><td>应用层</td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td>表示层</td><td style="text-align:center">应用层</td><td style="text-align:right">应用层</td></tr><tr><td>会话层</td><td style="text-align:center"></td></tr></tbody></table><p>传输层  | 传输层  | 传输层|<br>| 网络层| 网络层 | 网络层 |<br>|数据链路层 | 数据链路层 |     链接层/实体层 |<br>|物理层 | 物理层 |  |</p><p> 七层模型的上三层归为应用层即为TCP/IP五层模型，五层模型的下两层归为链接层或者说实体层即为四层模型。</p><p> 从本质上来区分，HTTP，WebSocket，TCP，UDP，IP都是协议，而TCP/IP是不同协议的组合，你也可以称之为协议栈，协议族，TCP/IP模型。</p><p> 而Socket（套接字）才是真正能操作的东西。Socket的本质是API，是先人对TCP/IP协议族的抽象或者说封装，它就像一个门面，给你一个操作TCP/IP协议的入口，来建立Socket连接。值得一提的是，此Socket是指网络编程下的Socket，而不是Unix中的Socket。虽然概念相似，但是Unix中的Socket不是基于这些乱七八糟的协议，而是基于操作系统本身的文件系统。</p><p>从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议。</p><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><blockquote><p>网络之间互连的协议(Internet Protoco)</p></blockquote><p>网络之间互连的协议也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。IP地址具有唯一性，根据用户性质的不同，可以分为5类。另外，IP还有进入防护，知识产权，指针寄存器等含义。</p><p>IP 是无连接的</p><p>IP 用于计算机之间的通信。</p><p>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。</p><p>通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。</p><p>IP 负责将每个包路由至它的目的地。<br>IP地址</p><p>每个计算机必须有一个 IP 地址才能够连入因特网。</p><p>每个 IP 包必须有一个地址才能够发送到另一台计算机。</p><p>网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。</p><p>TCP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。<br>一个计算机字节可以包含 256 个不同的值：<br>00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ……. 直到 11111111。<br>现在，你知道了为什么 TCP/IP 地址是介于 0 到 255 之间的 4 个数字。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><blockquote><p>传送控制协议(Transmission Control Protocol)</p></blockquote><p> TCP是面向连接的一种传输控制协议。<br> TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。<br> 特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至。</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：<br>TCP三次握手.png</p><p>（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p><p>（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p><p>（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><h4 id="简单来说，就是"><a href="#简单来说，就是" class="headerlink" title="简单来说，就是"></a>简单来说，就是</h4><p>1、建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认</p><p>2、服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态</p><p>3、客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。</p><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：</p><pre><code>netstat -nap | grep SYN_RECV</code></pre><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：<br>TCP四次挥手.png</p><p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p><p>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><p>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><p>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p><p>参考：<a href="https://www.jianshu.com/p/ef892323e68f" target="_blank" rel="external">https://www.jianshu.com/p/ef892323e68f</a><br><a href="https://www.cnblogs.com/yueminghai/p/6646043.html" target="_blank" rel="external">https://www.cnblogs.com/yueminghai/p/6646043.html</a></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote><p>用户数据报协议(User Datagram Protocol)</p></blockquote><p>UDP是无连接的用户数据报协议。<br>所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。<br>故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至。</p><h2 id="ftp-（文件传输协议）"><a href="#ftp-（文件传输协议）" class="headerlink" title="ftp （文件传输协议）"></a>ftp （文件传输协议）</h2><blockquote><p>文件传输协议(File Transfer Protocol)<br>ftp用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p></blockquote><h2 id="ip和tcp"><a href="#ip和tcp" class="headerlink" title="ip和tcp"></a>ip和tcp</h2><p>TCP/IP 意味着 TCP 和 IP 在一起协同工作。</p><p>TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。</p><p>IP 负责计算机之间的通信。</p><p>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。</p><p>IP 负责将包发送至接受者。</p><h2 id="tcp和udp"><a href="#tcp和udp" class="headerlink" title="tcp和udp"></a>tcp和udp</h2><h2 id="TCP与UDP基本区别"><a href="#TCP与UDP基本区别" class="headerlink" title="TCP与UDP基本区别"></a>TCP与UDP基本区别</h2><pre><code>1.基于连接与无连接2.TCP要求系统资源较多，UDP较少； 3.UDP程序结构较简单 4.流模式（TCP）与数据报模式(UDP); 5.TCP保证数据正确性，UDP可能丢包 6.TCP保证数据顺序，UDP不保证 </code></pre><p>　　<br>UDP应用场景</p><pre><code>1.面向数据报方式2.网络数据大多为短消息 3.拥有大量Client4.对数据安全性无特殊要求5.网络负担非常重，但对响应速度要求高</code></pre><p>具体编程时的区别</p><pre><code>1.socket()的参数不同 2.UDP Server不需要调用listen和accept 3.UDP收发数据用sendto/recvfrom函数 4.TCP：地址信息在connect/accept时确定 5.UDP：在sendto/recvfrom函数中每次均 需指定地址信息 6.UDP：shutdown函数无效</code></pre><p>通常我们在说到网络编程时默认是指TCP编程，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为SOCK_STREAM。即socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。</p><p>SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，也是双向的，即任何一方都可以收发数据，协议本身提供了一些保障机制保证它是可靠的、有序的，即每个包按照发送的顺序到达接收方。</p><p>SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的，因为通讯双方发送数据后不知道对方是否已经收到数据，是否正常收到数据。任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据。根本不关心对方是否存在，是否发送了数据。它的特点是通讯速度比较快。大家都知道TCP是要经过三次握手的，而UDP没有。 </p><p>基于上述不同，UDP和TCP编程步骤也有些不同，如下：</p><h3 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h3><p>TCP编程的服务器端一般步骤</p><pre><code>　　1、创建一个socket，用函数socket()； 　　2、设置socket属性，用函数setsockopt(); * 可选 　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 　　4、开启监听，用函数listen()； 　　5、接收客户端上来的连接，用函数accept()； 　　6、收发数据，用函数send()和recv()，或者read()和write(); 　　7、关闭网络连接； 　　8、关闭监听； </code></pre><p>TCP编程的客户端一般步骤</p><pre><code>　　1、创建一个socket，用函数socket()； 　　2、设置socket属性，用函数setsockopt();* 可选 　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 　　4、设置要连接的对方的IP地址和端口等属性； 　　5、连接服务器，用函数connect()； 　　6、收发数据，用函数send()和recv()，或者read()和write(); 　　7、关闭网络连接；</code></pre><h3 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h3><p>UDP编程的服务器端一般步骤 </p><pre><code>　　1、创建一个socket，用函数socket()； 　　2、设置socket属性，用函数setsockopt();* 可选 　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 　　4、循环接收数据，用函数recvfrom(); 　　5、关闭网络连接； </code></pre><p>UDP编程的客户端一般步骤 </p><pre><code>　　1、创建一个socket，用函数socket()； 　　2、设置socket属性，用函数setsockopt();* 可选 　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 　　4、设置对方的IP地址和端口等属性; 　　5、发送数据，用函数sendto(); 　　6、关闭网络连接；</code></pre><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><h3 id="UDP补充"><a href="#UDP补充" class="headerlink" title="UDP补充"></a>UDP补充</h3><p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。</p><h3 id="TCP补充"><a href="#TCP补充" class="headerlink" title="TCP补充"></a>TCP补充</h3><p>TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><h3 id="TCP与UDP区别总结"><a href="#TCP与UDP区别总结" class="headerlink" title="TCP与UDP区别总结"></a>TCP与UDP区别总结</h3><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议</p></blockquote><p>HTTP是基于TCP协议的应用，请求时需建立TCP连接，而且请求包中需要包含请求方法，URI，协议版本等信息，请求结束后断开连接，完成一次请求/响应操作。故称为短连接。</p><p>而HTTP/1.1中的keep-alive所保持的长连接则是为了优化每次HTTP请求中TCP连接三次握手的麻烦和资源开销，只建立一次TCP连接，多次的在这个通道上完成请求/响应操作。</p><p>值得一提的是，服务器无法主动给客户端推送消息。<br> HTTP全称是HyperText Transfer Protocal，即：超文本传输协议，HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p><h3 id="HTTPS通信原理"><a href="#HTTPS通信原理" class="headerlink" title="HTTPS通信原理"></a>HTTPS通信原理</h3><p>HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议 它是一个安全通信通道</p><p>HTTPS是HTTP over SSL/TLS，HTTP是应用层协议，TCP是传输层协议，在应用层和传输层之间，增加了一个安全套接层SSL/TLS：</p><p>SSL (Secure Socket Layer，安全套接字层)</p><p>TLS (Transport Layer Security，传输层安全协议)</p><p>SSL使用40 位关键字作为RC4流加密算法</p><h3 id="Https的作用"><a href="#Https的作用" class="headerlink" title="Https的作用"></a>Https的作用</h3><pre><code>内容加密 建立一个信息安全通道，来保证数据传输的安全；身份认证 确认网站的真实性数据完整性 防止内容被第三方冒充或者篡改</code></pre><h3 id="Https和Http"><a href="#Https和Http" class="headerlink" title="Https和Http"></a>Https和Http</h3><pre><code>https协议需要到CA申请证书。http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。http默认使用80端口，https默认使用443端口</code></pre><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP长连接每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化，但WebSocket不仅仅在Web应用程序上得到支持。</p><h2 id="Socket连接和TCP连接"><a href="#Socket连接和TCP连接" class="headerlink" title="Socket连接和TCP连接"></a>Socket连接和TCP连接</h2><p>其实这就是一个文字游戏而已，建立Socket连接需要至少一对Socket（套接字），而创建Socket连接可以指定不同的传输层协议，即TCP或UDP，所以当采用TCP建立连接时，该Socket连接就视为一个TCP连接。而采用UDP则是无连接的。</p><h2 id="Socket和WebSocket"><a href="#Socket和WebSocket" class="headerlink" title="Socket和WebSocket"></a>Socket和WebSocket</h2><p>这两个虽然名字差不多，但却是两个完全不同的概念，就好比Java和JavaScript一样毫无关系。Socket是一套协议封装后的接口，用于建立Socket连接，而WebSocket虽然是Html5的产物，但也不仅仅局限于浏览器的应用程序，许多语言都提供了WebSocket的支持，比如C，C++，Python等。</p><h2 id="HTTP、WebSocket与TCP的关系"><a href="#HTTP、WebSocket与TCP的关系" class="headerlink" title="HTTP、WebSocket与TCP的关系"></a>HTTP、WebSocket与TCP的关系</h2><p>HTTP通信过程属于“你推一下，我走一下”的方式，客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯。所以，HTTP和WebSocket虽都是基于TCP协议，但是两者属于完全不同的两种通讯方式。</p><table><thead><tr><th></th><th style="text-align:center">层次</th><th style="text-align:right"></th></tr></thead><tbody><tr><td>http</td><td style="text-align:center">WebSocket</td><td style="text-align:right"></td></tr><tr><td></td><td style="text-align:center">tcp</td><td style="text-align:right"></td></tr><tr><td></td><td style="text-align:center">ip</td><td style="text-align:right"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Innodb 锁行还是锁表</title>
    <link href="http://martist.cn/2018/06/01/MYSQL/Innodb%20%E9%94%81%E8%A1%8C%E8%BF%98%E6%98%AF%E9%94%81%E8%A1%A8/"/>
    <id>http://martist.cn/2018/06/01/MYSQL/Innodb 锁行还是锁表/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-06-05T08:45:57.963Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>InnoDB默认行级锁。行级锁都是基于索引的。</p><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ </p><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><h2 id="行级锁变为表级锁情况"><a href="#行级锁变为表级锁情况" class="headerlink" title="行级锁变为表级锁情况"></a>行级锁变为表级锁情况</h2><pre><code>1、如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。2、表字段进行变更。3、进行整表查询。(没使用索引)4、like语句查询的时候。(没使用索引)</code></pre><h2 id="行级锁与死锁"><a href="#行级锁与死锁" class="headerlink" title="行级锁与死锁"></a>行级锁与死锁</h2><p>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。</p><p>在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。</p><p>当两个事务同时执行，一个锁住了逐渐索引在等待其他相关索引，一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。</p><p>发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p><p>有多种方法可以避免死锁，这里只介绍常见的三种，具体如下</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。<br>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；<br>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>多列索引</title>
    <link href="http://martist.cn/2018/06/01/MYSQL/%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95/"/>
    <id>http://martist.cn/2018/06/01/MYSQL/多列索引/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-06-03T06:19:03.211Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>mysql中 myisam，innodb默认使用的是Btree索引。<br>索引那这个数据结构最后是排好序；就像新华字典他的目录就是按照a,b,c..这样排好序的；<br>所以你在找东西的时候才快，比如你找 “中” 这个字的解释，你肯定就会定位到目录的 z 开头部分；<br>组合索引可以这样理解，比如（a,b,c），abc都是排好序的，在任意一段a的下面b都是排好序的，任何一段b下面c都是排好序的；</p><h2 id="生效规则"><a href="#生效规则" class="headerlink" title="生效规则"></a>生效规则</h2><p>从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用，比如</p><pre><code>where a=3 and b=45 and c=5 .... 这种三个索引顺序使用中间没有断点，全部发挥作用；where a=3 and c=5... 这种情况下b就是断点，a发挥了效果，c没有效果where b=3 and c=4... 这种情况下a就是断点，在a后面的索引都没有发挥作用，这种写法联合索引没有发挥任何效果；where b=45 and a=3 and c=5 .... 这个跟第一个一样，全部发挥作用，abc只要用上了就行，跟写的顺序无关</code></pre><p>（a,b,c） 三个列上加了联合索引（是联合索引 不是在每个列上单独加索引）</p><p>还需注意，  (a,b,c)多列索引和 (a,c,b)是不一样的，看上面的图也看得出来关系顺序是不一样的；<br>分析几个实际例子来加强理解；<br>分析句子中使用的索引情况</p><pre><code>(0)    select * from mytable where a=3 and b=5 and c=4;abc三个索引都在where条件里面用到了，而且都发挥了作用(1)    select * from mytable where  c=4 and b=6 and a=3;这条语句列出来只想说明 mysql没有那么笨，where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样(2)    select * from mytable where a=3 and c=7;a用到索引，b没有用，所以c是没有用到索引效果的(3)    select * from mytable where a=3 and b&gt;7 and c=3;a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引(4)    select * from mytable where b=3 and c=4;因为a索引没有使用，所以这里 bc都没有用上索引效果(5)    select * from mytable where a&gt;4 and b=7 and c=9;a用到了  b没有使用，c没有使用(6)    select * from mytable where a=3 order by b;a用到了索引，b在结果排序中也用到了索引的效果，前面说了，a下面任意一段的b是排好序的(7)    select * from mytable where a=3 order by c;a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 explain 可以看到 filesort(8)    select * from mytable where b=3 order by a;b没有用到索引，排序中a也没有发挥索引效果</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>高并发的处理思路</title>
    <link href="http://martist.cn/2018/05/31/WEB/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF/"/>
    <id>http://martist.cn/2018/05/31/WEB/高并发的处理思路/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2018-06-06T10:53:43.056Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p><a href="https://www.cnblogs.com/luyucheng/p/6340758.html" target="_blank" rel="external">https://www.cnblogs.com/luyucheng/p/6340758.html</a></p><p><a href="https://segmentfault.com/q/1010000003018297" target="_blank" rel="external">https://segmentfault.com/q/1010000003018297</a></p><p><a href="https://www.cnblogs.com/yuliang8/p/6803238.html" target="_blank" rel="external">https://www.cnblogs.com/yuliang8/p/6803238.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>存储引擎－－MyISAM与InnoDB</title>
    <link href="http://martist.cn/2018/05/29/MYSQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://martist.cn/2018/05/29/MYSQL/存储引擎/</id>
    <published>2018-05-28T16:00:00.000Z</published>
    <updated>2018-06-01T08:36:31.595Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</p><h2 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h2><p>　　◆1.InnoDB不支持FULLTEXT类型的索引。</p><p>　　◆2.InnoDB 中不保存表的具体行数，也就是说，执行select count(<em>) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含 where条件时，两种表的操作是一样的。</p><p>　　◆3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p><p>　　◆4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p><p>　　◆5.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p><p>　　◆6.InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p><p>　　◆7.InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</p><p>两种类型最主要的差别就是Innodb支持事务处理与外键和行级锁。而MyISAM不支持.所以MyISAM往往就容易被人认为只适合在小项目中使用。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>MyISAM适合：(1)做很多count 的计算；(2)插入不频繁，查询非常频繁；(3)没有事务。</p><p>InnoDB适合：(1)可靠性要求比较高，或者要求事务；(2)表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>nginx的502，503，504</title>
    <link href="http://martist.cn/2018/05/29/LINUX/nginx%E7%9A%84502%EF%BC%8C503%EF%BC%8C504/"/>
    <id>http://martist.cn/2018/05/29/LINUX/nginx的502，503，504/</id>
    <published>2018-05-28T16:00:00.000Z</published>
    <updated>2018-06-01T07:11:08.627Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><pre><code>502 Bad GatewayThe server was acting as a gateway or proxy and received an invalid response from the upstream server.503 Service UnavailableThe server is currently unavailable (because it is overloaded or down for maintenance). Generally, this is a temporary state.504 Gateway Time-outThe server was acting as a gateway or proxy and did not receive a timely response from the upstream server.</code></pre><h2 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h2><p>fpm进程挂掉或者后端程序过长时间未返回。</p><h2 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h2><p>当遇到这个状态码的时候表示服务临时不可用，比如nginx配置了频率限制而client端又超过了配置的限制后就会收到503的响应。</p><h2 id="504-Gateway-Time-out"><a href="#504-Gateway-Time-out" class="headerlink" title="504 Gateway Time-out"></a>504 Gateway Time-out</h2><p>nginx的fastcgi模块有一个fastcgi_read_timeout配置，它表示从FastCGI server获取数据的超时时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="NGINX" scheme="http://martist.cn/categories/NGINX/"/>
    
    
      <category term="NGINX" scheme="http://martist.cn/tags/NGINX/"/>
    
      <category term="LINUX" scheme="http://martist.cn/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>索引详解与优化</title>
    <link href="http://martist.cn/2018/05/22/MYSQL/%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://martist.cn/2018/05/22/MYSQL/索引详解与优化/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2018-06-06T07:21:46.926Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p><a href="https://blog.csdn.net/zhangliangzi/article/details/51366345" target="_blank" rel="external">https://blog.csdn.net/zhangliangzi/article/details/51366345</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>php代码规范</title>
    <link href="http://martist.cn/2018/05/16/PHP/php%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://martist.cn/2018/05/16/PHP/php代码规范/</id>
    <published>2018-05-15T16:00:00.000Z</published>
    <updated>2018-06-26T13:28:46.946Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>规范有以下优点：</p><pre><code>高效编码 - 避免了过多的选择造成的『决策时间』浪费；风格统一 - 最大程度统一了开发团队成员代码书写风格和思路，代码阅读起来如出一辙；减少错误 - 减小初级工程师的犯错几率。</code></pre><h2 id="开发哲学"><a href="#开发哲学" class="headerlink" title="开发哲学"></a>开发哲学</h2><p>因为篇幅原因本规范无法涉及到项目里每一块代码的编写标准，所以此处重点说明下此规范遵循的『开发哲学』，开发中请把其当做指明灯，来指引你做决策：</p><pre><code>DRY –「Don&apos;t Repeat Yourself」不写重复的逻辑代码；约定俗成 - 「Convention Over Configuration」，优先选择框架提倡的做法，不过度配置；KISS - 「Keep it Simple, Stupid」提倡简单易读的代码，不写高深、晦涩难懂的代码，不过度设计；主厨精选 - 让有经验的人来为你选择方案，不独创方案；官方提倡 - 优先选择官方推崇的方案。</code></pre><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>以下是一些优秀的『程序设计理念』：</p><pre><code>MVC - Model, View, Controller ，以 MVC 为核心，严格控制 Controller 的可读性和代码行数；Restful - 利用『资源化概念』和标准的 HTTP 动词来组织你的程序；</code></pre><p>在此规范中，我们会将使用这两套理念作为程序设计基础。这些设计理念为我们设计程序提供了依据，遵循这些理念，能让程序变得清晰易读。</p><h2 id="不要过于灵活"><a href="#不要过于灵活" class="headerlink" title="不要过于灵活"></a>不要过于灵活</h2><p>在开发中如果完成一个动作的实现方式过多，建议框架统一方式，易于其他人或多年后的自己阅读代码。</p><h2 id="创建指定版本laravel"><a href="#创建指定版本laravel" class="headerlink" title="创建指定版本laravel"></a>创建指定版本laravel</h2><p>通过安装指定版本的laravel，让项目更加稳定和获得更长时间维护。</p><pre><code>composer create-project laravel/laravel project-name --prefer-dist &quot;5.5.*&quot;</code></pre><h2 id="密钥存放"><a href="#密钥存放" class="headerlink" title="密钥存放"></a>密钥存放</h2><pre><code>硬代码，直接写死。- ❌ 可维护性低写死在 config/app.php 文件中。 - ❌ 无法区分环境进行配置存储于 .env 文件中，使用 env() 方法直接读取。 - ❌ 虽然解决了环境变量问题但是不推荐存储在 .env 和 config/app.php 文件中，然后使用 config() 函数来读取。- ✅ 最佳实践</code></pre><p>这样做主要有以下几个优势：</p><pre><code>定义分明，config() 是配置信息，env() 只是用来区分不同环境；统一放置于 config 中还可以利用框架的 配置信息缓存功能 来提高运行效率；代码健壮性， config() 在 env() 之上多出来一个抽象层，会使代码更加健壮，更加灵活。</code></pre><h2 id="readme-md-文档"><a href="#readme-md-文档" class="headerlink" title="readme.md 文档"></a>readme.md 文档</h2><pre><code>「项目概述」- 介绍说明项目的一些情况，类似于简单的产品说明，简单的功能描述，项目相关链接等，500 字以内；「运行环境」- 运行环境说明，系统要求等信息；「开发环境部署/安装」- 一步一步引导说明，保证项目新成员能最快速的，没有歧义的部署好开发环境；「服务器架构说明」- 最好能有服务器架构图，从用户浏览器请求开始，包括后端缓存服务使用等都描述清楚（主要体现为软件的使用），配合「运行环境」区块内容，可作为线上环境部署的依据；「代码上线」- 介绍代码上线流程，需要执行哪些步骤；「扩展包说明」- 表格列出所有使用的扩展包，还有在哪些业务逻辑或者用例中使用了此扩展包；「自定义 Artisan 命令列表」- 以表格形式罗列出所有自定义的命令，说明用途，指出调用场景；「队列列表」- 以表格形式罗列出项目所有队列接口，说明用途，指出调用场景。</code></pre><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>开发中用到最多的是psr-1和psr-2的开发规范，对其他psr规范有好奇心的可以自行学习。</p><h3 id="PSR-1"><a href="#PSR-1" class="headerlink" title="PSR-1"></a>PSR-1</h3><h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p> 必须 遵循 StudlyCaps 大写开头的驼峰命名规范；</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>所有字母都 必须 大写，单词间用下划线分隔；</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>必须 符合 camelCase 式的小写开头驼峰命名规范。</p><p>PHP代码 必须 且只可使用 不带 BOM 的 UTF-8 编码。</p><h4 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h4><pre><code>大写开头的驼峰式 ($StudlyCaps)小写开头的驼峰式 ($camelCase)下划线分隔式 ($under_score)</code></pre><p>本规范不做强制要求，但无论遵循哪种命名方式，都 应该 在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。</p><h3 id="PSR-2"><a href="#PSR-2" class="headerlink" title="PSR-2"></a>PSR-2</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><pre><code>代码 必须 使用 4 个空格符而不是「Tab 键」进行缩进。每行的字符数 应该 软性保持在 80 个之内，理论上 一定不可 多于 120 个，但 一定不可 有硬性限制。每个 namespace 命名空间声明语句和 use 声明语句块后面，必须 插入一个空白行。类的开始花括号（{） 必须 写在函数声明后自成一行，结束花括号（}）也 必须 写在函数主体后自成一行。方法的开始花括号（{） 必须 写在函数声明后自成一行，结束花括号（}）也 必须 写在函数主体后自成一行。类的属性和方法 必须 添加访问修饰符（private、protected 以及 public），abstract 以及 final 必须 声明在访问修饰符之前，而 static 必须 声明在访问修饰符之后。控制结构的关键字后 必须 要有一个空格符，而调用方法或函数时则 一定不可 有。控制结构的开始花括号（{） 必须 写在声明的同一行，而结束花括号（}） 必须 写在主体后自成一行。控制结构的开始左括号后和结束右括号前，都 一定不可 有空格符。</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>&lt;?phpnamespace Vendor\Package;use FooInterface;use BarClass as Bar;use OtherVendor\OtherPackage\BazClass;class Foo extends Bar implements FooInterface{    public function sampleMethod($a, $b = null)    {        if ($a === $b) {            bar();        } elseif ($a &gt; $b) {            $foo-&gt;bar($arg1);        } else {            BazClass::bar($arg2, $arg3);        }    }    final public static function bar()    {        // 方法体    }}</code></pre>]]></content>
    
    <summary type="html">
    
      如今外包和remote工作越来越多，代码规范尤为重要
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>聚簇索引(clustered index)</title>
    <link href="http://martist.cn/2018/05/14/MYSQL/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
    <id>http://martist.cn/2018/05/14/MYSQL/聚簇索引/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2018-06-05T07:23:58.250Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。<br>一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。</p><h2 id="生成规则"><a href="#生成规则" class="headerlink" title="生成规则"></a>生成规则</h2><p>mysql的聚簇索引是指innodb引擎的特性，mysiam并没有，如果需要该索引，只要将索引指定为主键（primary key）就可以了。</p><p>1)  有主键时，根据主键创建聚簇索引<br>2)  没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引<br>3) 如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>InnoDB是基于聚簇索引建立的。所以说建表是选择了innodb引擎，就代表默认差UN构建了聚簇索引。</p><p>InnoDB的索引结构和mysql的其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。它的二级索引(second index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应该尽可能的小。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>在《数据库原理》一书中是这么解释聚簇索引和非聚簇索引的区别的：<br>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p><p>因此，MYSQL中不同的数据存储引擎对聚簇索引的支持不同就很好解释了。</p><p>InnoDB的的二级索引的叶子节点存放的是KEY字段加主键值。因此，通过二级索引查询首先查到是主键值，然后InnoDB再根据查到的主键值通过主键索引找到相应的数据块。而MyISAM的二级索引叶子节点存放的还是列值与行号的组合，叶子节点中保存的是数据的物理地址。所以可以看出MYISAM的主键索引和二级索引没有任何区别，主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键。</p><h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><p>聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接指向对应数据块。</p><p>聚簇索引主键的插入速度要比非聚簇索引主键的插入速度慢很多。相比之下，聚簇索引适合排序，非聚簇索引（也叫二级索引）不适合用在排序的场合。<br>因为聚簇索引本身已经是按照物理顺序放置的，排序很快。非聚簇索引则没有按序存放，需要额外消耗资源来排序。<br>当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。<br>另外，二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据。</p><p>innodb索引分类：<br>聚簇索引(clustered index)<br>    1)  有主键时，根据主键创建聚簇索引<br>    2)  没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引<br>    3) 如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引<br>辅助索引(secondary index)<br>   非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引</p><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>聚簇索引的优点,就是提高数据访问性能。<br>聚簇索引把索引和数据都保存到同一棵B+树数据结构中，并且同时将索引列与相关数据行保存在一起。这意味着，当你访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。不同于MyISAM引擎，它将索引和数据没有放在一块，放在不同的物理文件中，索引文件是缓存在key_buffer中，索引对应的是磁盘位置，不得不通过磁盘位置访问磁盘数据。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1) 维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片。</p><p>2) 表因为使用UUId作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键。 </p><p>3) 如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>性能测试</title>
    <link href="http://martist.cn/2018/05/14/MYSQL/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://martist.cn/2018/05/14/MYSQL/性能测试/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2018-06-06T10:00:28.795Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="profiling"><a href="#profiling" class="headerlink" title="profiling"></a>profiling</h2><p>查看Mysql关于profile的设置</p><pre><code>show variables like &apos;%pro%&apos;;  #查验mysql中profile的设置选项  </code></pre><p>设置其profiling选项</p><pre><code>set profiling = 1  </code></pre><p>执行SQL，查看其执行情况 </p><pre><code>select * from om_transfer omt;show profiles;</code></pre><p>看到其执行的时间为6.48秒</p><p>duration单位是秒。</p><p>##查看索引</p><pre><code>--如果查看索引前，没有使用user db_name等命令指定具体的数据库，则必须加上FROM db_nameSHOW INDEX FROM table_name [FROM db_name]--如果查看索引前，没有使用user db_name等命令指定具体的数据库，则必须加上db_name.前缀SHOW INDEX FROM [db_name.]table_name</code></pre><h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><p>explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。</p><p>使用方法，在select语句前加上explain就可以了：</p><p>如：</p><pre><code>explain select surname,first_name form a,b where a.id=b.id </code></pre><p>EXPLAIN列的解释：</p><p>table：显示这一行的数据是关于哪张表的</p><p>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</p><pre><code>type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL一般来说，得保证查询至少达到range级别，最好能达到ref。</code></pre><p>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p><p>key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p><p>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数</p><p>rows：MYSQL认为必须检查的用来返回请求数据的行数</p><p>Extra：关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢</p><p>extra列返回的描述的意义</p><p> Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了</p><p> Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了</p><p> Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一</p><p> Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行</p><p> Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候</p><p> Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上</p><p> Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）</p><p> system 表只有一行：system表。这是const连接类型的特殊情况</p><p> const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待</p><p> eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用</p><p> ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好</p><p> range:这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况</p><p> index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）</p><p> ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免</p><p>先看一个例子：</p><pre><code>mysql&gt; explain select * from t_order; +----+-------------+---------+------+---------------+------+---------+------+--------+-------+ | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra | +----+-------------+---------+------+---------------+------+---------+------+--------+-------+ |  1 | SIMPLE      | t_order | ALL  | NULL          | NULL | NULL    | NULL | 100453 |       | +----+-------------+---------+------+---------------+------+---------+------+--------+-------+ 1 row in set (0.03 sec) </code></pre><p>加上extended后之后：</p><pre><code>mysql&gt; explain extended select * from t_order; +----+-------------+---------+------+---------------+------+---------+------+--------+----------+-------+ | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra | +----+-------------+---------+------+---------------+------+---------+------+--------+----------+-------+ |  1 | SIMPLE      | t_order | ALL  | NULL          | NULL | NULL    | NULL | 100453 |   100.00 |       | +----+-------------+---------+------+---------------+------+---------+------+--------+----------+-------+ 1 row in set, 1 warning (0.00 sec) </code></pre><p>有必要解释一下这个长长的表格里每一列的含义：<br>id     SELECT识别符。这是SELECT的查询序列号<br>select_type     </p><p>SELECT类型,可以为以下任何一种:</p><pre><code>SIMPLE:简单SELECT(不使用UNION或子查询)PRIMARY:最外面的SELECTUNION:UNION中的第二个或后面的SELECT语句DEPENDENT UNION:UNION中的第二个或后面的SELECT语句,取决于外面的查询UNION RESULT:UNION 的结果SUBQUERY:子查询中的第一个SELECTDEPENDENT SUBQUERY:子查询中的第一个SELECT,取决于外面的查询DERIVED:导出表的SELECT(FROM子句的子查询)</code></pre><p>table     </p><p>输出的行所引用的表<br>type     </p><p>联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:</p><pre><code>system:表仅有一行(=系统表)。这是const联接类型的一个特例。const:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!eq_ref:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。ref:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。ref_or_null:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。index_merge:该联接类型表示使用了索引合并优化方法。unique_subquery:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。index_subquery:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)range:只检索给定范围的行,使用一个索引来选择行。index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。ALL:对于每个来自于先前的表的行组合,进行完整的表扫描。</code></pre><p>possible_keys     </p><p>指出MySQL能使用哪个索引在该表中找到行<br>key     显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。<br>key_len     显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。<br>ref     显示使用哪个列或常数与key一起从表中选择行。<br>rows     显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。<br>filtered     显示了通过条件过滤出的行数的百分比估计值。<br>Extra     </p><p>该列包含MySQL解决查询的详细信息</p><pre><code>Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果。Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。Using sort_union(...), Using union(...), Using intersect(...):这些函数说明如何为index_merge联接类型合并索引扫描。Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。</code></pre><p>一.select_type的说明</p><p>1.UNION:</p><p>当通过union来连接多个查询结果时，第二个之后的select其select_type为UNION。</p><pre><code>mysql&gt; explain select * from t_order where order_id=100 union select * from t_order where order_id=200; +----+--------------+------------+-------+---------------+---------+---------+-------+------+-------+ | id | select_type  | table      | type  | possible_keys | key     | key_len | ref   | rows | Extra | +----+--------------+------------+-------+---------------+---------+---------+-------+------+-------+ |  1 | PRIMARY      | t_order    | const | PRIMARY       | PRIMARY | 4       | const |    1 |       | |  2 | UNION        | t_order    | const | PRIMARY       | PRIMARY | 4       | const |    1 |       | | NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL    | NULL    | NULL  | NULL |       | +----+--------------+------------+-------+---------------+---------+---------+-------+------+-------+ 3 rows in set (0.34 sec) </code></pre><p>2.DEPENDENT UNION与DEPENDENT SUBQUERY:</p><p>当union作为子查询时，其中第二个union的select_type就是DEPENDENT UNION。<br>第一个子查询的select_type则是DEPENDENT SUBQUERY。</p><pre><code>mysql&gt; explain select * from t_order where order_id in (select order_id from t_order where order_id=100 union select order_id from t_order where order_id=200); +----+--------------------+------------+-------+---------------+---------+---------+-------+--------+-------------+ | id | select_type        | table      | type  | possible_keys | key     | key_len | ref   | rows   | Extra       | +----+--------------------+------------+-------+---------------+---------+---------+-------+--------+-------------+ |  1 | PRIMARY            | t_order    | ALL   | NULL          | NULL    | NULL    | NULL  | 100453 | Using where | |  2 | DEPENDENT SUBQUERY | t_order    | const | PRIMARY       | PRIMARY | 4       | const |      1 | Using index | |  3 | DEPENDENT UNION    | t_order    | const | PRIMARY       | PRIMARY | 4       | const |      1 | Using index | | NULL | UNION RESULT       | &lt;union2,3&gt; | ALL   | NULL          | NULL    | NULL    | NULL  |   NULL |             | +----+--------------------+------------+-------+---------------+---------+---------+-------+--------+-------------+ 4 rows in set (0.03 sec) </code></pre><p>3.SUBQUERY:</p><p>子查询中的第一个select其select_type为SUBQUERY。</p><pre><code>mysql&gt; explain select * from t_order where order_id=(select order_id from t_order where order_id=100); +----+-------------+---------+-------+---------------+---------+---------+-------+------+-------------+ | id | select_type | table   | type  | possible_keys | key     | key_len | ref   | rows | Extra       | +----+-------------+---------+-------+---------------+---------+---------+-------+------+-------------+ |  1 | PRIMARY     | t_order | const | PRIMARY       | PRIMARY | 4       | const |    1 |             | |  2 | SUBQUERY    | t_order | const | PRIMARY       | PRIMARY | 4       |       |    1 | Using index | +----+-------------+---------+-------+---------------+---------+---------+-------+------+-------------+ 2 rows in set (0.03 sec) </code></pre><p>4.DERIVED:</p><p>当子查询是from子句时，其select_type为DERIVED。</p><pre><code>mysql&gt; explain select * from (select order_id from t_order where order_id=100) a; +----+-------------+------------+--------+---------------+---------+---------+------+------+-------------+ | id | select_type | table      | type   | possible_keys | key     | key_len | ref  | rows | Extra       | +----+-------------+------------+--------+---------------+---------+---------+------+------+-------------+ |  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL    | NULL    | NULL |    1 |             | |  2 | DERIVED     | t_order    | const  | PRIMARY       | PRIMARY | 4       |      |    1 | Using index | +----+-------------+------------+--------+---------------+---------+---------+------+------+-------------+ 2 rows in set (0.03 sec) </code></pre><p>二.type的说明</p><p>1.system，const</p><p>见上面4.DERIVED的例子。其中第一行的type就是为system，第二行是const，这两种联接类型是最快的。</p><p>2.eq_ref</p><p>在t_order表中的order_id是主键，t_order_ext表中的order_id也是主键，该表可以认为是订单表的补充信息表，他们的关系是1对1，在下面的例子中可以看到b表的连接类型是eq_ref，这是极快的联接类型。</p><pre><code>mysql&gt; explain select * from t_order a,t_order_ext b where a.order_id=b.order_id; +----+-------------+-------+--------+---------------+---------+---------+-----------------+------+-------------+ | id | select_type | table | type   | possible_keys | key     | key_len | ref             | rows | Extra       | +----+-------------+-------+--------+---------------+---------+---------+-----------------+------+-------------+ |  1 | SIMPLE      | b     | ALL    | order_id      | NULL    | NULL    | NULL            |    1 |             | |  1 | SIMPLE      | a     | eq_ref | PRIMARY       | PRIMARY | 4       | test.b.order_id |    1 | Using where | +----+-------------+-------+--------+---------------+---------+---------+-----------------+------+-------------+ 2 rows in set (0.00 sec) </code></pre><p>3.ref</p><p>下面的例子在上面的例子上略作了修改，加上了条件。此时b表的联接类型变成了ref。因为所有与a表中order_id=100的匹配记录都将会从b表获取。这是比较常见的联接类型。</p><pre><code>mysql&gt; explain select * from t_order a,t_order_ext b where a.order_id=b.order_id and a.order_id=100; +----+-------------+-------+-------+---------------+----------+---------+-------+------+-------+ | id | select_type | table | type  | possible_keys | key      | key_len | ref   | rows | Extra | +----+-------------+-------+-------+---------------+----------+---------+-------+------+-------+ |  1 | SIMPLE      | a     | const | PRIMARY       | PRIMARY  | 4       | const |    1 |       | |  1 | SIMPLE      | b     | ref   | order_id      | order_id | 4       | const |    1 |       | +----+-------------+-------+-------+---------------+----------+---------+-------+------+-------+ 2 rows in set (0.00 sec) </code></pre><p>4.ref_or_null</p><p>user_id字段是一个可以为空的字段，并对该字段创建了一个索引。在下面的查询中可以看到联接类型为ref_or_null，这是mysql为含有null的字段专门做的处理。在我们的表设计中应当尽量避免索引字段为NULL，因为这会额外的耗费mysql的处理时间来做优化。</p><pre><code>mysql&gt; explain select * from t_order where user_id=100 or user_id is null; +----+-------------+---------+-------------+---------------+---------+---------+-------+-------+-------------+ | id | select_type | table   | type        | possible_keys | key     | key_len | ref   | rows  | Extra       | +----+-------------+---------+-------------+---------------+---------+---------+-------+-------+-------------+ |  1 | SIMPLE      | t_order | ref_or_null | user_id       | user_id | 5       | const | 50325 | Using where | +----+-------------+---------+-------------+---------------+---------+---------+-------+-------+-------------+ 1 row in set (0.00 sec) </code></pre><p>5.index_merge</p><p>经常出现在使用一张表中的多个索引时。mysql会将多个索引合并在一起，如下例:</p><pre><code>mysql&gt; explain select * from t_order where order_id=100 or user_id=10; +----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+-------------------------------------------+ | id | select_type | table   | type        | possible_keys   | key             | key_len | ref  | rows | Extra                                     | +----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+-------------------------------------------+ |  1 | SIMPLE      | t_order | index_merge | PRIMARY,user_id | PRIMARY,user_id | 4,5     | NULL |    2 | Using union(PRIMARY,user_id); Using where | +----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+-------------------------------------------+ 1 row in set (0.09 sec) </code></pre><p>6.unique_subquery</p><p>该联接类型用于替换value IN (SELECT primary_key FROM single_table WHERE some_expr)这样的子查询的ref。注意ref列，其中第二行显示的是func，表明unique_subquery是一个函数，而不是一个普通的ref。</p><pre><code>mysql&gt; explain select * from t_order where order_id in (select order_id from t_order where user_id=10); +----+--------------------+---------+-----------------+-----------------+---------+---------+------+--------+-------------+ | id | select_type        | table   | type            | possible_keys   | key     | key_len | ref  | rows   | Extra       | +----+--------------------+---------+-----------------+-----------------+---------+---------+------+--------+-------------+ |  1 | PRIMARY            | t_order | ALL             | NULL            | NULL    | NULL    | NULL | 100649 | Using where | |  2 | DEPENDENT SUBQUERY | t_order | unique_subquery | PRIMARY,user_id | PRIMARY | 4       | func |      1 | Using where | +----+--------------------+---------+-----------------+-----------------+---------+---------+------+--------+-------------+ 2 rows in set (0.00 sec) </code></pre><p>7.index_subquery</p><p>该联接类型与上面的太像了，唯一的差别就是子查询查的不是主键而是非唯一索引。</p><pre><code>mysql&gt; explain select * from t_order where user_id in (select user_id from t_order where order_id&gt;10); +----+--------------------+---------+----------------+-----------------+---------+---------+------+--------+--------------------------+ | id | select_type        | table   | type           | possible_keys   | key     | key_len | ref  | rows   | Extra                    | +----+--------------------+---------+----------------+-----------------+---------+---------+------+--------+--------------------------+ |  1 | PRIMARY            | t_order | ALL            | NULL            | NULL    | NULL    | NULL | 100649 | Using where              | |  2 | DEPENDENT SUBQUERY | t_order | index_subquery | PRIMARY,user_id | user_id | 5       | func |  50324 | Using index; Using where | +----+--------------------+---------+----------------+-----------------+---------+---------+------+--------+--------------------------+ 2 rows in set (0.00 sec) </code></pre><p>8.range</p><p>按指定的范围进行检索，很常见。</p><pre><code>mysql&gt; explain select * from t_order where user_id in (100,200,300); +----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+ | id | select_type | table   | type  | possible_keys | key     | key_len | ref  | rows | Extra       | +----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+ |  1 | SIMPLE      | t_order | range | user_id       | user_id | 5       | NULL |    3 | Using where | +----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+ 1 row in set (0.00 sec) </code></pre><p>9.index</p><p>在进行统计时非常常见，此联接类型实际上会扫描索引树，仅比ALL快些。</p><pre><code>mysql&gt; explain select count(*) from t_order; +----+-------------+---------+-------+---------------+---------+---------+------+--------+-------------+ | id | select_type | table   | type  | possible_keys | key     | key_len | ref  | rows   | Extra       | +----+-------------+---------+-------+---------------+---------+---------+------+--------+-------------+ |  1 | SIMPLE      | t_order | index | NULL          | user_id | 5       | NULL | 100649 | Using index | +----+-------------+---------+-------+---------------+---------+---------+------+--------+-------------+ 1 row in set (0.00 sec) </code></pre><p>10.ALL</p><p>完整的扫描全表，最慢的联接类型，尽可能的避免。</p><pre><code>mysql&gt; explain select * from t_order; +----+-------------+---------+------+---------------+------+---------+------+--------+-------+ | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra | +----+-------------+---------+------+---------------+------+---------+------+--------+-------+ |  1 | SIMPLE      | t_order | ALL  | NULL          | NULL | NULL    | NULL | 100649 |       | +----+-------------+---------+------+---------------+------+---------+------+--------+-------+ 1 row in set (0.00 sec) </code></pre><p>三.extra的说明</p><p>1.Distinct</p><p>MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。对于此项没有找到合适的例子，求指点。</p><p>2.Not exists</p><p>因为b表中的order_id是主键，不可能为NULL，所以mysql在用a表的order_id扫描t_order表，并查找b表的行时，如果在b表发现一个匹配的行就不再继续扫描b了，因为b表中的order_id字段不可能为NULL。这样避免了对b表的多次扫描。</p><pre><code>mysql&gt; explain select count(1) from t_order a left join t_order_ext b on a.order_id=b.order_id where b.order_id is null;  +----+-------------+-------+-------+---------------+--------------+---------+-----------------+--------+--------------------------------------+ | id | select_type | table | type  | possible_keys | key          | key_len | ref             | rows   | Extra                                | +----+-------------+-------+-------+---------------+--------------+---------+-----------------+--------+--------------------------------------+ |  1 | SIMPLE      | a     | index | NULL          | express_type | 1       | NULL            | 100395 | Using index                          | |  1 | SIMPLE      | b     | ref   | order_id      | order_id     | 4       | test.a.order_id |      1 | Using where; Using index; Not exists | +----+-------------+-------+-------+---------------+--------------+---------+-----------------+--------+--------------------------------------+ 2 rows in set (0.01 sec) </code></pre><p>3.Range checked for each record</p><p>这种情况是mysql没有发现好的索引可用，速度比没有索引要快得多。</p><pre><code>mysql&gt; explain select * from t_order t, t_order_ext s where s.order_id&gt;=t.order_id and s.order_id&lt;=t.order_id and t.express_type&gt;5; +----+-------------+-------+-------+----------------------+--------------+---------+------+------+------------------------------------------------+ | id | select_type | table | type  | possible_keys        | key          | key_len | ref  | rows | Extra                                          | +----+-------------+-------+-------+----------------------+--------------+---------+------+------+------------------------------------------------+ |  1 | SIMPLE      | t     | range | PRIMARY,express_type | express_type | 1       | NULL |    1 | Using where                                    | |  1 | SIMPLE      | s     | ALL   | order_id             | NULL         | NULL    | NULL |    1 | Range checked for each record (index map: 0x1) | +----+-------------+-------+-------+----------------------+--------------+---------+------+------+------------------------------------------------+ 2 rows in set (0.00 sec)</code></pre><p>4.Using filesort</p><p>在有排序子句的情况下很常见的一种情况。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行。</p><pre><code>mysql&gt; explain select * from t_order order by express_type; +----+-------------+---------+------+---------------+------+---------+------+--------+----------------+ | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra          | +----+-------------+---------+------+---------------+------+---------+------+--------+----------------+ |  1 | SIMPLE      | t_order | ALL  | NULL          | NULL | NULL    | NULL | 100395 | Using filesort | +----+-------------+---------+------+---------------+------+---------+------+--------+----------------+ 1 row in set (0.00 sec) </code></pre><p>5.Using index</p><p>这是性能很高的一种情况。当查询所需的数据可以直接从索引树中检索到时，就会出现。上面的例子中有很多这样的例子，不再多举例了。</p><p>6.Using temporary</p><p>发生这种情况一般都是需要进行优化的。mysql需要创建一张临时表用来处理此类查询。</p><pre><code>mysql&gt; explain select * from t_order a left join t_order_ext b on a.order_id=b.order_id group by b.order_id; +----+-------------+-------+------+---------------+----------+---------+-----------------+--------+---------------------------------+ | id | select_type | table | type | possible_keys | key      | key_len | ref             | rows   | Extra                           | +----+-------------+-------+------+---------------+----------+---------+-----------------+--------+---------------------------------+ |  1 | SIMPLE      | a     | ALL  | NULL          | NULL     | NULL    | NULL            | 100395 | Using temporary; Using filesort | |  1 | SIMPLE      | b     | ref  | order_id      | order_id | 4       | test.a.order_id |      1 |                                 | +----+-------------+-------+------+---------------+----------+---------+-----------------+--------+---------------------------------+ 2 rows in set (0.00 sec) </code></pre><p>7.Using where</p><p>当有where子句时，extra都会有说明。</p><p>8.Using sort_union(…)/Using union(…)/Using intersect(…)</p><p>下面的例子中user_id是一个检索范围，此时mysql会使用sort_union函数来进行索引的合并。而当user_id是一个固定值时，请参看上面type说明5.index_merge的例子，此时会使用union函数进行索引合并。</p><pre><code>mysql&gt; explain select * from t_order where order_id=100 or user_id&gt;10; +----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+------------------------------------------------+ | id | select_type | table   | type        | possible_keys   | key             | key_len | ref  | rows | Extra                                          | +----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+------------------------------------------------+ |  1 | SIMPLE      | t_order | index_merge | PRIMARY,user_id | user_id,PRIMARY | 5,4     | NULL |    2 | Using sort_union(user_id,PRIMARY); Using where | +----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+------------------------------------------------+ 1 row in set (0.00 sec) </code></pre><p>对于Using intersect的例子可以参看下例，user_id与express_type发生了索引交叉合并。</p><pre><code>mysql&gt; explain select * from t_order where express_type=1 and user_id=100; +----+-------------+---------+-------------+----------------------+----------------------+---------+------+------+----------------------------------------------------+ | id | select_type | table   | type        | possible_keys        | key                  | key_len | ref  | rows | Extra                                              | +----+-------------+---------+-------------+----------------------+----------------------+---------+------+------+----------------------------------------------------+ |  1 | SIMPLE      | t_order | index_merge | user_id,express_type | user_id,express_type | 5,1     | NULL |    1 | Using intersect(user_id,express_type); Using where | +----+-------------+---------+-------------+----------------------+----------------------+---------+------+------+----------------------------------------------------+ 1 row in set (0.00 sec) </code></pre><p>9.Using index for group-by</p><p>表明可以在索引中找到分组所需的所有数据，不需要查询实际的表。</p><pre><code>mysql&gt; explain select user_id from t_order group by user_id; +----+-------------+---------+-------+---------------+---------+---------+------+------+--------------------------+ | id | select_type | table   | type  | possible_keys | key     | key_len | ref  | rows | Extra                    | +----+-------------+---------+-------+---------------+---------+---------+------+------+--------------------------+ |  1 | SIMPLE      | t_order | range | NULL          | user_id | 5       | NULL |    3 | Using index for group-by | +----+-------------+---------+-------+---------------+---------+---------+------+------+--------------------------+ 1 row in set (0.00 sec) </code></pre><p>除了上面的三个说明，还需要注意rows的数值，多行之间的数值是乘积的关系，可以估算大概要处理的行数，如果乘积很大，那就很有优化的必要了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/zhu_tianwei/article/details/53418041" target="_blank" rel="external">https://blog.csdn.net/zhu_tianwei/article/details/53418041</a><br><a href="https://blog.csdn.net/shaochenshuo/article/details/51580296" target="_blank" rel="external">https://blog.csdn.net/shaochenshuo/article/details/51580296</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://martist.cn/2018/05/14/MYSQL/%E6%AD%BB%E9%94%81/"/>
    <id>http://martist.cn/2018/05/14/MYSQL/死锁/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2018-06-06T07:56:58.103Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p><a href="https://blog.csdn.net/qq_16681169/article/details/73359670" target="_blank" rel="external">https://blog.csdn.net/qq_16681169/article/details/73359670</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>索引基础</title>
    <link href="http://martist.cn/2018/05/14/MYSQL/%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://martist.cn/2018/05/14/MYSQL/索引基础/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2018-06-06T02:28:42.960Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>索引基础——B-Tree、B+Tree、红黑树、B*Tree数据结构</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B-Tree（并不是B“减”树，横杠为连接符，容易被误导）是一种多路搜索树（并不是二叉的）：</p><p>1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p><p>2.根结点的儿子数为[2, M]；</p><p>3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p><p>4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p><p>5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p><p>6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p><p>7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p><p>8.所有叶子结点位于同一层；</p><p>如：（M=3）</p><p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p><h2 id="B-树的特性"><a href="#B-树的特性" class="headerlink" title="B-树的特性"></a>B-树的特性</h2><p>1.关键字集合分布在整颗树中；</p><p>2.任何一个关键字出现且只出现在一个结点中；</p><p>3.搜索有可能在非叶子结点结束；</p><p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p><p>5.自动层次控制；<br>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B-树的变体，也是一种多路搜索树：其定义基本与B-树同，除了：<br>1.非叶子结点的子树指针与关键字个数相同；<br>2.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；<br>3.为所有叶子结点增加一个链指针；<br>4.所有关键字都在叶子结点出现；<br>如：（M=3）<br>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在<br>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><h2 id="B-的特性"><a href="#B-的特性" class="headerlink" title="B+的特性"></a>B+的特性</h2><p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；<br>2.不可能在非叶子结点命中；<br>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；<br>4.更适合文件索引系统；</p><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3（代替B+树的1/2）；<br>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；<br>B<em>树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；所以，B</em>树分配新结点的概率比B+树要低，空间使用率更高；</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树（Red-Black Tree）是二叉搜索树（Binary Search Tree）的一种改进。我们知道二叉搜索树在最坏的情况下可能会变成一个链表（当所有节点按从小到大的顺序依次插入后）。而红黑树在每一次插入或删除节点之后都会花O（log N）的时间来对树的结构作修改，以保持树的平衡。也就是说，红黑树的查找方法与二叉搜索树完全一样；插入和删除节点的的方法前半部分节与二叉搜索树完全一样，而后半部分添加了一些修改树的结构的操作。</p><p>红黑树的每个节点上的属性除了有一个key、3个指针：parent、lchild、rchild以外，还多了一个属性：color。它只能是两种颜色：红或黑。而红黑树除了具有二叉搜索树的所有性质之外，还具有以下4点性质：</p><ol><li>根节点是黑色的。</li><li>空节点是黑色的（红黑树中，根节点的parent以及所有叶节点lchild、rchild都不指向NULL，而是指向一个定义好的空节点）。</li><li>红色节点的父、左子、右子节点都是黑色。</li><li>在任何一棵子树中，每一条从根节点向下走到空节点的路径上包含的黑色节点数量都相同。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p><p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p><p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>laravel的核心</title>
    <link href="http://martist.cn/2018/05/10/LARAVEL/laravel%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://martist.cn/2018/05/10/LARAVEL/laravel核心概念/</id>
    <published>2018-05-09T16:00:00.000Z</published>
    <updated>2018-05-11T11:49:59.799Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="依赖注入容器不止laravel一家"><a href="#依赖注入容器不止laravel一家" class="headerlink" title="依赖注入容器不止laravel一家"></a>依赖注入容器不止laravel一家</h2><p>目前市面上流行有数十个依赖注入容器, 而这些DI(Dependency Injection)容器有着大相径庭的方式来存储条目.</p><pre><code>有一些基于回调(callbacks) (Pimple, Laravel, …)其他的基于配置(Symfony, ZendFramework, …), 配置有多种格式(PHP数组, YAML文件, XML文件)有一些可以 利用工厂(leverage factories)有一些使用PHP API来创建条目(PHP-DI, ZF, Symfony, Mouf, …)有一些可以自动装配(Laravel, PHP-DI)    即自动处理依赖其他的一些能根据注释来解决依赖(PHP-DI, JMS Bundle…)有一些提供图形用户界面(Mouf)有一些可以使用配置文件编译成PHP类(Symfony, ZF)有一些支持别名有一些可以使用代理以提供依赖关系的延迟加载(lazy loading of dependencies)</code></pre><p>局势就是如此, 当前有着非常多种方式来解决依赖注入问题, 因此有很多种DI容器的实现方式.<br>然而, 所有的DI容器都在满足同样的需求: 它们为应用程序提供一种检索一组配置对象(通常是服务)的方法.</p><p>通过标准化从容器中获取条目的方式, 使用 容器PSR规范 的框架和库可以与与任何兼容的容器.<br>这更便于用户(指使用容器的开发者)根据各自的喜好来选择容器.</p><h2 id="laravel的IOC"><a href="#laravel的IOC" class="headerlink" title="laravel的IOC"></a>laravel的IOC</h2><p>上面一篇文章《正确的理解IOC》提到，laravel的核心【IOC容器】很轻量，具体有以下几个特点：</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>类也不依赖DI对象，依赖注入是通过反射分析出类所依赖的其他类，然后从容器中获取相应的对象并自动注入到类里面。<br>依赖注入的写法是强类型参数，也就是参数有提示类名/接口。<br>laravel的服务容器实现了 PSR-11 接口。 因此，你可以使用 PSR-11容器『接口类型提示』来获取 Laravel 容器的实例。</p><h3 id="Facades"><a href="#Facades" class="headerlink" title="Facades"></a>Facades</h3><p>在 Laravel 应用程序的环境中，facade 是个提供从容器访问对象的类。Facade 类是让这个机制可以运作的原因。Laravel 的 facades 和你建立的任何自定义 facades，将会继承基类 Facade。</p><p>你的 facade 类只需要去实现一个方法：getFacadeAccessor。getFacadeAccessor 方法的工作是定义要从容器解析什么。基类 Facade 利用 __callStatic() 魔术方法来从你的 facade 调用到解析出来的对象。</p><p>所以当你对 facade 调用，例如 Cache::get，Laravel 从服务容器解析缓存管理类出来，并对该类调用 get 方法。用专业口吻来说，Laravel Facades 是使用 Laravel 服务容器作为服务定位器的便捷语法。<br>下面是route的facade类:</p><pre><code>namespace Illuminate\Support\Facades;class Route extends Facade{    /**     * Get the registered name of the component.     *     * @return string     */    protected static function getFacadeAccessor()    {        return &apos;router&apos;;    }}</code></pre><h3 id="serviceProvider"><a href="#serviceProvider" class="headerlink" title="serviceProvider"></a>serviceProvider</h3><p>服务提供者是所有 Laravel 应用程序的启动中心。你的应用程序，以及所有 Laravel 的核心服务，都是透过服务提供者启动。</p><p>但我们所说的「启动」指的是什么？一般而言，我们指注册事物，包括注册服务容器绑定、事件监听器、过滤器，甚至路由。服务提供者是你的应用程序配置中心所在。</p><p>如果你打开包含于 Laravel 中的 config/app.php 这一文件，你会看到 providers 数组。这些是所有将加载至你的应用程序里的服务提供者类。当然，它们之中有很多属于「缓载」提供者，意思是除非真正需要它们所提供的服务，否则它们并不会在每一个请求中都被加载。</p><h3 id="serviceProvider和Facades的关系"><a href="#serviceProvider和Facades的关系" class="headerlink" title="serviceProvider和Facades的关系"></a>serviceProvider和Facades的关系</h3><p>如果要把所有可能的service绑定，container类会变得非常庞大，如果在应用的开始调用N次bind方法，依次绑定需要的所有service，这个文件将难以维护，比如</p><pre><code>class Container {  protected $service_arr = [];  public function bind($name, $instance) {     $this-&gt;servie_arr[$name] = $instance;  }  public function get($name) {    return $this-&gt;service_arr[$name];  }}$con = new Container();$db = new DBClass([&apos;locahost&apos;,3306,root,pwd]);$con-&gt;bind(&apos;db&apos;, $db);$cache = new Cache([&apos;127.0.0.1&apos;,11211]);$con-&gt;bind(&apos;cache&apos;,$cache);//...</code></pre><p>所有的类的实例化都写到一个文件里了，讲会是耦合性升高。<br>ServiceProvider就是解决这个问题的<br>每一个需要绑定到container的service，你需要创建一个对应ServiceProvider，这个ServiceProvider中有一个register方法，在这里面进行绑定，而不是像上述那样。比如：</p><pre><code>class SomeServiceProvider extends ServiceProvider {  public function register() {      $this-&gt;app-&gt;bind(&apos;some&apos;, new Some());  }}</code></pre><p>Laravel的container为了知道需要绑定哪些service,它会去读一个数组，这个数组是config/app.php中的Providers，然后你只需要把你的SomeServiceProvider写进这个数组，就可以绑定上了。<br>Facade</p><p>刚开始看Facade其实还是不太好理解，到底什么是Facade呢，它存在的意义又是什么呢？<br>我的理解</p><pre><code>简化对service的使用，可以理解为语法糖可以方便的替换</code></pre><p>可能你有疑惑，到底替换什么呢？看看下面的代码吧</p><pre><code>use Illuminate\Support\Facades\Redis;class IndexController extends Controller {  public function index() {    $redis = Redis::connect();    //do something  }}</code></pre><p>然而当我们打开Illuminate\Support\Facades\Redis看看，并没有connect的静态方法啊？但是可以发现唯一的一个方法返回了一个redis字符串，有什么玄机呢？<br>那么我们再看看RedisServiceProvider，我们的RedisServiceProvider在container里绑定了一个redis……所以大概你也猜到了，没错！</p><pre><code>Redis::connect() 等价于 $this-&gt;app-&gt;get(&apos;redis&apos;)-&gt;connect()</code></pre><p>get的到底是什么，取决于Facade中getFacadeAccessor方法返回的字符串！<br>这样有什么好处呢？文档也说了，除了简便使用以外最大的用处是测试，想想看，你把Redis的getFacadeAccessor方法返回值变成’memcached’，那么你所有使用Redis::some()是不是就全部切换成memcache啦？</p><h2 id="Application-php"><a href="#Application-php" class="headerlink" title="Application.php"></a>Application.php</h2><p>我们可以在Illuminate\Foundation命名空间下的Application.php里面看下，这个文件时laravel的基础。</p><pre><code>class Application extends Container implements ApplicationContract, HttpKernelInterface{}</code></pre><p>Application.php继承自 Container ，也就是说Foundation命名空间下的Application 类本身是一个容器。<br>我们可以在Illuminate\Container命名空间下的Container.php里面看下，这个文件时laravel的容器，基础中的基础。</p><h2 id="后期静态绑定"><a href="#后期静态绑定" class="headerlink" title="后期静态绑定"></a>后期静态绑定</h2><p>laravel框架中Model类的部分代码，$model = new static($attributes); 和 return static::create($attributes);<br>因为该类是抽象类，所以他的实现类在调用这些函数时，最终动态绑定的是实现类，而非model抽象类。</p><h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><p>Trait是PHP 5.4引入的新概念，看上去既像类又像接口，其实都不是，Trait可以看做类的部分实现，可以混入一个或多个现有的PHP类中。<br>其作用有两个：表明类可以做什么；提供模块化实现。<br>Trait是一种代码复用技术，为PHP的单继承限制提供了一套灵活的代码复用机制。</p><h3 id="从index-php进入项目"><a href="#从index-php进入项目" class="headerlink" title="从index.php进入项目"></a>从index.php进入项目</h3><pre><code>&lt;?php/*设置脚本开始时间 define(&apos;LARAVEL_START&apos;, microtime(true));  引入composer的自动加载，在composer.json中可以看出相当于    require(&apos;app/*&apos;) require(&apos;database/*&apos;) require(&apos;vendor/*&apos;)    之后使用时只要引入命名空间即可*/require __DIR__.&apos;/../bootstrap/autoload.php&apos;;$app = require_once __DIR__.&apos;/../bootstrap/app.php&apos;;/*在phpstrom中ctrl+左键单击查看app.php代码。*//*app.php代码如下:*//*首先创建app服务容器，即ioc容器，稍后分析*/$app = new Illuminate\Foundation\Application(    realpath(__DIR__.&apos;/../&apos;));/*看官方文档可知，singleton 方法绑定一个只需要解析一次的类或接口到容器，然后接下来对容器的调用将会返回同一个实例即以后需要使用Illuminate\Contracts\Http\Kernel这个类时，会返回App\Http\Kernel使用代码 $app-&gt;make(&apos;Illuminate\Contracts\Http\Kernel&apos;)*//*在laravel中Contracts（契约）文件夹里面的都是interfere类实现时都在Foundation这个文件夹中而查看App\Http\Kernel会发现它继承了实现接口类的类*//*这里绑定的是http启动的一些启动服务（session。env。config等）和中间件。以后分析。*/$app-&gt;singleton(    Illuminate\Contracts\Http\Kernel::class,    App\Http\Kernel::class);/*这里绑定的是控制台用的服务，即php artisan 如果上线了可以省去。*/$app-&gt;singleton(    Illuminate\Contracts\Console\Kernel::class,    App\Console\Kernel::class);/*绑定错误提示类上线后可以省去。*/$app-&gt;singleton(    Illuminate\Contracts\Debug\ExceptionHandler::class,    App\Exceptions\Handler::class);return $app;/*继续查看index.php*//*这里解析http的核心*/$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);/*处理请求，生成响应这里的handle函数是一大难点。其实现贼复杂*/$response = $kernel-&gt;handle(/*这里利用symfont的http request解析http请求里面有post。get。文件。路径等很多信息。*/    $request = Illuminate\Http\Request::capture());/*发送响应*/$response-&gt;send();/*后续处理，比如写log等*/$kernel-&gt;terminate($request, $response);/*由app.php里面的singleton很容易得知handle函数的所在*/public function handle($request)    {        try {/*这是symfont的允许在路由中使用GET和POST以外的HTTP方法 */            $request-&gt;enableHttpMethodParameterOverride();/*把request交给router处理，首先肯定是要匹配的你在route里面定义的方法*/            $response = $this-&gt;sendRequestThroughRouter($request);        } catch (Exception $e) {/*接下来都是些错误处理*/            $this-&gt;reportException($e);            $response = $this-&gt;renderException($request, $e);        } catch (Throwable $e) {            $this-&gt;reportException($e = new FatalThrowableError($e));            $response = $this-&gt;renderException($request, $e);        }/*分发事件，让事件监听获取信息，以后说*/        event(new Events\RequestHandled($request, $response));        return $response;    }/*然后我们专注于sendRequestThroughRouter这函数*/protected function sendRequestThroughRouter($request)    {/*绑定一个实例。laravel实现3种绑定，bind singleton instance。每次绑定如果名字相同会覆盖掉上次绑定的。bind每次make返回的都是新的实例singleton每次make返回的都是同一个实例instance每次返回的都是绑定时给的实例*/        $this-&gt;app-&gt;instance(&apos;request&apos;, $request);/*未知作用*/        Facade::clearResolvedInstance(&apos;request&apos;);/*启动初始服务，比如config。env等，以后有机会分析*/        $this-&gt;bootstrap();/*利用管道类处理请求，先绑定app容器，然后发送request请求，通过中间件，最后匹配路由，并执行route里面定义的方法，生成并返回reponse，其中源码绕来绕去就不一一解析*/        return (new Pipeline($this-&gt;app))                    -&gt;send($request)                    -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware)                    -&gt;then($this-&gt;dispatchToRouter());    }</code></pre><h3 id="laravel的spl-autoload-register-注册了什么"><a href="#laravel的spl-autoload-register-注册了什么" class="headerlink" title="laravel的spl_autoload_register()注册了什么"></a>laravel的spl_autoload_register()注册了什么</h3><p>在路由文件中经常会出现Route::get()这样的写法，但实际上并没有Route类，Route只是\Illuminate\Support\Facades\Route::class外观类的别名，这样取个别名只是为了简化作用。</p><pre><code>namespace Illuminate\Foundation;class AliasLoader{   /**     * Register the loader on the auto-loader stack.     *     * @return void     */     public function register()    {        if (! $this-&gt;registered) {            $this-&gt;prependToLoaderStack();            $this-&gt;registered = true;        }    }     /**     * Prepend the load method to the auto-loader stack.     *     * @return void     */    protected function prependToLoaderStack()    {        spl_autoload_register([$this, &apos;load&apos;], true, true);    }     /**     * Load a class alias if it is registered.     *     * @param  string  $alias     * @return bool|null     */    public function load($alias)    {        if (static::$facadeNamespace &amp;&amp; strpos($alias, static::$facadeNamespace) === 0) {            $this-&gt;loadFacade($alias);            return true;        }        if (isset($this-&gt;aliases[$alias])) {            return class_alias($this-&gt;aliases[$alias], $alias);        }    }   ...}</code></pre><p>Route::get()的调用过程就是，首先发现没有Route类，就去自动加载函数堆栈中通过AliasLoader::load()函数查找到Route是IlluminateSupportFacadesRoute的别名，那就调用IlluminateSupportFacadesRoute::get()，当然这里IlluminateSupportFacadesRoute没有get()静态方法，那就调用父类Facade的__callStatic()来找到名为router的服务，名为’router’的服务那就是早就注册到容器中的IlluminateRoutingRouter对象，所以最终就是调用IlluminateRoutingRouter::get()方法。这个过程主要使用了两个技术：一个是外观类的别名；一个是PHP的重载，</p><p>参考：<br><a href="https://segmentfault.com/a/1190000006946685" target="_blank" rel="external">https://segmentfault.com/a/1190000006946685</a></p><h1 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h1><p>route.php文件中，</p><pre><code>Class Foo{}//如果没有这个class会报错。Route::get(&apos;/&apos;,function(Foo $foo){  dd($foo);});</code></pre><p>Foo $foo 是依赖注入的写法，</p><p>laravel框架利用反射机制，尝试解释语义Foo $foo，<br>在laravel内核执行实例化</p><pre><code>$foo = new Foo();</code></pre><p>当laravel尝试new依赖的这个类，找不到的话就会报错找不到这个类。</p><p>当laravel找到的依赖的类。这个类本身依赖注入的类不明确时。<br>会爆其他错误：不能解析。</p><p>另一种方式</p><p>当使用App:bind这个方法时，laravel会优先通过这里加载这个类<br>而不是 反射机制 根据命名空间或者require路径去寻找。</p><pre><code>App::bind(&apos;Foo&apos;,function(){    dd(&apos;called here&apos;);    return new Foo();})</code></pre><hr><h1 id="service-provider"><a href="#service-provider" class="headerlink" title="service provider"></a>service provider</h1><p>service provider 的类中，有意义的是register（）方法，</p><p>在index.php里面有$app这个变量，这是框架的核心。</p><pre><code>$this-&gt;app-&gt;sigleton(&apos;files&apos;,functionZ(){    return new Filesystem;})</code></pre><p>在这里的‘files’我们可以看做键名，指向Filesystem这个类的实例化。<br>这样我们可以在路由中试用下看看。</p><pre><code>Route::get(&apos;/&apos;,function(Foo $foo){  $content = app(&apos;files&apos;)-&gt;get(__DIR__.&apos;/kernel.php&apos;);  dd($content);});//打印出来这个文件的内容</code></pre><p>使用service provider中注册并提供一个简明的键名去申明这个类，<br>可以节约代码，易于管理。</p><h1 id="在Ioc容器中添加自己的类"><a href="#在Ioc容器中添加自己的类" class="headerlink" title="在Ioc容器中添加自己的类"></a>在Ioc容器中添加自己的类</h1><p>比如说项目中需要收费的功能，</p><p>app目录下新建目录billing，生成类文件</p><pre><code>Class stripe{  public function pay(){        dd(&apos;I pay&apos;);    }}</code></pre><p>artisan命令：<br>php artisan  make:provider BillingServicePovider</p><p>在 app/Providers目录下生成BillingServicePovider.php文件，<br>里面有意义的就是register（），我们在这里面注册stripe类。</p><pre><code>public function register(){  $this-&gt;app-&gt;bind(&apos;billing&apos;,fintion(){    return new Stripe();    });}</code></pre><p>再把它放到IOC容器中，config/app.php中添加。</p><p>此时，app(‘billing’)就可以相当于new Stripe()了。</p><p>app(‘billing’)-&gt;pay();//输出 I pay</p><h1 id="Facade-门面-运行机制"><a href="#Facade-门面-运行机制" class="headerlink" title="Facade(门面)运行机制"></a>Facade(门面)运行机制</h1><p>config/app.php下  alias数组，</p><p>用IDE的查找类的功能点进去，比如点route,Mail<br>进去一个类是继承的Facade，</p><p>里面有 getFacadeAccessor()函数返回一个字符串，//return ‘mailer’;<br>这个字符串对应MailserviceProvider.php中register()的字符串。</p><p>Facade类里面有__callStatic(),里面有</p><pre><code>$instance = static::getFacadeRoot();//IOC容器生成$instance，可以使用真正类中的方法//看下面pubilic static function getFacadeRoot(){  return static::resolveFacadeInstance(static::getFacadeAccessor());//app(&apos;mailer&apos;);}</code></pre><p>流程：</p><p>app.php下的别名数组的值指向一个类，这个类通过返回给Facade一个字符串实现app（‘name’）,<br>然后通过serviceProvider去注册返回实例化之后的类。</p><hr><h1 id="contract-契约"><a href="#contract-契约" class="headerlink" title="contract (契约)"></a>contract (契约)</h1><p>在项目目录framework/src/Illuminate/Contracts下面定义了很多interface。</p><p>面向接口编程。在依赖注入中很大好处。该目录下的类都是接口类。</p><p>比如：Config真正是新的类，在Illuminate\Contracts\Config\Repository，</p><p>app()方法:</p><pre><code>dd(app(&apos;Illuminate\Contracts\Config\Repository&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysqldd(Config::get());//可以看到laravel的配置dd(app(&apos;config&apos;)[&apos;database&apos;][&apos;default&apos;]);//可以得到 mysql</code></pre><p>contract给出整个框架给出的扩展接口，比如config类不能满足你的需求，<br>可以自己集成config接口实现这个类。</p><h1 id="Container的背后"><a href="#Container的背后" class="headerlink" title="Container的背后"></a>Container的背后</h1><p>这几种的返回结果都一样</p><pre><code>dd(Hash::make(&apos;pwd&apos;));//dsdsvdrssrbsssret5u4h6l8mdd(app(&apos;Hash&apos;)-&gt;make(&apos;pwd&apos;));dd(app()[&apos;Hash&apos;]-&gt;make(&apos;pwd&apos;));dd(app(&apos;Illuminate\Hashing\BcryptHasher&apos;)-&gt;make(&apos;pwd&apos;));</code></pre><p>想知道laravel单个功能的源代码，比如hash的功能，去serviceProvider去找。</p><pre><code>$this-&gt;app-&gt;singleton(&apos;hash&apos;,function(){  return new BcryptHasher;})</code></pre><p>singleton，bind是在核心的Contianer里面，</p><p>callFunction 是 Clouse ，会在singleton，bind中进行判断。</p><p>singleton，将hash的值保存到container的binding数组。</p><p>make(),build()可以通过serviceProvider、别名实现实例。</p><p>app（）判断传入的是key =&gt; serviceProvider去实现实例</p><p>包含命名空间的类 =&gt; Application.php  中 registerCoreContainerAliases()</p><p>Application.php里面是laravel的核心内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>laravel的IOC容器和php反射机制</title>
    <link href="http://martist.cn/2018/05/10/LARAVEL/laravel%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E5%92%8Cphp%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://martist.cn/2018/05/10/LARAVEL/laravel的IOC容器和php反射机制/</id>
    <published>2018-05-09T16:00:00.000Z</published>
    <updated>2018-05-11T11:54:40.887Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>以下是代码实例，利用反射可以寻找类的【构造函数中的参数】，然后根据【类型提示类】，利用反射机制实例化类，从而实现依赖加载</p><pre><code>&lt;?php/**** 工具类，使用该类来实现自动依赖注入。**/class Ioc {    static $i = 0;    // 获得类的对象实例    public static function getInstance($className) {        $paramArr = self::getMethodParams($className);        var_dump($paramArr);die;        return (new ReflectionClass($className))-&gt;newInstanceArgs($paramArr);//newInstanceArgs 从给出的参数创建一个新的类实例。    }    /**     * 执行类的方法     * @param  [type] $className  [类名]     * @param  [type] $methodName [方法名称]     * @param  [type] $params     [额外的参数]     * @return [type]             [description]     */    public static function make($className, $methodName, $params = []) {        // 获取类的实例        $instance = self::getInstance($className);        // 获取该方法所需要依赖注入的参数        $paramArr = self::getMethodParams($className, $methodName);        return $instance-&gt;{$methodName}(...array_merge($paramArr, $params));// ... 可变函数参数    }    /**     * 获得类的方法参数，只获得有类型的参数     * @param  [type] $className   [description]     * @param  [type] $methodsName [description]     * @return [type]              [description]     */    protected static function getMethodParams($className, $methodsName = &apos;__construct&apos;) {self::$i++;        // 通过反射获得该类        $class = new ReflectionClass($className);        echo  &quot;&lt;pre&gt;&quot;;        // print_r($class);        $paramArr = []; // 记录参数，和参数类型        // dd($class);  //       ReflectionClass Object        // (        //     [name] =&gt; B        // )        // 判断该类是否有构造函数        if ($class-&gt;hasMethod($methodsName)) {            // 获得构造函数            $construct = $class-&gt;getMethod($methodsName); //getMethod 检查方法是否已定义            // dd($construct);              //ReflectionMethod Object            // (            //     [name] =&gt; __construct            //     [class] =&gt; B            // )            // 判断构造函数是否有参数            $params = $construct-&gt;getParameters();// 获取参数            // dd($params);            //  Array            // (            //     [0] =&gt; ReflectionParameter Object            //         (            //             [name] =&gt; a            //         )            // )            if (count($params) &gt; 0) {                // 判断参数类型                foreach ($params as $key =&gt; $param) {                    if ($paramClass = $param-&gt;getClass()) { //getClass 获得类型提示类                        // dd($paramClass);      //                   ReflectionClass Object                        // (                        //     [name] =&gt; A                        // )                        // 获得参数类型名称                        $paramClassName = $paramClass-&gt;getName(); //获取类名                        // dd($paramClassName);                        // A                        // 获得参数类型                        $args = self::getMethodParams($paramClassName);                        // print_r($args);                        // Array                        // (                        // )                        // Array                        // (                        //     [0] =&gt; C Object                        //         (                        //         )                        // )                        $paramArr[] = (new ReflectionClass($paramClass-&gt;getName()))-&gt;newInstanceArgs($args);                         // print_r($paramArr);//                         Array                        // (                        //     [0] =&gt; C Object                        //         (                        //         )                        // )//                         Array                        // (                        //     [0] =&gt; A Object                        //         (                        //             [cObj:protected] =&gt; C Object                        //                 (                        //                 )                        //         )                        // )                        //  newInstanceArgs 从给出的参数创建一个新的类实例。                    }                }            }        }        return $paramArr;    }}class A {    protected $cObj;    /**     * 用于测试多级依赖注入 B依赖A，A依赖C     * @param C $c [description]     */    public function __construct(C $c) {        $this-&gt;cObj = $c;    }    public function aa() {        echo &apos;this is A-&gt;test&apos;;    }    public function aac() {        $this-&gt;cObj-&gt;cc();    }}class B {    protected $aObj;    /**     * 测试构造函数依赖注入     * @param A $a [使用引来注入A]     */    public function __construct(A $a) {        $this-&gt;aObj = $a;    }    /**     * [测试方法调用依赖注入]     * @param  C      $c [依赖注入C]     * @param  string $b [这个是自己手动填写的参数]     * @return [type]    [description]     */    public function bb(C $c, $b) {        $c-&gt;cc();        echo &quot;\r\n&quot;;        echo &apos;params:&apos; . $b;    }    /**     * 验证依赖注入是否成功     * @return [type] [description]     */    public function bbb() {        $this-&gt;aObj-&gt;aac();    }}class C {    public function cc() {        echo &apos;this is C-&gt;cc&apos;;    }}function dd($dd){    echo &quot;&lt;pre&gt;&quot;;    print_r($dd);    die;}//实例化B，B构造依赖A,A构造依赖C.// 使用Ioc来创建B类的实例，B的构造函数依赖A类，A的构造函数依赖C类。$bObj = Ioc::getInstance(&apos;B&apos;);$bObj-&gt;bbb(); // 输出：this is C-&gt;cc ， 说明依赖注入成功。// 打印$bObj// var_dump($bObj);// // 打印结果，可以看出B中有A实例，A中有C实例，说明依赖注入成功。// object(B)#3 (1) {//   [&quot;aObj&quot;:protected]=&gt;//   object(A)#7 (1) {//     [&quot;cObj&quot;:protected]=&gt;//     object(C)#10 (0) {//     }//   }// }Ioc::make(&apos;B&apos;, &apos;bb&apos;, [&apos;this is param b&apos;]);// // 输出结果，可以看出依赖注入成功。// this is C-&gt;cc// params:this is param b</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>记住密码基本原理</title>
    <link href="http://martist.cn/2018/05/08/PHP/%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://martist.cn/2018/05/08/PHP/记住密码基本原理/</id>
    <published>2018-05-07T16:00:00.000Z</published>
    <updated>2018-05-08T02:42:40.535Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="怎么在浏览器退出登录后保持状态"><a href="#怎么在浏览器退出登录后保持状态" class="headerlink" title="怎么在浏览器退出登录后保持状态"></a>怎么在浏览器退出登录后保持状态</h2><p>SESSION信息存储在服务端，相对于存储在客户端的COOKIE更为安全，所以正常一般网站在用于“判断用户是否登录”时，确实是使用SESSION，例如可以在SESSION里存储如下一个数组：</p><pre><code>//验证用户名和密码成功后$_SESSION[&apos;userinfo&apos;] = [  &apos;uid&apos; =&gt; 123,  &apos;username&apos; =&gt; &apos;testuser&apos;];</code></pre><p>而后在需要验证登录的地方加入类似如下判断</p><pre><code>if(empty($_SESSION[&apos;userinfo&apos;]) || empty($_SESSION[&apos;userinfo&apos;][&apos;uid&apos;])){  //未登录，引导登录}</code></pre><p>以上是使用SESSION做用户登录的基本存储和验证逻辑，当然实际开发过程中会将这部分的代码封装</p><p>我们都知道，SESSION一般是通过在COOKIE里记录一个KEY为PHPSESSID的COOKIE来保持上下文的，而这个PHPSESSID的COOKIE的有效期是设置为“会话”，意味着关闭浏览器后该COOKIE被销毁，相应的后端SESSION也就销毁，如图<br>另外，由于PHP的Session本身就有GC的机制，一般默认1440秒内页面没有刷新动作（准确的说是没有新的请求来刷新该PHPSESSID的生命周期），该SESSION也就被自动回收，伴随着用户的登录就失效了。</p><p>虽然COOKIE保存在客户端，不安全，易被伪造，这是客观存在的事实，但要实现这个“记住我”，还确实就得用到COOKIE，我们能做的是尽量去提高伪造的门槛。</p><h2 id="一个参考的设计方案"><a href="#一个参考的设计方案" class="headerlink" title="一个参考的设计方案"></a>一个参考的设计方案</h2><h3 id="签名机制"><a href="#签名机制" class="headerlink" title="签名机制"></a>签名机制</h3><p>1、将用户信息，比如一个[‘uid’=&gt;123, ‘username’=&gt;’testuser’]的数组，序列化后成为字符串，使用可逆加密算法加密该字符串，写到一个Key为userinfo的COOKIE里<br>2、由于可逆加密算法容易被解密，一旦加密的规则被别人猜测到以后，就可以轻易篡改这个COOKIE的内容，然后自行根据加密规则加密后伪造，所以，我们另外加入一个infodig的COOKIE，是将以上的userinfo的COOKIE内容，加入salt后使用不可逆加密算法生成散列，至于salt咱们可以自己定，总之要对外保密，不可逆算法例如md5，甚至多次加盐多次md5<br>3、以上两个COOKIE，为增强安全性，防止用户被XSS攻击后拿到，可以设置http-only属性</p><h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>服务端判断存在以上两个COOKIE后<br>1、验证infodig与userinfo是否匹配（将userinfo的内容使用生成infodig的方法计算后，与COOKIE传上来的infodig匹配是否一致）<br>2、infodig验证通过后，使用解密算法解密userinfo串，得到用户信息，如果用户信息里的uid存在用户表中，则写SESSION，通过SESSION保持本次会话</p><p>总而言之，使用COOKIE记录用户信息是可行的（当然不建议把用户敏感的东西存在COOKIE，例如邮箱、手机、甚至密码，只记录对登录有用的部分，例如uid、username等标识，以及nickname可能会在某些地方提升用户体验），可以确定的是，这个COOKIE对用户可见，我们要做的就是两点：<br>1、尽量让用户看不懂，而只有我们服务端自己认识（可逆加密算法）；<br>2、即使用户看懂了，他也不能够轻易的伪造（不可逆的散列算法）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>nginx如何配置重定向</title>
    <link href="http://martist.cn/2018/05/07/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/nginx%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://martist.cn/2018/05/07/服务部署/nginx如何配置重定向/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-05-07T07:38:47.974Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="Nginx中if语句中的判断条件"><a href="#Nginx中if语句中的判断条件" class="headerlink" title="Nginx中if语句中的判断条件"></a>Nginx中if语句中的判断条件</h2><h3 id="if语句中的判断条件-nginx"><a href="#if语句中的判断条件-nginx" class="headerlink" title="if语句中的判断条件(nginx)"></a>if语句中的判断条件(nginx)</h3><ol><li><p>正则表达式匹配：</p><pre><code>==:等值比较;~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；</code></pre></li></ol><ol><li>文件及目录匹配判断：</li></ol><p>-f, !-f：判断指定的路径是否为存在且为文件；</p><p>-d, !-d：判断指定的路径是否为存在且为目录；</p><p>-e, !-e：判断指定的路径是否存在，文件或目录均可；</p><p>-x, !-x：判断指定路径的文件是否存在且可执行；</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>有些公司可能有这样的需求，如:我的网站或者网页游戏需要更新，所有的用户或者玩家访问到的是一个停服更新页面，而本公司的IP可以访问，甚至说本公司的某个内网IP可以访问，用于确认更新成功与否，针对这个问题写了如下的访问控制规则:</p><ol><li><p>可以作为nginx的停服更新使用，仅允许222.222.222.222或者内网的两个IP访问,其他IP都rewrite到停服页面<br>Nginx.conf中加入在你项目的正确位置</p><pre><code>set $my_ip &apos;&apos;; if ( $remote_addr = 222.222.222.222){set $my_ip 1;} #注意这里的$remote_addr如何用了负载均衡的话,这里应该是$http_x_forwarded_forif ( $remote_addr = 192.168.1.170 ){ set $my_ip 1;}if ( $remote_addr = 192.168.1.169 ){ set $my_ip 1;}if ( $my_ip != 1) {rewrite ^/design/(.*)\.php$ /tingfu.html?$1&amp;;}  #将*.php转到tingfu.html</code></pre><ol><li><p>访问某个php应用的时候我只想让内部的某个IP访问，其他的IP都转到另一个PHP上。如下:<br>访问test.php，且IP不等222.222.222.222的跳转到55555.php:</p><p>  set $test ‘’;<br>  if ( $request_uri ~* /img/test.php ) {</p><pre><code>set $test P;</code></pre><p>  }</p></li></ol></li></ol><pre><code>if ( $http_x_forwarded_for !~* ^222\.222\.222\.222.* ) {        set $test &quot;${test}C&quot;;}if ( $test = PC ) {  #当条件符合 访问test.php并且 ip不是222.222.222.222的 转发到55555.phprewrite ^(.*)$ /img/55555.php permanent;  }</code></pre><ol><li><p>区分PC或手机访问不同网站</p><pre><code>location / {                proxy_pass http://10.10.100.60:8183;        if ( $http_user_agent ~* &quot;(mobile|nokia|iPhone|ipad|android|samsung|htc|blackberry)&quot; )                {                rewrite  ^/$    http://www.baidu.com;                }                index index.html index.htm;        }</code></pre></li></ol><ol><li><p>if判断&amp;&amp;(并且)写法【post 提交并且是php文件的把变量$allowss设置成false】</p><pre><code>set $allowphp &apos;&apos;;if ($request_method ~ ^(POST)$) {     set $allowphp p;}if ( $request_filename !~ \.php$) {    set $allowphp &quot;${allowphp}c&quot;;}if ( $allowphp = pc) {    set $allowss false;}</code></pre></li></ol><ol><li><p>nginx if判断||(或)写法【ip地址222.186.34.41或180.97.106.37的把变量$allowss设置成false】</p><pre><code>set $allowss true;if ($http_x_forwarded_for ~ &quot; ?222\.186\.34\.41$&quot;) {   set $allowss false;}if ($http_x_forwarded_for ~ &quot; ?180\.97\.106\.37$&quot;) {   set $allowss false;}</code></pre></li></ol><p>加上下面的代码，可以拒绝访问。</p><pre><code>if ($allowss = false) {return 403;}</code></pre><ol><li>post请求转发维持数据</li></ol><p>用301重定向给网站更换新域名get有效，但是post会失效变成get怎么办？针对301的response，浏览器的行为就是发送GET请求Location中的URL。<br>如果需要保持原来的POST方法不变去重新请求，需要使用307，但这未必是你想要的，因为根据标准浏览器针对307的POST请求需要用户明确确认（比如会弹一个alert）。可以用代理的方式去解决（proxy_pass）。</p><pre><code>server {     server_name  gaogd.com;    location / {    if ($request_method ~ ^(POST)$) {        proxy_pass http://www.gaogd.com;        break ;    }    rewrite ^/(.*)$   http://www.gaogd.com/$1 permanent;}</code></pre><h2 id="nginx参数作用"><a href="#nginx参数作用" class="headerlink" title="nginx参数作用"></a>nginx参数作用</h2><pre><code>$arg_PARAMETER #这个变量包含GET请求中，如果有变量PARAMETER时的值。$args #这个变量等于请求行中(GET请求)的参数，例如foo=123&amp;bar=blahblah;$binary_remote_addr #二进制的客户地址。$body_bytes_sent #响应时送出的body字节数数量。即使连接中断，这个数据也是精确的。$content_length #请求头中的Content-length字段。$content_type #请求头中的Content-Type字段。$cookie_COOKIE #cookie COOKIE变量的值$document_root #当前请求在root指令中指定的值。$document_uri #与$uri相同。$host #请求主机头字段，否则为服务器名称。$hostname #Set to the machine&apos;s hostname as returned by gethostname$http_HEADER$is_args #如果有$args参数，这个变量等于”?”，否则等于”&quot;，空值。$http_user_agent #客户端agent信息$http_cookie #客户端cookie信息$limit_rate #这个变量可以限制连接速率。$query_string #与$args相同。$request_body_file #客户端请求主体信息的临时文件名。$request_method #客户端请求的动作，通常为GET或POST。$remote_addr #客户端的IP地址。$remote_port #客户端的端口。$remote_user #已经经过Auth Basic Module验证的用户名。$request_completion #如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)。$request_method #GET或POST$request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。$request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。$scheme #HTTP方法（如http，https）。$server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr #服务器地址，在完成一次系统调用后可以确定这个值。$server_name #服务器名称。$server_port #请求到达服务器的端口号。$uri #不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。该值有可能和$request_uri 不一致。$request_uri是浏览器发过来的值。该值是rewrite后的值。例如做了internal redirects后。</code></pre><h2 id="重定向举例"><a href="#重定向举例" class="headerlink" title="重定向举例"></a>重定向举例</h2><h3 id="rewrite同时参数保留"><a href="#rewrite同时参数保留" class="headerlink" title="rewrite同时参数保留"></a>rewrite同时参数保留</h3><p>把<a href="http://example.com/test.php?para=xxx" target="_blank" rel="external">http://example.com/test.php?para=xxx</a> 重定向到 <a href="http://example.com/new" target="_blank" rel="external">http://example.com/new</a><br>若按照默认的写法：rewrite ^/test.php(.<em>) /new permanent;<br>重定向后的结果是：<a href="http://example.com/new?para=xxx" target="_blank" rel="external">http://example.com/new?para=xxx</a><br>如果改写成：rewrite ^/test.php(.</em>) /new? permanent;<br>那结果就是：<a href="http://example.com/new" target="_blank" rel="external">http://example.com/new</a></p><p>所以，关键点就在于“？”这个尾缀。假如又想保留某个特定的参数，那又该如何呢？可以利用Nginx本身就带有的$arg_PARAMETER参数来实现。</p><p>例如：<br>把<a href="http://example.com/test.php?para=xxx&amp;p=xx" target="_blank" rel="external">http://example.com/test.php?para=xxx&amp;p=xx</a> 重写向到 <a href="http://example.com/new?p=xx" target="_blank" rel="external">http://example.com/new?p=xx</a><br>可以写成：rewrite  ^/test.php   /new?p=$arg_p?  permanent;</p><p>只求结果的朋友可以直接忽略前面的内容，看这里：</p><pre><code>rewrite  ^/test.php  /new  permanent;       //重写向带参数的地址rewrite  ^/test.php  /new?  permanent;      //重定向后不带参数rewrite  ^/test.php   /new?id=$arg_id?  permanent;    //重定向后带指定的参数</code></pre><p>permanent是永久重定向参数，根据需要去掉也可以，不过最好是带有。</p><p> 首先Apache的Rewite规则差别不是很大,但是Nginx的Rewrite规则比Apache的简单灵活多了<br>Nginx可以用if进行条件匹配，语法规则类似C</p><pre><code>if ($http_user_agent ~ MSIE) {rewrite ^(.*)$ /msie/$1 break;}</code></pre><h3 id="Rewrite的Flags"><a href="#Rewrite的Flags" class="headerlink" title="Rewrite的Flags"></a>Rewrite的Flags</h3><p>last - 完成重写指令后，搜索相应的URI和位置。相当于Apache里的[L]标记，表示完成rewrite，不再匹配后面的规则。<br>break - 中止Rewirte，不在继续匹配。<br>redirect - 返回临时重定向的HTTP状态302。<br>permanent - 返回永久重定向的HTTP状态301。</p><h3 id="ZEND-Framework的重定向规则"><a href="#ZEND-Framework的重定向规则" class="headerlink" title="ZEND Framework的重定向规则"></a>ZEND Framework的重定向规则</h3><p>案例一：<br>全部重定向到 /index.php</p><pre><code>rewrite ^/(.*) /index.php?$1&amp;;</code></pre><p>案例二：<br>如果文件或目录不存在则重定向到index.php</p><pre><code>if (!-e $request_filename) {rewrite ^/(.*) /index.php?$1&amp;;}</code></pre><h3 id="WordPress的重定向规则"><a href="#WordPress的重定向规则" class="headerlink" title="WordPress的重定向规则"></a>WordPress的重定向规则</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><p><a href="http://www.wemvc.com/12" target="_blank" rel="external">http://www.wemvc.com/12</a> 重定向到 <a href="http://www.wemvc.com/index.php?p=12" target="_blank" rel="external">http://www.wemvc.com/index.php?p=12</a></p><pre><code>if (!-e $request_filename) {rewrite ^/(.+)$ /index.php?p=$1 last;}</code></pre><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><p>与zendframework配置很像</p><pre><code>if (!-e $request_filename) {rewrite ^/(.*) /index.php?$1&amp;;}</code></pre><h3 id="Discuz完整的Rewrite-for-Nginx规则"><a href="#Discuz完整的Rewrite-for-Nginx规则" class="headerlink" title="Discuz完整的Rewrite for Nginx规则"></a>Discuz完整的Rewrite for Nginx规则</h3><pre><code>if (!-f $request_filename) {rewrite ^/archiver/((fid|tid)-[\w\-]+\.html)$ /archiver/index.php?$1 last;rewrite ^/forum-([0-9]+)-([0-9]+)\.html$ /forumdisplay.php?fid=$1&amp;page=$2 last;rewrite ^/thread-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /viewthread.php?tid=$1&amp;extra=page=$3&amp;page=$2 last;rewrite ^/space-(username|uid)-(.+)\.html$ /space.php?$1=$2 last;rewrite ^/tag-(.+)\.html$ /tag.php?name=$1 last;}</code></pre><h2 id="文件及目录匹配【参数释义】"><a href="#文件及目录匹配【参数释义】" class="headerlink" title="文件及目录匹配【参数释义】"></a>文件及目录匹配【参数释义】</h2><pre><code>-f和!-f用来判断是否存在文件-d和!-d用来判断是否存在目录-e和!-e用来判断是否存在文件或目录-x和!-x用来判断文件是否可执行</code></pre><h2 id="正则表达式全部符号解释"><a href="#正则表达式全部符号解释" class="headerlink" title="正则表达式全部符号解释"></a>正则表达式全部符号解释</h2><pre><code>~ 为区分大小写匹配~* 为不区分大小写匹配!~和!~* 分别为区分大小写不匹配及不区分大小写不匹配(pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript. 中使用 SubMatches 集合，在JScript. 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘\(&apos; 或 ‘\)&apos;。^ 匹配输入字符串的开始位置。$ 匹配输入字符串的结束位置。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php-fpm" scheme="http://martist.cn/categories/php-fpm/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
      <category term="php-fpm" scheme="http://martist.cn/tags/php-fpm/"/>
    
  </entry>
  
  <entry>
    <title>正确的理解IOC</title>
    <link href="http://martist.cn/2018/05/05/LARAVEL/%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%90%86%E8%A7%A3IOC/"/>
    <id>http://martist.cn/2018/05/05/LARAVEL/正确的理解IOC/</id>
    <published>2018-05-04T16:00:00.000Z</published>
    <updated>2018-05-10T09:13:29.229Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h2><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。<br>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。</p><h2 id="IOC也叫依赖注入-DI"><a href="#IOC也叫依赖注入-DI" class="headerlink" title="IOC也叫依赖注入(DI)"></a>IOC也叫依赖注入(DI)</h2><p>IOC是控制反转是哪些方面的控制被反转了呢？<br>“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。</p><h2 id="实现IOC的方法"><a href="#实现IOC的方法" class="headerlink" title="实现IOC的方法"></a>实现IOC的方法</h2><p>注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p><h2 id="IOC容器的技术实现"><a href="#IOC容器的技术实现" class="headerlink" title="IOC容器的技术实现"></a>IOC容器的技术实现</h2><p>IOC中最基本的技术就是“反射(Reflection)”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中 NHibernate、Spring.Net框架都是把“反射”做为最基本的技术手段。</p><h2 id="代码层面的技术剖析"><a href="#代码层面的技术剖析" class="headerlink" title="代码层面的技术剖析"></a>代码层面的技术剖析</h2><h3 id="new-class"><a href="#new-class" class="headerlink" title="new class"></a>new class</h3><p>先假设我们这里有一个类，类里面需要用到数据库连接，按照最最原始的办法，我们可能是这样写这个类的：</p><pre><code>class example {     private $_db;     function __construct(){         include &quot;./Lib/Db.php&quot;;         $this-&gt;_db = new Db(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;test&quot;);     }     function getList(){         $this-&gt;_db-&gt;query(&quot;......&quot;);//这里具体sql语句就省略不写了     } }</code></pre><p>过程：</p><p>在构造函数里先将数据库类文件include进来；<br>然后又通过new Db并传入数据库连接信息实例化db类；<br>之后getList方法就可以通过$this-&gt;_db来调用数据库类，实现数据库操作。</p><p>看上去我们实现了想要的功能，但是这是一个噩梦的开始，以后example1,example2,example3….越来越多的类需要用到db组件，如果都这么写的话，万一有一天数据库密码改了或者db类发生变化了，岂不是要回头修改所有类文件？</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>ok，为了解决这个问题，工厂模式出现了，我们创建了一个Factory方法，并通过Factory::getDb()方法来获得db组件的实例：</p><pre><code>class Factory {     public static function getDb(){         include &quot;./Lib/Db.php&quot;;         return new Db(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;test&quot;);     } }</code></pre><p>sample类变成：</p><pre><code>class example {     private $_db;     function __construct(){         $this-&gt;_db = Factory::getDb();     }     function getList(){         $this-&gt;_db-&gt;query(&quot;......&quot;);//这里具体sql语句就省略不写了     } }</code></pre><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>这样就完美了吗？再次想想一下以后example1,example2,example3….所有的类，你都需要在构造函数里通过Factory::getDb();获的一个Db实例，实际上你由原来的直接与Db类的耦合变为了和Factory工厂类的耦合，工厂类只是帮你把数据库连接信息给包装起来了，虽然当数据库信息发生变化时只要修改Factory::getDb()方法就可以了，但是突然有一天工厂方法需要改名，或者getDb方法需要改名，你又怎么办？当然这种需求其实还是很操蛋的，但有时候确实存在这种情况，一种解决方式是：</p><p>我们不从example类内部实例化Db组件，我们依靠从外部的注入，什么意思呢？看下面的例子：</p><pre><code>class example {     private $_db;     function getList(){         $this-&gt;_db-&gt;query(&quot;......&quot;);//这里具体sql语句就省略不写了     }     //从外部注入db连接     function setDb($connection){         $this-&gt;_db = $connection;     } } //调用 $example = new example(); $example-&gt;setDb(Factory::getDb());//注入db连接 $example-&gt;getList();</code></pre><p>这样一来，example类完全与外部类解除耦合了，你可以看到Db类里面已经没有工厂方法或Db类的身影了。我们通过从外部调用example类的setDb方法，将连接实例直接注入进去。这样example完全不用关心db连接怎么生成的了。</p><p><strong>这就叫依赖注入</strong></p><p>实现不是在代码内部创建依赖关系，而是让其作为一个参数传递，这使得我们的程序更容易维护，降低程序代码的耦合度，实现一种松耦合。</p><h3 id="松耦合的写法"><a href="#松耦合的写法" class="headerlink" title="松耦合的写法"></a>松耦合的写法</h3><p>这还没完，我们再假设example类里面除了db还要用到其他外部类，我们通过：</p><pre><code>$example-&gt;setDb(Factory::getDb());//注入db连接 $example-&gt;setFile(Factory::getFile());//注入文件处理类 $example-&gt;setImage(Factory::getImage());//注入Image处理类 ...</code></pre><p>我们没完没了的写这么多set？累不累?</p><p>ok，为了不用每次写这么多行代码，我们又去弄了一个工厂方法：</p><pre><code>class Factory {     public static function getExample(){         $example = new example();         $example-&gt;setDb(Factory::getDb());//注入db连接         $example-&gt;setFile(Factory::getFile());//注入文件处理类         $example-&gt;setImage(Factory::getImage());//注入Image处理类         return $expample;     } }</code></pre><p>实例化example时变为：</p><pre><code>$example=Factory::getExample(); $example-&gt;getList();</code></pre><p>似乎完美了，但是怎么感觉又回到了上面第一次用工厂方法时的场景？这确实不是一个好的解决方案，所以又提出了一个概念：容器，又叫做IoC容器、DI容器。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>我们本来是通过setXXX方法注入各种类，代码很长，方法很多，虽然可以通过一个工厂方法包装，但是还不是那么爽，好吧，我们不用setXXX方法了，这样也就不用工厂方法二次包装了，那么我们还怎么实现依赖注入呢？</p><p>这里我们引入一个约定：在example类的构造函数里传入一个名为Di $di的参数，如下：</p><pre><code>class example {     private $_di;     function __construct(Di &amp;$di){         $this-&gt;_di = $di;     }     //通过di容器获取db实例     function getList(){         $this-&gt;_di-&gt;get(&apos;db&apos;)-&gt;query(&quot;......&quot;);//这里具体sql语句就省略不写了     } } $di = new Di(); $di-&gt;set(&quot;db&quot;,function(){    return new Db(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;test&quot;);  }); $example = new example($di); $example-&gt;getList();</code></pre><p>Di就是IoC容器，所谓容器就是存放我们可能会用到的各种类的实例，我们通过$di-&gt;set()设置一个名为db的实例，因为是通过回调函数的方式传入的，所以set的时候并不会立即实例化db类，而是当$di-&gt;get(‘db’)的时候才会实例化，同样，在设计di类的时候还可以融入单例模式。</p><p>这样我们只要在全局范围内申明一个Di类，将所有需要注入的类放到容器里，然后将容器作为构造函数的参数传入到example，即可在example类里面从容器中获取实例。当然也不一定是构造函数，你也可以用一个 setDi(Di $di)的方法来传入Di容器，总之约定是你制定的，你自己清楚就行。</p><h3 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h3><p>我们需要一种高级的生产车间，我们只需要向生产车间提交一个脚本，工厂便能够通过指令自动化生产。这种更为高级的工厂，就是工厂模式的升华 —— IoC 容器。</p><pre><code>class Container{    protected $binds;    protected $instances;    public function bind($abstract, $concrete)    {        if ($concrete instanceof Closure) {            $this-&gt;binds[$abstract] = $concrete;        } else {            $this-&gt;instances[$abstract] = $concrete;        }    }    public function make($abstract, $parameters = [])    {        if (isset($this-&gt;instances[$abstract])) {            return $this-&gt;instances[$abstract];        }        array_unshift($parameters, $this);        return call_user_func_array($this-&gt;binds[$abstract], $parameters);    }}</code></pre><p>这时候，一个十分粗糙的容器就诞生了。现在的确很简陋，但不妨碍我们进一步提升他。先着眼现在，看看这个容器如何使用吧！</p><pre><code>// 创建一个容器（后面称作超级工厂）$container = new Container;// 向该 超级工厂添加超人的生产脚本$container-&gt;bind(&apos;superman&apos;, function($container, $moduleName) {    return new Superman($container-&gt;make($moduleName));});// 向该 超级工厂添加超能力模组的生产脚本$container-&gt;bind(&apos;xpower&apos;, function($container) {    return new XPower;});// 同上$container-&gt;bind(&apos;ultrabomb&apos;, function($container) {    return new UltraBomb;});// ****************** 华丽丽的分割线 **********************// 开始启动生产$superman_1 = $container-&gt;make(&apos;superman&apos;, &apos;xpower&apos;);$superman_2 = $container-&gt;make(&apos;superman&apos;, &apos;ultrabomb&apos;);$superman_3 = $container-&gt;make(&apos;superman&apos;, &apos;xpower&apos;);// ...随意添加</code></pre><p>通过最初的 绑定（bind） 操作，我们向 工厂类 注册了这些依赖，这些依赖在生产指令下达之时便会执行。</p><p>我们彻底的解除了 实例 与 创建 的依赖关系，更重要的是，容器类也丝毫没有和他们产生任何依赖！我们通过注册、绑定的方式向容器中添加一段可以被执行的回调（可以是匿名函数、非匿名函数、类的方法）作为生产一个类的实例的 脚本 ，只有在真正的 生产（make） 操作被调用执行时，才会触发。</p><p>这样一种方式，使得我们更容易在创建一个实例的同时解决其依赖关系，并且更加灵活。当有新的需求，只需另外绑定一个“生产脚本”即可。</p><h3 id="更高级的用法"><a href="#更高级的用法" class="headerlink" title="更高级的用法"></a>更高级的用法</h3><p>实际上类也不应当依赖$di对象，依赖注入的意思是通过反射分析类所依赖的其他类，从容器中获取相应的对象并自动注入到类里面。laravel 就是这种写法。此处推荐laravel作者写的书，中文译名叫《从百草园到三味书屋》。</p><h2 id="laravel中的IOC容器源码分析"><a href="#laravel中的IOC容器源码分析" class="headerlink" title="laravel中的IOC容器源码分析"></a>laravel中的IOC容器源码分析</h2><p>laravel中的 IoC 容器会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。</p><p>自动搜寻依赖需求的功能，是通过反射（Reflection）实现的。</p><p>laravel中有这些概念：</p><pre><code>IoC(Inversion of Controller) 控制反转(概念)DI(Dependency Inject) 依赖注入(IoC概念中的一种类型实现) 通过依赖声明自动实例化依赖的类(通常通过反射实现)Container 容器  存储实例化对象 单例的一种实现工具ServiceProvider 服务提供者  一次实例化一批(也可能是一个) 需要使用的类，并可做一个容器中对象的别名绑定    Facades 门面 为应用程序的 服务容器 中可用的类提供了一个「静态」接口。契约（Contracts）</code></pre><h3 id="Laravel的核心"><a href="#Laravel的核心" class="headerlink" title="Laravel的核心"></a>Laravel的核心</h3><p>现在，我们开始慢慢解读 Laravel 的核心。其实，Laravel 的核心就是一个 IoC 容器，也恰好是我之前所说的高级的 IoC 容器。</p><p>可以说，Laravel 的核心本身十分轻量，并没有什么很神奇很实质性的应用功能。很多人用到的各种功能模块比如 Route（路由）、Eloquent ORM（数据库 ORM 组件）、Request（请求）以及 Response（响应）等等等等，实际上都是与核心无关的类模块提供的，这些类从注册到实例化，最终被你所使用，其实都是 Laravel 的服务容器负责的。</p><p>我们以大家最常见的 Route 类作为例子。大家可能经常见到路由定义是这样的：</p><pre><code>Route::get(&apos;/&apos;, function() {    // bla bla bla...});</code></pre><p>实际上， Route 类被定义在这个命名空间：Illuminate\Routing\Router，文件 vendor/laravel/framework/src/Illuminate/Routing/Router.php。</p><p>我们通过打开发现，这个类的这一系列方法，如 get，post，any 等都不是静态（static）方法，这是怎么一回事儿？不要急，我们继续。<br>服务提供者</p><p>我们在前文介绍 IoC 容器的部分中，提到了，一个类需要绑定、注册至容器中，才能被“制造”。</p><p>对，一个类要被容器所能够提取，必须要先注册至这个容器。既然 Laravel 称这个容器叫做服务容器，那么我们需要某个服务，就得先注册、绑定这个服务到容器，那么提供服务并绑定服务至容器的东西，就是服务提供者（Service Provider）。</p><p>虽然，绑定一个类到容器不一定非要通过服务提供者。</p><p>但是，我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，Laravel 将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的服务提供者。</p><p>服务提供者主要分为两个部分，register（注册） 和 boot（引导、初始化），具体参考文档。register 负责进行向容器注册“脚本”，但要注意注册部分不要有对未知事物的依赖，如果有，就要移步至 boot 部分。<br>门面（Facade）</p><p>我们现在解答之前关于 Route 的方法为何能以静态方法访问的问题。实际上这个问题文档上有写，简单说来就是模拟一个类，提供一个静态魔术方法__callStatic，并将该静态方法映射到真正的方法上。</p><p>我们使用的 Route 类实际上是 Illuminate\Support\Facades\Route 通过 class_alias() 函数创造的别名而已，这个类被定义在文件 vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php 。</p><p>我们打开文件一看……诶？怎么只有这么简单的一段代码呢？</p><pre><code>&lt;?php     namespace Illuminate\Support\Facades;    /**     * @see \Illuminate\Routing\Router     */    class Route extends Facade {        /**         * Get the registered name of the component.         *         * @return string         */        protected static function getFacadeAccessor()        {            return &apos;router&apos;;        }}</code></pre><p>其实仔细看，会发现这个类继承了一个叫做 Facade 的类，到这里谜底差不多要解开了。</p><p>上述简单的定义中，我们看到了 getFacadeAccessor 方法返回了一个 route，这是什么意思呢？事实上，这个值被一个 ServiceProvider 注册过，大家应该知道注册了个什么，当然是那个真正的路由类！</p><h3 id="PSR-11"><a href="#PSR-11" class="headerlink" title="PSR-11"></a>PSR-11</h3><p>Laravel 的服务容器实现了 PSR-11 接口。 因此，你可以使用 PSR-11容器『接口类型提示』来获取 Laravel 容器的实例.<br>目前还没有很好的译文，需要读者自己去看英文文档。</p><h2 id="laravel中常见的写法-强类型"><a href="#laravel中常见的写法-强类型" class="headerlink" title="laravel中常见的写法-强类型"></a>laravel中常见的写法-强类型</h2><pre><code>class User {    function ec(){        echo &quot;123333&quot;;    }}$u = new User();function billUser(User $user){   $user-&gt;ec();}billUser($u);</code></pre><p>结果：</p><pre><code>123333</code></pre><p>如果最后一行换成其他代码，如：</p><pre><code>billUser(‘u’);</code></pre><p>结果：</p><pre><code>Fatal error: Uncaught TypeError: Argument 1 passed to billUser() must be an instance of User, string given, called in /Users/machuang/Desktop/m.php on line 20 and defined in /Users/machuang/Desktop/m.php:12Stack trace:#0 /Users/machuang/Desktop/m.php(20): billUser(&apos;u&apos;)#1 {main}  thrown in /Users/machuang/Desktop/m.php on line 12</code></pre><p>有个关于鸭子类型（下文译作：弱类型）的解释：如果一个东西看起来像个鸭子，叫声也像鸭子叫，那他就是个鸭子。换言之在程序里，一个对象看上去是个User，方法响应也像个User，那他就是个User。</p><p>PHP到底有没有任何强类型功能呢？当然有！PHP混合了强类型和弱类型的结构。<br>给方法加上了加上了User类型提示后， 我们可以确信的说所有传入billUser方法的参数，都是User类或是继承自User类的一个实例。如果不是，会引起报错。</p><h3 id="laravel-中的接口使用"><a href="#laravel-中的接口使用" class="headerlink" title="laravel 中的接口使用"></a>laravel 中的接口使用</h3><p><a href="https://my.oschina.net/zgldh/blog/340975" target="_blank" rel="external">https://my.oschina.net/zgldh/blog/340975</a></p><p>参考这一篇，理解接口和容器的使用。</p><pre><code>interface OrderRepositoryInterface {    public function getMostRecent(User $user);}</code></pre><p>一旦建立了约定，就算约定还没实现，前端开发者也可以测试他的控制器了！这样应用中的不同组件就可以按不同的速度开发，并且单元测试也可以做。而且这种处理方法还可以使组件内部的改动不会影响到其他不相关组件。要记着无知是福。我们写的那些类们不用知道别的类如何实现的，只要知道它们能实现什么。这下咱们有了定义好的约定，再来写控制器：</p><pre><code>&lt;!-- lang:php --&gt;class OrderController {    public function __construct(OrderRepositoryInterface $orders)    {        $this-&gt;orders = $orders;    }    public function getRecent()    {        $recent = $this-&gt;orders-&gt;getMostRecent(Auth::user());        return View::make(&apos;orders.recent&apos;, compact(&apos;recent&apos;));    }}</code></pre><p>一旦假实现写好了，就可以被绑定到IoC容器里，然后整个程序都可以调用他了：</p><pre><code>&lt;!-- lang:php --&gt;App::bind(&apos;OrderRepositoryInterface&apos;, &apos;DummyOrderRepository&apos;);</code></pre><p>接下来一旦后台开发者写完了真正的实现代码，比如叫RedisOrderRepository。那么IoC容器就可以轻易的切换到真正的实现上。整个应用就会使用从Redis读出来的数据。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>具体参见：<br><a href="http://php.net/manual/zh/book.reflection.php" target="_blank" rel="external">http://php.net/manual/zh/book.reflection.php</a></p><p>我博客里面也有一篇总结的文章，可供借鉴。</p><h2 id="PHP基础补充"><a href="#PHP基础补充" class="headerlink" title="PHP基础补充"></a>PHP基础补充</h2><h3 id="compact"><a href="#compact" class="headerlink" title="compact()"></a>compact()</h3><p>创建一个包含变量名和它们的值的数组：</p><pre><code>&lt;?php$firstname = &quot;Bill&quot;;$lastname = &quot;Gates&quot;;$age = &quot;60&quot;;$result = compact(&quot;firstname&quot;, &quot;lastname&quot;, &quot;age&quot;);print_r($result);?&gt;</code></pre><p>结果：</p><pre><code>Array ( [firstname] =&gt; Bill [lastname] =&gt; Gates [age] =&gt; 60 ) </code></pre><h3 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h3><p>把数组中的值赋给一些变量：</p><pre><code>&lt;?php$my_array = array(&quot;Dog&quot;,&quot;Cat&quot;,&quot;Horse&quot;);list($a, $b, $c) = $my_array;echo &quot;I have several animals, a $a, a $b and a $c.&quot;;?&gt;</code></pre><p>结果：</p><pre><code>I have several animals, a Dog, a Cat and a Horse. </code></pre><h3 id="array-reduce"><a href="#array-reduce" class="headerlink" title="array_reduce()"></a>array_reduce()</h3><p>向用户自定义函数发送数组中的值，并返回一个字符串：</p><pre><code>&lt;?phpfunction myfunction($v1,$v2){return $v1 . &quot;-&quot; . $v2;}$a=array(&quot;Dog&quot;,&quot;Cat&quot;,&quot;Horse&quot;);print_r(array_reduce($a,&quot;myfunction&quot;));?&gt;</code></pre><p>结果： </p><pre><code>-Dog-Cat-Horse </code></pre><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><p><a href="http://www.w3school.com.cn/php/php_ref_array.asp" target="_blank" rel="external">http://www.w3school.com.cn/php/php_ref_array.asp</a><br><a href="https://my.oschina.net/zgldh/blog/389246" target="_blank" rel="external">https://my.oschina.net/zgldh/blog/389246</a><br><a href="http://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html" target="_blank" rel="external">http://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html</a><br><a href="https://www.tuicool.com/articles/Jbeyuur" target="_blank" rel="external">https://www.tuicool.com/articles/Jbeyuur</a><br>www.thinkphp.cn/topic/12180.html<br><a href="https://segmentfault.com/a/1190000002411255" target="_blank" rel="external">https://segmentfault.com/a/1190000002411255</a><br><a href="https://blog.csdn.net/qq_20678155/article/details/70158374" target="_blank" rel="external">https://blog.csdn.net/qq_20678155/article/details/70158374</a><br><a href="https://laravel-china.org/docs/laravel/5.6" target="_blank" rel="external">https://laravel-china.org/docs/laravel/5.6</a><br><a href="http://php.net/manual/zh/book.reflection.php" target="_blank" rel="external">http://php.net/manual/zh/book.reflection.php</a><br><a href="https://www.insp.top/article/realization-of-pipeline-component-for-laravel" target="_blank" rel="external">https://www.insp.top/article/realization-of-pipeline-component-for-laravel</a><br><a href="http://laravelacademy.org/post/2792.html" target="_blank" rel="external">http://laravelacademy.org/post/2792.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>laravel路由组件源码分析</title>
    <link href="http://martist.cn/2018/05/03/LARAVEL/laravel%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://martist.cn/2018/05/03/LARAVEL/laravel路由组件源码分析/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-05-04T01:33:28.235Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>Macaw是一个类似laravel路由形式的组件，一共不到200行源码，这里具体分析下怎么实现的路由部分。</p><p>项目地址:<a href="https://github.com/noahbuscher/Macaw" target="_blank" rel="external">https://github.com/noahbuscher/Macaw</a></p><h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><p>composer安装：</p><pre><code>composer require noahbuscher/macaw</code></pre><p>index.php 文件：</p><pre><code>&lt;?php    use NoahBuscher\Macaw\Macaw;// Autoload 自动载入require &apos;../vendor/autoload.php&apos;;Macaw::get(&apos;success&apos;, function() {  echo &quot;成功！&quot;;});Macaw::get(&apos;(:all)&apos;, function($fu) {  echo &apos;未匹配到路由&lt;br&gt;&apos;.$fu;});Macaw::dispatch();</code></pre><p>然后你就可以在浏览器进行测试了,具体源码可以参见本文最下面。</p><h2 id="基础补习"><a href="#基础补习" class="headerlink" title="基础补习"></a>基础补习</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">array_push() 函数向第一个参数的数组尾部添加一个或多个元素（入栈），然后返回新数组的长度。</div><div class="line">strtoupper() 函数把字符串转换为大写。</div><div class="line"></div><div class="line">strpos() 函数查找字符串在另一字符串中第一次出现的位置（区分大小写）</div><div class="line">strrpos() 查找字符串在另一字符串中最后一次出现的位置（区分大小写）</div><div class="line"></div><div class="line">stripos()  查找字符串在另一字符串中第一次出现的位置（不区分大小写）</div><div class="line">strripos()  查找字符串在另一字符串中最后一次出现的位置（不区分大小写）</div><div class="line"></div><div class="line">parse_url()  解析 URL，返回其组成部分</div><div class="line">preg_replace()  函数执行一个正则表达式的搜索和替换</div><div class="line"></div><div class="line">$_SERVER[&apos;REQUEST_URI&apos;]  域名之后的路由部分</div><div class="line">$_SERVER[&apos;REQUEST_METHOD&apos;] 请求方式，如GET，POST</div><div class="line"></div><div class="line">call_user_func() 调用一个回调函数处理字符串,可以用匿名函数，可以用有名函数，可以传递类的方法，</div><div class="line">call_user_func_array()  调用回调函数，并把一个数组参数作为回调函数的参数</div></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>一开始进入路由：</p><pre><code>Macaw::get(&apos;success&apos;, function() {    echo &quot;进入成功！&quot;;});</code></pre><p>调用Macaw的静态方法get(),但是Macaw类里面没有get(),于是进入__callstatic()方法。</p><p>打印下这个路由进去之后，的大的method和param参数是个啥，</p><pre><code>string(3) &quot;get&quot;array(2) {  [0]=&gt;  string(4) &quot;success&quot;  [1]=&gt;  object(Closure)#12 (0) {  }}</code></pre><p>如果路由是：</p><pre><code>Macaw::get(&apos;home&apos;, &apos;HomeController@home&apos;);</code></pre><p>打印结果就是：</p><pre><code>string(3) &quot;get&quot;array(2) {  [0]=&gt;  string(4) &quot;home&quot;  [1]=&gt;  string(19) &quot;HomeController@home&quot;}</code></pre><p>然后Macaw把整个路有文件读一遍，把路由和function或者控制器都array_push到类的静态变量里面。</p><p>路由文件最后一行的 Macaw::dispatch()方法才是真正处理当前 URL 的地方。</p><p>下面看一下dispatch()</p><ol><li>先判断$uri是否在 self::$routes数组里面</li><li>1成立，再看method是不是匹配</li><li>1，2成立，然后进入action阶段，判断是闭包（闭包是一种对象来判断）还是字符串</li><li>如果是闭包，则通过call_user_func()执行</li><li>如果是字符串，则通过new controller调用方法去执行(这样的处理方式导致路由组件不能处理‘？param=value’这样的传值，不过我们可以改造它让他可以接受get传参)</li><li>回到1，如果$uri不在 self::$routes数组里面，则再次正则匹配判断，判断是否符合$patterns数组内元素的格式</li><li>如果符合则call_user_func_array（）调用方法并传递参数执行；如果不符合，继续执行下面的代码。</li><li>最后没有找到路由的情况下，$found_route为假，根据self::$error_callback处理路由错误。</li><li>路由不存在处理有两种办法，（1）闭包直接执行；（2）字符串则将不存在的路由加入路由数组内，将错误处理方法加入$callback数组。再一次发起dispatch（），就可以在找到了处理办法。</li></ol><h2 id="代码中使用了大量的静态方法和静态变量，为什么呢？"><a href="#代码中使用了大量的静态方法和静态变量，为什么呢？" class="headerlink" title="代码中使用了大量的静态方法和静态变量，为什么呢？"></a>代码中使用了大量的静态方法和静态变量，为什么呢？</h2><p>类的方法定义成static，就尽量定义成static，它的速度会提升将近4倍。<br>能够在多次调用类时保留数据。</p><h2 id="关于laravel中的使用"><a href="#关于laravel中的使用" class="headerlink" title="关于laravel中的使用"></a>关于laravel中的使用</h2><p>laravel在这个包的基础上，加上了中间件和路由组等用法，实现了更多的功能。当然你在laravel项目中式找不到这个包的，作者自己写了Routing包。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>&lt;?phpnamespace NoahBuscher\Macaw;/** * @method static Macaw get(string $route, Callable $callback) * @method static Macaw post(string $route, Callable $callback) * @method static Macaw put(string $route, Callable $callback) * @method static Macaw delete(string $route, Callable $callback) * @method static Macaw options(string $route, Callable $callback) * @method static Macaw head(string $route, Callable $callback) */class Macaw {  public static $halts = false;  public static $routes = array();  public static $methods = array();  public static $callbacks = array();  public static $maps = array();  public static $patterns = array(      &apos;:any&apos; =&gt; &apos;[^/]+&apos;,      &apos;:num&apos; =&gt; &apos;[0-9]+&apos;,      &apos;:all&apos; =&gt; &apos;.*&apos;  );  public static $error_callback;  /**   * Defines a route w/ callback and method   */  public static function __callstatic($method, $params) {    if ($method == &apos;map&apos;) {        $maps = array_map(&apos;strtoupper&apos;, $params[0]);        $uri = strpos($params[1], &apos;/&apos;) === 0 ? $params[1] : &apos;/&apos; . $params[1];        $callback = $params[2];    } else {        $maps = null;        $uri = strpos($params[0], &apos;/&apos;) === 0 ? $params[0] : &apos;/&apos; . $params[0];        $callback = $params[1];    }    array_push(self::$maps, $maps);    array_push(self::$routes, $uri);    array_push(self::$methods, strtoupper($method));    array_push(self::$callbacks, $callback);  }  /**   * Defines callback if route is not found  */  public static function error($callback) {    self::$error_callback = $callback;  }  public static function haltOnMatch($flag = true) {    self::$halts = $flag;  }  /**   * Runs the callback for the given request   */  public static function dispatch(){    $uri = parse_url($_SERVER[&apos;REQUEST_URI&apos;], PHP_URL_PATH);    $method = $_SERVER[&apos;REQUEST_METHOD&apos;];    $searches = array_keys(static::$patterns);    $replaces = array_values(static::$patterns);    $found_route = false;    self::$routes = preg_replace(&apos;/\/+/&apos;, &apos;/&apos;, self::$routes);    // Check if route is defined without regex    if (in_array($uri, self::$routes)) {      $route_pos = array_keys(self::$routes, $uri);      foreach ($route_pos as $route) {        // Using an ANY option to match both GET and POST requests        if (self::$methods[$route] == $method || self::$methods[$route] == &apos;ANY&apos; || in_array($method, self::$maps[$route])) {          $found_route = true;          // If route is not an object          if (!is_object(self::$callbacks[$route])) {            // Grab all parts based on a / separator            $parts = explode(&apos;/&apos;,self::$callbacks[$route]);            // Collect the last index of the array            $last = end($parts);            // Grab the controller name and method call            $segments = explode(&apos;@&apos;,$last);            // Instanitate controller            $controller = new $segments[0]();            // Call method            $controller-&gt;{$segments[1]}();            if (self::$halts) return;          } else {            // Call closure            call_user_func(self::$callbacks[$route]);            if (self::$halts) return;          }        }      }    } else {      // Check if defined with regex      $pos = 0;      foreach (self::$routes as $route) {        if (strpos($route, &apos;:&apos;) !== false) {          $route = str_replace($searches, $replaces, $route);        }        if (preg_match(&apos;#^&apos; . $route . &apos;$#&apos;, $uri, $matched)) {          if (self::$methods[$pos] == $method || self::$methods[$pos] == &apos;ANY&apos; || (!empty(self::$maps[$pos]) &amp;&amp; in_array($method, self::$maps[$pos]))) {            $found_route = true;            // Remove $matched[0] as [1] is the first parameter.            array_shift($matched);            if (!is_object(self::$callbacks[$pos])) {              // Grab all parts based on a / separator              $parts = explode(&apos;/&apos;,self::$callbacks[$pos]);              // Collect the last index of the array              $last = end($parts);              // Grab the controller name and method call              $segments = explode(&apos;@&apos;,$last);              // Instanitate controller              $controller = new $segments[0]();              // Fix multi parameters              if (!method_exists($controller, $segments[1])) {                echo &quot;controller and action not found&quot;;              } else {                call_user_func_array(array($controller, $segments[1]), $matched);              }              if (self::$halts) return;            } else {              call_user_func_array(self::$callbacks[$pos], $matched);              if (self::$halts) return;            }          }        }        $pos++;      }    }    // Run the error callback if the route was not found    if ($found_route == false) {      if (!self::$error_callback) {        self::$error_callback = function() {          header($_SERVER[&apos;SERVER_PROTOCOL&apos;].&quot; 404 Not Found&quot;);          echo &apos;404&apos;;        };      } else {        if (is_string(self::$error_callback)) {          self::get($_SERVER[&apos;REQUEST_URI&apos;], self::$error_callback);          self::$error_callback = null;          self::dispatch();          return ;        }      }      call_user_func(self::$error_callback);    }  }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>opcache 和 php jit</title>
    <link href="http://martist.cn/2018/05/03/PHP/%20opcache%20%E5%92%8C%20php%20jit/"/>
    <id>http://martist.cn/2018/05/03/PHP/ opcache 和 php jit/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-05-11T11:56:59.664Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>opcache 是用于缓存 zend 引擎编译生成的 opcode，下次就无需编译。</p><p>JIT编译（just-in-time compilation），即即时编译，狭义指某段代码即将第一次被执行时进行编译，而后则不用编译直接执行，它为动态编译的一种特例。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="正常的转码流程"><a href="#正常的转码流程" class="headerlink" title="正常的转码流程"></a>正常的转码流程</h3><pre><code>源代码(人认识)-&gt;字节码(解释器认识)-&gt;机器码(硬件认识)</code></pre><h3 id="opacache的流程"><a href="#opacache的流程" class="headerlink" title="opacache的流程"></a>opacache的流程</h3><p>来看下PHP的执行流程，假设有个a.php文件</p><ol><li><p>不启用opacache的流程</p><p> a.php-&gt;经过zend编译-&gt;opcode-&gt;PHP解释器-&gt;机器码</p></li><li><p>启用opacache的流程</p><p> a.php-&gt;查找opacache缓存，如果没有则进行zend编译为opcode并缓存-&gt;opacode-&gt;PHP解释器-&gt;机器码</p></li></ol><h3 id="jit的流程"><a href="#jit的流程" class="headerlink" title="jit的流程"></a>jit的流程</h3><pre><code>a.php-&gt;编译-&gt;机器码</code></pre><p>启用jit以后都只执行机器码，不编译，效率上高了很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
</feed>
