<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARTIST</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://martist.cn/"/>
  <updated>2018-05-03T06:39:03.227Z</updated>
  <id>http://martist.cn/</id>
  
  <author>
    <name>马闯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实现一个类似laravel的现代化PHP框架</title>
    <link href="http://martist.cn/2018/05/03/%E6%A1%86%E6%9E%B6/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BClaravel%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%8C%96PHP%E6%A1%86%E6%9E%B6/"/>
    <id>http://martist.cn/2018/05/03/框架/实现一个类似laravel的现代化PHP框架/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-05-03T06:39:03.227Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>读了JohnLui的7篇博文之后，我想要把学到的东西总结一下，于是写了这篇文章。<br>他的博客地址：<a href="https://lvwenhan.com/sort/php" target="_blank" rel="external">https://lvwenhan.com/sort/php</a></p><h2 id="路由组件Macaw"><a href="#路由组件Macaw" class="headerlink" title="路由组件Macaw"></a>路由组件Macaw</h2><p>推荐 <a href="https://github.com/NoahBuscher/Macaw" target="_blank" rel="external">https://github.com/NoahBuscher/Macaw</a> , 这个包体积小，很优雅。</p><p>下面开始安装它，更改 composer.json：</p><pre><code>{  &quot;require&quot;: {    &quot;noahbuscher/macaw&quot;: &quot;dev-master&quot;  }}</code></pre><p>运行</p><pre><code>composer update</code></pre><p>新建 MFFC/public 文件夹，这个文件夹将是用户唯一可见的部分。在文件夹下新建 index.php 文件：</p><pre><code>&lt;?php// Autoload 自动载入require &apos;../vendor/autoload.php&apos;;// 路由配置require &apos;../config/routes.php&apos;;上面一行表示引入 Composer 的自动载入功能，下面一行表示载入路由配置文件。新建 MFFC/config 文件夹，在里面新建 routs.php 文件，内容如下：&lt;?phpuse NoahBuscher\Macaw\Macaw;Macaw::get(&apos;fuck&apos;, function() {  echo &quot;成功！&quot;;});Macaw::get(&apos;(:all)&apos;, function($fu) {  echo &apos;未匹配到路由&lt;br&gt;&apos;.$fu;});Macaw::dispatch();</code></pre><p>然后你就可以在浏览器进行测试了。</p><h3 id="Macaw代码分析"><a href="#Macaw代码分析" class="headerlink" title="Macaw代码分析"></a>Macaw代码分析</h3><p>Macaw 的文档位于 <a href="https://github.com/NoahBuscher/Macaw，请按照你的" target="_blank" rel="external">https://github.com/NoahBuscher/Macaw，请按照你的</a> HTTP 服务软件类型自行设置伪静态，其实跟绝大多数框架一样：“将所有非静态文件全部指向 index.php”。</p><p>Macaw 只有一个文件，去除空行总共也就一百行多一点，通过代码我们能直接看明白它是怎么工作。</p><p>路由文件最后一行的 Macaw::dispatch(); 方法才是真正处理当前 URL 的地方。</p><h2 id="设计mvc"><a href="#设计mvc" class="headerlink" title="设计mvc"></a>设计mvc</h2><h3 id="规划文件夹"><a href="#规划文件夹" class="headerlink" title="规划文件夹"></a>规划文件夹</h3><p>新建 MFFC/app 文件夹，在 app 中创建 controllers、models、views 三个文件夹，开始正式开始踏上 MVC 的征程。</p><h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h3><p>增加一条路由： Macaw::get(‘’, ‘HomeController@home’);，打开浏览器直接访问 <a href="http://127.0.0.1:81/，出现以下提示：" target="_blank" rel="external">http://127.0.0.1:81/，出现以下提示：</a></p><pre><code>Fatal error: Class &apos;HomeController&apos; not found in /Library/WebServer/Documents/wwwroot/MFFC/vendor/codingbean/macaw/Macaw.php on line 93</code></pre><p>为什么没找到 HomeController 类？因为我们没有让他自动加载，修改 composer.json 为：</p><pre><code>&quot;autoload&quot;: {  &quot;classmap&quot;: [    &quot;app/controllers&quot;,    &quot;app/models&quot;  ]}</code></pre><p>运行 composer 命令</p><pre><code>composer dump-autoload</code></pre><h2 id="ORM组件illuminate-database"><a href="#ORM组件illuminate-database" class="headerlink" title="ORM组件illuminate/database"></a>ORM组件illuminate/database</h2><p>给 composer.json 增加一个 require 项：</p><pre><code>&quot;illuminate/database&quot;: &quot;*&quot;</code></pre><p>运行 composer update ，等待安装完成。</p><pre><code>&lt;?phpuse Illuminate\Database\Capsule\Manager as Capsule;// Autoload 自动载入require &apos;../vendor/autoload.php&apos;;// Eloquent ORM$capsule = new Capsule;$capsule-&gt;addConnection(require &apos;../config/database.php&apos;);$capsule-&gt;bootEloquent();// 路由配置require &apos;../config/routes.php&apos;;</code></pre><p>新增 config/database.php （注意替换数据库密码）：</p><pre><code>&lt;?phpreturn [  &apos;driver&apos;    =&gt; &apos;mysql&apos;,  &apos;host&apos;      =&gt; &apos;localhost&apos;,  &apos;database&apos;  =&gt; &apos;mffc&apos;,  &apos;username&apos;  =&gt; &apos;root&apos;,  &apos;password&apos;  =&gt; &apos;password&apos;,  &apos;charset&apos;   =&gt; &apos;utf8&apos;,  &apos;collation&apos; =&gt; &apos;utf8_general_ci&apos;,  &apos;prefix&apos;    =&gt; &apos;&apos;  ];</code></pre><p>修改 models/Article.php ：</p><pre><code>&lt;?phpclass Article extends Illuminate\Database\Eloquent\Model{  public $timestamps = false;}</code></pre><p>controllers/HomeController.php ：</p><pre><code>&lt;?phpclass HomeController extends BaseController{    public function index()    {        $article = Article::first();        require dirname(__FILE__).&apos;/../views/home.php&apos;;//模板文件    }}</code></pre><p>更新自动加载配置：</p><pre><code>composer dump-autoload</code></pre><p>SQL 语句：</p><pre><code>DROP TABLE IF EXISTS `articles`;CREATE TABLE `articles` (  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,  `title` varchar(255) DEFAULT NULL,  `content` longtext,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;LOCK TABLES `articles` WRITE;/*!40000 ALTER TABLE `articles` DISABLE KEYS */;INSERT INTO `articles` (`id`, `title`, `content`)VALUES    (1,&apos;我是标题&apos;,&apos;&lt;h3&gt;我是内容呀~~&lt;/h3&gt;&lt;p&gt;我真的是内容，不信算了，哼~ O(∩_∩)O&lt;/p&gt;&apos;),    (2,&apos;我是标题&apos;,&apos;&lt;h3&gt;我是内容呀~~&lt;/h3&gt;&lt;p&gt;我真的是内容，不信算了，哼~ O(∩_∩)O&lt;/p&gt;&apos;);/*!40000 ALTER TABLE `articles` ENABLE KEYS */;UNLOCK TABLES;</code></pre><p>刷新页面，可以看到成功出现数据库的数据了。</p><h2 id="错误页面提示组件whoops"><a href="#错误页面提示组件whoops" class="headerlink" title="错误页面提示组件whoops"></a>错误页面提示组件whoops</h2><p>引入错误页面提示组件，修改  composer.json ：</p><pre><code>&quot;require&quot;: {  &quot;codingbean/macaw&quot;: &quot;dev-master&quot;,  &quot;illuminate/database&quot;: &quot;*&quot;,  &quot;filp/whoops&quot;: &quot;*&quot;},</code></pre><p>运行  composer update ，然后在  bootstrap.php  的最后添加：</p><pre><code>// whoops 错误提示$whoops = new \Whoops\Run;$whoops-&gt;pushHandler(new \Whoops\Handler\PrettyPageHandler);$whoops-&gt;register();</code></pre><p>下面我们将增加路由配置中  无匹配项  的错误页面，修改  config/routes.php ：</p><pre><code>&lt;?phpuse NoahBuscher\Macaw\Macaw;Macaw::get(&apos;&apos;, &apos;HomeController@home&apos;);Macaw::get(&apos;fuck&apos;, function() {  echo &quot;成功！&quot;;});Macaw::$error_callback = function() {  throw new Exception(&quot;路由无匹配项 404 Not Found&quot;);};Macaw::dispatch();</code></pre><p>这时随便在配的域名后面加上个路由，系统就会报错了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个项目学下来，整个目录结构差不多就这样。</p><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/martp目录.png" alt=""></p><p>里面有几个用到的函数和概念，需要在这里做下笔记。</p><h3 id="PHP写startswith和endswith"><a href="#PHP写startswith和endswith" class="headerlink" title="PHP写startswith和endswith"></a>PHP写startswith和endswith</h3><pre><code>&lt;?phpfunction starts_with($a,$b){    return strpos($a, $b) &gt; 0?true: false;}var_dump(starts_with(&apos;I love she&apos;,&apos;L&apos;));function end_with($a,$b,$lowerorup=1){    // 如果$lowerorup = 0则不用区分大小写        $begin= $lowerorup?strpos($a,$b):stripos($a,$b);    if($begin){    echo &apos;开始于第&apos;,$begin,&apos;个字符&lt;br /&gt;&apos;;    echo &apos;结束于&apos;,$begin+strlen($b);    }}echo &apos;&lt;br /&gt;&apos;;end_with(&apos;I love she&apos;,&apos;Lov&apos;,0);</code></pre><h3 id="ctype-lower"><a href="#ctype-lower" class="headerlink" title="ctype_lower()"></a>ctype_lower()</h3><p>做小写字符检测,数字不能通过检测。</p><pre><code>bool ctype_lower ( string $text )</code></pre><h3 id="strtolower"><a href="#strtolower" class="headerlink" title="strtolower()"></a>strtolower()</h3><p>函数把字符串转换为小写。</p><p>相关函数：</p><pre><code>lcfirst() - 把字符串中的首字符转换为小写strtoupper() - 把字符串转换为大写ucfirst() - 把字符串中的首字符转换为大写ucwords() - 把字符串中每个单词的首字符转换为大写</code></pre><h3 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h3><p>该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</p><p>举例：</p><pre><code>&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;?&gt;</code></pre><p>结果：</p><pre><code>$a = Cat; $b = Dog; $c = Horse</code></pre>]]></content>
    
    <summary type="html">
    
      实现一个类似laravel的现代化PHP框架
    
    </summary>
    
      <category term="框架" scheme="http://martist.cn/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="框架" scheme="http://martist.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>实现一个类似tp的轻量级框架</title>
    <link href="http://martist.cn/2018/05/02/%E6%A1%86%E6%9E%B6/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCtp%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A1%86%E6%9E%B6/"/>
    <id>http://martist.cn/2018/05/02/框架/实现一个类似tp的轻量级框架/</id>
    <published>2018-05-01T16:00:00.000Z</published>
    <updated>2018-05-02T10:10:22.326Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h2><h3 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h3><blockquote><p>MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式。</p></blockquote><p>MVC把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p><p>PHP中MVC模式也称Web MVC，从上世纪70年代进化而来。</p><p>MVC的目的是实现一种动态的程序设计，便于后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。</p><p>除此之外，此模式通过对复杂度的简化，使程序结构更加直观。</p><h3 id="MVC各部分的职能"><a href="#MVC各部分的职能" class="headerlink" title="MVC各部分的职能"></a>MVC各部分的职能</h3><pre><code>模型Model – 管理大部分的业务逻辑和所有的数据库逻辑。模型提供了连接和操作数据库的抽象层。控制器Controller - 负责响应用户请求、准备数据，以及决定如何展示数据。视图View – 负责渲染数据，通过HTML方式呈现给用户。</code></pre><h3 id="MVC流程图"><a href="#MVC流程图" class="headerlink" title="MVC流程图"></a>MVC流程图</h3><p>一个典型的Web MVC流程：</p><pre><code>Controller截获用户发出的请求；Controller调用Model完成状态的读写操作；Controller把数据传递给View；View渲染最终结果并呈献给用户。</code></pre><h3 id="为什么要自己开发MVC框架"><a href="#为什么要自己开发MVC框架" class="headerlink" title="为什么要自己开发MVC框架"></a>为什么要自己开发MVC框架</h3><p>网络上有大量优秀的MVC框架可供使用，本教程并不是为了开发一个全面的、终极的MVC框架解决方案。</p><p>我们将它看作是一个很好的从内部学习PHP的机会。</p><p>在此过程中，你将学习面向对象编程和MVC设计模式，并学习到开发中的一些注意事项。</p><p>更重要的是，通过自制MVC框架，每个人都可以完全控制自己的框架，将你的想法融入到你开发的框架中。</p><p>虽然不一定是最好的，但是你可以按照自己的方式开发各种功能。</p><h2 id="开始开发自己的MVC框架"><a href="#开始开发自己的MVC框架" class="headerlink" title="开始开发自己的MVC框架"></a>开始开发自己的MVC框架</h2><h3 id="目录准备"><a href="#目录准备" class="headerlink" title="目录准备"></a>目录准备</h3><p>在开始开发前，让我们先来把项目建立好。</p><p>假设我们建立的项目为 project，MVC的框架命名为 fastphp，那么接下来，第一步要把目录结构设置好。</p><p>project  WEB部署目录<br>├─application           应用目录<br>│  ├─controllers        控制器目录<br>│  ├─models             模块目录<br>│  ├─views              视图目录<br>├─config                配置文件目录<br>├─fastphp               框架核心目录<br>├─static                静态文件目录<br>├─index.php             入口文件</p><p>然后把Nginx或者Apache的站点根目录配置到project目录。</p><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>在目录设置好以后，我们接下来规定代码的规范：</p><pre><code>MySQL的表名需小写或小写加下划线，如：item，car_orders。模块名（Models）需用大驼峰命名法，即首字母大写，并在名称后添加Model，如：ItemModel，CarModel。控制器（Controllers）需用大驼峰命名法，即首字母大写，并在名称后添加Controller，如：ItemController，CarController。方法名（Action）需用小驼峰命名法，即首字母小写，如：index，indexPost。视图（Views）部署结构为控制器名/行为名，如：item/view.php，car/buy.php。</code></pre><p>上述规则是为了程序能更好地相互调用。</p><p>接下来就开始真正的PHP MVC编程了。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向的目的有两个：设置根目录为project所在位置，以及将所有请求都发送给 index.php 文件。</p><p>如果是Apache服务器，在 project 目录下新建一个 .htaccess 文件，内容为：</p><pre><code>&lt;IfModule mod_rewrite.c&gt;    RewriteEngine On    RewriteCond %{REQUEST_FILENAME} !-f    RewriteCond %{REQUEST_FILENAME} !-d    RewriteRule . index.php&lt;/IfModule&gt;</code></pre><p>如果是Nginx服务器，修改配置文件，在server块中加入如下的重定向：</p><pre><code>location / {    try_files $uri $uri/ /index.php$args;}</code></pre><h4 id="主要原因"><a href="#主要原因" class="headerlink" title="主要原因"></a>主要原因</h4><h5 id="静态文件能直接访问"><a href="#静态文件能直接访问" class="headerlink" title="静态文件能直接访问"></a>静态文件能直接访问</h5><p>如果文件或者目录真实存在，则直接访问存在的文件/目录。</p><p>比如，静态文件static/css/main.css真实存在，就可以直接访问它。</p><h5 id="程序有单一的入口"><a href="#程序有单一的入口" class="headerlink" title="程序有单一的入口"></a>程序有单一的入口</h5><p>这种情况是请求地址不是真实存在的文件或目录，这样请求就会传到 index.php 上。</p><p>例如，访问地址：localhost/item/view/1，在文件系统中并不存在这样的文件或目录。</p><p>那么，Apache或Nginx服务器会把请求发给index.php，并且把域名之后的字符串赋值给REQUEST_URI变量。</p><p>这样在PHP中用$_SERVER[‘REQUEST_URI’]就能拿到/item/view/1；</p><h5 id="可以用来生成美化的URL，利于SEO。"><a href="#可以用来生成美化的URL，利于SEO。" class="headerlink" title="可以用来生成美化的URL，利于SEO。"></a>可以用来生成美化的URL，利于SEO。</h5><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>接下来，在 project 目录下新建 index.php 入口文件，文件内容为：</p><pre><code>&lt;?phpdefine(&apos;APP_PATH&apos;, __DIR__ . &apos;/&apos;);define(&apos;APP_DEBUG&apos;, true);require(APP_PATH . &apos;fastphp/Fastphp.php&apos;);$config = require(APP_PATH . &apos;config/config.php&apos;);(new Fastphp($config))-&gt;run();</code></pre><p>注意，上面的PHP代码中，并没有添加PHP结束符号?&gt;。</p><h4 id="主要原因-1"><a href="#主要原因-1" class="headerlink" title="主要原因"></a>主要原因</h4><p>对于只有 PHP 代码的文件，最好没有结束标志 ?&gt;</p><p>PHP自身并不需要结束符号，不加结束符让程序更加安全，很大程度防止了末尾被注入额外的内容。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在入口文件中，我们加载了config.php文件的内容，那它有何作用呢？</p><p>从名称不难看出，它的作用是保存一些常用配置。</p><p>config.php 文件内容如下，作用是定义数据库连接参数参数，以及配置默认控制器名和操作名：</p><pre><code>&lt;?phpdefine(&apos;DB_NAME&apos;, &apos;project&apos;);define(&apos;DB_USER&apos;, &apos;root&apos;);define(&apos;DB_PASSWORD&apos;, &apos;123456&apos;);define(&apos;DB_HOST&apos;, &apos;localhost&apos;);$config[&apos;defaultController&apos;] = &apos;Item&apos;;$config[&apos;defaultAction&apos;] = &apos;index&apos;;return $config;</code></pre><p>入口中的$config变量接收到配置参数后，再传给框架的核心类，也就是Fastphp类。</p><h3 id="框架核心类"><a href="#框架核心类" class="headerlink" title="框架核心类"></a>框架核心类</h3><p>入口文件对框架类做了两步操作：实例化，调用run()方法。</p><p>实例化操作接受$config参数配置，并保存到类属性中。</p><p>run()方法则调用用类自身方法，完成：自动加载类文件、监测开发环境、过滤敏感字符、移除全局变量的老用法、和处理路由。</p><pre><code>&lt;?phpclass Fastphp{    protected $_config = [];    public function __construct($config)    {        $this-&gt;_config = $config;    }    public function run()    {        spl_autoload_register(array($this, &apos;loadClass&apos;));        $this-&gt;setReporting();        $this-&gt;removeMagicQuotes();        $this-&gt;unregisterGlobals();        $this-&gt;setDbConfig();        $this-&gt;route();    }    public function route()    {        $controllerName = $this-&gt;_config[&apos;defaultController&apos;];        $actionName = $this-&gt;_config[&apos;defaultAction&apos;];        $param = array();        $url = $_SERVER[&apos;REQUEST_URI&apos;];        $position = strpos($url, &apos;?&apos;);        $url = $position === false ? $url : substr($url, 0, $position);        $url = trim($url, &apos;/&apos;);        if ($url) {            $urlArray = explode(&apos;/&apos;, $url);            $urlArray = array_filter($urlArray);            $controllerName = ucfirst($urlArray[0]);            array_shift($urlArray);            $actionName = $urlArray ? $urlArray[0] : $actionName;            array_shift($urlArray);            $param = $urlArray ? $urlArray : array();        }        $controller = $controllerName . &apos;Controller&apos;;        if (!class_exists($controller)) {            exit($controller . &apos;控制器不存在&apos;);        }        if (!method_exists($controller, $actionName)) {            exit($actionName . &apos;方法不存在&apos;);        }        $dispatch = new $controller($controllerName, $actionName);        call_user_func_array(array($dispatch, $actionName), $param);    }    public function setReporting()    {        if (APP_DEBUG === true) {            error_reporting(E_ALL);            ini_set(&apos;display_errors&apos;,&apos;On&apos;);        } else {            error_reporting(E_ALL);            ini_set(&apos;display_errors&apos;,&apos;Off&apos;);            ini_set(&apos;log_errors&apos;, &apos;On&apos;);        }    }    public function stripSlashesDeep($value)    {        $value = is_array($value) ? array_map(array($this, &apos;stripSlashesDeep&apos;), $value) : stripslashes($value);        return $value;    }    public function removeMagicQuotes()    {        if (get_magic_quotes_gpc()) {            $_GET = isset($_GET) ? $this-&gt;stripSlashesDeep($_GET ) : &apos;&apos;;            $_POST = isset($_POST) ? $this-&gt;stripSlashesDeep($_POST ) : &apos;&apos;;            $_COOKIE = isset($_COOKIE) ? $this-&gt;stripSlashesDeep($_COOKIE) : &apos;&apos;;            $_SESSION = isset($_SESSION) ? $this-&gt;stripSlashesDeep($_SESSION) : &apos;&apos;;        }    }    public function unregisterGlobals()    {        if (ini_get(&apos;register_globals&apos;)) {            $array = array(&apos;_SESSION&apos;, &apos;_POST&apos;, &apos;_GET&apos;, &apos;_COOKIE&apos;, &apos;_REQUEST&apos;, &apos;_SERVER&apos;, &apos;_ENV&apos;, &apos;_FILES&apos;);            foreach ($array as $value) {                foreach ($GLOBALS[$value] as $key =&gt; $var) {                    if ($var === $GLOBALS[$key]) {                        unset($GLOBALS[$key]);                    }                }            }        }    }    public function setDbConfig()    {        if ($this-&gt;_config[&apos;db&apos;]) {            Model::$dbConfig = $this-&gt;_config[&apos;db&apos;];        }    }    public static function loadClass($class)    {        $frameworks = __DIR__ . &apos;/&apos; . $class . &apos;.php&apos;;        $controllers = APP_PATH . &apos;application/controllers/&apos; . $class . &apos;.php&apos;;        $models = APP_PATH . &apos;application/models/&apos; . $class . &apos;.php&apos;;        if (file_exists($frameworks)) {            include $frameworks;        } elseif (file_exists($controllers)) {            include $controllers;        } elseif (file_exists($models)) {            include $models;        } else {        }    }}</code></pre><p>下面重点讲解主请求方法<br> route()，它也称路由方法，作用是：截取URL，并解析出控制器名、方法名和URL参数。</p><p>假设我们的 URL 是这样：</p><pre><code>yoursite.com/controllerName/actionName/queryString</code></pre><p>当浏览器访问上面的URL，route()从全局变量 $_SERVER[‘REQUEST_URI’]中获取到字符串/controllerName/actionName/queryString。</p><p>然后，会将这个字符串分割成三部分：controller、action 和 queryString。</p><p>例如，URL链接为：yoursite.com/item/view/1/hello，那么route()分割之后，</p><pre><code>Controller名就是：itemaction名就是：viewURL参数就是：array(1, hello)</code></pre><p>分割完成后，再实例化控制器：itemController，并调用其中的view方法 。</p><h3 id="Controller基类"><a href="#Controller基类" class="headerlink" title="Controller基类"></a>Controller基类</h3><p>接下来，就是在 fastphp 中创建MVC基类，包括控制器、模型和视图三个基类。</p><p>新建控制器基类，文件名 Controller.class.php，功能就是总调度，内容如下：</p><pre><code>&lt;?phpclass Controller{    protected $_controller;    protected $_action;    protected $_view;    public function __construct($controller, $action)    {        $this-&gt;_controller = $controller;        $this-&gt;_action = $action;        $this-&gt;_view = new View($controller, $action);    }    public function assign($name, $value)    {        $this-&gt;_view-&gt;assign($name, $value);    }    public function render()    {        $this-&gt;_view-&gt;render();    }}Controller 类用assign()方法实现把变量保存到View对象中。这样，在调用$this-&gt; render() 后视图文件就能显示这些变量。</code></pre><h3 id="Model基类"><a href="#Model基类" class="headerlink" title="Model基类"></a>Model基类</h3><pre><code>新建模型基类，继承自数据库操作类Sql类（因为数据库操作比较复杂）。</code></pre><h4 id="模型基类-Model-class-php"><a href="#模型基类-Model-class-php" class="headerlink" title="模型基类 Model.class.php"></a>模型基类 Model.class.php</h4><pre><code>&lt;?phpclass Model extends Sql{    protected $_model;    protected $_table;    public static $dbConfig = [];    public function __construct()    {        $this-&gt;connect(self::$dbConfig[&apos;host&apos;], self::$dbConfig[&apos;username&apos;], self::$dbConfig[&apos;password&apos;],            self::$dbConfig[&apos;dbname&apos;]);        if (!$this-&gt;_table) {            $this-&gt;_model = get_class($this);            $this-&gt;_model = substr($this-&gt;_model, 0, -5);            $this-&gt;_table = strtolower($this-&gt;_model);        }    }}</code></pre><h4 id="数据库基类-Sql-class-php"><a href="#数据库基类-Sql-class-php" class="headerlink" title="数据库基类 Sql.class.php"></a>数据库基类 Sql.class.php</h4><pre><code>&lt;?phpclass Sql{    protected $_dbHandle;    protected $_result;    private $filter = &apos;&apos;;    public function connect($host, $username, $password, $dbname)    {        try {            $dsn = sprintf(&quot;mysql:host=%s;dbname=%s;charset=utf8&quot;, $host, $dbname);            $option = array(PDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC);            $this-&gt;_dbHandle = new PDO($dsn, $username, $password, $option);        } catch (PDOException $e) {            exit(&apos;错误: &apos; . $e-&gt;getMessage());        }    }    public function where($where = array())    {        if (isset($where)) {            $this-&gt;filter .= &apos; WHERE &apos;;            $this-&gt;filter .= implode(&apos; &apos;, $where);        }        return $this;    }    public function order($order = array())    {        if(isset($order)) {            $this-&gt;filter .= &apos; ORDER BY &apos;;            $this-&gt;filter .= implode(&apos;,&apos;, $order);        }        return $this;    }    public function selectAll()    {        $sql = sprintf(&quot;select * from `%s` %s&quot;, $this-&gt;_table, $this-&gt;filter);        $sth = $this-&gt;_dbHandle-&gt;prepare($sql);        $sth-&gt;execute();        return $sth-&gt;fetchAll();    }    public function select($id)    {        $sql = sprintf(&quot;select * from `%s` where `id` = &apos;%s&apos;&quot;, $this-&gt;_table, $id);        $sth = $this-&gt;_dbHandle-&gt;prepare($sql);        $sth-&gt;execute();        return $sth-&gt;fetch();    }    public function delete($id)    {        $sql = sprintf(&quot;delete from `%s` where `id` = &apos;%s&apos;&quot;, $this-&gt;_table, $id);        $sth = $this-&gt;_dbHandle-&gt;prepare($sql);        $sth-&gt;execute();        return $sth-&gt;rowCount();    }    public function query($sql)    {        $sth = $this-&gt;_dbHandle-&gt;prepare($sql);        $sth-&gt;execute();        return $sth-&gt;rowCount();    }    public function add($data)    {        $sql = sprintf(&quot;insert into `%s` %s&quot;, $this-&gt;_table, $this-&gt;formatInsert($data));        return $this-&gt;query($sql);    }    public function update($id, $data)    {        $sql = sprintf(&quot;update `%s` set %s where `id` = &apos;%s&apos;&quot;, $this-&gt;_table, $this-&gt;formatUpdate($data), $id);        return $this-&gt;query($sql);    }    private function formatInsert($data)    {        $fields = array();        $values = array();        foreach ($data as $key =&gt; $value) {            $fields[] = sprintf(&quot;`%s`&quot;, $key);            $values[] = sprintf(&quot;&apos;%s&apos;&quot;, $value);        }        $field = implode(&apos;,&apos;, $fields);        $value = implode(&apos;,&apos;, $values);        return sprintf(&quot;(%s) values (%s)&quot;, $field, $value);    }    private function formatUpdate($data)    {        $fields = array();        foreach ($data as $key =&gt; $value) {            $fields[] = sprintf(&quot;`%s` = &apos;%s&apos;&quot;, $key, $value);        }        return implode(&apos;,&apos;, $fields);    }}</code></pre><p>应该说，Sql.class.php 是框架的核心部分。为什么？</p><p>因为通过它，我们创建了一个 SQL 抽象层，可以大大减少了数据库的编程工作。</p><p>虽然 PDO 接口本来已经很简洁，但是抽象之后框架的可灵活性更高。</p><p>这里的数据库句柄$this-&gt;_dbHandle还能用单例模式返回，让数据读写更高效，这部分可自行实现。</p><h3 id="View基类"><a href="#View基类" class="headerlink" title="View基类"></a>View基类</h3><h4 id="视图基类-View-class-php"><a href="#视图基类-View-class-php" class="headerlink" title="视图基类 View.class.php"></a>视图基类 View.class.php</h4><pre><code>&lt;?phpclass View{    protected $variables = array();    protected $_controller;    protected $_action;    function __construct($controller, $action)    {        $this-&gt;_controller = $controller;        $this-&gt;_action = $action;    }    public function assign($name, $value)    {        $this-&gt;variables[$name] = $value;    }    public function render()    {        extract($this-&gt;variables);        $defaultHeader = APP_PATH . &apos;application/views/header.php&apos;;        $defaultFooter = APP_PATH . &apos;application/views/footer.php&apos;;        $controllerHeader = APP_PATH . &apos;application/views/&apos; . $this-&gt;_controller . &apos;/header.php&apos;;        $controllerFooter = APP_PATH . &apos;application/views/&apos; . $this-&gt;_controller . &apos;/footer.php&apos;;        $controllerLayout = APP_PATH . &apos;application/views/&apos; . $this-&gt;_controller . &apos;/&apos; . $this-&gt;_action . &apos;.php&apos;;        if (file_exists($controllerHeader)) {            include ($controllerHeader);        } else {            include ($defaultHeader);        }        include ($controllerLayout);        if (file_exists($controllerFooter)) {            include ($controllerFooter);        } else {            include ($defaultFooter);        }    }}</code></pre><p>这样，核心的PHP MVC框架核心就完成了。</p><p>下面我们编写应用来测试框架功能。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="部署数据库"><a href="#部署数据库" class="headerlink" title="部署数据库"></a>部署数据库</h3><p>在 SQL 中新建一个 project 数据库，增加一个item 表、并插入两条记录，命令如下：</p><pre><code>CREATE DATABASE `project` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;USE `project`;CREATE TABLE `item` (    `id` int(11) NOT NULL auto_increment,    `item_name` varchar(255) NOT NULL,    PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;INSERT INTO `item` VALUES(1, &apos;Hello World.&apos;);INSERT INTO `item` VALUES(2, &apos;Lets go!&apos;);</code></pre><h3 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h3><p>然后，我们还需要在 models 目录中创建一个 ItemModel.php 模型，内容如下：</p><pre><code>&lt;?phpclass ItemModel extends Model{    public $_table = &apos;item&apos;;}</code></pre><p>因为 Item 模型继承了 Model基类，所以它拥有 Model 类的所有功能。</p><h3 id="部署控制器"><a href="#部署控制器" class="headerlink" title="部署控制器"></a>部署控制器</h3><p>在 controllers 目录下创建一个 ItemController.php 控制器，内容如下：</p><pre><code>&lt;?phpclass ItemController extends Controller{    public function index()    {        $items = (new ItemModel)-&gt;selectAll();        $this-&gt;assign(&apos;title&apos;, &apos;全部条目&apos;);        $this-&gt;assign(&apos;items&apos;, $items);        $this-&gt;render();    }    public function add()    {        $data[&apos;item_name&apos;] = $_POST[&apos;value&apos;];        $count = (new ItemModel)-&gt;add($data);        $this-&gt;assign(&apos;title&apos;, &apos;添加成功&apos;);        $this-&gt;assign(&apos;count&apos;, $count);        $this-&gt;render();    }    public function view($id = null)    {        $item = (new ItemModel)-&gt;select($id);        $this-&gt;assign(&apos;title&apos;, &apos;正在查看&apos; . $item[&apos;item_name&apos;]);        $this-&gt;assign(&apos;item&apos;, $item);        $this-&gt;render();    }    public function update()    {        $data = array(&apos;id&apos; =&gt; $_POST[&apos;id&apos;], &apos;item_name&apos; =&gt; $_POST[&apos;value&apos;]);        $count = (new ItemModel)-&gt;update($data[&apos;id&apos;], $data);        $this-&gt;assign(&apos;title&apos;, &apos;修改成功&apos;);        $this-&gt;assign(&apos;count&apos;, $count);        $this-&gt;render();    }    public function delete($id = null)    {        $count = (new ItemModel)-&gt;delete($id);        $this-&gt;assign(&apos;title&apos;, &apos;删除成功&apos;);        $this-&gt;assign(&apos;count&apos;, $count);        $this-&gt;render();    }}</code></pre><h3 id="部署视图"><a href="#部署视图" class="headerlink" title="部署视图"></a>部署视图</h3><p>在 views 目录下新建 header.php 和 footer.php 两个页头页脚模板，如下。</p><h4 id="header-php"><a href="#header-php" class="headerlink" title="header.php"></a>header.php</h4><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;    &lt;title&gt;&lt;?php echo $title ?&gt;&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/main.css&quot; type=&quot;text/css&quot; /&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&lt;?php echo $title ?&gt;&lt;/h1&gt;</code></pre><h4 id="footer-php"><a href="#footer-php" class="headerlink" title="footer.php"></a>footer.php</h4><pre><code>&lt;/body&gt;&lt;/html&gt;</code></pre><p>页头文件用到了main.css样式文件，内容：</p><pre><code>input {    font-family:georgia,times;    font-size:24px;    line-height:1.2em;}a {    color:blue;    font-family:georgia,times;    font-size:20px;    line-height:1.2em;    text-decoration:none;}a:hover {    text-decoration:underline;}h1 {    color:#000000;    font-size:41px;    border-bottom:1px dotted #cccccc;}</code></pre><p>然后，在 views/item 创建以下几个视图文件。</p><h4 id="index-php-浏览数据库内-item-表的所有记录"><a href="#index-php-浏览数据库内-item-表的所有记录" class="headerlink" title="index.php[浏览数据库内 item 表的所有记录]"></a>index.php[浏览数据库内 item 表的所有记录]</h4><pre><code>&lt;form action=&quot;/item/add&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; value=&quot;点击添加&quot; onclick=&quot;this.value=&apos;&apos;&quot; name=&quot;value&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;&lt;/form&gt;&lt;br/&gt;&lt;?php foreach ($items as $item): ?&gt;    &lt;a class=&quot;big&quot; href=&quot;/item/view/&lt;?php echo $item[&apos;id&apos;] ?&gt;&quot; title=&quot;点击修改&quot;&gt;        &lt;span class=&quot;item&quot;&gt;            &lt;?php echo $item[&apos;id&apos;] ?&gt;            &lt;?php echo $item[&apos;item_name&apos;] ?&gt;        &lt;/span&gt;    &lt;/a&gt;    ----    &lt;a class=&quot;big&quot; href=&quot;/item/delete/&lt;?php echo $item[&apos;id&apos;]?&gt;&quot;&gt;删除&lt;/a&gt;&lt;br/&gt;&lt;?php endforeach ?&gt;</code></pre><h4 id="add-php-添加记录"><a href="#add-php-添加记录" class="headerlink" title="add.php[添加记录]"></a>add.php[添加记录]</h4><pre><code>&lt;a class=&quot;big&quot; href=&quot;/item/index&quot;&gt;成功添加&lt;?php echo $count ?&gt;条记录，点击返回&lt;/a&gt;</code></pre><h4 id="view-php-查看单条记录"><a href="#view-php-查看单条记录" class="headerlink" title="view.php[查看单条记录]"></a>view.php[查看单条记录]</h4><pre><code>&lt;form action=&quot;/item/update&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;value&quot; value=&quot;&lt;?php echo $item[&apos;item_name&apos;] ?&gt;&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&lt;?php echo $item[&apos;id&apos;] ?&gt;&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt;&lt;/form&gt;</code></pre><p><a class="big" href="/item/index">返回</a></p><h4 id="update-php-更改记录"><a href="#update-php-更改记录" class="headerlink" title="update.php[更改记录]"></a>update.php[更改记录]</h4><pre><code>&lt;a class=&quot;big&quot; href=&quot;/item/index&quot;&gt;成功修改&lt;?php echo $count ?&gt;项，点击返回&lt;/a&gt;</code></pre><h4 id="delete-php-删除记录"><a href="#delete-php-删除记录" class="headerlink" title="delete.php[删除记录]"></a>delete.php[删除记录]</h4><pre><code>&lt;a href=&quot;/item/index&quot;&gt;成功删除&lt;?php echo $count ?&gt;项，点击返回&lt;/a&gt;</code></pre><h3 id="应用测试"><a href="#应用测试" class="headerlink" title="应用测试"></a>应用测试</h3><p>这样，在浏览器中访问 project程序：<a href="http://localhost/item/index/，就可以看到效果了。" target="_blank" rel="external">http://localhost/item/index/，就可以看到效果了。</a></p>]]></content>
    
    <summary type="html">
    
      实现一个类似tp的轻量级框架
    
    </summary>
    
      <category term="框架" scheme="http://martist.cn/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="框架" scheme="http://martist.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>nginx中的PHP_VALUE</title>
    <link href="http://martist.cn/2018/04/20/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/nginx%E4%B8%AD%E7%9A%84PHP_VALUE/"/>
    <id>http://martist.cn/2018/04/20/服务部署/nginx中的PHP_VALUE/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-19T11:30:38.665Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>PHP_VALUE实现了动态修改php的配置项 ，而不需要去改项目代码。</p><p>我们一般修改php的配置项都是在php.ini中修改。在php,ini中的修改会影响到所有使用php的程序。假如我想让修改只在某个域名下生效，该如何做呢?首先想到的可能是使用ini_set()方法在脚本中修改。但是这个只能修改作用域为PHP_INI_USER和PHP_INI_ALL的配置项。所以我们用PHP_VALUE这个更好的做法。</p><h3 id="PHP配置指令作用域说明"><a href="#PHP配置指令作用域说明" class="headerlink" title="PHP配置指令作用域说明"></a>PHP配置指令作用域说明</h3><p>PHP总共有4个配置指令作用域，分别是PHP_INI_USER，PHP_INI_PERDIR，PHP_INI_SYSTEM，PHP_INI_ALL。这些作用域限制了指令是否可以被修改，在那里可以被修改。php的每个配置项都会有一个作用域。下面是对四种作用域的说明。</p><pre><code>作用域类型         说明PHP_INI_USER     可在用户脚本(如 ini_set())或Windows注册表(PHP 5.3 起)以及.user.ini中设定PHP_INI_PERDIR   可在 php.ini，.htaccess 或 httpd.conf 中设定PHP_INI_SYSTEM   可在 php.ini 或 httpd.conf 中设定PHP_INI_ALL      可在任何地方设定</code></pre><p>例如 output_buffering 指令是属于 PHP_INI_PERDIR，因而就不能用 ini_set() 来设定。但是 display_errors 指令是属于 PHP_INI_ALL 因而就可以在任何地方被设定，包括 ini_set()。httpd.conf相比ini_set()中可以设定更多级别的配置项。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>如果是apache+php的组合，我们可以在apache的配置文件中加入如下指令即可。</p><pre><code>PHP_VALUE auto_prepend_file /home/www/bo56.com/header.php</code></pre><p>如果是nginx+php组合，可以加入如下指令</p><pre><code>fastcgi_param PHP_VALUE &quot;auto_prepend_file=/home/www/bo56.com/header.php&quot;;</code></pre><p>注意，nginx中多次使用 PHP_VALUE时，最后的一个会覆盖之前的。如果想设置多个配置项，需要写在一起，然后用换行分割。如：</p><pre><code>fastcgi_param PHP_VALUE &quot;auto_prepend_file=/home/www/bo56.com/header.php \n auto_append_file=/home/www/bo56.com/external/footer.php&quot;;</code></pre><h2 id="fastcgi-pass配置"><a href="#fastcgi-pass配置" class="headerlink" title="fastcgi_pass配置"></a>fastcgi_pass配置</h2><p>我们看到nginx的虚拟主机server中的fastcgi_param，这是什么呢，引起了我的好奇心，下面讲解下。</p><p>Nginx 的 fastcgi 模块提供了 fastcgi_param 指令来主要处理这些映射关系，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。</p><pre><code>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;#脚本文件请求的路径,也就是说当访问127.0.0.1/index.php的时候，需要读取网站根目录下面的index.php文件，如果没有配置这一配置项时，nginx不回去网站根目录下访问.php文件，所以返回空白fastcgi_param QUERY_STRING $query_string;                        #请求的参数;如?app=123fastcgi_param REQUEST_METHOD $request_method;                    #请求的动作(GET,POST)fastcgi_param CONTENT_TYPE $content_type;                        #请求头中的Content-Type字段fastcgi_param CONTENT_LENGTH $content_length;                    #请求头中的Content-length字段。fastcgi_param SCRIPT_NAME $fastcgi_script_name;                  #脚本名称fastcgi_param REQUEST_URI $request_uri;                          #请求的地址不带参数fastcgi_param DOCUMENT_URI $document_uri;                        #与$uri相同。fastcgi_param DOCUMENT_ROOT $document_root;                      #网站的根目录。在server配置中root指令中指定的值fastcgi_param SERVER_PROTOCOL $server_protocol;                  #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。fastcgi_param GATEWAY_INTERFACE CGI/1.1;                         #cgi 版本fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;              #nginx 版本号，可修改、隐藏fastcgi_param REMOTE_ADDR $remote_addr;                          #客户端IPfastcgi_param REMOTE_PORT $remote_port;                          #客户端端口fastcgi_param SERVER_ADDR $server_addr;                          #服务器IP地址fastcgi_param SERVER_PORT $server_port;                          #服务器端口fastcgi_param SERVER_NAME $server_name;                          #服务器名，域名在server配置中指定的server_namefastcgi_param PATH_INFO $path_info;                             #可自定义变量-- PHP only, required if PHP was built with --enable-force-cgi-redirectfastcgi_param REDIRECT_STATUS 200;</code></pre><p>在php可打印出上面的服务环境变量<br>如：</p><pre><code>echo $_SERVER[&apos;REMOTE_ADDR&apos;]</code></pre><h2 id="open-basedir限制目录"><a href="#open-basedir限制目录" class="headerlink" title="open_basedir限制目录"></a>open_basedir限制目录</h2><p>open_basedir 将PHP所能打开的文件限制在指定的目录树中，包括文件本身。当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开。</p><p>本指令不受安全模式打开或关闭的影响。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>httpd.conf中的VritualHost</p><pre><code>php_admin_value open_basedir &quot;指定目录&quot;</code></pre><p>nginx fastcgi.conf</p><pre><code>fastcgi_param PHP_VALUE &quot;open_basedir=指定目录&quot;</code></pre><p>1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="nginx" scheme="http://martist.cn/categories/nginx/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>php7性能分析-xhprof【laravel】</title>
    <link href="http://martist.cn/2018/04/20/PHP/php%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/"/>
    <id>http://martist.cn/2018/04/20/PHP/php性能分析入门/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-26T11:06:09.048Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="xhprof"><a href="#xhprof" class="headerlink" title="xhprof"></a>xhprof</h2><p>Xhprof是facebook开源出来的一个php轻量级的性能分析工具，跟Xdebug类似，但性能开销更低，还可以用在生产环境中，也可以由程序开关来控制是否进行profile。</p><h2 id="xhprof-for-PHP7"><a href="#xhprof-for-PHP7" class="headerlink" title="xhprof for PHP7"></a>xhprof for PHP7</h2><p>xhprof已经不维护很久了，同事他也不再支持php7.这对我学习性能测试造成了困扰，好在有这个xhprof for PHP7的开源项目，供大家一起使用。</p><h3 id="适配PHP版本"><a href="#适配PHP版本" class="headerlink" title="适配PHP版本"></a>适配PHP版本</h3><pre><code>7.07.17.2</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>git clone https://github.com/longxinH/xhprof.git ./xhprofcd xhprof/extension/phpize./configure --with-php-config=/path/to/php7/bin/php-configmake &amp;&amp; sudo make install</code></pre><p>出现</p><pre><code>Installing shared extensions:     /opt/php-7.0.14/lib/php/extensions/no-debug-non-zts-20151012/</code></pre><p>代表编译成功</p><h4 id="编译过程问题"><a href="#编译过程问题" class="headerlink" title="编译过程问题"></a>编译过程问题</h4><pre><code>configure: error: Cannot find php-config. Please use --with-php-config=PATH</code></pre><p>configure: error: Cannot find php-config. Please use –with-php-config=PATH</p><p>一般出现这个错误说明你执行 ./configure 时  –with-php-config 这个参数配置路径错误导致的。</p><p>查找:</p><pre><code>find / -name  php-config</code></pre><p>修改为：</p><pre><code>./configure --with-php-config=/usr/local/php/bin/php-config</code></pre><p>就可以解决问题，上面的 /usr/local/php/ 是你的 php 安装路径。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="添加配置项到php-ini"><a href="#添加配置项到php-ini" class="headerlink" title="添加配置项到php.ini"></a>添加配置项到php.ini</h4><pre><code>[xhprof]extension=xhprof.soxhprof.output_dir=/Users/machuang/Desktop/project/xhprof/save_output_dir//此处你就留一个存放xhprof记录文件的目录ok了</code></pre><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><pre><code>mkdir -p  /Users/machuang/Desktop/project/xhprof/save_output_dir</code></pre><h4 id="重启php-fpm-php-ini就生效了"><a href="#重启php-fpm-php-ini就生效了" class="headerlink" title="重启php-fpm, php.ini就生效了"></a>重启php-fpm, php.ini就生效了</h4><pre><code>machuangdeMacBook-Pro:7.1 machuang$ fpm-n Gracefully shutting down php-fpm-n . done-n Starting php-fpm done</code></pre><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/longxinH/xhprof" target="_blank" rel="external">https://github.com/longxinH/xhprof</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="植入xhprof"><a href="#植入xhprof" class="headerlink" title="植入xhprof"></a>植入xhprof</h3><p>此处写个脚本就OK，文件命名为b.php。</p><pre><code>&lt;?php//1.开启xhprofxhprof_enable();//2.你需要分析的代码for($i=1;$i&lt;1000;$i++){  if($i%100 == 0){    echo  $i;    echo &quot;&lt;br&gt;&quot;;  }}//3.关闭xhprof,收集数据$xhprof_data = xhprof_disable();include_once &apos;./xhprof/xhprof_lib/utils/xhprof_lib.php&apos;;include_once &apos;./xhprof/xhprof_lib/utils/xhprof_runs.php&apos;;$xhprof_runs = new XHProfRuns_Default();$run_id = $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_test&quot;);echo &quot;&lt;br&gt;&quot;;echo  $run_id;die;//将run_id保存起来或者随代码一起输出</code></pre><h3 id="使用php内置部署工具"><a href="#使用php内置部署工具" class="headerlink" title="使用php内置部署工具"></a>使用php内置部署工具</h3><pre><code>php -S 127.0.0.1:9001</code></pre><h3 id="在浏览器运行脚本"><a href="#在浏览器运行脚本" class="headerlink" title="在浏览器运行脚本"></a>在浏览器运行脚本</h3><p>打开：<a href="http://127.0.0.1:9001/b.php" target="_blank" rel="external">http://127.0.0.1:9001/b.php</a></p><p>输出：</p><pre><code>1002003004005006007008009005ad88171addf9</code></pre><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>在浏览器输入url，HOST为你的项目当前域名，get参数run的值为$run_id</p><pre><code>HOST/xhpfrof_html/index.php?run=58d3b28b521f6&amp;source=xhprof_test</code></pre><p>打开：<a href="http://127.0.0.1:9001/xhprof/xhprof_html/" target="_blank" rel="external">http://127.0.0.1:9001/xhprof/xhprof_html/</a></p><p>可见生成的文件，点击一个打开，url地址变为  <a href="http://127.0.0.1:9001/xhprof/xhprof_html/index.php?run=5ad88171addf9&amp;source=xhprof_test" target="_blank" rel="external">http://127.0.0.1:9001/xhprof/xhprof_html/index.php?run=5ad88171addf9&amp;source=xhprof_test</a></p><pre><code>Function Name    Calls    Calls%    Incl. Wall Time(microsec)    IWall%    Excl. Wall Time(microsec)    EWall%main()     1     50.0%     3     100.0%     3     100.0%xhprof_disable     1     50.0%     0     0.0%     0     0.0%</code></pre><h3 id="xhprof-enable的参数控制"><a href="#xhprof-enable的参数控制" class="headerlink" title="xhprof_enable的参数控制"></a>xhprof_enable的参数控制</h3><pre><code>HPROF_FLAGS_NO_BUILTINS 跳过所有内置（内部）函数。XHPROF_FLAGS_CPU 输出的性能数据中添加 CPU 数据。XHPROF_FLAGS_MEMORY 输出的性能数据中添加内存数据。</code></pre><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>xhprof_html/index.php将记录的结果整理并可视化，默认的UI里列出了：</p><pre><code>funciton name ： 函数名calls: 调用次数Incl. Wall Time (microsec)： 函数运行时间（包括子函数）IWall%：函数运行时间（包括子函数）占比Excl. Wall Time(microsec)：函数运行时间（不包括子函数）EWall%：函数运行时间（不包括子函数）</code></pre><p>在xhprof_html/index.php中还可以看到[View Full Callgraph]链接，点击后可以绘制出一张可视化的性能分析图，如果点击后报错的话，可能是缺少依赖graphviz，<br>graphviz是一个绘制图形的工具，可以更为直观的让你查看性能的瓶颈。</p><h2 id="优化读取测试数据"><a href="#优化读取测试数据" class="headerlink" title="优化读取测试数据"></a>优化读取测试数据</h2><ul><li>graphviz<br><a href="https://graphviz.gitlab.io/download/" target="_blank" rel="external">https://graphviz.gitlab.io/download/</a></li></ul><p>macbook上的安装很简单，brew就可以。</p><pre><code>brew install  graphviz</code></pre><p>安装成功，brew会帮你配置graphviz，所以后面可以直接使用。点击 [View Full Callgraph] ，可以更直观查看所有的性能测试信息。</p><h2 id="XHProf报告含义"><a href="#XHProf报告含义" class="headerlink" title="XHProf报告含义"></a>XHProf报告含义</h2><p>XHProf报告中有许多列，它们代表的含义见下表：</p><table><thead><tr><th>列名</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Function Name</td><td style="text-align:center">方法名称。</td></tr><tr><td>Calls</td><td style="text-align:center">方法被调用的次数。</td></tr><tr><td>Calls%</td><td style="text-align:center">方法调用次数在同级方法总数调用次数中所占的百分比。</td></tr><tr><td>Incl.Wall Time(microsec)</td><td style="text-align:center">方法执行花费的时间，包括子方法的执行时间。（单位：微秒）</td></tr><tr><td>IWall%</td><td style="text-align:center">方法执行花费的时间百分比。</td></tr><tr><td>Excl. Wall Time(microsec)</td><td style="text-align:center">方法本身执行花费的时间，不包括子方法的执行时间。（单位：微秒）</td></tr><tr><td>EWall%</td><td style="text-align:center">方法本身执行花费的时间百分比。</td></tr><tr><td>Incl. CPU(microsecs)</td><td style="text-align:center">方法执行花费的CPU时间，包括子方法的执行时间。（单位：微秒）</td></tr><tr><td>ICpu%</td><td style="text-align:center">方法执行花费的CPU时间百分比。</td></tr><tr><td>Excl. CPU(microsec)</td><td style="text-align:center">方法本身执行花费的CPU时间，不包括子方法的执行时间。（单位：微秒）</td></tr><tr><td>ECPU%</td><td style="text-align:center">方法本身执行花费的CPU时间百分比。</td></tr><tr><td>Incl.MemUse(bytes)</td><td style="text-align:center">方法执行占用的内存，包括子方法执行占用的内存。（单位：字节）</td></tr><tr><td>IMemUse%</td><td style="text-align:center">方法执行占用的内存百分比。</td></tr><tr><td>Excl.MemUse(bytes)</td><td style="text-align:center">方法本身执行占用的内存，不包括子方法执行占用的内存。（单位：字节）</td></tr><tr><td>EMemUse%</td><td style="text-align:center">方法本身执行占用的内存百分比。</td></tr><tr><td>Incl.PeakMemUse(bytes)</td><td style="text-align:center">Incl.MemUse峰值。（单位：字节）</td></tr><tr><td>IPeakMemUse%</td><td style="text-align:center">ncl.MemUse峰值百分比。</td></tr><tr><td>Excl.PeakMemUse(bytes)</td><td style="text-align:center">Excl.MemUse峰值。单位：（字节）</td></tr><tr><td>EPeakMemUse%</td><td style="text-align:center">Excl.MemUse峰值百分比。</td></tr></tbody></table><h2 id="php框架中使用"><a href="#php框架中使用" class="headerlink" title="php框架中使用"></a>php框架中使用</h2><p>此处我们有比较优雅的注入方式，首先，把xhprof项目放到laravel项目的public目录下，<br>然后在index.php的最上面加入如下代码：</p><pre><code>ini_set(&apos;xhprof.output_dir&apos;,dirname(__DIR__).&apos;/xhprof_save_dir&apos;);//echo ini_get(&apos;xhprof.output_dir&apos;); die;$xhprof_lib_dir = dirname(__DIR__).&apos;/public/xhprof/xhprof_lib/utils/xhprof_lib.php&apos;;$xhprof_runs_dir = dirname(__DIR__).&apos;/public/xhprof/xhprof_lib/utils/xhprof_runs.php&apos;;include_once $xhprof_lib_dir;include_once $xhprof_runs_dir;//开启xhprofxhprof_enable(XHPROF_FLAGS_MEMORY );//在程序结束后收集数据register_shutdown_function(function() {    $xhprof_data        = xhprof_disable();    //让数据收集程序在后台运行    if (function_exists(&apos;fastcgi_finish_request&apos;)) {        fastcgi_finish_request();    }    //保存    $xhprof_runs = new XHProfRuns_Default();    $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_crm&quot;);});</code></pre><p>然后，在xhprof/xhprof_html/index.php增加一行代码，如下：</p><pre><code>ini_set(&apos;xhprof.output_dir&apos;,dirname(dirname(dirname(__DIR__))).&apos;/xhprof_save_dir&apos;);</code></pre><p>这是为了保证数据的存储和读取目录一致。</p><p>打开类似链接，即可看到测试数据分析了<br><a href="http://xhprof.your-laravel.app/xhprof/xhprof_html/index.php?run=5adeaebf97d31&amp;source=xhprof_crm" target="_blank" rel="external">http://xhprof.your-laravel.app/xhprof/xhprof_html/index.php?run=5adeaebf97d31&amp;source=xhprof_crm</a></p><h3 id="数据如下"><a href="#数据如下" class="headerlink" title="数据如下"></a>数据如下</h3><p>  Overall Summary<br>  Total Incl. Wall Time (microsec):    818,313 microsecs<br>  Total Incl. MemUse (bytes):    10,521,952 bytes<br>  Total Incl. PeakMemUse (bytes):    10,435,224 bytes<br>  Number of Function Calls:    56,935</p><p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/xhprof.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="性能测试" scheme="http://martist.cn/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>深蹲怎么不伤膝盖</title>
    <link href="http://martist.cn/2018/04/18/%E5%81%A5%E8%BA%AB/%E6%B7%B1%E8%B9%B2%E6%80%8E%E4%B9%88%E4%B8%8D%E4%BC%A4%E8%86%9D%E7%9B%96/"/>
    <id>http://martist.cn/2018/04/18/健身/深蹲怎么不伤膝盖/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-18T03:10:11.417Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="关于膝关节"><a href="#关于膝关节" class="headerlink" title="关于膝关节"></a>关于膝关节</h2><p>膝关节是人体运动最多、负重最大的关节之一。<br>膝关节承受来自人体的所有重量，甚至是额外的负重。据研究显示，两腿同时站立无屈曲时，双膝关节分别承受膝以上体重的一半，约43%的体重；单腿站立时约承受2倍体重；平地行走时，膝关节承载的负荷可达体重的2至3倍；平地快速行走时，可增加到体重的4.3倍；而上下楼时则分别达到4.4倍和4.9倍；跑步时负重大约是4倍；打球时大约是6倍；蹲和跪时可增高至约8倍。</p><p>膝关节的位置与结构，使它比其他关节承受更大的冲击和压力，是很容易发生运动损伤的关节。</p><h2 id="膝关节弹响的原因"><a href="#膝关节弹响的原因" class="headerlink" title="膝关节弹响的原因"></a>膝关节弹响的原因</h2><h3 id="膝关节温度低，运动时尚发凉发紧，肌肉粘滞性大，血液循环不好。"><a href="#膝关节温度低，运动时尚发凉发紧，肌肉粘滞性大，血液循环不好。" class="headerlink" title="膝关节温度低，运动时尚发凉发紧，肌肉粘滞性大，血液循环不好。"></a>膝关节温度低，运动时尚发凉发紧，肌肉粘滞性大，血液循环不好。</h3><p>解决方法：深蹲前或运动前充分热身，活动开髋关节、膝关节、踝关节，提高组织温度。那么如何热身呢：一般准备活动部分（5-10分钟）：进行慢跑或跳跃目的：提高心率肌肉温度，降低关节肌肉的粘滞性，使血液循环2. 专项活动部分（10-12分钟）：可以进行动态拉伸和专项技能相关训练。比如深蹲前你可以你可以做原地高抬腿100次，充分活动关节。目的：进一步在运动模式下激活肌肉。</p><h3 id="柔韧性不好"><a href="#柔韧性不好" class="headerlink" title="柔韧性不好"></a>柔韧性不好</h3><p>要想让膝关节在负重运动的时候没有摩擦，就要要保持膝关节在负重运动中下的空间。所以呢大腿肌肉就需要有很好的柔韧性。如果柔韧性不好肌肉过紧膝关节肌肉把关节向中间挤压关节软骨。随着咱们的训练，肌肉越来越发达，如果做不好柔韧性练习就会导致肌肉越来越近，关节间隙会越来越小。解决方法：滚泡沫轴。拉伸肌肉。注意大腿前侧，后侧，内侧，外侧肌肉的拉伸，组间和训练前后要及时拉伸，放松肌肉，防止关节过紧。</p><h3 id="强化你的膝盖"><a href="#强化你的膝盖" class="headerlink" title="强化你的膝盖"></a>强化你的膝盖</h3><p>可能有的人会问，既练习肌肉的柔韧性和力量会不会冲突呢，答案是不会的。肌肉本身是既有力量又有弹性和伸展性的。好的健美运动员，在肌肉收缩的时候像铁一样硬，但是松下来之后用手抓能够陷进去。强化你膝关节部的稳定，训练脚的肌肉群，除了股四头(quadriceps)之外，尤其是膕绳肌(hamstrings)及臀肌(glutes)。</p><h3 id="改善髋关节的灵活性"><a href="#改善髋关节的灵活性" class="headerlink" title="改善髋关节的灵活性"></a>改善髋关节的灵活性</h3><p>膝盖的功用是稳定，而髋关节的目的在于灵活性。髋关节缺乏活动性时，膝盖就必须补偿回来，势必会增加膝盖的负担。</p><h3 id="改善脚踝的灵活性"><a href="#改善脚踝的灵活性" class="headerlink" title="改善脚踝的灵活性"></a>改善脚踝的灵活性</h3><p>跟第四点是同样的说明，脚踝缺乏活动性，膝盖就必须补偿回来，势必会增加膝盖的负担。</p><h3 id="活化臀肌"><a href="#活化臀肌" class="headerlink" title="活化臀肌"></a>活化臀肌</h3><p>髋屈肌过紧．髋关节会缺乏活动性，也连带影响了臀肌的运作。臀肌无力会导致脚后跟离开地面、膝关节弯曲。</p><h3 id="下蹲的技术动作"><a href="#下蹲的技术动作" class="headerlink" title="下蹲的技术动作"></a>下蹲的技术动作</h3><p>正确的深蹲动作(Squat Correctly.)脚长及躯干的长度影响你在进行深蹲时，膝盖的位置。根据每个人的状 ，在进行深蹲时，有人的膝盖可能会超过脚趾，而有人不会，所以要注意，应在以下几点：</p><h4 id="比水平高度在低一点"><a href="#比水平高度在低一点" class="headerlink" title="比水平高度在低一点"></a>比水平高度在低一点</h4><p>平行高度的深蹲，对于身体后方的肌肉群(posterior chain)训练较少，会导致身体肌肉的失衡。所以建议是髋关节(hip joint)的高度要低于膝关节。 并且腘绳肌的力量本来就比股四头肌要弱，如果腘绳肌力量低于股四头肌力量的60％就很容易出问题。</p><h4 id="往后坐"><a href="#往后坐" class="headerlink" title="往后坐"></a>往后坐</h4><p>做深蹲的重点是，先是臀是往后坐的，不是脚往前弯。 膝外开．趾外开(Knees out, Toes out.) 训练你的内缩肌群。</p><h4 id="后脚跟请著地"><a href="#后脚跟请著地" class="headerlink" title="后脚跟请著地"></a>后脚跟请著地</h4><p>脚跟著离地在进行深蹲时，膝盖也承受压力。很多举重的动作，都会造成膝盖的受伤，所以先从合适的动作开始训练起，再渐进式的开始增加重量，让肌肉在渐进成长的情况下，去负荷更重的重量。</p><h4 id="重点动作"><a href="#重点动作" class="headerlink" title="重点动作"></a>重点动作</h4><p>1 两脚分开与肩同宽，脚尖稍微外旋，左右脚对准11点5分的方向。</p><p>2 膝盖打开，髋部打开。</p><p>3 在蹲和起的过程中，膝盖对准脚尖，膝盖角度始终保持不变。4 节奏缓慢。</p><h3 id="膝关节有受伤有疼痛时，请停止能引起膝关节4分疼痛以上的动作。膝关节至关重要，大家一定要保护好自己的膝关节。"><a href="#膝关节有受伤有疼痛时，请停止能引起膝关节4分疼痛以上的动作。膝关节至关重要，大家一定要保护好自己的膝关节。" class="headerlink" title="膝关节有受伤有疼痛时，请停止能引起膝关节4分疼痛以上的动作。膝关节至关重要，大家一定要保护好自己的膝关节。"></a>膝关节有受伤有疼痛时，请停止能引起膝关节4分疼痛以上的动作。膝关节至关重要，大家一定要保护好自己的膝关节。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="健身" scheme="http://martist.cn/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>加密如何保障安全</title>
    <link href="http://martist.cn/2018/04/18/%E6%9E%B6%E6%9E%84/%E5%8A%A0%E5%AF%86%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://martist.cn/2018/04/18/架构/加密如何保障安全/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-19T03:12:12.810Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>你还在用md5+salt方式加密密码吗？PHP5.5引入了Password Hashing函数，内核自带无需安装扩展。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>  password_get_info — 返回指定散列（hash）的相关信息<br>  password_hash — 创建密码的散列（hash）<br>  password_needs_rehash — 检测散列值是否匹配指定的选项<br>  password_verify — 验证密码是否和散列值匹配</p><p>提供了这4个函数，具体案例可以看 <a href="http://php.net/manual/zh/function.password-hash.php" target="_blank" rel="external">http://php.net/manual/zh/function.password-hash.php</a></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>代码：</p><pre><code>&lt;?php$pwd = password_hash(&apos;123456abc&apos;,PASSWORD_DEFAULT);$v = password_get_info($pwd);if(password_verify(&apos;123456abc&apos;, $pwd)){  echo &apos;yes&apos;;  echo  PHP_EOL;}var_dump($v);  echo  PHP_EOL;var_dump($pwd);  echo  PHP_EOL;</code></pre><p>在cli模式下运行结果：</p><pre><code>$ php b.phpyesarray(3) {  [&quot;algo&quot;]=&gt;  int(1)  [&quot;algoName&quot;]=&gt;  string(6) &quot;bcrypt&quot;  [&quot;options&quot;]=&gt;  array(1) {    [&quot;cost&quot;]=&gt;    int(10)  }}string(60) &quot;$2y$10$PQcdiu8BHfKS.43/RJ5xUeYDdHQ8/vcDSlM6lubIdCiTwso6T9.7.&quot;</code></pre><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>通过password_hash加密后的密码，使用字典方式很难破解，因为每次生成的密码都是不一样的,破解这种加密只能采用暴力破解。加密方法再好，原始密码设置的过于简单都容易被破解，设置复杂的密码才是王道。</p><h2 id="laravel框架中的使用"><a href="#laravel框架中的使用" class="headerlink" title="laravel框架中的使用"></a>laravel框架中的使用</h2><p>这两篇文章从框架源码讲解了Password Hashing函数的应用。<br><a href="http://laravelacademy.org/post/8327.html" target="_blank" rel="external">http://laravelacademy.org/post/8327.html</a><br><a href="http://laravelacademy.org/post/4764.html" target="_blank" rel="external">http://laravelacademy.org/post/4764.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然通过password_hash()创建的哈希密码更加安全，但是却降低了互操作性。<br>如我们使用md5方式，在php中用标准的MD5加密，很容易通过其他语言来校验，因为md5的加密方式其他语言也可以使用。而使用password_hash()加密的哈希值基本只能通过PHP的password_verify来校验。<br>这2种方法各有优劣，是使用md5(或sha1等)+salt(干扰字符串)的方式还是使用password_hash()大家根据具体情况取舍把。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>phper需要注意的web安全</title>
    <link href="http://martist.cn/2018/04/18/PHP/phper%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84web%E5%AE%89%E5%85%A8/"/>
    <id>http://martist.cn/2018/04/18/PHP/phper需要注意的web安全/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-18T11:27:59.064Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>我一开始想写，思想被局限在后端了，可能是因为我是一名后端开发吧，其实前端也可以做很多事情来防止网络攻击，下面以前后端来分类简单讲讲web安全。</p><h2 id="前端眼里的web安全"><a href="#前端眼里的web安全" class="headerlink" title="前端眼里的web安全"></a>前端眼里的web安全</h2><ul><li>xss</li><li>csrf</li></ul><p>XSS（cross-site scripting跨域脚本攻击）攻击也是最常见的WEB攻击之一，其重点是“跨域”和“客户端执行”。<br>CSRF（cross-site request forgery），翻译为跨站请求伪造，与XSS非常相似，但XSS是利用用户对当前网站的信任来发起攻击，而CSRF是利用网站对用户的信任来发起攻击。<br>推荐阅读：<br><a href="https://www.cnblogs.com/vajoy/p/4176908.html" target="_blank" rel="external">https://www.cnblogs.com/vajoy/p/4176908.html</a><br><a href="https://segmentfault.com/a/1190000006672214" target="_blank" rel="external">https://segmentfault.com/a/1190000006672214</a></p><h2 id="后端眼里的web安全"><a href="#后端眼里的web安全" class="headerlink" title="后端眼里的web安全"></a>后端眼里的web安全</h2><p>SQL注入攻击<br>中间人攻击（会话劫持）<br>文件上传漏洞攻击<br>DoS和DDoS攻击<br>不安全加密<br>后门</p><p>推荐阅读：<br><a href="https://www.cnblogs.com/Miss-mickey/p/6636813.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">https://www.cnblogs.com/Miss-mickey/p/6636813.html?utm_source=tuicool&amp;utm_medium=referral</a><br><a href="https://segmentfault.com/a/1190000007028595" target="_blank" rel="external">https://segmentfault.com/a/1190000007028595</a><br><a href="https://www.cnblogs.com/luyucheng/p/6234524.html" target="_blank" rel="external">https://www.cnblogs.com/luyucheng/p/6234524.html</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前我也在学习阶段，发现一本书很不多，《白帽子讲web安全》，希望大家可以和我一起学习。</p><p>1</p>]]></content>
    
    <summary type="html">
    
      关于网络安全，phper开发时候需要注意到的地方
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>php-fpm概念理解和优化总结</title>
    <link href="http://martist.cn/2018/04/17/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/php-fpm%E4%BC%98%E5%8C%96/"/>
    <id>http://martist.cn/2018/04/17/服务部署/php-fpm优化/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-19T11:06:48.232Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>fpm 是FastCGI Process Manager (FPM)的简拼。php-fpm就是FastCGI的后端实现。并提供了进程管理的功能。</p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>因本文提到的概念比较多，首先提炼下关键词，读者不解之处可以自行百度。</p><ul><li>Apache</li><li>nginx</li><li>反向代理</li><li>cgi</li><li>fastcgi</li><li>php-fpm</li><li>进程</li><li>并发</li><li>kill命令</li></ul><p>Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器，Web Application 一般指PHP、Java、Asp.net等应用程序。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>支持平滑停止/启动的高级进程管理功能；</li><li>可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe_mode 的设置）；</li><li>stdout 和 stderr 日志记录;</li><li>在发生意外情况的时候能够重新启动并缓存被破坏的 opcode;</li><li>文件上传优化支持;</li><li>“慢日志” - 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢;</li><li>fastcgi_finish_request() - 特殊功能：用于在请求完成和刷新数据后，继续在后台执行耗时的工作（录入视频转换、统计处理等）；</li><li>动态／静态子进程产生；</li><li>基本 SAPI 运行状态信息（类似Apache的 mod_status）；</li><li>基于 php.ini 的配置文件。</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="php-fpm-conf"><a href="#php-fpm-conf" class="headerlink" title="php-fpm.conf"></a>php-fpm.conf</h3><p>首先要找到php-fpm.conf配置文件,查看pid的配置路径</p><p>···<br>    machuangdeMacBook-Pro:etc machuang$  ps aux | grep php-fpm<br>    machuang          1619   0.0  0.0  4267768    888 s000  S+   10:17上午   0:00.00 grep php-fpm<br>    _www              1610   0.0  0.0  4327128    856   ??  S    10:17上午   0:00.00 /usr/local/Cellar/php71/7.1.11_22/sbin/php-fpm –daemonize –fpm-config /usr/local/etc/php/7.1/php-fpm.conf –pid /usr/local/var/run/php-fpm.pid<br>    _www              1609   0.0  0.0  4328152    892   ??  S    10:17上午   0:00.00 /usr/local/Cellar/php71/7.1.11_22/sbin/php-fpm –daemonize –fpm-config /usr/local/etc/php/7.1/php-fpm.conf –pid /usr/local/var/run/php-fpm.pid<br>    root              1608   0.0  0.0  4326104   1108   ??  Ss   10:17上午   0:00.00 /usr/local/Cellar/php71/7.1.11_22/sbin/php-fpm –daemonize –fpm-config /usr/local/etc/php/7.1/php-fpm.conf –pid /usr/local/var/run/php-fpm.pid<br>···</p><h3 id="查看php-fpm进程数"><a href="#查看php-fpm进程数" class="headerlink" title="查看php-fpm进程数"></a>查看php-fpm进程数</h3><pre><code>ps aux | grep -c php-fpm</code></pre><p>此处应该减一，因为这条命令也被统计进去了。同时统计进去的还有php-fom的master worker进程。</p><h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><p>见文末。</p><h2 id="nginx和php-fpm的工作机制"><a href="#nginx和php-fpm的工作机制" class="headerlink" title="nginx和php-fpm的工作机制"></a>nginx和php-fpm的工作机制</h2><p>Nginx通过类似反向代理的功能将动态请求转向后端Php-fpm。</p><p>FastCGI 是一个协议，它是应用程序和 WEB 服务器连接的桥梁。Nginx 并不能直接与 PHP-FPM 通信，而是将请求通过 FastCGI 交给 PHP-FPM 处理。<br>下面是nginx的虚拟主机配置内容：</p><pre><code>location ~ \.php$ {    try_files $uri /index.php =404;    fastcgi_pass 127.0.0.1:9000;    fastcgi_index index.php;    fastcgi_buffers 16 16k;    fastcgi_buffer_size 32k;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    include fastcgi_params;}</code></pre><p>这里 fastcgi_pass 就是把所有 php 请求转发给 php-fpm 进行处理。通过 netstat 命令可以看到，127.0.0.1:9000 这个端口上运行的进程就是 php-fpm.</p><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>Nginx 反向代理最重要的指令是 proxy_pass，如：</p><pre><code>location ^~ /seckill_query/ {    proxy_pass http://ris.xxmail.gdrive:8090/;    proxy_set_header Host ris.xxmail.gdrive;}location ^~ /push_message/ {    proxy_pass http://channel.xxmail.gdrive:8090/;    proxy_set_header Host channel.xxmail.gdrive;}location ^~ /data/ {    proxy_pass http://ds.xxmail.gdrive:8087/;    proxy_set_header Host ds.xxmail.gdrive;}</code></pre><p>通过 location 匹配 url 路径，将其转发到另外一个服务器处理。</p><p>通过负载均衡 upstream 也可以实现反向代理。</p><h3 id="Nginx-负载均衡"><a href="#Nginx-负载均衡" class="headerlink" title="Nginx 负载均衡"></a>Nginx 负载均衡</h3><p>介绍一下 upstream 模块：</p><pre><code>负载均衡模块用于从”upstream”指令定义的后端主机列表中选取一台主机。nginx先使用负载均衡模块找到一台主机，再使用upstream模块实现与这台主机的交互。</code></pre><p>负载均衡配置：</p><pre><code>upstream php-upstream {    ip_hash;    server 192.168.0.1;    server 192.168.0.2;}location / {    root   html;    index  index.html index.htm;    proxy_pass http://php-upstream;}</code></pre><p>该例定义了一个 php-upstream 的负载均衡配置，通过 proxy_pass 反向代理指令应用这个配置。这里用的 ip_hash 算法，负载均衡的算法有多种，就不一一列举了。</p><p>负载均衡也可以用在 fastcgi_pass 上。</p><p>如：</p><pre><code>fastcgi_pass http://php-upstream</code></pre><p>如果使用负载均衡，可能存在一个 session 失效的问题，你的每次请求可能分配到不同的服务器，一个解决方法是把 Memcached 或 Redis 作为 session 存储的方式，而且还可以提高性能。</p><p>反向代理和负载均衡这两个词经常出现在一起，但他们实际上是不同的概念，负载均衡它更多的是强调的是一种算法或策略，将请求分布到不同的机器上，因此实际上也起到了反向代理的作用。<br>可以说是使用反向代理和算法实现了负载均衡。</p><h3 id="proxy-pass-和-fastcgi-pass-的区别"><a href="#proxy-pass-和-fastcgi-pass-的区别" class="headerlink" title="proxy_pass 和 fastcgi_pass 的区别"></a>proxy_pass 和 fastcgi_pass 的区别</h3><p>一个是反向代理模块，一个是转发给 factcgi 后端处理。</p><pre><code>fastcgi_pass客户端----[HTTP]----webserver(nginx)----[fastcgi]----fastcgi服务(php-fpm)proxy_pass客户端----[HTTP]----webserver(nginx)----[HTTP]----webserver(nginx)</code></pre><h3 id="webserver配置和运行"><a href="#webserver配置和运行" class="headerlink" title="webserver配置和运行"></a>webserver配置和运行</h3><p>1、配置nginx.conf文件</p><p>进入nginx目录下，编辑 nginx.conf文件。<br>如图，在nginx.conf最后一行，</p><ul><li><p>添加include文件（引入虚拟主机的配置目录）</p><p>  include /usr/local/etc/nginx/erver/*</p></li><li><p>添加对应的server（进入上面include的路径，添加一个server）</p></li></ul><p>比如新建一个文件,路径为 /usr/local/etc/nginx/erver/www.example.com.conf，内容如下：</p><pre><code>server {    listen       80; #监听80端口，接收http请求    server_name  www.example.com; #就是网站地址    root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径    #路由到网站根目录www.example.com时候的处理    location / {        index index.php; #跳转到www.example.com/index.php        autoindex on;    }       #当请求网站下php文件的时候，反向代理到php-fpm    location ~ \.php$ {        include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块        fastcgi_intercept_errors on;        fastcgi_pass   127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口    }}</code></pre><p>总而言之：当我们访问www.example.com的时候，处理流程是这样的：</p><pre><code>www.example.com      |      |    Nginx      |      |路由到www.example.com/index.php      |      |加载nginx的fast-cgi模块      |      |fast-cgi监听127.0.0.1:9000地址      |      |www.example.com/index.php请求到达127.0.0.1:9000      |      |   等待处理...</code></pre><p>下面我们启用php的php-fpm来处理这个请求，打开php-fpm.conf文件，我们看到如下配置：</p><pre><code>listen 127.0.0.1:9000</code></pre><p>即:php-fpm模块监听127.0.0.1:9000端口，等待请求到来去处理。</p><h3 id="nginx与php-fpm的结合后的完整流程"><a href="#nginx与php-fpm的结合后的完整流程" class="headerlink" title="nginx与php-fpm的结合后的完整流程"></a>nginx与php-fpm的结合后的完整流程</h3><pre><code>www.example.com       |       |     Nginx       |       |路由到www.example.com/index.php       |       |加载nginx的fast-cgi模块       |       |fast-cgi监听127.0.0.1:9000地址       |       |www.example.com/index.php请求到达127.0.0.1:9000       |       |php-fpm 监听127.0.0.1:9000       |       |php-fpm 接收到请求，启用worker进程处理请求       |       |php-fpm 处理完请求，返回给nginx       |       |nginx将结果通过http返回给浏览器</code></pre><p>下面继续相信研究php-fpm是具体怎么工作的。</p><h2 id="Nginx和fastcgi的通信机制"><a href="#Nginx和fastcgi的通信机制" class="headerlink" title="Nginx和fastcgi的通信机制"></a>Nginx和fastcgi的通信机制</h2><p>我们来看一段Nginx中fastcgi_pass的配置：</p><p>   location ~ .php$ {<br>        root           /home/wwwroot;<br>        fastcgi_pass   127.0.0.1:9000;</p><pre><code>    #fastcgi_pass  unix:/var/run/php-fpm/php-fpm.sock;    #fastcgi_pass  unix:/tmp/php-cgi.sock;    try_files $uri /index.php =404;    fastcgi_split_path_info ^(.+\.php)(/.+)$;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><h3 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h3><p>Nginx和PHP-FPM的进程间通信有两种方式,一种是TCP,一种是UNIX Domain Socket.</p><p>其中TCP是IP加端口,可以跨服务器.而UNIX Domain Socket不经过网络,只能用于Nginx跟PHP-FPM都在同一服务器的场景.用哪种取决于你的PHP-FPM配置:</p><pre><code>方式1:php-fpm.conf: listen = 127.0.0.1:9000nginx.conf: fastcgi_pass 127.0.0.1:9000;方式2:php-fpm.conf: listen = /tmp/php-fpm.socknginx.conf: fastcgi_pass unix:/tmp/php-fpm.sock;</code></pre><p>其中php-fpm.sock是一个文件,由php-fpm生成,类型是srw-rw—-.</p><h3 id="UNIX-Domain-Socket和tcp链接的区别"><a href="#UNIX-Domain-Socket和tcp链接的区别" class="headerlink" title="UNIX Domain Socket和tcp链接的区别"></a>UNIX Domain Socket和tcp链接的区别</h3><p>UNIX Domain Socket可用于两个没有亲缘关系的进程,是目前广泛使用的IPC机制,比如X Window服务器和GUI程序之间就是通过UNIX Domain Socket通讯的.这种通信方式是发生在系统内核里而不会在网络里传播.UNIX Domain Socket和长连接都能避免频繁创建TCP短连接而导致TIME_WAIT连接过多的问题.对于进程间通讯的两个程序,UNIX Domain Socket的流程不会走到TCP那层,直接以文件形式,以stream socket通讯.如果是TCP Socket,则需要走到IP层,对于非同一台服务器上,TCP Socket走的就更多了.</p><pre><code>UNIX Domain Socket:Nginx &lt;=&gt; socket &lt;=&gt; PHP-FPMTCP Socket(本地回环):Nginx &lt;=&gt; socket &lt;=&gt; TCP/IP &lt;=&gt; socket &lt;=&gt; PHP-FPMTCP Socket(Nginx和PHP-FPM位于不同服务器):Nginx &lt;=&gt; socket &lt;=&gt; TCP/IP &lt;=&gt; 物理层 &lt;=&gt; 路由器 &lt;=&gt; 物理层 &lt;=&gt; TCP/IP &lt;=&gt; socket &lt;=&gt; PHP-FPM</code></pre><p>像mysql命令行客户端连接mysqld服务也类似有这两种方式:</p><p>使用Unix Socket连接(默认):</p><pre><code>mysql -uroot -p --protocol=socket --socket=/tmp/mysql.sock</code></pre><p>使用TCP连接:</p><pre><code>mysql -uroot -p --protocol=tcp --host=127.0.0.1 --port=3306</code></pre><h2 id="php-fpm的运行机制"><a href="#php-fpm的运行机制" class="headerlink" title="php-fpm的运行机制"></a>php-fpm的运行机制</h2><h3 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h3><p>php-fpm是一种master（主）/worker（子）多进程架构。<br>master进程主要负责CGI及PHP环境初始化、事件监听、子进程状态等等，worker进程负责处理php请求。<br>在介绍运行原理之前，我们先了解下它的几种运行模式。</p><h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h3><p>php-fpm支持三种运行模式，分别为static、ondemand、dynamic，默认为dynamic 。</p><pre><code>static : 静态模式，启动时分配固定的worker进程。ondemand: 按需分配，当收到用户请求时fork worker进程。dynamic: 动态模式，启动时分配固定的进程。伴随着请求数增加，在设定的浮动范围调整worker进程。</code></pre><p>这三种模式各有千秋，大家可以根据不同的环境调整相应的配置。</p><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>php-fpm采用master/worker架构设计，前面简单地描述master和worker进程模块的功能。下面将详细讲解这两个模块的运行原理。<br>master进程</p><p>master进程工作流程分为4个阶段，</p><pre><code>初始化cgi-----&gt; 初始化php环境  -----&gt; 初始化php-fpm -----&gt; 运行php-fpm</code></pre><ol><li>cgi初始化阶段：分别调用fcgi_init()和 sapi_startup()函数，注册进程信号以及初始化sapi_globals全局变量。</li><li>php环境初始化阶段：由cgi_sapi_module.startup 触发。实际调用php_cgi_startup函数，而php_cgi_startup内部又调用php_module_startup执行。 php_module_startup主要功能：a).加载和解析php配置；b).加载php模块并记入函数符号表(function_table)；c).加载zend扩展 ; d).设置禁用函数和类库配置；e).注册回收内存方法；</li><li>php-fpm初始化阶段：执行fpm_init()函数。负责解析php-fpm.conf文件配置，获取进程相关参数（允许进程打开的最大文件数等）,初始化进程池及事件模型等操作。</li><li>php-fpm运行阶段：执行fpm_run() 函数，运行后主进程发生阻塞。该阶段分为两部分：fork子进程 和 循环事件。fork子进程部分交由fpm_children_create_initial函数处理（ 注：ondemand模式在fpm_pctl_on_socket_accept函数创建）。循环事件部分通过fpm_event_loop函数处理，其内部是一个死循环，负责事件的收集工作。</li></ol><h3 id="worker进程"><a href="#worker进程" class="headerlink" title="worker进程"></a>worker进程</h3><p>worker进程分为 接收客户端请求、处理请求、请求结束三个阶段。</p><ol><li><p>接收客户端请求：执行fcgi_accept_request函数，其内部通过调用accept 函数获取客户端请求。</p><p> //请求锁<br> FCGI_LOCK(req-&gt;listen_socket);<br> req-&gt;fd = accept(listen_socket, (struct sockaddr *)&amp;sa, &amp;len);<br> //释放锁<br> FCGI_UNLOCK(req-&gt;listen_socket);</p></li></ol><p>从上面的代码，可以注意到accept之前有一个请求锁的操作，这么设计是为了避免请求出现“惊群”的现象。当然，这是一个可选的选项，可以取消该功能。</p><ol><li><p>处理请求阶段：首先，分别调用fpm_request_info、php_request_startup获取请求内容及注册全局变量($_GET、$_POST、$_SERVER、$_ENV、$_FILES)；然后根据请求信息调用php_fopen_primary_script访问脚本文件；最后交给php_execute_script执行。php_execute_script内部调用zend_execute_scripts方法将脚本交给zend引擎处理。</p></li><li><p>请求结束阶段：执行php_request_shutdown函数。此时 回调register_shutdown_function注册的函数及__destruct()方法，发送响应内容、释放内存等操作。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>php-fpm采用master/worker架构设计， master进程负责CGI、PHP公共环境的初始化及事件监听操作。worker进程负责请求的处理功能。在worker进程处理请求时，无需再次初始化PHP运行环境，这也是php-fpm性能优异的原因之一。</p><h2 id="CGI、FastCGI、php-fpm的关系"><a href="#CGI、FastCGI、php-fpm的关系" class="headerlink" title="CGI、FastCGI、php-fpm的关系"></a>CGI、FastCGI、php-fpm的关系</h2><h3 id="CGI（Common-Gateway-Interface）"><a href="#CGI（Common-Gateway-Interface）" class="headerlink" title="CGI（Common Gateway Interface）"></a>CGI（Common Gateway Interface）</h3><p>最初，CGI 是在 1993 年由美国国家超级电脑应用中心（NCSA）为 NCSA HTTPd Web 服务器开发的。</p><p>这个 Web 服务器使用了 UNIX shell 环境变量 来保存从 Web 服务器传递出去的参数，然后生成一个运行 CGI 的独立进程。CGI的第一个实现是 Perl 写的 1。</p><ul><li>效率低下：每一个连接 fork 一个进程处理。</li><li>功能十分有限：CGI只能收到一个请求，输出一个响应。很难在CGI体系去对Web请求的控制，例如：用户认证等。</li></ul><p>正因为这些问题，在CGI诞生后的很长一段时间，各种Web Server都还是采用API这种强绑定的方式去支持Web开发，其中Apache的mod_php就属于这种方式。所以后面就有大神提出了FastCGI标准。</p><h3 id="FastCGI（Fast-Common-Gateway-Interface）"><a href="#FastCGI（Fast-Common-Gateway-Interface）" class="headerlink" title="FastCGI（Fast Common Gateway Interface）"></a>FastCGI（Fast Common Gateway Interface）</h3><p>FastCGI使用进程/线程池来处理一连串的请求。这些进程/线程由FastCGI服务器管理，而不是Web服务器。 当进来一个请求时，Web服务器把环境变量和这个页面请求通过一个Socket长连接传递给FastCGI进程。所以FastCGI有如下的优点：</p><p>性能：通过进程/线程池规避了CGI开辟新的进程的开销。<br>兼容：非常容易改造现有CGI标准的程序。<br>语言无关：FastCGI是一套标准，理论上讲只要能进行标准输出（stdout）的语言都可以作为FastCGI标准的Web后端。<br>下面是一个简单FastCGI后端的伪代码</p><pre><code>void main(void){int count = 0;  while(FCGI_Accept() &gt;= 0) {    printf(“Content-type: text/html\r\n”);    printf(“\r\n”);    printf(“Hello world!\r\n”);    printf(“Request number %d.”, count++);  }exit(0);}</code></pre><ul><li>Web Server隔离：FastCGI后端和Web Server运行在不同的进程中，后端的任何故障不会导致Web Server挂掉。</li><li>专利：没有Apache mod_php之类的私有API的知识产权问题。</li><li>扩展：FastCGI后端和Web Server通过Socket进行通信，两者可以分布式部署并方便进行横向扩展。</li></ul><p>所以FastCGI一推出就几乎获得了所有主流Web Server的支持，Apache、Lighttpd、IIS、Cherokee……</p><p>But，事情总是还有改进的余地的，FastCGI这套工作模式实际上没有什么太大缺陷，但是有些不安分的Python程序猿觉得，FastCGI标准下写异步的Web服务还是不太方便，如果能够收到请求后CGI端去处理，处理完毕后通过Callback回调来返回结果，那样岂不是很Cool？！所以WSGI就被创造出来了：</p><h3 id="WSGI（Web-Server-Gateway-Interface）"><a href="#WSGI（Web-Server-Gateway-Interface）" class="headerlink" title="WSGI（Web Server Gateway Interface）"></a>WSGI（Web Server Gateway Interface）</h3><p>Web服务器网关接口（Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。</p><p>当Web Server收到一个请求后，可以通过Socket把环境变量和一个Callback回调函数传给后端Web应用，Web应用在完成页面组装后通过Callback把内容返回给Web Server。这样做的优点有很多：</p><ul><li>异步化，通过Callback将Web请求的工作拆解开，可以很方便的在一个线程空间里同时处理多个Web请求。</li><li>方便进行各种负载均衡和请求转发，不会造成后端Web应用阻塞。</li></ul><p>Web开发有3P：Perl、Python、PHP。<br>Perl是1987年发布的，Python是1989年，PHP是1995年。CGI标准提出的时候正是Perl如日中天的时候，所以CGI的提出当时也是主要为了解决Perl作为Web编程语言的需求。熟悉正则（regex）的程序员可能知道正则的事实标准叫做pcre（Perl兼容正则表达式，Perl Compatible Regular Expressions），这也从一个侧面体现了Perl作为一个古老的语言在当时对各种业界标准的影响。</p><h3 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a>简而言之</h3><ul><li>CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。</li><li>FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。同样，SCGI 协议与 FastCGI 类似。</li><li>PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。</li><li>PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。</li></ul><h2 id="进程数和并发数的关系"><a href="#进程数和并发数的关系" class="headerlink" title="进程数和并发数的关系"></a>进程数和并发数的关系</h2><p>PHP-FPM 采用 master/worker 多进程架构。<br>即：众多的 worker 进程组成了进程池，等待 master 进程分配任务，而且每个 worker 进程只能同时处理单个任务，前一个处理结束，才能为下一个服务。<br>PHP-FPM 是 1:1 模型。单机情况下，如果 PHP-FPM 配置的最大子进程数为 20，那么就最多可以并发处理 20 个请求。之后的请求会进行排队，这个排队由fpm主进程完成，nginx采用的是异步IO模型，不会产生阻塞。</p><h2 id="php-fpm-进程管理"><a href="#php-fpm-进程管理" class="headerlink" title="php-fpm 进程管理"></a>php-fpm 进程管理</h2><p>进程包含 master 进程和 worker 进程两种进程。<br>master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。</p><h2 id="php-fpm和进程数量的关系"><a href="#php-fpm和进程数量的关系" class="headerlink" title="php-fpm和进程数量的关系"></a>php-fpm和进程数量的关系</h2><h3 id="php-fpm的两种进程管理模式"><a href="#php-fpm的两种进程管理模式" class="headerlink" title="php-fpm的两种进程管理模式"></a>php-fpm的两种进程管理模式</h3><p>php-fpm的进程数也是可以根据设置分为动态和静态的。<br>一种是直接开启指定数量的php-fpm进程，不再增加或者减少；<br>另一种则是开始的时候开启一定数量的php-fpm进程，当请求量变大的时候，动态的增加php-fpm进程数到上限，当空闲的时候自动释放空闲的进程数到一个下限。</p><p>这两种不同的执行方式，可以根据服务器的实际需求来进行调整。 这里先说一下涉及到这个的几个参数吧，他们分别是</p><pre><code>pmpm.max_childrenpm.start_serverspm.min_spare_serverspm.max_spare_servers</code></pre><p>pm表示使用那种方式，有两个值可以选择，就是static（静态）或者dynamic（动态）。 在更老一些的版本中，dynamic被称作apache-like。这个要注意看配置文件给出的说明了。PHP5.3 php-fpm的默认静态处理方式会使得php-cgi的进程长期占用内存而无法释放，这也是导致nginx出错的原因之 一，因此可以将php-fpm的处理方式改成apache模式。</p><p>下面4个参数的意思分别为：</p><pre><code>pm.max_children：静态方式下开启的php-fpm进程数量。 pm.start_servers：动态方式下的起始php-fpm进程数量。 pm.min_spare_servers：动态方式下的最小php-fpm进程数量。 pm.max_spare_servers：动态方式下的最大php-fpm进程数量。</code></pre><p>如果dm设置为static，那么其实只有pm.max_children这个参数生效。系统会开启设置的数量个php-fpm进程。<br> 如果dm设置为dynamic，那么pm.max_children参数失效，后面3个参数生效。</p><p> 系统会在php-fpm运行开始的时候启动 pm.start_servers个php-fpm进程，然后根据系统的需求动态在pm.min_spare_servers和 pm.max_spare_servers之间调整php-fpm进程数。</p><h3 id="那么，对于我们的服务器，选择哪种执行方式比较好呢？"><a href="#那么，对于我们的服务器，选择哪种执行方式比较好呢？" class="headerlink" title="那么，对于我们的服务器，选择哪种执行方式比较好呢？"></a>那么，对于我们的服务器，选择哪种执行方式比较好呢？</h3><p> 事实上，跟Apache一样，我们运行的PHP程序在执行完成后，或多或少会有内存泄露的问题。 这也是为什么开始的时候一个php-fpm进程只占用3M左右内存，运行一段时间后就会上升到20-30M的原因了。所以，动态方式因为会结束掉多余的进程，可以回收释放一些内存，所以推荐在内存较少的服务器或者VPS上使用。具体最大数量根据 内存/20M 得到。比如说512M的VPS，议pm.max_spare_servers设置为20。至于pm.min_spare_servers，则建议根据服务器的负载情况来设置，比较合适的值在5~10之间。 然后对于比较大内存的服务器来说，设置为静态的话会提高效率。因为频繁开关php-fpm进程也会有时滞，所以内存够大的情况下开静态效果会更好。数量也可以根据内存/30M 得到。比如说2GB内存的服务器，可以设置为50；4GB内存可以设置为100等。</p><h2 id="php-fpm操作"><a href="#php-fpm操作" class="headerlink" title="php-fpm操作"></a>php-fpm操作</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>/usr/local/php/sbin/php-fpm</code></pre><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>master进程可以理解以下信号</p><pre><code>INT, TERM 立刻终止QUIT 平滑终止USR1 重新打开日志文件USR2 平滑重载所有worker进程并重新载入配置和二进制模块</code></pre><p>关闭命令</p><pre><code>kill -QUIT 42891</code></pre><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>先查看php-fpm的master进程号</p><pre><code># ps aux|grep php-fpmroot     21891  0.0  0.0 112660   960 pts/3    R+   16:18   0:00 grep --color=auto php-fpmroot     42891  0.0  0.1 182796  1220 ?        Ss   4月18   0:19 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)nobody   42892  0.0  0.6 183000  6516 ?        S    4月18   0:07 php-fpm: pool wwwnobody   42893  0.0  0.6 183000  6508 ?        S    4月18   0:17 php-fpm: pool www</code></pre><p>重启命令</p><pre><code>kill -USR2 42891</code></pre><p>上面方案一般是没有生成php-fpm.pid文件时使用，如果要生成php-fpm.pid，使用下面这种方案：</p><p>上面master进程可以看到，matster使用的是/usr/local/php/etc/php-fpm.conf这个配置文件，cat /usr/local/php/etc/php-fpm.conf 发现：</p><pre><code>[global]; Pid file; Note: the default prefix is /usr/local/php/var; Default Value: none;pid = run/php-fpm.pid</code></pre><p>pid文件路径应该位于/usr/local/php/var/run/php-fpm.pid，由于注释掉，所以没有生成，我们把注释去除，再kill -USR2 42891 重启php-fpm,便会生成pid文件，下次就可以使用以下命令重启,关闭php-fpm了：</p><pre><code>php-fpm 关闭：kill -INT &apos;cat /usr/local/php/var/run/php-fpm.pid&apos;php-fpm 重启：kill -USR2 &apos;cat /usr/local/php/var/run/php-fpm.pid&apos;</code></pre><h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2><h3 id="避免程序跑死（hang）"><a href="#避免程序跑死（hang）" class="headerlink" title="避免程序跑死（hang）"></a>避免程序跑死（hang）</h3><p>在负载较高的服务器上定时重载php-fpm，reload可以平滑重启而不影响生产系统的php脚本运行，每15分钟reload一次，定时任务如下：</p><pre><code>0-59/15 * * * * /usr/local/php/sbin/php-fpm reload</code></pre><h3 id="增加最大处理请求数"><a href="#增加最大处理请求数" class="headerlink" title="增加最大处理请求数"></a>增加最大处理请求数</h3><p>最大处理请求数是指一个php-fpm的worker进程在处理多少个请求后就终止掉，master进程会重新respawn新的。该配置可以避免php解释器自身或程序引起的memory leaks。默认值是500，可以修改为如下配置：</p><pre><code>pm.max_requests = 1024</code></pre><p>这段配置的意思是，当一个 PHP-CGI 进程处理的请求数累积到 500 个后，自动重启该进程。<br>但是为什么要重启进程呢？</p><p>一般在项目中，我们多多少少都会用到一些 PHP 的第三方库，这些第三方库经常存在内存泄漏问题，如果不定期重启 PHP-CGI 进程，势必造成内存使用量不断增长。因此 PHP-FPM 作为 PHP-CGI 的管理器，提供了这么一项监控功能，对请求达到指定次数的 PHP-CGI 进程进行重启，保证内存使用量不增长。</p><p>正是因为这个机制，在高并发的站点中，经常导致 502 错误，我猜测原因是 PHP-FPM 对从 NGINX 过来的请求队列没处理好。不过我目前用的还是 PHP 5.3.2，不知道在 PHP 5.3.3 中是否还存在这个问题。</p><p>目前我们的解决方法是，把这个值尽量设置大些，尽可能减少 PHP-CGI 重新 SPAWN 的次数，同时也能提高总体性能。在我们自己实际的生产环境中发现，内存泄漏并不明显，因此我们将这个值设置得非常大（204800）。大家要根据自己的实际情况设置这个值，不能盲目地加大。</p><h3 id="优化动态fpm进程数"><a href="#优化动态fpm进程数" class="headerlink" title="优化动态fpm进程数"></a>优化动态fpm进程数</h3><pre><code>pm.max_children = 100pm.start_servers = 30pm.min_spare_servers = 20pm.max_spare_servers = 100pm.max_requests = 500</code></pre><p>对于我们的服务器，选择哪种执行方式比较好呢？事实上，跟Apache一样，运行的PHP程序在执行完成后，或多或少会有内存泄露的问题。<br>这也是为什么开始的时候一个php-fpm进程只占用3M左右内存，运行一段时间后就会上升到20-30M的原因了。<br>对于内存大的服务器（比如8G以上）来说，指定静态的max_children实际上更为妥当，因为这样不需要进行额外的进程数目控制，会提高效率。<br>因为频繁开关php-fpm进程也会有时滞，所以内存够大的情况下开静态效果会更好。数量也可以根据 内存/30M 得到，比如8GB内存可以设置为100，<br>那么php-fpm耗费的内存就能控制在 2G-3G的样子。如果内存稍微小点，比如1G，那么指定静态的进程数量更加有利于服务器的稳定。<br>这样可以保证php-fpm只获取够用的内存，将不多的内存分配给其他应用去使用，会使系统的运行更加畅通。<br>对于小内存的服务器来说，比如256M内存的VPS，即使按照一个20M的内存量来算，10个php-cgi进程就将耗掉200M内存，那系统的崩溃就应该很正常了。<br>因此应该尽量地控制php-fpm进程的数量，大体明确其他应用占用的内存后，给它指定一个静态的小数量，会让系统更加平稳一些。或者使用动态方式，<br>因为动态方式会结束掉多余的进程，可以回收释放一些内存，所以推荐在内存较少的服务器或VPS上使用。具体最大数量根据 内存/20M 得到。<br>比如说512M的VPS，建议pm.max_spare_servers设置为20。至于pm.min_spare_servers，则建议根据服务器的负载情况来设置，比如服务器上只是部署php环境的话，比较合适的值在5~10之间。</p><h2 id="php-fpm-config的参数配置"><a href="#php-fpm-config的参数配置" class="headerlink" title="php-fpm.config的参数配置"></a>php-fpm.config的参数配置</h2><p>FPM 使用类似 php.ini 语法的 php-fpm.conf 和进程池配置文件。<br>php-fpm.conf 全局配置段</p><h4 id="pid-string"><a href="#pid-string" class="headerlink" title="pid string"></a>pid string</h4><p>   PID 文件的位置。默认为空。</p><h4 id="error-log-string"><a href="#error-log-string" class="headerlink" title="error_log string"></a>error_log string</h4><p>   错误日志的位置。默认：#INSTALL_PREFIX#/log/php-fpm.log。 如果设置为 “syslog”，日志将不会写入本地文件，而是发送到 syslogd。</p><h4 id="log-level-string"><a href="#log-level-string" class="headerlink" title="log_level string"></a>log_level string</h4><p>   错误级别。可用级别为：alert（必须立即处理），error（错误情况），warning（警告情况），notice（一般重要信息），debug（调试信息）。默认：notice。</p><h4 id="syslog-facility-string"><a href="#syslog-facility-string" class="headerlink" title="syslog.facility string"></a>syslog.facility string</h4><p>   设置何种程序记录消息，默认值：daemon。</p><h4 id="syslog-ident-string"><a href="#syslog-ident-string" class="headerlink" title="syslog.ident string"></a>syslog.ident string</h4><p>   为每条信息添加前缀。 如果在同一台服务器上运行了多个 FPM 实例，可以修改此默认值来满足需求。默认值：php-fpm。</p><h4 id="emergency-restart-threshold-int"><a href="#emergency-restart-threshold-int" class="headerlink" title="emergency_restart_threshold int"></a>emergency_restart_threshold int</h4><p>   如果子进程在 emergency_restart_interval 设定的时间内收到该参数设定次数的 SIGSEGV 或者 SIGBUS退出信息号，则FPM会重新启动。0 表示“关闭该功能”。默认值：0（关闭）。</p><h4 id="emergency-restart-interval-mixed"><a href="#emergency-restart-interval-mixed" class="headerlink" title="emergency_restart_interval mixed"></a>emergency_restart_interval mixed</h4><p>   emergency_restart_interval 用于设定平滑重启的间隔时间。这么做有助于解决加速器中共享内存的使用问题。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。</p><h4 id="process-control-timeout-mixed"><a href="#process-control-timeout-mixed" class="headerlink" title="process_control_timeout mixed"></a>process_control_timeout mixed</h4><p>   设置子进程接受主进程复用信号的超时时间。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。</p><h4 id="process-max-int"><a href="#process-max-int" class="headerlink" title="process.max int"></a>process.max int</h4><p>   Fork 的最大 FPM 进程数。使用动态管理进程数时，此设计可以控制在一个进程池内的全局进程数量。 使用需谨慎。默认值：0。</p><h4 id="process-priority-int"><a href="#process-priority-int" class="headerlink" title="process.priority int"></a>process.priority int</h4><p>   设置 master 进程的 nice(2) 优先级（如果设置了此值）。 可以是 -19（最高优先级）到 20 （更低优先级）。 默认值：不设置。</p><h4 id="daemonize-boolean"><a href="#daemonize-boolean" class="headerlink" title="daemonize boolean"></a>daemonize boolean</h4><p>   设置 FPM 在后台运行。设置“no”将 FPM 保持在前台运行用于调试。默认值：yes。</p><h4 id="rlimit-files-int"><a href="#rlimit-files-int" class="headerlink" title="rlimit_files int"></a>rlimit_files int</h4><p>   设置 master 进程的打开文件描述符 rlimit 数。</p><h4 id="rlimit-core-int"><a href="#rlimit-core-int" class="headerlink" title="rlimit_core int"></a>rlimit_core int</h4><p>   设置 master 进程最大 core 的 rlimit 尺寸。 默认值：0。</p><h4 id="events-mechanism-string"><a href="#events-mechanism-string" class="headerlink" title="events.mechanism string"></a>events.mechanism string</h4><p>   设置 FPM 使用的事件机制。 可用以下选项：select、pool、epoll、kqueue (*BSD)、port (Solaris)。 默认值：不设置（自动检测）</p><h4 id="systemd-interval-int"><a href="#systemd-interval-int" class="headerlink" title="systemd_interval int"></a>systemd_interval int</h4><p>   使用 systemd 集成的 FPM 时，设置间歇秒数，报告健在通知给 systemd。 设置为 0 表示禁用。默认值：10。</p><h3 id="运行配置区段"><a href="#运行配置区段" class="headerlink" title="运行配置区段"></a>运行配置区段</h3><p>在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。</p><h4 id="listen-string"><a href="#listen-string" class="headerlink" title="listen string"></a>listen string</h4><p>   设置接受 FastCGI 请求的地址。可用格式为：’ip:port’，’port’，’/path/to/unix/socket’。每个进程池都需要设置。</p><h4 id="listen-backlog-int"><a href="#listen-backlog-int" class="headerlink" title="listen.backlog int"></a>listen.backlog int</h4><p>   设置 listen(2) 的 backlog 最大值。“-1”表示无限制。默认值：-1。</p><h4 id="listen-allowed-clients-string"><a href="#listen-allowed-clients-string" class="headerlink" title="listen.allowed_clients string"></a>listen.allowed_clients string</h4><p>   设置允许连接到 FastCGI 的服务器 IPV4 地址。等同于 PHP FastCGI (5.2.2+) 中的 FCGI_WEB_SERVER_ADDRS 环境变量。仅对 TCP 监听起作用。每个地址是用逗号分隔，如果没有设置或者为空，则允许任何服务器请求连接。默认值：any。 PHP 5.5.20 和 5.6.4起，开始支持 IPv6 地址。</p><h4 id="listen-owner-string"><a href="#listen-owner-string" class="headerlink" title="listen.owner string"></a>listen.owner string</h4><p>   如果使用了 Unix 套接字，表示它的权限。在 Linux 中必须设置读/写权限，以便用于 WEB 服务器连接。 在很多 BSD 派生的系统中可以忽略权限允许自由连接。 默认值：运行所使用的用户和组，权限为 0660。</p><h4 id="listen-group-string"><a href="#listen-group-string" class="headerlink" title="listen.group string"></a>listen.group string</h4><p>   参见 listen.owner。</p><h4 id="listen-mode-string"><a href="#listen-mode-string" class="headerlink" title="listen.mode string"></a>listen.mode string</h4><p>   参见 listen.owner。</p><h4 id="listen-acl-users-string"><a href="#listen-acl-users-string" class="headerlink" title="listen.acl_users string"></a>listen.acl_users string</h4><p>   当系统支持 POSIX ACL（Access Control Lists）时，可以设置使用此选项。 当设置了的时候，将会忽略 listen.owner 和 listen.group。 值是逗号分割的用户名列表。 PHP 5.6.5 起可用。</p><h4 id="listen-acl-groups-string"><a href="#listen-acl-groups-string" class="headerlink" title="listen.acl_groups string"></a>listen.acl_groups string</h4><p>   参见 listen.acl_users。 值是逗号分割的用户组名称列表。 PHP 5.6.5 起可用。</p><h4 id="user-string"><a href="#user-string" class="headerlink" title="user string"></a>user string</h4><p>   FPM 进程运行的Unix用户。必须设置。</p><h4 id="group-string"><a href="#group-string" class="headerlink" title="group string"></a>group string</h4><p>   FPM 进程运行的 Unix 用户组。如果不设置，就使用默认用户的用户组。</p><h4 id="pm-string"><a href="#pm-string" class="headerlink" title="pm string"></a>pm string</h4><p>   设置进程管理器如何管理子进程。可用值：static，ondemand，dynamic。必须设置。</p><p>   static - 子进程的数量是固定的（pm.max_children）。</p><p>   ondemand - 进程在有需求时才产生（当请求时才启动。与 dynamic 相反，在服务启动时 pm.start_servers 就启动了。</p><p>   dynamic - 子进程的数量在下面配置的基础上动态设置：pm.max_children，pm.start_servers，pm.min_spare_servers，pm.max_spare_servers。</p><h4 id="pm-max-children-int"><a href="#pm-max-children-int" class="headerlink" title="pm.max_children int"></a>pm.max_children int</h4><p>   pm 设置为 static 时表示创建的子进程的数量，pm 设置为 dynamic 时表示最大可创建的子进程的数量。必须设置。</p><p>   该选项设置可以同时提供服务的请求数限制。类似 Apache 的 mpm_prefork 中 MaxClients 的设置和 普通PHP FastCGI中的 PHP_FCGI_CHILDREN 环境变量。</p><h4 id="pm-start-servers-in"><a href="#pm-start-servers-in" class="headerlink" title="pm.start_servers in"></a>pm.start_servers in</h4><p>   设置启动时创建的子进程数目。仅在 pm 设置为 dynamic 时使用。默认值：min_spare_servers + (max_spare_servers - min_spare_servers) / 2。</p><h4 id="pm-min-spare-servers-int"><a href="#pm-min-spare-servers-int" class="headerlink" title="pm.min_spare_servers int"></a>pm.min_spare_servers int</h4><p>   设置空闲服务进程的最低数目。仅在 pm 设置为 dynamic 时使用。必须设置。</p><h4 id="pm-max-spare-servers-int"><a href="#pm-max-spare-servers-int" class="headerlink" title="pm.max_spare_servers int"></a>pm.max_spare_servers int</h4><p>   设置空闲服务进程的最大数目。仅在 pm 设置为 dynamic 时使用。必须设置。</p><h4 id="pm-process-idle-timeout-mixed"><a href="#pm-process-idle-timeout-mixed" class="headerlink" title="pm.process_idle_timeout mixed"></a>pm.process_idle_timeout mixed</h4><p>   秒数，多久之后结束空闲进程。 仅当设置 pm 为 ondemand。 可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：10s。</p><h4 id="pm-max-requests-int"><a href="#pm-max-requests-int" class="headerlink" title="pm.max_requests int"></a>pm.max_requests int</h4><p>   设置每个子进程重生之前服务的请求数。对于可能存在内存泄漏的第三方模块来说是非常有用的。如果设置为 ‘0’ 则一直接受请求，等同于 PHP_FCGI_MAX_REQUESTS 环境变量。默认值：0。</p><h4 id="pm-status-path-string"><a href="#pm-status-path-string" class="headerlink" title="pm.status_path string"></a>pm.status_path string</h4><p>   FPM 状态页面的网址。如果没有设置，则无法访问状态页面，默认值：无。</p><h4 id="ping-path-string"><a href="#ping-path-string" class="headerlink" title="ping.path string"></a>ping.path string</h4><p>   FPM 监控页面的 ping 网址。如果没有设置，则无法访问 ping 页面。该页面用于外部检测 FPM 是否存活并且可以响应请求。请注意必须以斜线开头（/）。</p><h4 id="ping-response-string"><a href="#ping-response-string" class="headerlink" title="ping.response string"></a>ping.response string</h4><p>   用于定义 ping 请求的返回响应。返回为 HTTP 200 的 text/plain 格式文本。默认值：pong。</p><h4 id="process-priority-int-1"><a href="#process-priority-int-1" class="headerlink" title="process.priority int"></a>process.priority int</h4><p>   设置 worker 的 nice(2)优先级（如果设置了的话）。 该值从 -19（最高优先级） 到 20（更低优先级）。 默认值：不设置</p><h4 id="prefix-string"><a href="#prefix-string" class="headerlink" title="prefix string"></a>prefix string</h4><p>   检测路径时使用的前缀。</p><h4 id="request-terminate-timeout-mixed"><a href="#request-terminate-timeout-mixed" class="headerlink" title="request_terminate_timeout mixed"></a>request_terminate_timeout mixed</h4><p>   设置单个请求的超时中止时间。该选项可能会对 php.ini 设置中的 ‘max_execution_time’ 因为某些特殊原因没有中止运行的脚本有用。设置为 ‘0’ 表示 ‘Off’。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。</p><h4 id="request-slowlog-timeout-mixed"><a href="#request-slowlog-timeout-mixed" class="headerlink" title="request_slowlog_timeout mixed"></a>request_slowlog_timeout mixed</h4><p>   当一个请求该设置的超时时间后，就会将对应的 PHP 调用堆栈信息完整写入到慢日志中。设置为 ‘0’ 表示 ‘Off’。可用单位：s（秒），m（分），h（小时）或者 d（天）。默认单位：s（秒）。默认值：0（关闭）。</p><h4 id="slowlog-string"><a href="#slowlog-string" class="headerlink" title="slowlog string"></a>slowlog string</h4><p>   慢请求的记录日志。默认值：#INSTALL_PREFIX#/log/php-fpm.log.slow。</p><h4 id="rlimit-files-int-1"><a href="#rlimit-files-int-1" class="headerlink" title="rlimit_files int"></a>rlimit_files int</h4><p>   设置文件打开描述符的 rlimit 限制。默认值：系统定义值。</p><h4 id="rlimit-core-int-1"><a href="#rlimit-core-int-1" class="headerlink" title="rlimit_core int"></a>rlimit_core int</h4><p>   设置核心 rlimit 最大限制值。可用值：’unlimited’，0 或者正整数。默认值：系统定义值。</p><h4 id="chroot-string"><a href="#chroot-string" class="headerlink" title="chroot string"></a>chroot string</h4><p>   启动时的 Chroot 目录。所定义的目录需要是绝对路径。如果没有设置，则 chroot 不被使用。</p><h4 id="chdir-string"><a href="#chdir-string" class="headerlink" title="chdir string"></a>chdir string</h4><p>   设置启动目录，启动时会自动 Chdir 到该目录。所定义的目录需要是绝对路径。默认值：当前目录，或者根目录（chroot时）。</p><h4 id="catch-workers-output-boolean"><a href="#catch-workers-output-boolean" class="headerlink" title="catch_workers_output boolean"></a>catch_workers_output boolean</h4><p>   重定向运行过程中的 stdout 和 stderr 到主要的错误日志文件中。如果没有设置，stdout 和 stderr 将会根据 FastCGI 的规则被重定向到 /dev/null。默认值：无。</p><h4 id="clear-env-boolean"><a href="#clear-env-boolean" class="headerlink" title="clear_env boolean"></a>clear_env boolean</h4><p>   为 FPM worker 进程清除环境变量。 在进程池配置文件里设置环境变量前，阻止任意系统的环境变量进入 FPM worker 进程。 自 PHP 5.4.27、 5.5.11 和 5.6.0 起。 默认值: Yes</p><h4 id="security-limit-extensions-string"><a href="#security-limit-extensions-string" class="headerlink" title="security.limit_extensions string"></a>security.limit_extensions string</h4><p>   限制 FPM 允许解析的脚本扩展名。 此设置可以预防 web 服务器配置的错误。 应当限制 FPM 仅仅解析 .php 扩展名，阻止恶意用户使用其他扩展名运行 php 代码。 默认值： .php .phar</p><h4 id="access-log-string"><a href="#access-log-string" class="headerlink" title="access.log string"></a>access.log string</h4><p>   Access log 文件。 默认值：不设置</p><h4 id="access-format-string"><a href="#access-format-string" class="headerlink" title="access.format string"></a>access.format string</h4><p>   access log 的格式。 默认值: “%R - %u %t \”%m %r\” %s”</p><p>还可以在为一个运行池传递附加的环境变量，或者更新 PHP 的配置值。可以在进程池配置文件中如下面的配置参数来做到：</p><h4 id="Example-1-给运行池传递环境变量和设置-PHP-的配置值"><a href="#Example-1-给运行池传递环境变量和设置-PHP-的配置值" class="headerlink" title="Example #1 给运行池传递环境变量和设置 PHP 的配置值"></a>Example #1 给运行池传递环境变量和设置 PHP 的配置值</h4><pre><code>env[HOSTNAME] = $HOSTNAMEenv[PATH] = /usr/local/bin:/usr/bin:/binenv[TMP] = /tmpenv[TMPDIR] = /tmpenv[TEMP] = /tmpphp_admin_value[sendmail_path] = /usr/sbin/sendmail -t -i -f www@my.domain.comphp_flag[display_errors] = offphp_admin_value[error_log] = /var/log/fpm-php.www.logphp_admin_flag[log_errors] = onphp_admin_value[memory_limit] = 32M</code></pre><p>PHP配置值通过 php_value 或者 php_flag 设置，并且会覆盖以前的值。请注意 disable_functions 或者 disable_classes 在 php.ini 之中定义的值不会被覆盖掉，但是会将新的设置附加在原有值的后面。</p><p>使用 php_admin_value 或者 php_admin_flag 定义的值，不能被 PHP 代码中的 ini_set() 覆盖。</p><p>自 5.3.3 起，也可以通过 web 服务器设置 PHP 的设定。</p><h4 id="Example-2-在-nginx-conf-中设定-PHP"><a href="#Example-2-在-nginx-conf-中设定-PHP" class="headerlink" title="Example #2 在 nginx.conf 中设定 PHP"></a>Example #2 在 nginx.conf 中设定 PHP</h4><pre><code>set $php_value &quot;pcre.backtrack_limit=424242&quot;;set $php_value &quot;$php_value \n pcre.recursion_limit=99999&quot;;fastcgi_param  PHP_VALUE $php_value;fastcgi_param  PHP_ADMIN_VALUE &quot;open_basedir=/var/www/htdocs&quot;;</code></pre><h4 id="Caution"><a href="#Caution" class="headerlink" title="Caution"></a>Caution</h4><p>由于这些设定是以 FastCGI 标头传递给 php-fpm，php-fpm 不应绑定到外部网可以访问的地址上，否则任何人都能修改 PHP 的配置选项了。参见 listen.allowed_clients。</p><h3 id="各项配置解析"><a href="#各项配置解析" class="headerlink" title="各项配置解析"></a>各项配置解析</h3><pre><code>pid = run/php-fpm.pid#pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启error_log = log/php-fpm.log#错误日志，默认在安装目录中的var/log/php-fpm.loglog_level = notice#错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.emergency_restart_threshold = 60emergency_restart_interval = 60s#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。process_control_timeout = 0#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.daemonize = yes#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。listen = 127.0.0.1:9000#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’. 每个进程池都需要设置.listen.backlog = -1#backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：http://www.3gyou.cc/?p=41listen.allowed_clients = 127.0.0.1#允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接listen.owner = wwwlisten.group = wwwlisten.mode = 0666#unix socket设置选项，如果使用tcp方式访问，这里注释即可。user = wwwgroup = www#启动进程的帐户和组pm = dynamic #对于专用服务器，pm可以设置为static。#如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：pm.max_children #，子进程最大数pm.start_servers #，启动时的进程数pm.min_spare_servers #，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程pm.max_spare_servers #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理pm.max_requests = 1000#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ’0′ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.pm.status_path = /status#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到ping.path = /ping#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。ping.response = pong#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.request_terminate_timeout = 0#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ’0′ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。request_slowlog_timeout = 10s#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 ’0′ 表示 ‘Off’slowlog = log/$pool.log.slow#慢请求的记录日志,配合request_slowlog_timeout使用rlimit_files = 1024#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。rlimit_core = 0#设置核心rlimit最大限制值. 可用值: ‘unlimited’ 、0或者正整数. 默认值: 系统定义值.chroot =#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.chdir =#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）catch_workers_output = yes#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空.</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://php.net/manual/zh/install.fpm.configuration.php" target="_blank" rel="external">http://php.net/manual/zh/install.fpm.configuration.php</a><br><a href="http://blog.51reboot.com/cgi-fastcgi-wsgi/" target="_blank" rel="external">http://blog.51reboot.com/cgi-fastcgi-wsgi/</a><br><a href="https://www.awaimai.com/371.html" target="_blank" rel="external">https://www.awaimai.com/371.html</a><br><a href="https://www.cnblogs.com/ahaii/p/5776809.html" target="_blank" rel="external">https://www.cnblogs.com/ahaii/p/5776809.html</a><br><a href="https://blog.csdn.net/mijar2016/article/details/53311986" target="_blank" rel="external">https://blog.csdn.net/mijar2016/article/details/53311986</a></p><p>1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php-fpm" scheme="http://martist.cn/categories/php-fpm/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
      <category term="php-fpm" scheme="http://martist.cn/tags/php-fpm/"/>
    
  </entry>
  
  <entry>
    <title>monolog</title>
    <link href="http://martist.cn/2018/04/13/PHP/monolog/"/>
    <id>http://martist.cn/2018/04/13/PHP/monolog/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-16T08:55:05.910Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="php中的日志库"><a href="#php中的日志库" class="headerlink" title="php中的日志库"></a>php中的日志库</h2><p>php中并没有内建的日志接口，故长期以来也没一个功能完备并且应用广泛的日志库。monolog是一个为5.3以上版本php开发的日志库，但是需要注意的是现在主干版本只支持php 7以上版本，如果你的服务器环境还是php 5的话，可以使用monolog的1.x版本。</p><p>monolog的github地址：<a href="https://github.com/Seldaek/monolog" target="_blank" rel="external">https://github.com/Seldaek/monolog</a><br>中文文档地址：<a href="https://github.com/Clarence-pan/monolog-zh-doc" target="_blank" rel="external">https://github.com/Clarence-pan/monolog-zh-doc</a><br>psr规范官方地址：<a href="https://www.php-fig.org/psr" target="_blank" rel="external">https://www.php-fig.org/psr</a></p><p>值得一提的是monolog是一个符合psr-3规范的日志类库，并且符合psr-4加载规范。这有利于松耦合的融入框架中。下面是正在使用monolog作为日志组件的框架。</p><h3 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h3><p>使用 PSR-3 的框架和库可以非常简单地集成 Monolog, 因为它实现了这个接口。<br>Symfony2 开箱即用 Monolog.<br>Silex 开箱即用 Monolog.<br>Laravel 4 &amp; 5 开箱即用 Monolog.<br>Lumen 开箱即用 Monolog.<br>PPI 开箱即用 Monolog.<br>CakePHP 可以通过 cakephp-monolog 这个插件来使用 Monolog.<br>Slim 可以通过 Slim-Monolog 这个日志适配器来使用 Monolog.<br>XOOPS 2.6 开箱即用 Monolog.<br>Aura.Web_Project 开箱即用 Monolog.<br>Nette Framework 可以通过 Kdyby/Monolog 这个扩展来使用 Monolog.<br>Proton Micro Framework 开箱即用 Monolog.<br>FuelPHP 开箱即用 Monolog.<br>Equip Framework 开箱即用 Monolog.<br>Yii 2 可以通过 yii2-monolog 这个插件来使用 Monolog.<br>Hawkbit Micro Framework 开箱即用 Monolog.</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>Monolog 需要 PHP 7.0 或以上版本才能正常工作。至于 PHP 5.3 请使用 Monolog ^1.0.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>composer require monolog/monolog</code></pre><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;// 创建一个日志通道$log = new Logger(&apos;name&apos;);$log-&gt;pushHandler(new StreamHandler(&apos;path/to/your.log&apos;, Logger::WARNING));// 添加日志记录$log-&gt;warning(&apos;Foo&apos;);$log-&gt;error(&apos;Bar&apos;);</code></pre><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>每一个日志服务实例 (Logger) 都有一个通道（名称），并有一个处理器 (Handler)栈. 无论何时你添加一条 记录 到对应的日志服务实例，这个处理器栈将被遍历一遍：每个处理器都将依次决定是否要处理这条记录，而如果要处理，则遍历结束（译注：类似DOM事件冒泡）。</p><p>这样子可以创建非常灵活的日志配置。比如一个 StreamHandler 可以把所有日志都写入磁盘，而上面加个MailHandler 可以把错误日志作为邮件发送出去。处理器还有一个 $bubble 属性定义了是否屏蔽某条记录或者处理了某条记录。在这个示例中，配置 MailHandler 的 $bubble 参数为 false 则意味着 MailHandler 将不会把自己已处理过的记录继续冒泡给 StreamHandler.</p><p>你可以创建许多日志服务实例(Logger)，每一个则定义一个通道（比如数据库、请求、路由…）。而每一个日志服务实例都可以组合各种各样的处理器，可以共享处理器也可以不共享。这个通道将会在日志中反映出来，从而允许你可以很容易地查看或者筛选记录。</p><p>每一个处理还会有一个格式化器（Formatter）。如果你没有配置一个，则一个有意义的默认的格式化器将被创建。格式化器用来规范化并格式化输入的记录，以便处理器能输出一些有用的信息。</p><p>不支持自定义的严重性级别。只支持使用RFC 5424中定义的八个级别（调试/Debug、信息/Info、提示/Notice、警告/Warning、错误/Error、严重/Critical、警报/Alert、紧急/Emergency）来作为基本的筛选目的。不过，如果为了排序或者其他需要灵活性的使用场景，你可以添加加工程序（Processor）从而可以在（处理器）处理前添加额外的信息（标签、用户IP…）。</p><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>Monolog 支持一下 RFC 5424 中的日志级别：</p><pre><code>调试/DEBUG (100): 详细的调试信息。信息/INFO (200): 有意义的事件，比如用户登录、SQL日志。提示/NOTICE (250): 正常但是值得注意的事件。警告/WARNING (300): 异常事件，但是并不是错误。比如使用了废弃了的API，错误地使用了一个API，以及其他不希望发生但是并非必要的错误。错误/ERROR (400): 运行时的错误，不需要立即注意到，但是需要被专门记录并监控到。严重/CRITICAL (500): 边界条件/危笃场景。比如应用组件不可用了，未预料到的异常。警报/ALERT (550): 必须立即采取行动。比如整个网站都挂了，数据库不可用了等。这种情况应该发送短信警报，并把你叫醒。紧急/EMERGENCY (600): 紧急请求：系统不可用了。</code></pre><h2 id="配置一个日志服务"><a href="#配置一个日志服务" class="headerlink" title="配置一个日志服务"></a>配置一个日志服务</h2><p>这里有一个基本的配置，可以记录日志到文件，并在 DEBUG 级别下记录到 firephp 中:</p><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;use Monolog\Handler\FirePHPHandler;// 创建日志服务$logger = new Logger(&apos;my_logger&apos;);// 添加一些处理器$logger-&gt;pushHandler(new StreamHandler(__DIR__.&apos;/my_app.log&apos;, Logger::DEBUG));$logger-&gt;pushHandler(new FirePHPHandler());// 现在你就可以用日志服务了$logger-&gt;info(&apos;My logger is now ready&apos;);</code></pre><p>解释一下。第一步是创建日志服务实例，这个实例后将在代码中用到。唯一的参数是通道的名称，它在你有多个日志服务实例的时候很有用。（更多详情参见下面）</p><p>这个日志服务实例自己是不是知道如何处理一条日志记录的。它把记录代理给了一些处理器。上面的代码中注册了两个处理器到栈中，以便允许使用两种不同的方式来处理日志记录。</p><p>注意，FirePHPHandler 是被先调用的，因而它被添加到了栈顶。这允许你临时添加一个禁止冒泡的处理器从而允许你覆盖其他配置的日志（处理器）。</p><pre><code>如果你单独使用 Monolog, 并且在寻找一种简单的方式来配置许多处理器，那可以用 theorchard/monolog-cascade 。 它可以帮你使用PHP数组、YAML或者JSON来构建复杂的日志配置。</code></pre><h2 id="为记录添加额外的数据"><a href="#为记录添加额外的数据" class="headerlink" title="为记录添加额外的数据"></a>为记录添加额外的数据</h2><p>Monolog 提供了两种不同的方式来为简单的文本消息增加额外的信息</p><h3 id="使用上下文-context"><a href="#使用上下文-context" class="headerlink" title="使用上下文(context)"></a>使用上下文(context)</h3><p>第一种方式是使用上下文（context），这允许你在传递记录的时候传递一个数组格式的数据：</p><pre><code>&lt;?php$logger-&gt;info(&apos;Adding a new user&apos;, array(&apos;username&apos; =&gt; &apos;Seldaek&apos;));</code></pre><p>简单的处理器（比如StreamHandler）将只是把数组转换成字符串。而复杂的处理器则可以利用上下文的优点（如 FirePHP 则将以一种优美的方式显示数组）。</p><h3 id="使用加工程序-Processor"><a href="#使用加工程序-Processor" class="headerlink" title="使用加工程序(Processor)"></a>使用加工程序(Processor)</h3><p>第二种方式是使用加工程序来为所有的记录添加额外数据。加工程序可以是任何可以调用的函数。 加工程序接收日志记录作为参数，并且需要在修改了extra字段后再返回日志记录。让我们来写一个添加一些假数据的加工程序：</p><pre><code>&lt;?php$logger-&gt;pushProcessor(function ($record) {    $record[&apos;extra&apos;][&apos;dummy&apos;] = &apos;Hello world!&apos;;    return $record;});</code></pre><p>Monolog提供了一些内置的加工程序，你可以在你的项目中使用它们。请参见对应的章节.</p><pre><code>小技巧：加工程序可以被注册到一个特定的处理器上而不是直接在日志服务实例上，从而可以只在对应的处理器上生效。</code></pre><h2 id="使用通道"><a href="#使用通道" class="headerlink" title="使用通道"></a>使用通道</h2><p>通道是一种非常棒的方式来区分是应用的哪个部分的日志被记录下来的。这通常在大型项目中非常有用（而且被Symfony2的MonologBundle所使用）。</p><p>假设有两个日志服务实例共享了一个处理器，这个处理器将日志写入单个日志文件。通道则将允许你来区分是哪个日志服务实例记录了哪条日志。你可以很简单地通过通道来筛选日志。</p><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;use Monolog\Handler\FirePHPHandler;// 创建一些处理器$stream = new StreamHandler(__DIR__.&apos;/my_app.log&apos;, Logger::DEBUG);$firephp = new FirePHPHandler();// 创建应用的主要日志服务实例$logger = new Logger(&apos;my_logger&apos;);$logger-&gt;pushHandler($stream);$logger-&gt;pushHandler($firephp);// 使用另外的通道来创建安全相关的日志服务示例$securityLogger = new Logger(&apos;security&apos;);$securityLogger-&gt;pushHandler($stream);$securityLogger-&gt;pushHandler($firephp);// 或者克隆第一个，只是改变下通道$securityLogger = $logger-&gt;withName(&apos;security&apos;);</code></pre><h2 id="自定义日志格式"><a href="#自定义日志格式" class="headerlink" title="自定义日志格式"></a>自定义日志格式</h2><p>在Monolog中，可以很简单地来自定义日志的格式，无论是写入文件、套接字、邮件、数据库还是其他处理器。大多数处理器都是用 $record[‘formatted’] 这个值来自动写入日志设备。这个值依赖格式化器的配置。你可以选择预定义的格式化器类，也可以自己写一个（比如一个可读的多行文本文件）。</p><p>想要配置一个预定义的格式化器类，可以直接把它设置为处理器的字段：</p><p>// 默认的日期格式是 “Y-m-d H:i:s”<br>$dateFormat = “Y n j, g:i a”;<br>// 默认的输出格式是 “[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n”<br>$output = “%datetime% &gt; %level_name% &gt; %message% %context% %extra%\n”;<br>// 最后创建一个格式化器<br>$formatter = new LineFormatter($output, $dateFormat);</p><p>// 创建一个处理器<br>$stream = new StreamHandler(<strong>DIR</strong>.’/my_app.log’, Logger::DEBUG);<br>$stream-&gt;setFormatter($formatter);</p><p>// 将其绑定到日志服务对象上<br>$securityLogger = new Logger(‘security’);<br>$securityLogger-&gt;pushHandler($stream);</p><p>// 你还可以在多个处理器之间复用同一个格式化器，并且在多个日志服务实例间共享这些处理器。</p>]]></content>
    
    <summary type="html">
    
      这可能是php世界中最好的日志库——monolog
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>关于小产权房的一些看法</title>
    <link href="http://martist.cn/2018/04/09/%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%85%B3%E4%BA%8E%E5%B0%8F%E4%BA%A7%E6%9D%83%E6%88%BF%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/"/>
    <id>http://martist.cn/2018/04/09/非技术文章/关于小产权房的一些看法/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2018-04-16T07:37:24.915Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="先回答几个问题"><a href="#先回答几个问题" class="headerlink" title="先回答几个问题"></a>先回答几个问题</h2><h3 id="什么是小产权房？"><a href="#什么是小产权房？" class="headerlink" title="什么是小产权房？"></a>什么是小产权房？</h3><p>小产权房是指在农村集体土地上建设的房屋，未缴纳土地出让金等费用，其产权证不是由国家房管部门颁发，而是由乡政府或村政府颁发，亦称“乡产权房”。“小产权房”不是法律概念，是人们在社会实践中形成的一种约定俗成的称谓。该类房没有国家发放的土地使用证和预售许可证，购房合同在国土房管局不会给予备案。所谓产权证亦不是真正合法有效的产权证。按照国家的相关要求，“小产权房”不得确权发证，不受法律保护。</p><h3 id="小产权房有保障吗？"><a href="#小产权房有保障吗？" class="headerlink" title="小产权房有保障吗？"></a>小产权房有保障吗？</h3><p>如果有一天这些村民把开发商买地的钱花完了，没钱了，开始动歪脑筋找钱花的时候，这群敢买小产权房的羔羊是再好宰不过了。隔三差五要求你每个月交物业费，村管理费，或者看当下房价高想在卖一次，直接撕毁合同。都是买房者不能承受之重</p><blockquote><p>家里在京郊有一套小产权，可谓依山傍水，空气清新，景色怡人，完全脱离城市的喧嚣。简单整了整之后，父母每周末都要过去住两天，感情状态回到新婚的水准。<br>然后，开放商想把这卖给某企业，就断水断电，列了个正常人不会签的条件，准备收房了。– 郭云昊</p></blockquote><h3 id="小产权房为什么不受保护？"><a href="#小产权房为什么不受保护？" class="headerlink" title="小产权房为什么不受保护？"></a>小产权房为什么不受保护？</h3><p>1.本集体组织成员之间买卖小产权房一般认定合同有效<br>2.本集体与他集体组织成员之间买卖小产权房一般认定合同无效<br>3.集体组织成员与城镇居民之间买卖小产权房一般认定合同无效<br>例外情形:城镇居民在签订小产权房买卖合同后取得了该集体组织户口并经相关部门批准，该房屋买卖合同一般认定有效。<br>4.小产权房买卖合同被认定无效之后的处理规则<br>5.上海地区对小产权房纠纷特别规定</p><p><strong> 法律禁止非同一集体组织成员间小产权房买卖，因此，买卖小产权房请慎重！</strong></p><p>具体参见： <a href="https://www.zhihu.com/question/20158141" target="_blank" rel="external">https://www.zhihu.com/question/20158141</a></p><h3 id="如果购买了小产权房，需要承担什么风险呢？"><a href="#如果购买了小产权房，需要承担什么风险呢？" class="headerlink" title="如果购买了小产权房，需要承担什么风险呢？"></a>如果购买了小产权房，需要承担什么风险呢？</h3><ol><li>法律效力<br>“小产权房”买卖合同的效力一般认定无效。</li><li>房产转让<br>“小产权房”拿不到正式的房产证，因此并不构成真正法律意义上的产权。即小产权房只有使用权，没有所有权。<br>根据《中华人民共和国土地管理法》的规定，小产权房不能向非本集体成员的第三人转让或出售，即购买后不能合法转让过户。其同时对房屋的保值和升值也有一定影响。</li><li>政策风险<br>购买在建小产权房时，购房人与开发商签订合同并交付房款后，如果相关部门整顿乡产权房的建设项目，可导致部分项目停建甚至被强迫拆除。购房人会面临既无法取得房屋，又不能及时索回房款的尴尬境地。<br>其次，购房后如果遇到国家征地拆迁，由于乡产权房没有国家认可的合法产权，购房人并非合法的产权人，所以无法得到对产权进行的拆迁补偿。</li><li>监管缺位<br>乡产权房屋的开发建设没有明确的规定加以约束，开发建设的监管存在缺位，对购房者的利益有一定的影响。同时，开发单位的资质没有，房屋质量和房屋售后保修难以保证。</li></ol><p><strong>综上所述，小产权房是不受法律保障的，所以不建议购买。</strong></p><h2 id="“小产权房”能不能买？"><a href="#“小产权房”能不能买？" class="headerlink" title="“小产权房”能不能买？"></a>“小产权房”能不能买？</h2><p>通俗的说，没有所谓小产权房，咱们国家从来没有过这个概念。你口中的“小产权”其实是“没产权”，不出纠纷还好，出了事没有任何保障，断水断电，然后三天两头村民去你家闹，你不能维权。反过头来国家或者村里要整你，也只需要一纸公文。</p><p>不是内行不要碰。</p><p>小产权房经常要求全款支付，也不能贷款。其次手续各方面容易出问题。如果不是自己涉入很深，对风险把控非常彻底，或者是对卖方有十足的把控能力的话，绝对不要碰。</p><p>这类房子不能考虑未来转手，不能考虑增值空间。</p><p>千万别碰小产权“期房”，那就等于是拿着血汗钱做了一次风投。</p>]]></content>
    
    <summary type="html">
    
      北漂生活
    
    </summary>
    
      <category term="生活" scheme="http://martist.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>健身相关文章的推荐</title>
    <link href="http://martist.cn/2018/04/08/%E5%81%A5%E8%BA%AB/%E5%81%A5%E8%BA%AB%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%E7%9A%84%E6%8E%A8%E8%8D%90/"/>
    <id>http://martist.cn/2018/04/08/健身/健身相关文章的推荐/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-16T02:15:40.514Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="健身还是伤身？"><a href="#健身还是伤身？" class="headerlink" title="健身还是伤身？"></a>健身还是伤身？</h2><p><a href="https://zhuanlan.zhihu.com/p/34315947" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34315947</a></p><h2 id="健身后的禁忌—10个不要，关乎身家性命"><a href="#健身后的禁忌—10个不要，关乎身家性命" class="headerlink" title="健身后的禁忌—10个不要，关乎身家性命"></a>健身后的禁忌—10个不要，关乎身家性命</h2><p><a href="https://zhuanlan.zhihu.com/p/25606492" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25606492</a></p><h2 id="运动不是膝盖杀手，它才是"><a href="#运动不是膝盖杀手，它才是" class="headerlink" title="运动不是膝盖杀手，它才是!"></a>运动不是膝盖杀手，它才是!</h2><p><a href="https://zhuanlan.zhihu.com/p/31894631" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/31894631</a></p><h2 id="史上最全面的拉伸指南"><a href="#史上最全面的拉伸指南" class="headerlink" title="史上最全面的拉伸指南"></a>史上最全面的拉伸指南</h2><p><a href="https://zhuanlan.zhihu.com/p/32118734" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/32118734</a></p><h2 id="严谨的健身书籍推荐2-姿态评估、运动损伤和身体疼痛"><a href="#严谨的健身书籍推荐2-姿态评估、运动损伤和身体疼痛" class="headerlink" title="严谨的健身书籍推荐2 - 姿态评估、运动损伤和身体疼痛"></a>严谨的健身书籍推荐2 - 姿态评估、运动损伤和身体疼痛</h2><p><a href="https://zhuanlan.zhihu.com/p/22864752" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22864752</a></p><h2 id="物美价廉的健身装备推荐，亲测好用！"><a href="#物美价廉的健身装备推荐，亲测好用！" class="headerlink" title="物美价廉的健身装备推荐，亲测好用！"></a>物美价廉的健身装备推荐，亲测好用！</h2><p><a href="https://zhuanlan.zhihu.com/p/22762552" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22762552</a></p><p>持续更新！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="健身" scheme="http://martist.cn/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>SaaS的php技术实现</title>
    <link href="http://martist.cn/2018/04/01/%E6%9E%B6%E6%9E%84/SaaS%E7%9A%84php%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>http://martist.cn/2018/04/01/架构/SaaS的php技术实现/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-03T03:33:56.321Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="SOFTWARE-AS-A-SERVICE"><a href="#SOFTWARE-AS-A-SERVICE" class="headerlink" title="SOFTWARE AS A SERVICE"></a>SOFTWARE AS A SERVICE</h3><p>在某些方面，SaaS非常类似于早些年的瘦客户端软件模式，其中客户端（在这种情况下通常是Web浏览器）提供对服务器上运行的软件的访问点。 SaaS是消费者最熟悉的云服务形式。 SaaS将管理软件及其部署的任务转移到第三方服务。最熟悉的业务SaaS应用程序是客户关系管理应用程序，如Salesforce，像Google Apps这样的生产力软件，以及Box和Dropbox等存储解决方案的软件。</p><p>使用SaaS应用程序往往会降低软件所有权成本，因为不需要技术人员来管理软件的安装，管理和升级，同时这也可以降低软件许可的成本。SaaS应用程序通常在订阅模式上被提出来。</p><h3 id="PLATFORM-AS-A-SERVICE"><a href="#PLATFORM-AS-A-SERVICE" class="headerlink" title="PLATFORM AS A SERVICE"></a>PLATFORM AS A SERVICE</h3><p>PaaS提供比SaaS低一级的功能，通常提供可以开发和部署软件的平台。 PaaS提供者抽象处理服务器的大部分工作，并为客户提供了操作系统和服务器软件以及底层服务器硬件和网络基础设施的环境，使用户可以自由地关注业务端可扩展性及其产品或服务的应用开发。</p><p>与大多数云服务一样，PaaS是建立在虚拟化技术之上的。企业可以根据需要申请资源，随着需求的增长而不是以冗余资源投入硬件。</p><p>PaaS提供商的例子包括Heroku，Google App Engine和Red Hat的OpenShift。</p><h3 id="INFRASTRUCTURE-AS-A-SERVICE"><a href="#INFRASTRUCTURE-AS-A-SERVICE" class="headerlink" title="INFRASTRUCTURE AS A SERVICE"></a>INFRASTRUCTURE AS A SERVICE</h3><p>继续朝服务的下层看，我们就可以看到云服务的基本构件。 IaaS由高度自动化和可扩展的计算资源组成，由云存储和可以自动配置，计量和可用的按需网络功能组成。</p><p>IaaS提供商通过仪表板以及API（API可能没有）提供这些云服务器及其相关资源。 IaaS客户可以直接访问其服务器和存储，就像传统服务器一样，但这样拥有更高级别的可扩展性。 IaaS的用户可以在云中外包和构建“虚拟数据中心”，并可以访问许多与传统数据中心相同的技术和资源功能，而无需投资于服务器容量规划或物理管理维护。</p><p>IaaS是最灵活的云计算模式，允许自动的服务器，处理能力，存储和网络的自动部署。 IaaS客户对基础设施拥有真正的控制，比PaaS或SaaS服务的用户不知道高到哪里去了。 IaaS的主要用途包括PaaS，SaaS和网络规模应用程序的实际开发和部署。</p><p>有很多提供商提供Iaas，比如Navisite，Exoscale和Softlayer，具有自己独特的价格方案和服务组合可供选择。</p><p>ComputeNext（作者的网站）为IaaS提供一个经纪服务，以便你可以确保为您的应用需求选择合适的IaaS提供商。通过使用单一API对20多个云提供商进行归一化的访问，您可以比较提供商的价格和性能，从而找到最佳配置，然后构建和部署，而不会被绑死到一个平台。</p><p>具体例子可以参考：<a href="https://www.zhihu.com/question/21641778/answer/95652959" target="_blank" rel="external">https://www.zhihu.com/question/21641778/answer/95652959</a></p><h3 id="通俗的讲pass和saas的区别"><a href="#通俗的讲pass和saas的区别" class="headerlink" title="通俗的讲pass和saas的区别"></a>通俗的讲pass和saas的区别</h3><p>paas给你一个完善的开发，测试，上线的环境，应用工程代码还是需要你来开发，在开发过程需要的一些服务已经帮你做好，比如：短信服务，邮件服务，分布式文件系统服务，域名备案服务，网络端负载均衡服务，数据库端负载主从热备服务，分片服务，vpn服务，https服务，各个线上服务器的监控统计服务等；saas是应用工程帮你做好，你只需要调整下页面配置，即可上线运营，有点类似淘宝平台与淘宝入驻商家之间的关系。</p><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>saas系统分层大概是：  </p><blockquote><p>租户识别&gt;应用层&gt;数据访问层&gt;缓存层&gt;数据库  </p></blockquote><p>业务代码都是写在应用层。<br>租户识别可以用spring拦截器实现，然后使用ThreadLocal传递给后端<br>数据库和缓存层对应用层应该是透明的。程序员在写代码的时候，只关心业务逻辑，不应该担心多租户的问题。</p><h3 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h3><p>saas系统说起来很简单，任何系统似乎加个tenant_id(租户id)就变成saas系统了。比如原来的用户登录是：</p><pre><code>select username,password from users where email=&apos;abc@qq.com&apos;</code></pre><p>改成</p><pre><code>select username,password from users where email=&apos;abc@qq.com&apos; and tenant_id =1;</code></pre><p>对于复杂业务的saas系统，这样做法非常危险，而且开发效率很低。你想想如果那个程序员写sql时候忘了加 “ and tenant_id =1” . 结果不堪设想。<br>比较好做法是在数据库访问层对SQL进行改写。</p><pre><code>TenantContext.exec(&quot;select username,password from users where email=&apos;abc@qq.com&apos; &quot;);</code></pre><p>在连接池根据TenatnContext改写Sql.<br>这样做好处是，一来程序猿最多把系统搞down了，也不至于信息串了互相泄露。二来将来做分表分库也很方便，上层应用不用修改。</p><h3 id="租户识别方案"><a href="#租户识别方案" class="headerlink" title="租户识别方案"></a>租户识别方案</h3><p>比较好做法是通过url识别租户。系统是给租户生成一个随机的三级域名，比如 abc.crm.baidu.com.   如果客户想使用自己的域名，可以在cname到我们生成的三级域名，并在管理系统里面做绑定。<br>这样一个租户可以有两个域名，访问saas,一个随机生成的三级域名，另外一个租户自己的域名.代码里面可以根据过来的域名，判断是那个租户然后初始化TenantContext.<br>如果不想通过域名来做，也可以通过登录名来判断。这种方式要涉及到租户切换问题。</p><h3 id="租户管理系统（计费，订购，定制，充值，催缴）"><a href="#租户管理系统（计费，订购，定制，充值，催缴）" class="headerlink" title="租户管理系统（计费，订购，定制，充值，催缴）"></a>租户管理系统（计费，订购，定制，充值，催缴）</h3><p>Saas系统是必须考虑计费系统和租户控制系统。这个系统需要都是独立设计。比如那个租户购买了那些模块，一个月多少钱。租户可以创建最多的用户数。计费到期邮件提醒等功能。<br>计费方式一般有两种，周期性计费，类似月租方案，和使用量计费,用多少付多少。 周期性计费比较简单。也可以两者结合起来。</p><h3 id="定制化开发"><a href="#定制化开发" class="headerlink" title="定制化开发"></a>定制化开发</h3><p>SAAS的优势在于一套系统多人使用，似乎和定制化开发有冲突。比如A客户想要A功能，B客户不想要。但定制化开发是无法避免的，比如CRM系统这样复杂的系统，不可能一套系统满足所有公司的要求。定制化开发尽可能分系统，分模块去做。然后通过控制台中配置不同租户订购不同模块，那些模块可以在前端页面上显示。不同的子系统需要分开部署。前端可通过nginx根据url分发，比如 abc.crm.baidu.com/bi/xxx/xx这个地址，就分发到BI子系统。不要尝试OSGI去搞模块化，这个是个大坑。<br>还有开发和产品，现有需求一定要分析清楚，不要一上线发现后患无穷。新功能尽量做的独立可以配置。</p><h3 id="灰度升级"><a href="#灰度升级" class="headerlink" title="灰度升级"></a>灰度升级</h3><p>SAAS付费企业客户对系统问题都特别敏感。 为了减少升级可能出现问题的影响范围，一般都采用灰度升级策略。如果使用了url来区分不同租户，灰度升级配置就会很方便。可以配置nginx 来根据域名做分发，比如租户A（aaa.com）到实例1（版本1.0），租户B(bbb.com)到实例2(版本). 当需要域名配置非常多的时候，nginx配置文档会乱。这块时候可以考虑使用nignx_lua来写一些扩展模块。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="关于多租户的数据隔离方案"><a href="#关于多租户的数据隔离方案" class="headerlink" title="关于多租户的数据隔离方案"></a>关于多租户的数据隔离方案</h3><h4 id="独立数据库"><a href="#独立数据库" class="headerlink" title="独立数据库"></a>独立数据库</h4><p>这是第一种方案，即一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本较高。<br>优点：<br>为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。<br>缺点：<br>增多了数据库的安装数量，随之带来维护成本和购置成本的增加。<br>这种方案与传统的一个客户、一套数据、一套部署类似，差别只在于软件统一部署在运营商那里。如果面对的是银行、医院等需要非常高数据隔离级别的租户，可以选择这种模式，提高租用的定价。如果定价较低，产品走低价路线，这种方案一般对运营商来说是无法承受的。</p><h4 id="共享数据库，隔离数据架构"><a href="#共享数据库，隔离数据架构" class="headerlink" title="共享数据库，隔离数据架构"></a>共享数据库，隔离数据架构</h4><p>这是第二种方案，即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。<br>优点：<br>为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可支持更多的租户数量。<br>缺点：<br>如果出现故障，数据恢复比较困难，因为恢复数据库将牵涉到其他租户的数据；<br>如果需要跨租户统计数据，存在一定困难。</p><h4 id="共享数据库，共享数据架构"><a href="#共享数据库，共享数据架构" class="headerlink" title="共享数据库，共享数据架构"></a>共享数据库，共享数据架构</h4><p>这是第三种方案，即租户共享同一个Database、同一个Schema，但在表中增加TenantID多租户的数据字段。这是共享程度最高、隔离级别最低的模式。<br>优点：<br>三种方案比较，第三种方案的维护和购置成本最低，允许每个数据库支持的租户数量最多。<br>缺点：<br>隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；<br>数据备份和恢复最困难，需要逐表逐条备份和还原。<br>如果希望以最少的服务器为最多的租户提供服务，并且租户接受牺牲隔离级别换取降低成本，这种方案最适合。</p><h3 id="选择合理的实现模式"><a href="#选择合理的实现模式" class="headerlink" title="选择合理的实现模式"></a>选择合理的实现模式</h3><p>衡量三种模式主要考虑的因素是隔离还是共享。</p><h4 id="成本角度因素"><a href="#成本角度因素" class="headerlink" title="成本角度因素"></a>成本角度因素</h4><p>隔离性越好，设计和实现的难度和成本越高，初始成本越高。共享性越好，同一运营成本下支持的用户越多，运营成本越低。</p><h4 id="安全因素"><a href="#安全因素" class="headerlink" title="安全因素"></a>安全因素</h4><p>要考虑业务和客户的安全方面的要求。安全性要求越高，越要倾向于隔离。</p><h4 id="租户数量因素"><a href="#租户数量因素" class="headerlink" title="租户数量因素"></a>租户数量因素</h4><p>系统要支持多少租户？上百？上千还是上万？可能的租户越多，越倾向于共享。<br>平均每个租户要存储数据需要的空间大小。存贮的数据越多，越倾向于隔离。<br>每个租户的同时访问系统的最终用户数量。需要支持的越多，越倾向于隔离。<br>是否想针对每一租户提供附加的服务，例如数据的备份和恢复等。这方面的需求越多， 越倾向于隔离。</p><h4 id="信息监管因素"><a href="#信息监管因素" class="headerlink" title="信息监管因素"></a>信息监管因素</h4><p>要考虑政府，机关，企业，公司的安全和信息监管相关的一些政策和规定。</p><h3 id="基于laravel框架开发SaaS系统"><a href="#基于laravel框架开发SaaS系统" class="headerlink" title="基于laravel框架开发SaaS系统"></a>基于laravel框架开发SaaS系统</h3><ol><li>利用laravel内置的前置中间件对租户请求域名进行判断，进而区分租户。</li><li>每个租户的密钥来对应请求域名，后端鉴权通过每个租户不同的密钥和请求域名来制造签名，中心API服务器以此鉴权。实现ACL，防止数据遭窃。</li><li>分库分表，实现数据隔离，可以使分库作为本公司master数据库的一个备库扩展库，从而实现读写分离，数据安全，查询优化等功能。</li><li>为saas用户提供服务器前端项目，不提供数据链接，服务器前端项目为可转发请求的服务治理中间件功能的框架（curl，guzzle），租户可以买账号直接使用系统，也可以搭在自己服务器，自行增减配置运维，写前端代码添加个性化的内容比如商标、首页、详情页等等。后端接口维护在本公司的服务器，如果系统有bug可以随时处理而不需要去所有租户的服务器重新部署，实现平滑升级。</li></ol><p>1</p>]]></content>
    
    <summary type="html">
    
      对我们phper来讲，这些概念不难理解
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>简单谈接口设计</title>
    <link href="http://martist.cn/2018/03/20/%E6%9E%B6%E6%9E%84/%E7%AE%80%E5%8D%95%E8%B0%88%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
    <id>http://martist.cn/2018/03/20/架构/简单谈接口设计/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-04-26T11:21:35.998Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>关于接口设计，需要注意区分pc,wap,app不同端的接口请求和通用性，以及实现签名鉴权，访问控制等功能。</p><h2 id="接口参数定义"><a href="#接口参数定义" class="headerlink" title="接口参数定义"></a>接口参数定义</h2><p>接口设计中往可以抽象出一些新的公共参数，从事了近三年的接口开发工作中，我目前能想到了一些较为常见的公共接口参数如下：</p><table><thead><tr><th>公共参数</th><th style="text-align:center">含意</th><th>定义该参数的意义</th></tr></thead><tbody><tr><td>timestamp</td><td style="text-align:center">毫秒级时间戳</td><td>1.客户端的请求时间标示 2.后端可以做请求过期验证 3.该参数参与签名算法增加签名的唯一性</td></tr><tr><td>app_key/source</td><td style="text-align:center">签名公钥(来源)</td><td>签名算法的公钥，后端通过公钥可以得到对应的私钥（也就是来源的意义）</td></tr><tr><td>sign</td><td style="text-align:center">接口签名</td><td>通过请求的参数和定义好的签名算法生成接口签名，作用防止中间人篡改请求参数</td></tr><tr><td>did</td><td style="text-align:center">设备ID</td><td>设备的唯一标示，生成规则例如android的mac地址的md5和ios曾今udid(目前无法获取)的md5, 1:数据收集 2.便于问题追踪 3.消息推送标示</td></tr></tbody></table><h2 id="接口版本化"><a href="#接口版本化" class="headerlink" title="接口版本化"></a>接口版本化</h2><p>我不太习惯把版本号直接放到路由里面去，还有其他方式可以区别版本，比如get、post传参。</p><h2 id="接口安全性"><a href="#接口安全性" class="headerlink" title="接口安全性"></a>接口安全性</h2><h3 id="过期验证"><a href="#过期验证" class="headerlink" title="过期验证"></a>过期验证</h3><p>通过时间戳进行验证</p><pre><code>if (microtime(true)*1000 - $_REQUEST[&apos;timestamp&apos;] &gt; 5000) {    throw new \Exception(401, &apos;Expired request&apos;);}</code></pre><h3 id="签名验证-公钥校验省略，如果是saas，密钥可能不同"><a href="#签名验证-公钥校验省略，如果是saas，密钥可能不同" class="headerlink" title="签名验证(公钥校验省略，如果是saas，密钥可能不同)"></a>签名验证(公钥校验省略，如果是saas，密钥可能不同)</h3><p>通过配对私钥的加密算法产生签名，请求中携带签名进行鉴权。</p><pre><code>$params = ksort($_REQUEST);unset($params[&apos;sign&apos;]);$sign = md5(sha1(implode(&apos;-&apos;, $params) . $_REQUEST[&apos;app_key&apos;]));if ($sign !== $_REQUEST[&apos;sign&apos;]) {    throw new \Exception(401, &apos;Invalid sign&apos;);}</code></pre><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>防止一次相同请求多次攻击API服务器。</p><pre><code> /** @params noise string 随机字符串或随机正整数，与 Timestamp 联合起来, 用于防止重放攻击 例如腾讯云是6位随机正整数 */$key = md5(&quot;{$_REQUEST[&apos;REQUEST_URI&apos;]}-{$_REQUEST[&apos;timestamp&apos;]}-{$_REQUEST[&apos;noise&apos;]}-{$_REQUEST[&apos;did&apos;]}&quot;);if ($redisInstance-&gt;exists($key)) {    throw new \Exception(401, &apos;Repeated request&apos;);}</code></pre><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>防止同一ip频繁访问API服务器。</p><pre><code>$key = md5(&quot;{$_REQUEST[&apos;REQUEST_URI&apos;]}-{$_REQUEST[&apos;REMOTE_ADDR&apos;]}-{$_REQUEST[&apos;did&apos;]}&quot;);if ($redisInstance-&gt;get($key) &gt; 60) {    throw new \Exception(401, &apos;Request limit&apos;);}$redisInstance-&gt;incre($key);</code></pre><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>防止注入，xss等攻击。</p><pre><code>$username = htmlspecialchars($_REQUEST[&apos;username&apos;]);</code></pre><h2 id="接口的解耦设计"><a href="#接口的解耦设计" class="headerlink" title="接口的解耦设计"></a>接口的解耦设计</h2><ol><li>活用中间件、钩子</li><li>借口多用post请求，少用get</li><li>废弃的代码及时删掉，或者注释掉并且标注</li><li>接口文件合理切割（laravel，lumen等有接口文件的框架）</li><li>服务间调用不要私钥公钥相同，免得一破百破</li></ol><h2 id="接口的状态码"><a href="#接口的状态码" class="headerlink" title="接口的状态码"></a>接口的状态码</h2><p>推荐一些公用的，如果还有私信，广播，商城等状态码可以另加。</p><pre><code>200 -&gt; 正常400 -&gt; 缺少公共必传参数或者业务必传参数401 -&gt; 接口校验失败 例如签名403 -&gt; 没有该接口的访问权限499 -&gt; 上游服务响应时间超过接口设置的超时时间500 -&gt; 代码错误501 -&gt; 不支持的接口method502 -&gt; 上游服务返回的数据格式不正确503 -&gt; 上游服务超时504 -&gt; 上游服务不可用</code></pre><p>转自：<a href="http://tigerb.cn/2018/03/13/api/" target="_blank" rel="external">http://tigerb.cn/2018/03/13/api/</a></p><p>1</p>]]></content>
    
    <summary type="html">
    
      接口设计
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>深蹲膝盖要不要过脚尖</title>
    <link href="http://martist.cn/2018/03/18/%E5%81%A5%E8%BA%AB/%E6%B7%B1%E8%B9%B2%E8%86%9D%E7%9B%96%E8%A6%81%E4%B8%8D%E8%A6%81%E8%BF%87%E8%84%9A%E5%B0%96/"/>
    <id>http://martist.cn/2018/03/18/健身/深蹲膝盖要不要过脚尖/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-04-12T12:05:03.724Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>网上流传着“深蹲时膝盖不能过脚尖，过了脚尖容易伤膝盖”这种说法。今天，我们来探讨一下。</p><p>本来我以为这个事已经达成共识了，还是有人问，那么，我觉得有必要说两句。</p><p>看到一个说法，首先可以提问，对于这个说法，该问的就是：为什么不过脚尖能保护膝盖？网上的解释一般是：膝盖过脚尖，膝关节承受的压力会增加，于是受伤风险增加。</p><p>脊椎和任何关节，都与膝关节一样，增加压力就会提高受伤风险。现在，有这么一个膝盖和脚尖关系的说法，好，我炮制一个“背角（躯干与地面的夹角）小于45度就有椎间盘突出的风险”，你觉得怎么样？你说我没有理论支撑，那你找找看，深蹲脚尖这个事，有理论支撑吗？上网一查就发现，原来这说法没有任何文献，和我刚编出来的东西差不多，是拍脑门的产物。</p><p>你说，压力增加，就是容易受伤啊。他们这个说法虽然没有文献支撑，但是也没错啊。</p><p>我就奇了怪了，照他们这么说，深蹲就不能负重，因为一旦负重，膝关节承受的压力肯定就增加了，于是，大家都徒手深蹲吧。既然要减轻膝关节的压力，那徒手深蹲也不合适，最好找个人辅助一下。都这么干了，为啥还要膝盖不过脚尖地深蹲啊，干脆就别蹲了。为了减轻膝关节的压力，而采用膝盖不过脚尖的办法，还蹲什么啊？</p><p>哦，还是要蹲，还是要负重，毕竟还得训练，只是找一个最安全的办法，这种说法也站不住脚。与其用不过脚尖的怪异姿势保护膝关节，为什么不减轻一点重量用正常动作呢？嫌强度不够，那做硬拉得了。</p><p>哦，硬拉和深蹲不一样，就得蹲，就得上重量。你看，不蹲最安全，你要蹲；轻重量相对安全，你要上重量。你已经决定要让膝关节承受很大的压力，也就是说，你可以接受风险啊。膝关节压力增加，受伤的风险增加，说得很对，问题是，它是废话。你只要训练，只要想提高，要么增加强度、要么增加训练量（文末扩展阅读），受伤的风险就会增加，没有人会几十年如一日地用同样的负重、同样的组次、同样的节奏来训练吧。</p><p>你说你要翘臀，伸膝的事无所谓。那么，你最好做纯直腿的站躬身或硬拉，这样伸膝就没多少参与了。可是，你要知道，一旦站姿负重，这些重量就直接作用于膝关节上了，而且即便你完全直着腿，伸髋的时候腘绳肌发力，一样会再次增加膝关节压力的。</p><p>所以，无论怎么练，只要负重，甚至就算徒手，都会增大膝关节压力，照他们这个理论，也就增加了膝伤风险。显然，我们还是要锻炼的，不能因为它受压就放弃，所以，要探讨的就是膝伤风险问题了。</p><p>干什么事都有风险对不对？不能接受风险的话，应该老老实实躺在床上，不然上楼、跑步，甚至走路都有伤膝盖的风险，出门还有被车撞的风险呢。像我这种脸大的，躺床上看手机都有被砸到的风险。如果一听说风险就要避免，人是没法活了。</p><p>人活着，只要风险在可接受的范围内，生活就是第一位的。锻炼也是如此，只要风险可接受，训练目的就应该是第一位的。</p><p>你知道几个人单纯因为膝盖超脚尖深蹲导致膝伤的？你说健身房那个胖子某甲这么蹲膝盖就受伤了。这就没意思了，你只看见他“深蹲时膝盖超脚尖”和“受伤”这两件事了，也许它们相关，但不能说就是因果啊。我奶奶啥都没干，膝盖还坏了呢，实际上是退行性的事，我一定把她的“膝盖坏了”和“啥都没干”建立起因果关系，得出“什么都没干易导致膝伤”的结论，不合适吧。</p><p>你应该看看健身房里那些负重比较大的训练者，他们深蹲时膝盖都过脚尖了，他们是否受伤。如果得出的结论是：那些膝盖超脚尖的训练者，负重非常大，没有一个因此而膝伤的。那么就说明，这样的训练方式受伤概率极低，尽管这个风险可能存在，但是，它是可接受的。于是，你也应该考虑不管这个拍脑门出来的说法，而把训练目的放在首要位置。</p><p>也许你又想了，虽然这说法没什么道理，但宁可信其有不可信其无，反正也没什么坏处。我得告诉你，你真这么干的话，有坏处。</p><p>现在，好像大家都非常爱护自己的膝关节，说起啥来都是伤膝盖。难道，大家身上除了膝关节就没有别的关节了吗？</p><p>我们还要保护腰部，因为过于后倾的深蹲，对腰部肌肉甚至骨骼的损害是很大的。希望大家在健身过程中，保护好自己的身体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="健身" scheme="http://martist.cn/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>linux之curl命令</title>
    <link href="http://martist.cn/2018/03/18/LINUX/linux%E4%B9%8BCURL%E5%91%BD%E4%BB%A4/"/>
    <id>http://martist.cn/2018/03/18/LINUX/linux之CURL命令/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-04-10T10:16:21.487Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>curl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>curl(选项)(参数)</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><pre><code>-a/--append    上传文件时，附加到目标文件-A/--user-agent &lt;string&gt;    设置用户代理发送给服务器-anyauth    可以使用“任何”身份验证方法-b/--cookie &lt;name=string/file&gt;    cookie字符串或文件读取位置    --basic    使用HTTP基本验证-B/--use-ascii    使用ASCII /文本传输-c/--cookie-jar &lt;file&gt;    操作结束后把cookie写入到这个文件中-C/--continue-at &lt;offset&gt;    断点续转-d/--data &lt;data&gt;    HTTP POST方式传送数据    --data-ascii &lt;data&gt;    以ascii的方式post数据    --data-binary &lt;data&gt;    以二进制的方式post数据    --negotiate    使用HTTP身份验证    --digest    使用数字身份验证    --disable-eprt    禁止使用EPRT或LPRT    --disable-epsv    禁止使用EPSV-D/--dump-header &lt;file&gt;    把header信息写入到该文件中    --egd-file &lt;file&gt;    为随机数据(SSL)设置EGD socket路径    --tcp-nodelay    使用TCP_NODELAY选项-e/--referer    来源网址-E/--cert &lt;cert[:passwd]&gt;    客户端证书文件和密码 (SSL)    --cert-type &lt;type&gt;    证书文件类型 (DER/PEM/ENG) (SSL)    --key &lt;key&gt;    私钥文件名 (SSL)    --key-type &lt;type&gt;    私钥文件类型 (DER/PEM/ENG) (SSL)    --pass &lt;pass&gt;    私钥密码 (SSL)    --engine &lt;eng&gt;    加密引擎使用 (SSL). &quot;--engine list&quot; for list    --cacert &lt;file&gt;    CA证书 (SSL)    --capath &lt;directory&gt;    CA目录 (made using c_rehash) to verify peer against (SSL)    --ciphers &lt;list&gt;    SSL密码    --compressed    要求返回是压缩的形势 (using deflate or gzip)    --connect-timeout &lt;seconds&gt;    设置最大请求时间    --create-dirs    建立本地目录的目录层次结构    --crlf    上传是把LF转变成CRLF-f/--fail    连接失败时不显示http错误    --ftp-create-dirs    如果远程目录不存在，创建远程目录    --ftp-method [multicwd/nocwd/singlecwd]    控制CWD的使用    --ftp-pasv    使用 PASV/EPSV 代替端口    --ftp-skip-pasv-ip    使用PASV的时候,忽略该IP地址    --ftp-ssl    尝试用 SSL/TLS 来进行ftp数据传输    --ftp-ssl-reqd    要求用 SSL/TLS 来进行ftp数据传输-F/--form &lt;name=content&gt;    模拟http表单提交数据    --form-string &lt;name=string&gt;    模拟http表单提交数据-g/--globoff    禁用网址序列和范围使用{}和[]-G/--get    以get的方式来发送数据-H/--header &lt;line&gt;    自定义头信息传递给服务器    --ignore-content-length    忽略的HTTP头信息的长度-i/--include    输出时包括protocol头信息-I/--head    只显示请求头信息-j/--junk-session-cookies    读取文件进忽略session cookie    --interface &lt;interface&gt;    使用指定网络接口/地址    --krb4 &lt;level&gt;    使用指定安全级别的krb4-k/--insecure    允许不使用证书到SSL站点-K/--config    指定的配置文件读取-l/--list-only    列出ftp目录下的文件名称    --limit-rate &lt;rate&gt;    设置传输速度    --local-port&lt;NUM&gt;    强制使用本地端口号-m/--max-time &lt;seconds&gt;    设置最大传输时间    --max-redirs &lt;num&gt;    设置最大读取的目录数    --max-filesize &lt;bytes&gt;    设置最大下载的文件总量-M/--manual    显示全手动-n/--netrc    从netrc文件中读取用户名和密码    --netrc-optional    使用 .netrc 或者 URL来覆盖-n    --ntlm    使用 HTTP NTLM 身份验证-N/--no-buffer    禁用缓冲输出-o/--output    把输出写到该文件中-O/--remote-name    把输出写到该文件中，保留远程文件的文件名-p/--proxytunnel    使用HTTP代理    --proxy-anyauth    选择任一代理身份验证方法    --proxy-basic    在代理上使用基本身份验证    --proxy-digest    在代理上使用数字身份验证    --proxy-ntlm    在代理上使用ntlm身份验证-P/--ftp-port &lt;address&gt;    使用端口地址，而不是使用PASV-q    作为第一个参数，关闭 .curlrc-Q/--quote &lt;cmd&gt;    文件传输前，发送命令到服务器-r/--range &lt;range&gt;    检索来自HTTP/1.1或FTP服务器字节范围--range-file    读取（SSL）的随机文件-R/--remote-time    在本地生成文件时，保留远程文件时间    --retry &lt;num&gt;    传输出现问题时，重试的次数    --retry-delay &lt;seconds&gt;    传输出现问题时，设置重试间隔时间    --retry-max-time &lt;seconds&gt;    传输出现问题时，设置最大重试时间-s/--silent    静默模式。不输出任何东西-S/--show-error    显示错误    --socks4 &lt;host[:port]&gt;    用socks4代理给定主机和端口    --socks5 &lt;host[:port]&gt;    用socks5代理给定主机和端口    --stderr &lt;file&gt;     -t/--telnet-option &lt;OPT=val&gt;    Telnet选项设置    --trace &lt;file&gt;    对指定文件进行debug    --trace-ascii &lt;file&gt;    Like --跟踪但没有hex输出    --trace-time    跟踪/详细输出时，添加时间戳-T/--upload-file &lt;file&gt;    上传文件    --url &lt;URL&gt;    Spet URL to work with-u/--user &lt;user[:password]&gt;    设置服务器的用户和密码-U/--proxy-user &lt;user[:password]&gt;    设置代理用户名和密码-w/--write-out [format]    什么输出完成后-x/--proxy &lt;host[:port]&gt;    在给定的端口上使用HTTP代理-X/--request &lt;command&gt;    指定什么命令-y/--speed-time    放弃限速所要的时间，默认为30-Y/--speed-limit    停止传输速度的限制，速度时间</code></pre><p>具体可看：<a href="http://man.linuxde.net/curl" target="_blank" rel="external">http://man.linuxde.net/curl</a></p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><h3 id="一、查看网页源码"><a href="#一、查看网页源码" class="headerlink" title="一、查看网页源码"></a>一、查看网页源码</h3><p>直接在curl命令后加上网址，就可以看到网页源码。我们以网址www.sina.com为例（选择该网址，主要因为它的网页代码较短）：</p><pre><code>　　$ curl www.sina.com　　&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;　　&lt;html&gt;&lt;head&gt;　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;　　&lt;/head&gt;&lt;body&gt;　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;　　&lt;p&gt;The document has moved &lt;a href=&quot;http://www.sina.com.cn/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;　　&lt;/body&gt;&lt;/html&gt;</code></pre><p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用wget命令了。</p><pre><code>　　$ curl -o [文件名] www.sina.com</code></pre><h3 id="二、自动跳转"><a href="#二、自动跳转" class="headerlink" title="二、自动跳转"></a>二、自动跳转</h3><p>有的网址是自动跳转的。使用<code>-L</code>参数，curl就会跳转到新的网址。</p><pre><code>　　$ curl -L www.sina.com</code></pre><p>键入上面的命令，结果就自动跳转为www.sina.com.cn。</p><h3 id="三、显示头信息"><a href="#三、显示头信息" class="headerlink" title="三、显示头信息"></a>三、显示头信息</h3><p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p><pre><code>　　$ curl -i www.sina.com　　HTTP/1.0 301 Moved Permanently　　Date: Sat, 03 Sep 2011 23:44:10 GMT　　Server: Apache/2.0.54 (Unix)　　Location: http://www.sina.com.cn/　　Cache-Control: max-age=3600　　Expires: Sun, 04 Sep 2011 00:44:10 GMT　　Vary: Accept-Encoding　　Content-Length: 231　　Content-Type: text/html; charset=iso-8859-1　　Age: 3239　　X-Cache: HIT from sh201-9.sina.com.cn　　Connection: close　　&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;　　&lt;html&gt;&lt;head&gt;　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;　　&lt;/head&gt;&lt;body&gt;　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;　　&lt;p&gt;The document has moved &lt;a href=&quot;http://www.sina.com.cn/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;　　&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>-I</code>参数则是只显示http response的头信息。</p><h3 id="四、显示通信过程"><a href="#四、显示通信过程" class="headerlink" title="四、显示通信过程"></a>四、显示通信过程</h3><p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p><pre><code>　　$ curl -v www.sina.com　　* About to connect() to www.sina.com port 80 (#0)　　* Trying 61.172.201.195... connected　　* Connected to www.sina.com (61.172.201.195) port 80 (#0)　　&gt; GET / HTTP/1.1　　&gt; User-Agent: curl/7.21.3 (i686-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18　　&gt; Host: www.sina.com　　&gt; Accept: */*　　&gt;　　* HTTP 1.0, assume close after body　　&lt; HTTP/1.0 301 Moved Permanently　　&lt; Date: Sun, 04 Sep 2011 00:42:39 GMT　　&lt; Server: Apache/2.0.54 (Unix)　　&lt; Location: http://www.sina.com.cn/　　&lt; Cache-Control: max-age=3600　　&lt; Expires: Sun, 04 Sep 2011 01:42:39 GMT　　&lt; Vary: Accept-Encoding　　&lt; Content-Length: 231　　&lt; Content-Type: text/html; charset=iso-8859-1　　&lt; X-Cache: MISS from sh201-19.sina.com.cn　　&lt; Connection: close　　&lt;　　&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;　　&lt;html&gt;&lt;head&gt;　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;　　&lt;/head&gt;&lt;body&gt;　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;　　&lt;p&gt;The document has moved &lt;a href=&quot;http://www.sina.com.cn/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;　　&lt;/body&gt;&lt;/html&gt;　　* Closing connection #0</code></pre><p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p><pre><code>　　$ curl --trace output.txt www.sina.com</code></pre><p>或者</p><pre><code>　　$ curl --trace-ascii output.txt www.sina.com</code></pre><p>运行后，请打开output.txt文件查看。</p><h3 id="五、发送表单信息"><a href="#五、发送表单信息" class="headerlink" title="五、发送表单信息"></a>五、发送表单信息</h3><p>发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。</p><pre><code>　　$ curl example.com/form.cgi?data=xxx</code></pre><p>POST方法必须把数据和网址分开，curl就要用到–data参数。</p><pre><code>　　$ curl -X POST --data &quot;data=xxx&quot; example.com/form.cgi</code></pre><p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是<code>--data-urlencode</code>。</p><pre><code>　　$ curl -X POST--data-urlencode &quot;date=April 1&quot; example.com/form.cgi</code></pre><h3 id="六、HTTP动词"><a href="#六、HTTP动词" class="headerlink" title="六、HTTP动词"></a>六、HTTP动词</h3><p>curl默认的HTTP动词是GET，使用<code>-X</code>参数可以支持其他动词。</p><pre><code>　　$ curl -X POST www.example.com　　$ curl -X DELETE www.example.com</code></pre><h3 id="七、文件上传"><a href="#七、文件上传" class="headerlink" title="七、文件上传"></a>七、文件上传</h3><p>假定文件上传的表单是下面这样：</p><pre><code>　　&lt;form method=&quot;POST&quot; enctype=&apos;multipart/form-data&apos; action=&quot;upload.cgi&quot;&gt;　　　　&lt;input type=file name=upload&gt;　　　　&lt;input type=submit name=press value=&quot;OK&quot;&gt;　　&lt;/form&gt;</code></pre><p>你可以用curl这样上传文件：</p><pre><code>　　$ curl --form upload=@localfilename --form press=OK [URL]</code></pre><h3 id="八、Referer字段"><a href="#八、Referer字段" class="headerlink" title="八、Referer字段"></a>八、Referer字段</h3><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p><pre><code>　　$ curl --referer http://www.example.com http://www.example.com</code></pre><h3 id="九、User-Agent字段"><a href="#九、User-Agent字段" class="headerlink" title="九、User Agent字段"></a>九、User Agent字段</h3><p>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p><p>iPhone4的User Agent是</p><pre><code>　　Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</code></pre><p>curl可以这样模拟：</p><pre><code>　　$ curl --user-agent &quot;[User Agent]&quot; [URL]</code></pre><h3 id="十、cookie"><a href="#十、cookie" class="headerlink" title="十、cookie"></a>十、cookie</h3><p>使用<code>--cookie</code>参数，可以让curl发送cookie。</p><pre><code>　　$ curl --cookie &quot;name=xxx&quot; www.example.com</code></pre><p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p><p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p><pre><code>　　$ curl -c cookies http://example.com　　$ curl -b cookies http://example.com</code></pre><h3 id="十一、增加头信息"><a href="#十一、增加头信息" class="headerlink" title="十一、增加头信息"></a>十一、增加头信息</h3><p>有时需要在http request之中，自行增加一个头信息。<code>--header</code>参数就可以起到这个作用。</p><pre><code>　　$ curl --header &quot;Content-Type:application/json&quot; http://example.com</code></pre><h3 id="十二、HTTP认证"><a href="#十二、HTTP认证" class="headerlink" title="十二、HTTP认证"></a>十二、HTTP认证</h3><p>有些网域需要HTTP认证，这时curl需要用到<code>--user</code>参数。</p><pre><code>　　$ curl --user name:password example.com</code></pre><h3 id="十三、监控"><a href="#十三、监控" class="headerlink" title="十三、监控"></a>十三、监控</h3><p>1、开启gzip请求</p><pre><code>curl -I http://www.sina.com.cn/ -H Accept-Encoding:gzip,defalte</code></pre><p>2、监控网页的响应时间</p><pre><code>curl -o /dev/null -s -w &quot;time_connect: %{time_connect}\ntime_starttransfer: %{time_starttransfer}\ntime_total: %{time_total}\n&quot; &quot;http://www.kklinux.com&quot;</code></pre><p>3、 监控站点可用性</p><pre><code>curl -o /dev/null -s -w %{http_code} &quot;http://www.kklinux.com&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>nginx的502问题</title>
    <link href="http://martist.cn/2018/03/14/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/Nginx%20+%20PHP%EF%BC%88php-fpm%EF%BC%89%E9%81%87%E5%88%B0%E7%9A%84502%20Bad%20Gateway%E9%94%99%E8%AF%AF/"/>
    <id>http://martist.cn/2018/03/14/服务部署/Nginx + PHP（php-fpm）遇到的502 Bad Gateway错误/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-04-19T09:38:59.951Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>nginx出现502有很多原因，但大部分原因可以归结为资源数量不够用,也就是说后端PHP-fpm处理有问题，nginx将正确的客户端请求发给了后端的php-fpm进程，但是因为php-fpm进程的问题导致不能正确解析php代码，最终返回给了客户端502错误。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>nginx+php出现502 bad gateway，一般这都不是nginx的问题，而是由于 fastcgi或者php的问题导致的，常见的有以下几种(其实解决问题的最好的方式还是自己去看nginx和fastcgi的errorlog):</p><h3 id="php-ini的memory-limit-过小"><a href="#php-ini的memory-limit-过小" class="headerlink" title="php.ini的memory_limit 过小"></a>php.ini的memory_limit 过小</h3><p>如果有个别php程序进程需要占用极大内存时这个必须注意</p><h3 id="php-fpm-conf中max-children或者max-requests设置不合理"><a href="#php-fpm-conf中max-children或者max-requests设置不合理" class="headerlink" title="php-fpm.conf中max_children或者max_requests设置不合理"></a>php-fpm.conf中max_children或者max_requests设置不合理</h3><p>设置过小会因为没有足够的cgi进程处理请求，设置过大会出现一会儿有响应正常，一会儿等很久才有响应的情况，一般情况下children按 照内存计算，比如说1G设置64，2G128。这个根据实际情况自行调整。另外查看当前的PHP FastCGI进程数是否够用的命令为：netstat  -anpo |grep &ldquo;php-cgi&rdquo; | wc -l   如果实际使用的&ldquo;FastCGI进程数&rdquo;接近预设的&ldquo;FastCGI进程数&rdquo;，那么，说明&ldquo;FastCGI进程数&rdquo;不够用，需要增大。</p><h3 id="查看nginx错误日志"><a href="#查看nginx错误日志" class="headerlink" title="查看nginx错误日志"></a>查看nginx错误日志</h3><p>发现 pstream sent too big header while reading response  headerfrom upstream ，则检查client head buffer，fastcgi buffer  size是否过小，可设置为32K。</p><h3 id="php程序执行时间过长而超时"><a href="#php程序执行时间过长而超时" class="headerlink" title="php程序执行时间过长而超时"></a>php程序执行时间过长而超时</h3><p>检查各种timeout设置：</p><p>nginx</p><pre><code>fastcgi_connect_timeout 300fastcgi_send_timeout    300fastcgi_read_timeout    300keepalive_timeout</code></pre><p>php-fpm</p><pre><code>request_terminate_timeout</code></pre><p>php.ini</p><pre><code>max_execution_time</code></pre><h3 id="max-requests【php-fpm】"><a href="#max-requests【php-fpm】" class="headerlink" title="max_requests【php-fpm】"></a>max_requests【php-fpm】</h3><p>php-fpm有一个参数 max_requests ，该参数指明了每个children最多处理多少个请求后便会被关闭。在大量处理请求下，如果该值设置过小会导致children频繁的自杀和建立而浪费 大量时间，若所有的children差不多都在这个时候自杀，则重建前将没有children响应请求，于是出现502  。可以将该值设置大一些或者是0[无限]。</p><h2 id="高并发引起的502"><a href="#高并发引起的502" class="headerlink" title="高并发引起的502"></a>高并发引起的502</h2><p>如果你服务器并发量非常大，那只能先增加机器，然后按以下方式优化会取得更好效果;但如果你并发不大却出现502，一般都可以归结为配置问题，脚本超时问题。</p><h3 id="php-fpm进程数不够用"><a href="#php-fpm进程数不够用" class="headerlink" title="php-fpm进程数不够用"></a>php-fpm进程数不够用</h3><p>使用netstat -napo |grep “php-fpm” | wc -l查看一下当前fastcgi进程个数，如果个数接近conf里配置的上限，就需要调高进程数。<br>但也不能无休止调高，可以根据服务器内存情况，可以把php-fpm子进程数调到100或以上，在4G内存的服务器上200就可以。</p><h3 id="调高调高Linux内核打开文件数量"><a href="#调高调高Linux内核打开文件数量" class="headerlink" title="调高调高Linux内核打开文件数量"></a>调高调高Linux内核打开文件数量</h3><p>可以使用这些命令(必须是root帐号)</p><pre><code>echo &apos;ulimit -HSn 65536&apos;&gt;&gt; /etc/profileecho &apos;ulimit -HSn 65536&apos;&gt;&gt; /etc/rc.localsource /etc/profile</code></pre><h3 id="缓存设置比较小"><a href="#缓存设置比较小" class="headerlink" title="缓存设置比较小"></a>缓存设置比较小</h3><p>修改或增加配置到nginx.conf</p><pre><code>proxy_buffer_size 64k;proxy_buffers  512k;proxy_busy_buffers_size 128k;</code></pre><h3 id="运维问题"><a href="#运维问题" class="headerlink" title="运维问题"></a>运维问题</h3><pre><code>recv()failed (104: Connection reset by peer) while reading response header fromupstream</code></pre><p>发生这种错误，可能的原因机房网络丢包或者机房有硬件防火墙禁止访问该域名。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php-fpm" scheme="http://martist.cn/categories/php-fpm/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
      <category term="php-fpm" scheme="http://martist.cn/tags/php-fpm/"/>
    
  </entry>
  
  <entry>
    <title>关于php的单例模式</title>
    <link href="http://martist.cn/2018/03/12/%E6%9E%B6%E6%9E%84/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://martist.cn/2018/03/12/架构/单例模式的理解/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-04-23T08:02:17.540Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><blockquote><p>单例模式(Singleton Pattern)：顾名思义，就是只有一个实例。作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p></blockquote><h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><p>1、PHP语言本身的局限性<br>PHP语言是一种解释型的脚本语言，这种运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收。也就是说，PHP在语言级别上没有办法让某个对象常驻内存，这和asp.NET、Java等编译型是不同的，比如在Java中单例会一直存在于整个应用程序的生命周期里，变量是跨页面级的，真正可以做到这个实例在应用程序生命周期中的唯一性。然而在PHP中，所有的变量无论是全局变量还是类的静态成员，都是页面级的，每次页面被执行时，都会重新建立新的对象，都会在页面执行完毕后被清空，这样似乎PHP单例模式就没有什么意义了，所以PHP单例模式我觉得只是针对单次页面级请求时出现多个应用场景并需要共享同一对象资源时是非常有意义的。</p><p>2、应用场景<br>一个应用中会存在大量的数据库操作，比如过数据库句柄来连接数据库这一行为，使用单例模式可以避免大量的new操作，因为每一次new操作都会消耗内存资源和系统资源。<br>如果系统中需要有一个类来全局控制某些配置信息,那么使用单例模式可以很方便的实现.</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>一个类只能有一个对象</li><li>必须是自行创建这个类的对象</li><li>要想整个系统提供这一个对象</li></ol><h2 id="具体实现的重点"><a href="#具体实现的重点" class="headerlink" title="具体实现的重点"></a>具体实现的重点</h2><ol><li>单例模式的类只提供私有的构造函数，</li><li>类定义中含有一个该类的静态私有对象，</li><li>该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>class Singleton{        //存放实例 私有静态变量        private static $_instance = null;        //私有化构造方法、        private function __construct(){            echo &quot;单例模式的实例被构造了&quot;;        }        //私有化克隆方法        private function __clone(){        }        //公有化获取实例方法        public static function getInstance(){            if (!(self::$_instance instanceof Singleton)){                self::$_instance = new Singleton();            }            return self::$_instance;        }    }    $singleton=Singleton::getInstance();</code></pre><h2 id="OOP知识补习"><a href="#OOP知识补习" class="headerlink" title="OOP知识补习"></a>OOP知识补习</h2><h3 id="类型运算符instanceof"><a href="#类型运算符instanceof" class="headerlink" title="类型运算符instanceof"></a>类型运算符instanceof</h3><pre><code>&lt;?phpclass MyClass{}class NotMyClass{}$a = new MyClass;var_dump($a instanceof MyClass);var_dump($a instanceof NotMyClass);?&gt;</code></pre><p>以上例程会输出：</p><pre><code>bool(true)bool(false)</code></pre><p>instanceof用于确定一个变量是不是实现了某个类，继承类，接口的对象的实例。<br>如果被检测的变量不是对象，instanceof 并不发出任何错误信息而是返回 FALSE。不允许用来检测常量。</p><h3 id="魔术方法-construct"><a href="#魔术方法-construct" class="headerlink" title="魔术方法__construct()"></a>魔术方法__construct()</h3><p>构造方法声明为private，防止直接创建对象 ，这样new Singleton() 会报错。</p><p>  private function __construct()<br>  {<br>      echo ‘Iam constructed’;<br>  }</p><h3 id="魔术方法-clone"><a href="#魔术方法-clone" class="headerlink" title="魔术方法__clone()"></a>魔术方法__clone()</h3><p>当类的复制完成时，如果定义了<strong>clone()方法，则新创建的对象（复制生成的对象）中的</strong>clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。私有化<strong>clone可以防止克隆该类的对象。<br>注意一点：clone的对象不执行</strong>construct里的方法</p><p>所以我们在防止单例模式的 $singleton对象被clone，有两种方法可以做到。</p><p>第一种方法:设置魔术方法<strong>clone();访问权限为private<br>第二种方法:若</strong>clone()为公用方法，则在函数中加上自定义错误。</p><pre><code>// 阻止用户复制对象实例public function __clone(){    trigger_error(&apos;Clone is not allowed.&apos;,E_USER_ERROR);}</code></pre><blockquote><p>关于 <strong>clone() , PHP官方的文档： Once the cloing is complete, if a </strong>clone() method is defined, then the newly created object’s __clone() method will be called, to allow any necessary properties that need to be changed.</p></blockquote><h3 id="关键字clone和赋值"><a href="#关键字clone和赋值" class="headerlink" title="关键字clone和赋值"></a>关键字clone和赋值</h3><pre><code>class foo {    public $bar = &apos;php&apos;;}$foo = new foo();$a = $foo; // 标识符赋值(把$a赋值为null,原来的$foo并不会变成null,但通过$a能够修改$foo的成员$bar)$a = &amp;$foo; // 引用赋值(把$a赋值为null,原来的$foo也会跟着变成null)$a = clone $foo; // 值赋值(赋值后互不影响，在计算机内存上的体现属于浅复制)</code></pre><h3 id="对象复制"><a href="#对象复制" class="headerlink" title="对象复制"></a>对象复制</h3><p>在PHP中， 对象间的赋值操作实际上是引用操作 （事实上，绝大部分的编程语言都是如此! 主要原因是内存及性能的问题) ， 比如 :</p><pre><code>class myclass {public $data;}$obj1 = new myclass();$obj1-&gt;data = &quot;aaa&quot;；$obj2 = $obj1;$obj2-&gt;data =&quot;bbb&quot;;     //$obj1-&gt;data的值也会变成&quot;bbb&quot;</code></pre><p>因为$obj1和$obj2都是指向同一个内存区的引用，所以修改任何一个对象都会同时修改另外一个对象。</p><p>在有些时候，我们其实不希望这种reference式的赋值方式， 我们希望能完全复制一个对象，这是侯就需要用到 Php中的clone (对象复制）。</p><pre><code>class myclass {public $data;}$obj1 = new myclass();$obj1-&gt;data =&quot;aaa&quot;;$obj2 = clone $obj1;$obj2-&gt;data =&quot;bbb&quot;;     // $obj1-&gt;data的值仍然为&quot;aaa&quot;</code></pre><p>因为clone的方式实际上是对整个对象的内存区域进行了一次复制并用新的对象变量指向新的内存， 因此赋值后的对象和源对象相互之间是基本来说独立的。</p><h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p>什么？ 基本独立？！这是什么意思？ 因为PHP的object clone采用的是浅复制(shallow copy)的方法, 如果对象里的属性成员本身就是reference类型的，clone以后这些成员并没有被真正复制，仍然是引用的。 （事实上，其他大部分语言也是这样实现的， 如果你对C++的内存，拷贝，copy constructor等概念比较熟悉，就很容易理解这个概念）, 下面是一个例子来说明：</p><pre><code>class myClass{public $data;}$sss =&quot;aaa&quot;;$obj1 = new myClass();$obj1-&gt;data =&amp;$sss;   //注意，这里是个reference!$obj2 = clone $obj1;$obj2-&gt;data=&quot;bbb&quot;;  //这时，$obj1-&gt;data的值变成了&quot;bbb&quot; 而不是&quot;aaa&quot;!var_dump($obj1);var_dump($obj2);</code></pre><p>我们再举一个更实用的例子来说明一下PHP clone这种浅复制带来的后果：</p><pre><code>class testClass{   public $str_data;   public $obj_data;}$dateTimeObj = new DateTime(&quot;2014-07-05&quot;, new DateTimeZone(&quot;UTC&quot;));$obj1 = new testClass();$obj1-&gt;str_data =&quot;aaa&quot;;$obj1-&gt;obj_data = $dateTimeObj;$obj2 = clone $obj1;var_dump($obj1);    // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;var_dump($obj2);    // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;$obj2-&gt;str_data =&quot;bbb&quot;;$obj2-&gt;obj_data-&gt;add(new DateInterval(&apos;P10D&apos;));      //给$obj2-&gt;obj_date 的时间增加了10天var_dump($obj1);     // str_data：&quot;aaa&quot;   obj_data：&quot;2014-07-15 00:00:00&quot;  !!!!var_dump($obj2);     // str_data：&quot;bbb&quot;   obj_data：&quot;2014-07-15 00:00:00&quot;var_dump($dateTimeObj)  // 2014-07-15 00:00:00&quot;</code></pre><p>这一下可以更加清楚的看到问题了吧。 一般来讲，你用clone来复制对象，希望是把两个对象彻底分开，不希望他们之间有任何关联， 但由于clone的shallow copy的特性， 有时候会出现非你期望的结果.</p><h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>1) $obj1-&gt;obj_data =$dateTimeObj 这句话实际上是个引用类型的赋值. 还记得前面提到的PHP中对象直接的赋值是引用操作么？除非你用$obj1-&gt;obj_dat = clone $dataTimeObj!</p><p>2) $obj2 = clone $obj1 这句话生成了一个obj1对象的浅复制对象，并赋给obj2. 由于是浅复制，obj2中的obj_data也是对$dateTimeObj的引用！</p><p>3）$dateTimeObj, $obj1-&gt;obj_data, $obj2-&gt;obj_data 实际上是同一个内存区对象数据的引用，因此修改其中任何一个都会影响其他两个！</p><p>如何解决这个问题呢？ 采用PHP中的 __clone方法 把浅复制转换为深复制（这个方法给C++中的copy constructor概念上有些相似，但执行流程并不一样）</p><pre><code>class testClass{ public $str_data; public $obj_data; public function __clone() {   $this-&gt;obj_data = clone $this-&gt;obj_data;}$dateTimeObj = new DateTime(&quot;2014-07-05&quot;, new DateTimeZone(&quot;UTC&quot;));$obj1 = new testClass();$obj1-&gt;str_data =&quot;aaa&quot;;$obj1-&gt;obj_data = $dateTimeObj;$obj2 = clone $obj1;var_dump($obj1);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;var_dump($obj2);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;$obj2-&gt;str_data =&quot;bbb&quot;;$obj2-&gt;obj_data-&gt;add(new DateInterval(&apos;P10D&apos;));var_dump($obj1);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;var_dump($obj2);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-15 00:00:00&quot;var_dump($dateTimeObj);  //&quot;2014-07-05 00:00:00&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>nginx优化</title>
    <link href="http://martist.cn/2018/03/11/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/nginx%E4%BC%98%E5%8C%96/"/>
    <id>http://martist.cn/2018/03/11/服务部署/nginx优化/</id>
    <published>2018-03-10T16:00:00.000Z</published>
    <updated>2018-04-19T09:57:02.056Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="nginx配置文件中"><a href="#nginx配置文件中" class="headerlink" title="nginx配置文件中"></a>nginx配置文件中</h1><h2 id="worker-processes-8"><a href="#worker-processes-8" class="headerlink" title="worker_processes 8;"></a>worker_processes 8;</h2><p>nginx进程数，建议按照cpu数目来指定，一般为它的倍数,平时设置为2倍。</p><p>cpu个数查看方法参考:<a href="http://blog.haohtml.com/archives/11123" target="_blank" rel="external">http://blog.haohtml.com/archives/11123</a> 和 <a href="http://blog.haohtml.com/archives/9236" target="_blank" rel="external">http://blog.haohtml.com/archives/9236</a></p><h2 id="worker-cpu-affinity-00000001-00000010-00000100-00001000-00010000-00100000-01000000-10000000"><a href="#worker-cpu-affinity-00000001-00000010-00000100-00001000-00010000-00100000-01000000-10000000" class="headerlink" title="worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;"></a>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</h2><p>为每个进程分配cpu，上例中将8个进程分配到8个cpu，当然可以写多个，或者将一个进程分配到多个cpu。对worker_cu_affinity参数的优化参考:<a href="http://blog.haohtml.com/archives/14835" target="_blank" rel="external">http://blog.haohtml.com/archives/14835</a></p><h2 id="worker-rlimit-nofile-102400"><a href="#worker-rlimit-nofile-102400" class="headerlink" title="worker_rlimit_nofile 102400;"></a>worker_rlimit_nofile 102400;</h2><p>这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。ulimit的用法参考：<a href="http://blog.haohtml.com/archives/9883" target="_blank" rel="external">http://blog.haohtml.com/archives/9883</a></p><h2 id="use-epoll"><a href="#use-epoll" class="headerlink" title="use epoll;"></a>use epoll;</h2><p>使用epoll的I/O模型，这个不用说了吧。</p><h2 id="worker-connections-102400"><a href="#worker-connections-102400" class="headerlink" title="worker_connections 102400;"></a>worker_connections 102400;</h2><p>每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为worker_processes*worker_connections。</p><h2 id="keepalive-timeout-60"><a href="#keepalive-timeout-60" class="headerlink" title="keepalive_timeout 60;"></a>keepalive_timeout 60;</h2><p>keepalive超时时间。</p><h2 id="client-header-buffer-size-4k"><a href="#client-header-buffer-size-4k" class="headerlink" title="client_header_buffer_size 4k;"></a>client_header_buffer_size 4k;</h2><p>客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</p><h2 id="open-file-cache-max-102400-inactive-20s"><a href="#open-file-cache-max-102400-inactive-20s" class="headerlink" title="open_file_cache max=102400 inactive=20s;"></a>open_file_cache max=102400 inactive=20s;</h2><p>这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</p><h2 id="open-file-cache-valid-30s"><a href="#open-file-cache-valid-30s" class="headerlink" title="open_file_cache_valid 30s;"></a>open_file_cache_valid 30s;</h2><p>这个是指多长时间检查一次缓存的有效信息。</p><h2 id="open-file-cache-min-uses-1"><a href="#open-file-cache-min-uses-1" class="headerlink" title="open_file_cache_min_uses 1;"></a>open_file_cache_min_uses 1;</h2><p>open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</p><h1 id="关于内核参数的优化-etc-sysctl-conf-："><a href="#关于内核参数的优化-etc-sysctl-conf-：" class="headerlink" title="关于内核参数的优化(/etc/sysctl.conf)："></a>关于内核参数的优化(/etc/sysctl.conf)：</h1><h2 id="net-ipv4-tcp-max-tw-buckets-6000"><a href="#net-ipv4-tcp-max-tw-buckets-6000" class="headerlink" title="net.ipv4.tcp_max_tw_buckets = 6000"></a>net.ipv4.tcp_max_tw_buckets = 6000</h2><p>timewait的数量，默认是180000。</p><h2 id="net-ipv4-ip-local-port-range-1024-65000"><a href="#net-ipv4-ip-local-port-range-1024-65000" class="headerlink" title="net.ipv4.ip_local_port_range = 1024    65000"></a>net.ipv4.ip_local_port_range = 1024    65000</h2><p>允许系统打开的端口范围。</p><h2 id="net-ipv4-tcp-tw-recycle-1"><a href="#net-ipv4-tcp-tw-recycle-1" class="headerlink" title="net.ipv4.tcp_tw_recycle = 1"></a>net.ipv4.tcp_tw_recycle = 1</h2><p>启用timewait快速回收。</p><h2 id="net-ipv4-tcp-tw-reuse-1"><a href="#net-ipv4-tcp-tw-reuse-1" class="headerlink" title="net.ipv4.tcp_tw_reuse = 1"></a>net.ipv4.tcp_tw_reuse = 1</h2><p>开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。</p><h2 id="net-ipv4-tcp-syncookies-1"><a href="#net-ipv4-tcp-syncookies-1" class="headerlink" title="net.ipv4.tcp_syncookies = 1"></a>net.ipv4.tcp_syncookies = 1</h2><p>开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。</p><h2 id="net-core-somaxconn-262144"><a href="#net-core-somaxconn-262144" class="headerlink" title="net.core.somaxconn = 262144"></a>net.core.somaxconn = 262144</h2><p>web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。</p><h2 id="net-core-netdev-max-backlog-262144"><a href="#net-core-netdev-max-backlog-262144" class="headerlink" title="net.core.netdev_max_backlog = 262144"></a>net.core.netdev_max_backlog = 262144</h2><p>每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</p><h2 id="net-ipv4-tcp-max-orphans-262144"><a href="#net-ipv4-tcp-max-orphans-262144" class="headerlink" title="net.ipv4.tcp_max_orphans = 262144"></a>net.ipv4.tcp_max_orphans = 262144</h2><p>系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。</p><h2 id="net-ipv4-tcp-max-syn-backlog-262144"><a href="#net-ipv4-tcp-max-syn-backlog-262144" class="headerlink" title="net.ipv4.tcp_max_syn_backlog = 262144"></a>net.ipv4.tcp_max_syn_backlog = 262144</h2><p>记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。</p><h2 id="net-ipv4-tcp-timestamps-0"><a href="#net-ipv4-tcp-timestamps-0" class="headerlink" title="net.ipv4.tcp_timestamps = 0"></a>net.ipv4.tcp_timestamps = 0</h2><p>时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。</p><h2 id="net-ipv4-tcp-synack-retries-1"><a href="#net-ipv4-tcp-synack-retries-1" class="headerlink" title="net.ipv4.tcp_synack_retries = 1"></a>net.ipv4.tcp_synack_retries = 1</h2><p>为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。</p><h2 id="net-ipv4-tcp-syn-retries-1"><a href="#net-ipv4-tcp-syn-retries-1" class="headerlink" title="net.ipv4.tcp_syn_retries = 1"></a>net.ipv4.tcp_syn_retries = 1</h2><p>在内核放弃建立连接之前发送SYN包的数量。</p><h2 id="net-ipv4-tcp-fin-timeout-1"><a href="#net-ipv4-tcp-fin-timeout-1" class="headerlink" title="net.ipv4.tcp_fin_timeout = 1"></a>net.ipv4.tcp_fin_timeout = 1</h2><p>如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60 秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。</p><h2 id="net-ipv4-tcp-keepalive-time-30"><a href="#net-ipv4-tcp-keepalive-time-30" class="headerlink" title="net.ipv4.tcp_keepalive_time = 30"></a>net.ipv4.tcp_keepalive_time = 30</h2><p>当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时。</p><h1 id="完整的内核优化设置"><a href="#完整的内核优化设置" class="headerlink" title="完整的内核优化设置"></a>完整的内核优化设置</h1><pre><code>net.ipv4.ip_forward = 0net.ipv4.conf.default.rp_filter = 1net.ipv4.conf.default.accept_source_route = 0kernel.sysrq = 0kernel.core_uses_pid = 1net.ipv4.tcp_syncookies = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.shmmax = 68719476736kernel.shmall = 4294967296net.ipv4.tcp_max_tw_buckets = 6000net.ipv4.tcp_sack = 1net.ipv4.tcp_window_scaling = 1net.ipv4.tcp_rmem = 4096        87380   4194304net.ipv4.tcp_wmem = 4096        16384   4194304net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.core.netdev_max_backlog = 262144net.core.somaxconn = 262144net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_timestamps = 0net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_fin_timeout = 1net.ipv4.tcp_keepalive_time = 30net.ipv4.ip_local_port_range = 1024    65000</code></pre><h1 id="nginx配置文件"><a href="#nginx配置文件" class="headerlink" title="nginx配置文件"></a>nginx配置文件</h1><pre><code>user  www www;worker_processes 8;worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000;error_log  /www/log/nginx_error.log  crit;pid        /usr/local/nginx/nginx.pid;worker_rlimit_nofile 204800;events{use epoll;worker_connections 204800;}http{include       mime.types;default_type  application/octet-stream;charset  utf-8;server_names_hash_bucket_size 128;client_header_buffer_size 2k;large_client_header_buffers 4 4k;client_max_body_size 8m;sendfile on;tcp_nopush     on;keepalive_timeout 60;fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2keys_zone=TEST:10minactive=5m;fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;fastcgi_buffer_size 64k;fastcgi_buffers 8 64k;fastcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k;fastcgi_cache TEST;fastcgi_cache_valid 200 302 1h;fastcgi_cache_valid 301 1d;fastcgi_cache_valid any 1m;fastcgi_cache_min_uses 1;fastcgi_cache_use_stale error timeout invalid_header http_500;open_file_cache max=204800 inactive=20s;open_file_cache_min_uses 1;open_file_cache_valid 30s;tcp_nodelay on;gzip on;gzip_min_length  1k;gzip_buffers     4 16k;gzip_http_version 1.0;gzip_comp_level 2;gzip_types       text/plain application/x-javascript text/css application/xml;gzip_vary on;server{listen       8080;server_name  backup.aiju.com;index index.php index.htm;root  /www/html/;  #这里的位置很重要，不要写在其它指令里面，我曾经就调试了好久才发现这个问题的location /status{stub_status on;}location ~ .*\.(php|php5)?${fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;include fcgi.conf;}location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css)${expires      30d;}log_format  access  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;&apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;access_log  /www/log/access.log  access;}}</code></pre><h1 id="关于FastCGI的几个指令"><a href="#关于FastCGI的几个指令" class="headerlink" title="关于FastCGI的几个指令"></a>关于FastCGI的几个指令</h1><pre><code>fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2 keys_zone=TEST:10m inactive=5m;这个指令为FastCGI缓存指定一个路径，目录结构等级，关键字区域存储时间和非活动删除时间。fastcgi_connect_timeout 300;指定连接到后端FastCGI的超时时间。fastcgi_send_timeout 300;向FastCGI传送请求的超时时间，这个值是指已经完成两次握手后向FastCGI传送请求的超时时间。fastcgi_read_timeout 300;接收FastCGI应答的超时时间，这个值是指已经完成两次握手后接收FastCGI应答的超时时间。fastcgi_buffer_size 64k;指定读取FastCGI应答第一部分需要用多大的缓冲区，一般第一部分应答不会超过1k，由于页面大小为4k，所以这里设置为4k。fastcgi_buffers 8 64k;指定本地需要用多少和多大的缓冲区来缓冲FastCGI的应答。fastcgi_busy_buffers_size 128k;这个指令我也不知道是做什么用，只知道默认值是fastcgi_buffers的两倍。fastcgi_temp_file_write_size 128k;在写入fastcgi_temp_path时将用多大的数据块，默认值是fastcgi_buffers的两倍。fastcgi_cache TEST开启FastCGI缓存并且为其制定一个名称。个人感觉开启缓存非常有用，可以有效降低CPU负载，并且防止502错误。fastcgi_cache_valid 200 302 1h;fastcgi_cache_valid 301 1d;fastcgi_cache_valid any 1m;为指定的应答代码指定缓存时间，如上例中将200，302应答缓存一小时，301应答缓存1天，其他为1分钟。fastcgi_cache_min_uses 1;缓存在fastcgi_cache_path指令inactive参数值时间内的最少使用次数，如上例，如果在5分钟内某文件1次也没有被使用，那么这个文件将被移除。fastcgi_cache_use_stale error timeout invalid_header http_500;不知道这个参数的作用，猜想应该是让nginx知道哪些类型的缓存是没用的。以上为nginx中FastCGI相关参数，另外，FastCGI自身也有一些配置需要进行优化，如果你使用php-fpm来管理FastCGI，可以修改配置文件中的以下值：&lt;value name=&quot;max_children&quot;&gt;60&lt;/value&gt;同时处理的并发请求数，即它将开启最多60个子线程来处理并发连接。&lt;value name=&quot;rlimit_files&quot;&gt;102400&lt;/value&gt;最多打开文件数。&lt;value name=&quot;max_requests&quot;&gt;204800&lt;/value&gt;每个进程在重置之前能够执行的最多请求数。</code></pre><p>1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="nginx" scheme="http://martist.cn/categories/nginx/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>让我们脱离国定器械</title>
    <link href="http://martist.cn/2018/03/03/%E5%81%A5%E8%BA%AB/%E8%84%B1%E7%A6%BB%E5%9B%BD%E5%AE%9A%E5%99%A8%E6%A2%B0/"/>
    <id>http://martist.cn/2018/03/03/健身/脱离国定器械/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2018-04-12T12:00:05.603Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><blockquote><p>从安全角度讲，为什么不推荐史密斯架等固定轨迹器械训练？</p></blockquote><p>我说来说去都是杠铃、哑铃（其实哑铃我都没说过），从不推荐练史密斯架或是各种各样的固定轨迹器械。这是为什么？今天，我从安全角度来说说。针对普通训练者，高阶健美、康复阶段等不在探讨范围内。</p><p>看我文章的，大多是去过健身房的。健身房的一大特色就是，那里总有一堆一堆的器械，看上去很高级，甚至让初学者神往。有不少人问我，健身房的那些器械不会用，怎么办？我的回答很简单：那太好了，你直接路过就行，别碰它们。</p><p>我这么说，不是想拉人来我的地方训练，更不是不负责任，仅仅是从安全角度为他们考虑。</p><p>很多人认为，那些固定器械很安全，掉不下来，砸不到人，不会出事故。这是对的，非常正确的，所以，健身房就有了这些东西，注意——是为了不出事故。健身房不希望你深蹲的时候，哦，对了，好多健身房连自由深蹲架都没有，卧推吧。健身房不希望你卧推的时候被杠铃压在下面，你左右扭动，最终把杠铃扔到地上了，结果地板上多了一个坑；他们也不希望你左右扭动，却没扭出来，结果受伤了。所以，健身房要有那些能确保不会出现人身事故、财产损失的家伙，于是，“安全”的固定轨迹器械就诞生了。</p><p>可是，好像从没有人考虑，这些器械，对于自己的训练，会不会出问题。其实不是不考虑，是很多人考虑不到。我今天要说的安全，是关于训练者自己的，而不是关于健身房的经营者的。</p><p>我们还是拿一个几乎所有人都会做且都做过的项目来说吧——卧推。</p><p>这个动作功能性、结构性都很差，但力量表现很好，而且，当泵感上来的时候，借用我一个学员的话：“很屌的感觉”。那么卧推的时候，简单地说，主要发力肌群是胸大肌、肱三头肌、三角肌前束，这是我们都知道的。卧推在向心收缩过（把杠铃推起，向心离心搞不清楚的，请看文末扩展阅读）程中，主要是胸大肌、三角肌前束负责改变肩关节角度，肱三头肌伸展肘关节。但是，请注意，胸前那个家伙是相当重的啊，负责稳定的肌群要保证杠铃轨迹，千万不能让它远离我们控制的范围，换句话说，就是还有一些肌肉要保证杠铃别跑到眼睛或肚子上方。</p><p>可是在史密斯架卧推的时候呢，重量大了或次数多了，主发力肌群力量不足，而轨迹又被固定了，那么无论你的力是朝着哪个方向，只要有一点向上的意思杠铃就能向上走。结果显而易见，当即将力竭或是训练者无法准确控制动作的时候，所有负责稳定的肌群就都会参与发力，于是，关节只能承受50公斤的时候，你60公斤也一样推得起来。在史密斯架上，50公斤的力量、50公斤承受能力，推60公斤的杠铃，推一次可以，推十次，我就想问问你肩关节还是否舒服了。</p><p>再说了，如果你对自己的肩关节负责的话，卧推，能直上直下吗？</p><p>所有让负责稳定的肌群无需发力控制轨迹的固定轨迹器械，对普通训练者都非常糟糕。当然，作为职业健美运动员，这些器械是有价值的，它们可以让训练者更好地训练目标肌群。请注意，职业运动员，成绩是第一位的，其它都不重要。带伤上场、比赛受伤都是很常见的，现在禁药查得这么严，很多运动员不照样用嘛。但这作为他们的职业，就像你明知熬夜不好、作息颠倒不好，为了工作，有时候不也得这么干嘛。</p><p>问题是，你是职业健美运动员吗，你致力于成为职业健美运动员吗，你具备职业健美运动员的训练水平吗？不是的话，咱还是照着普通人健身的思路走，悠着点吧。</p><p>史密斯架深蹲，和史密斯架卧推还是有区别的。但是，深蹲这事，肩上那个杠铃很重，重到你不愿出现一点点重心不稳的情况，有保护还好，不然一不小心就是事故。而史密斯架深蹲就不一样了，什么节律、什么重心、什么前后左右，统统不用管，你就可劲干吧。50公斤的力量、50公斤承受能力，深蹲60公斤的杠铃。</p><p>健身房里，见过史密斯架前有人做“老熊蹭树”的动作吧？就是双脚站在杠铃投影前面老远做深蹲。蹲下去的时候躯干竖直，从侧面看就像是扛着杠铃坐上了一个不可见的椅子。你在侧面看一会，就能理解这诡异的动作为什么叫“老熊蹭树”了。如果他们的理由是这动作不伤膝盖，因为膝盖不会过脚尖，请看扩展阅读，深蹲能否过脚尖这事我写过了。</p><p>说道这，结论该有了。固定轨迹的器械会让训练者负责稳定的肌群参与发力。随着时间的推移，关节承受不了的重量长时间被使用，最终，训练者受伤。这时候，你到哪说理去呢？</p><p>如果你还对那些看上去很高级的器械神往的话，希望你看了这篇小文能有所收获，为了你自己，为了将陪你一辈子的关节考虑，放弃那些为健身房经营者设计的玩意吧。</p><p>多说一句。钢线器械不一样啊，不是固定轨迹的。钢线很好，不像杠铃哑铃壶铃之类只能对抗向下的重力，它可以让阻力朝向任何你需要的方向。比如，练肩外旋的同志们，用哑铃可苦了，得趴着或撅着，有了钢线器械，你想站着、坐着、甚至躺着都行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="健身" scheme="http://martist.cn/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="http://martist.cn/2018/03/02/%E6%9E%B6%E6%9E%84/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://martist.cn/2018/03/02/架构/中间件/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-03-27T07:38:10.575Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>根据zend-framework中的定义：</p><pre><code>所谓中间件是指提供在请求和响应之间的，能够截获请求，并在其基础上进行逻辑处理，与此同时能够完成请求的响应或传递到下一个中间件的代码。</code></pre><p>在两个服务之间的模块，都可以称为中间件。</p><p>中间件应该一种架构方法，不局限于特定的语言。<br>例如提供不同应用之间消息通讯的消息中间件。淘宝下面很多产品之间都需要信息共享，通过一个中间人来专门传递消息。这样做很容易扩展，对上层应用提供统一消息操作接口就行了。<br>单个程序内部也可以有中间件，一个程序内部实现对中间件接口对支持。<br>把底层的接口包装一层，然后向上层提供接口。这样底层改变的话，上层也就是你写的代码不用动，只改中间件即可。由于只有中间件一个地方调用底层，改起来会比较方便。</p><h2 id="有哪些"><a href="#有哪些" class="headerlink" title="有哪些"></a>有哪些</h2><p>非底层操作系统软件、非业务应用软件，不是直接给最终用户使用的，不能直接给客户带来价值的软件，统称中间件。常见的有如下几种：服务中间件、集成中间件、数据中间件、消息中间件、安全中间件。</p><p>用Java实现的中间件，统称Java中间件。中间件，可以理解为类库，介于类库和产品之间。中间件真的是java世界的产物，我等phper能找的资料太少了。</p><p>说简单一点，就是你的程序A和程序B互相通信使用的协议，程序A,B可以由不同语言不同平台构建。但是协议可以保证他们能互相认识互发的东西。</p><p>简单说，中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件是不可替换的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。</p><h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>消息中间件就是一个临时存储器。主要解决应用耦合，异步消息，流量削锋等问题，是大型分布式系统不可缺少的中间件。</p><pre><code>1.用于海量数据洪峰的临时存储,比如抢购秒杀,后端程序一下子处理不了这么多抢购请求,那就由消息中间件来存储抢购请求,后端程序再慢慢取出消息处理呗2.用于多个系统之间的消息传递</code></pre><p>目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。</p><h3 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h3><p>使用场景的比较多，比如：</p><pre><code>1、读写分离2、数据库从库的负载均衡3、分布式事务4、支持多种数据库（Mysql、PG、Oracle等）</code></pre><h3 id="框架中的中间件"><a href="#框架中的中间件" class="headerlink" title="框架中的中间件"></a>框架中的中间件</h3><p>CI框架和tp框架中的hook（钩子），就是中间件的一种。<br>laravel中可以使用php artisan 命令创建中间件，比如请求过滤器就是最常见的中间件使用方法一种。Laravel支持全局的中间件和根据具体路由规定的中间件两种，同时优先级又以定义顺序为准。<br>ZendFramework是由zend公司推出的php框架，其目标就是建立一套大而全的php框架。以满足企业应用开发的目标。其中”zend-stratigility” 负责提供中间件以及中间件执行流的功能。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>一片比较巧妙设计中间件的文章<br><a href="https://blog.csdn.net/qq_20329253/article/details/52202811" target="_blank" rel="external">https://blog.csdn.net/qq_20329253/article/details/52202811</a><br>一片用闭包实现中间件的文章<br><a href="http://blog.csdn.net/allen_tsang/article/details/51777911" target="_blank" rel="external">http://blog.csdn.net/allen_tsang/article/details/51777911</a></p>]]></content>
    
    <summary type="html">
    
      谈谈我对中间件的理解
    
    </summary>
    
      <category term="常识" scheme="http://martist.cn/categories/%E5%B8%B8%E8%AF%86/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
</feed>
