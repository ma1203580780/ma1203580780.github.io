<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARTIST</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://martist.cn/"/>
  <updated>2018-04-16T08:55:05.910Z</updated>
  <id>http://martist.cn/</id>
  
  <author>
    <name>martist.cn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>monolog</title>
    <link href="http://martist.cn/2018/04/13/monolog/"/>
    <id>http://martist.cn/2018/04/13/monolog/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-16T08:55:05.910Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="php中的日志库"><a href="#php中的日志库" class="headerlink" title="php中的日志库"></a>php中的日志库</h2><p>php中并没有内建的日志接口，故长期以来也没一个功能完备并且应用广泛的日志库。monolog是一个为5.3以上版本php开发的日志库，但是需要注意的是现在主干版本只支持php 7以上版本，如果你的服务器环境还是php 5的话，可以使用monolog的1.x版本。</p><p>monolog的github地址：<a href="https://github.com/Seldaek/monolog" target="_blank" rel="external">https://github.com/Seldaek/monolog</a><br>中文文档地址：<a href="https://github.com/Clarence-pan/monolog-zh-doc" target="_blank" rel="external">https://github.com/Clarence-pan/monolog-zh-doc</a><br>psr规范官方地址：<a href="https://www.php-fig.org/psr" target="_blank" rel="external">https://www.php-fig.org/psr</a></p><p>值得一提的是monolog是一个符合psr-3规范的日志类库，并且符合psr-4加载规范。这有利于松耦合的融入框架中。下面是正在使用monolog作为日志组件的框架。</p><h3 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h3><p>使用 PSR-3 的框架和库可以非常简单地集成 Monolog, 因为它实现了这个接口。<br>Symfony2 开箱即用 Monolog.<br>Silex 开箱即用 Monolog.<br>Laravel 4 &amp; 5 开箱即用 Monolog.<br>Lumen 开箱即用 Monolog.<br>PPI 开箱即用 Monolog.<br>CakePHP 可以通过 cakephp-monolog 这个插件来使用 Monolog.<br>Slim 可以通过 Slim-Monolog 这个日志适配器来使用 Monolog.<br>XOOPS 2.6 开箱即用 Monolog.<br>Aura.Web_Project 开箱即用 Monolog.<br>Nette Framework 可以通过 Kdyby/Monolog 这个扩展来使用 Monolog.<br>Proton Micro Framework 开箱即用 Monolog.<br>FuelPHP 开箱即用 Monolog.<br>Equip Framework 开箱即用 Monolog.<br>Yii 2 可以通过 yii2-monolog 这个插件来使用 Monolog.<br>Hawkbit Micro Framework 开箱即用 Monolog.</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>Monolog 需要 PHP 7.0 或以上版本才能正常工作。至于 PHP 5.3 请使用 Monolog ^1.0.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>composer require monolog/monolog</code></pre><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;// 创建一个日志通道$log = new Logger(&apos;name&apos;);$log-&gt;pushHandler(new StreamHandler(&apos;path/to/your.log&apos;, Logger::WARNING));// 添加日志记录$log-&gt;warning(&apos;Foo&apos;);$log-&gt;error(&apos;Bar&apos;);</code></pre><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>每一个日志服务实例 (Logger) 都有一个通道（名称），并有一个处理器 (Handler)栈. 无论何时你添加一条 记录 到对应的日志服务实例，这个处理器栈将被遍历一遍：每个处理器都将依次决定是否要处理这条记录，而如果要处理，则遍历结束（译注：类似DOM事件冒泡）。</p><p>这样子可以创建非常灵活的日志配置。比如一个 StreamHandler 可以把所有日志都写入磁盘，而上面加个MailHandler 可以把错误日志作为邮件发送出去。处理器还有一个 $bubble 属性定义了是否屏蔽某条记录或者处理了某条记录。在这个示例中，配置 MailHandler 的 $bubble 参数为 false 则意味着 MailHandler 将不会把自己已处理过的记录继续冒泡给 StreamHandler.</p><p>你可以创建许多日志服务实例(Logger)，每一个则定义一个通道（比如数据库、请求、路由…）。而每一个日志服务实例都可以组合各种各样的处理器，可以共享处理器也可以不共享。这个通道将会在日志中反映出来，从而允许你可以很容易地查看或者筛选记录。</p><p>每一个处理还会有一个格式化器（Formatter）。如果你没有配置一个，则一个有意义的默认的格式化器将被创建。格式化器用来规范化并格式化输入的记录，以便处理器能输出一些有用的信息。</p><p>不支持自定义的严重性级别。只支持使用RFC 5424中定义的八个级别（调试/Debug、信息/Info、提示/Notice、警告/Warning、错误/Error、严重/Critical、警报/Alert、紧急/Emergency）来作为基本的筛选目的。不过，如果为了排序或者其他需要灵活性的使用场景，你可以添加加工程序（Processor）从而可以在（处理器）处理前添加额外的信息（标签、用户IP…）。</p><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>Monolog 支持一下 RFC 5424 中的日志级别：</p><pre><code>调试/DEBUG (100): 详细的调试信息。信息/INFO (200): 有意义的事件，比如用户登录、SQL日志。提示/NOTICE (250): 正常但是值得注意的事件。警告/WARNING (300): 异常事件，但是并不是错误。比如使用了废弃了的API，错误地使用了一个API，以及其他不希望发生但是并非必要的错误。错误/ERROR (400): 运行时的错误，不需要立即注意到，但是需要被专门记录并监控到。严重/CRITICAL (500): 边界条件/危笃场景。比如应用组件不可用了，未预料到的异常。警报/ALERT (550): 必须立即采取行动。比如整个网站都挂了，数据库不可用了等。这种情况应该发送短信警报，并把你叫醒。紧急/EMERGENCY (600): 紧急请求：系统不可用了。</code></pre><h2 id="配置一个日志服务"><a href="#配置一个日志服务" class="headerlink" title="配置一个日志服务"></a>配置一个日志服务</h2><p>这里有一个基本的配置，可以记录日志到文件，并在 DEBUG 级别下记录到 firephp 中:</p><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;use Monolog\Handler\FirePHPHandler;// 创建日志服务$logger = new Logger(&apos;my_logger&apos;);// 添加一些处理器$logger-&gt;pushHandler(new StreamHandler(__DIR__.&apos;/my_app.log&apos;, Logger::DEBUG));$logger-&gt;pushHandler(new FirePHPHandler());// 现在你就可以用日志服务了$logger-&gt;info(&apos;My logger is now ready&apos;);</code></pre><p>解释一下。第一步是创建日志服务实例，这个实例后将在代码中用到。唯一的参数是通道的名称，它在你有多个日志服务实例的时候很有用。（更多详情参见下面）</p><p>这个日志服务实例自己是不是知道如何处理一条日志记录的。它把记录代理给了一些处理器。上面的代码中注册了两个处理器到栈中，以便允许使用两种不同的方式来处理日志记录。</p><p>注意，FirePHPHandler 是被先调用的，因而它被添加到了栈顶。这允许你临时添加一个禁止冒泡的处理器从而允许你覆盖其他配置的日志（处理器）。</p><pre><code>如果你单独使用 Monolog, 并且在寻找一种简单的方式来配置许多处理器，那可以用 theorchard/monolog-cascade 。 它可以帮你使用PHP数组、YAML或者JSON来构建复杂的日志配置。</code></pre><h2 id="为记录添加额外的数据"><a href="#为记录添加额外的数据" class="headerlink" title="为记录添加额外的数据"></a>为记录添加额外的数据</h2><p>Monolog 提供了两种不同的方式来为简单的文本消息增加额外的信息</p><h3 id="使用上下文-context"><a href="#使用上下文-context" class="headerlink" title="使用上下文(context)"></a>使用上下文(context)</h3><p>第一种方式是使用上下文（context），这允许你在传递记录的时候传递一个数组格式的数据：</p><pre><code>&lt;?php$logger-&gt;info(&apos;Adding a new user&apos;, array(&apos;username&apos; =&gt; &apos;Seldaek&apos;));</code></pre><p>简单的处理器（比如StreamHandler）将只是把数组转换成字符串。而复杂的处理器则可以利用上下文的优点（如 FirePHP 则将以一种优美的方式显示数组）。</p><h3 id="使用加工程序-Processor"><a href="#使用加工程序-Processor" class="headerlink" title="使用加工程序(Processor)"></a>使用加工程序(Processor)</h3><p>第二种方式是使用加工程序来为所有的记录添加额外数据。加工程序可以是任何可以调用的函数。 加工程序接收日志记录作为参数，并且需要在修改了extra字段后再返回日志记录。让我们来写一个添加一些假数据的加工程序：</p><pre><code>&lt;?php$logger-&gt;pushProcessor(function ($record) {    $record[&apos;extra&apos;][&apos;dummy&apos;] = &apos;Hello world!&apos;;    return $record;});</code></pre><p>Monolog提供了一些内置的加工程序，你可以在你的项目中使用它们。请参见对应的章节.</p><pre><code>小技巧：加工程序可以被注册到一个特定的处理器上而不是直接在日志服务实例上，从而可以只在对应的处理器上生效。</code></pre><h2 id="使用通道"><a href="#使用通道" class="headerlink" title="使用通道"></a>使用通道</h2><p>通道是一种非常棒的方式来区分是应用的哪个部分的日志被记录下来的。这通常在大型项目中非常有用（而且被Symfony2的MonologBundle所使用）。</p><p>假设有两个日志服务实例共享了一个处理器，这个处理器将日志写入单个日志文件。通道则将允许你来区分是哪个日志服务实例记录了哪条日志。你可以很简单地通过通道来筛选日志。</p><pre><code>&lt;?phpuse Monolog\Logger;use Monolog\Handler\StreamHandler;use Monolog\Handler\FirePHPHandler;// 创建一些处理器$stream = new StreamHandler(__DIR__.&apos;/my_app.log&apos;, Logger::DEBUG);$firephp = new FirePHPHandler();// 创建应用的主要日志服务实例$logger = new Logger(&apos;my_logger&apos;);$logger-&gt;pushHandler($stream);$logger-&gt;pushHandler($firephp);// 使用另外的通道来创建安全相关的日志服务示例$securityLogger = new Logger(&apos;security&apos;);$securityLogger-&gt;pushHandler($stream);$securityLogger-&gt;pushHandler($firephp);// 或者克隆第一个，只是改变下通道$securityLogger = $logger-&gt;withName(&apos;security&apos;);</code></pre><h2 id="自定义日志格式"><a href="#自定义日志格式" class="headerlink" title="自定义日志格式"></a>自定义日志格式</h2><p>在Monolog中，可以很简单地来自定义日志的格式，无论是写入文件、套接字、邮件、数据库还是其他处理器。大多数处理器都是用 $record[‘formatted’] 这个值来自动写入日志设备。这个值依赖格式化器的配置。你可以选择预定义的格式化器类，也可以自己写一个（比如一个可读的多行文本文件）。</p><p>想要配置一个预定义的格式化器类，可以直接把它设置为处理器的字段：</p><p>// 默认的日期格式是 “Y-m-d H:i:s”<br>$dateFormat = “Y n j, g:i a”;<br>// 默认的输出格式是 “[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n”<br>$output = “%datetime% &gt; %level_name% &gt; %message% %context% %extra%\n”;<br>// 最后创建一个格式化器<br>$formatter = new LineFormatter($output, $dateFormat);</p><p>// 创建一个处理器<br>$stream = new StreamHandler(<strong>DIR</strong>.’/my_app.log’, Logger::DEBUG);<br>$stream-&gt;setFormatter($formatter);</p><p>// 将其绑定到日志服务对象上<br>$securityLogger = new Logger(‘security’);<br>$securityLogger-&gt;pushHandler($stream);</p><p>// 你还可以在多个处理器之间复用同一个格式化器，并且在多个日志服务实例间共享这些处理器。</p>]]></content>
    
    <summary type="html">
    
      这可能是php世界中最好的日志库——monolog
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>关于小产权房的一些看法</title>
    <link href="http://martist.cn/2018/04/09/%E5%85%B3%E4%BA%8E%E5%B0%8F%E4%BA%A7%E6%9D%83%E6%88%BF%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/"/>
    <id>http://martist.cn/2018/04/09/关于小产权房的一些看法/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2018-04-16T07:37:24.915Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="先回答几个问题"><a href="#先回答几个问题" class="headerlink" title="先回答几个问题"></a>先回答几个问题</h2><h3 id="什么是小产权房？"><a href="#什么是小产权房？" class="headerlink" title="什么是小产权房？"></a>什么是小产权房？</h3><p>小产权房是指在农村集体土地上建设的房屋，未缴纳土地出让金等费用，其产权证不是由国家房管部门颁发，而是由乡政府或村政府颁发，亦称“乡产权房”。“小产权房”不是法律概念，是人们在社会实践中形成的一种约定俗成的称谓。该类房没有国家发放的土地使用证和预售许可证，购房合同在国土房管局不会给予备案。所谓产权证亦不是真正合法有效的产权证。按照国家的相关要求，“小产权房”不得确权发证，不受法律保护。</p><h3 id="小产权房有保障吗？"><a href="#小产权房有保障吗？" class="headerlink" title="小产权房有保障吗？"></a>小产权房有保障吗？</h3><p>如果有一天这些村民把开发商买地的钱花完了，没钱了，开始动歪脑筋找钱花的时候，这群敢买小产权房的羔羊是再好宰不过了。隔三差五要求你每个月交物业费，村管理费，或者看当下房价高想在卖一次，直接撕毁合同。都是买房者不能承受之重</p><blockquote><p>家里在京郊有一套小产权，可谓依山傍水，空气清新，景色怡人，完全脱离城市的喧嚣。简单整了整之后，父母每周末都要过去住两天，感情状态回到新婚的水准。<br>然后，开放商想把这卖给某企业，就断水断电，列了个正常人不会签的条件，准备收房了。– 郭云昊</p></blockquote><h3 id="小产权房为什么不受保护？"><a href="#小产权房为什么不受保护？" class="headerlink" title="小产权房为什么不受保护？"></a>小产权房为什么不受保护？</h3><p>1.本集体组织成员之间买卖小产权房一般认定合同有效<br>2.本集体与他集体组织成员之间买卖小产权房一般认定合同无效<br>3.集体组织成员与城镇居民之间买卖小产权房一般认定合同无效<br>例外情形:城镇居民在签订小产权房买卖合同后取得了该集体组织户口并经相关部门批准，该房屋买卖合同一般认定有效。<br>4.小产权房买卖合同被认定无效之后的处理规则<br>5.上海地区对小产权房纠纷特别规定</p><p><strong> 法律禁止非同一集体组织成员间小产权房买卖，因此，买卖小产权房请慎重！</strong></p><p>具体参见： <a href="https://www.zhihu.com/question/20158141" target="_blank" rel="external">https://www.zhihu.com/question/20158141</a></p><h3 id="如果购买了小产权房，需要承担什么风险呢？"><a href="#如果购买了小产权房，需要承担什么风险呢？" class="headerlink" title="如果购买了小产权房，需要承担什么风险呢？"></a>如果购买了小产权房，需要承担什么风险呢？</h3><ol><li>法律效力<br>“小产权房”买卖合同的效力一般认定无效。</li><li>房产转让<br>“小产权房”拿不到正式的房产证，因此并不构成真正法律意义上的产权。即小产权房只有使用权，没有所有权。<br>根据《中华人民共和国土地管理法》的规定，小产权房不能向非本集体成员的第三人转让或出售，即购买后不能合法转让过户。其同时对房屋的保值和升值也有一定影响。</li><li>政策风险<br>购买在建小产权房时，购房人与开发商签订合同并交付房款后，如果相关部门整顿乡产权房的建设项目，可导致部分项目停建甚至被强迫拆除。购房人会面临既无法取得房屋，又不能及时索回房款的尴尬境地。<br>其次，购房后如果遇到国家征地拆迁，由于乡产权房没有国家认可的合法产权，购房人并非合法的产权人，所以无法得到对产权进行的拆迁补偿。</li><li>监管缺位<br>乡产权房屋的开发建设没有明确的规定加以约束，开发建设的监管存在缺位，对购房者的利益有一定的影响。同时，开发单位的资质没有，房屋质量和房屋售后保修难以保证。</li></ol><p><strong>综上所述，小产权房是不受法律保障的，所以不建议购买。</strong></p><h2 id="“小产权房”能不能买？"><a href="#“小产权房”能不能买？" class="headerlink" title="“小产权房”能不能买？"></a>“小产权房”能不能买？</h2><p>通俗的说，没有所谓小产权房，咱们国家从来没有过这个概念。你口中的“小产权”其实是“没产权”，不出纠纷还好，出了事没有任何保障，断水断电，然后三天两头村民去你家闹，你不能维权。反过头来国家或者村里要整你，也只需要一纸公文。</p><p>不是内行不要碰。</p><p>小产权房经常要求全款支付，也不能贷款。其次手续各方面容易出问题。如果不是自己涉入很深，对风险把控非常彻底，或者是对卖方有十足的把控能力的话，绝对不要碰。</p><p>这类房子不能考虑未来转手，不能考虑增值空间。</p><p>千万别碰小产权“期房”，那就等于是拿着血汗钱做了一次风投。</p>]]></content>
    
    <summary type="html">
    
      北漂生活
    
    </summary>
    
      <category term="生活" scheme="http://martist.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>健身相关文章的推荐</title>
    <link href="http://martist.cn/2018/04/08/%E5%81%A5%E8%BA%AB%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%E7%9A%84%E6%8E%A8%E8%8D%90/"/>
    <id>http://martist.cn/2018/04/08/健身相关文章的推荐/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-16T02:15:40.514Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="健身还是伤身？"><a href="#健身还是伤身？" class="headerlink" title="健身还是伤身？"></a>健身还是伤身？</h2><p><a href="https://zhuanlan.zhihu.com/p/34315947" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34315947</a></p><h2 id="健身后的禁忌—10个不要，关乎身家性命"><a href="#健身后的禁忌—10个不要，关乎身家性命" class="headerlink" title="健身后的禁忌—10个不要，关乎身家性命"></a>健身后的禁忌—10个不要，关乎身家性命</h2><p><a href="https://zhuanlan.zhihu.com/p/25606492" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25606492</a></p><h2 id="运动不是膝盖杀手，它才是"><a href="#运动不是膝盖杀手，它才是" class="headerlink" title="运动不是膝盖杀手，它才是!"></a>运动不是膝盖杀手，它才是!</h2><p><a href="https://zhuanlan.zhihu.com/p/31894631" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/31894631</a></p><h2 id="史上最全面的拉伸指南"><a href="#史上最全面的拉伸指南" class="headerlink" title="史上最全面的拉伸指南"></a>史上最全面的拉伸指南</h2><p><a href="https://zhuanlan.zhihu.com/p/32118734" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/32118734</a></p><h2 id="严谨的健身书籍推荐2-姿态评估、运动损伤和身体疼痛"><a href="#严谨的健身书籍推荐2-姿态评估、运动损伤和身体疼痛" class="headerlink" title="严谨的健身书籍推荐2 - 姿态评估、运动损伤和身体疼痛"></a>严谨的健身书籍推荐2 - 姿态评估、运动损伤和身体疼痛</h2><p><a href="https://zhuanlan.zhihu.com/p/22864752" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22864752</a></p><h2 id="物美价廉的健身装备推荐，亲测好用！"><a href="#物美价廉的健身装备推荐，亲测好用！" class="headerlink" title="物美价廉的健身装备推荐，亲测好用！"></a>物美价廉的健身装备推荐，亲测好用！</h2><p><a href="https://zhuanlan.zhihu.com/p/22762552" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22762552</a></p><p>持续更新！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="健身" scheme="http://martist.cn/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>SaaS的php技术实现</title>
    <link href="http://martist.cn/2018/04/01/SaaS%E7%9A%84php%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>http://martist.cn/2018/04/01/SaaS的php技术实现/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-03T03:33:56.321Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="SOFTWARE-AS-A-SERVICE"><a href="#SOFTWARE-AS-A-SERVICE" class="headerlink" title="SOFTWARE AS A SERVICE"></a>SOFTWARE AS A SERVICE</h3><p>在某些方面，SaaS非常类似于早些年的瘦客户端软件模式，其中客户端（在这种情况下通常是Web浏览器）提供对服务器上运行的软件的访问点。 SaaS是消费者最熟悉的云服务形式。 SaaS将管理软件及其部署的任务转移到第三方服务。最熟悉的业务SaaS应用程序是客户关系管理应用程序，如Salesforce，像Google Apps这样的生产力软件，以及Box和Dropbox等存储解决方案的软件。</p><p>使用SaaS应用程序往往会降低软件所有权成本，因为不需要技术人员来管理软件的安装，管理和升级，同时这也可以降低软件许可的成本。SaaS应用程序通常在订阅模式上被提出来。</p><h3 id="PLATFORM-AS-A-SERVICE"><a href="#PLATFORM-AS-A-SERVICE" class="headerlink" title="PLATFORM AS A SERVICE"></a>PLATFORM AS A SERVICE</h3><p>PaaS提供比SaaS低一级的功能，通常提供可以开发和部署软件的平台。 PaaS提供者抽象处理服务器的大部分工作，并为客户提供了操作系统和服务器软件以及底层服务器硬件和网络基础设施的环境，使用户可以自由地关注业务端可扩展性及其产品或服务的应用开发。</p><p>与大多数云服务一样，PaaS是建立在虚拟化技术之上的。企业可以根据需要申请资源，随着需求的增长而不是以冗余资源投入硬件。</p><p>PaaS提供商的例子包括Heroku，Google App Engine和Red Hat的OpenShift。</p><h3 id="INFRASTRUCTURE-AS-A-SERVICE"><a href="#INFRASTRUCTURE-AS-A-SERVICE" class="headerlink" title="INFRASTRUCTURE AS A SERVICE"></a>INFRASTRUCTURE AS A SERVICE</h3><p>继续朝服务的下层看，我们就可以看到云服务的基本构件。 IaaS由高度自动化和可扩展的计算资源组成，由云存储和可以自动配置，计量和可用的按需网络功能组成。</p><p>IaaS提供商通过仪表板以及API（API可能没有）提供这些云服务器及其相关资源。 IaaS客户可以直接访问其服务器和存储，就像传统服务器一样，但这样拥有更高级别的可扩展性。 IaaS的用户可以在云中外包和构建“虚拟数据中心”，并可以访问许多与传统数据中心相同的技术和资源功能，而无需投资于服务器容量规划或物理管理维护。</p><p>IaaS是最灵活的云计算模式，允许自动的服务器，处理能力，存储和网络的自动部署。 IaaS客户对基础设施拥有真正的控制，比PaaS或SaaS服务的用户不知道高到哪里去了。 IaaS的主要用途包括PaaS，SaaS和网络规模应用程序的实际开发和部署。</p><p>有很多提供商提供Iaas，比如Navisite，Exoscale和Softlayer，具有自己独特的价格方案和服务组合可供选择。</p><p>ComputeNext（作者的网站）为IaaS提供一个经纪服务，以便你可以确保为您的应用需求选择合适的IaaS提供商。通过使用单一API对20多个云提供商进行归一化的访问，您可以比较提供商的价格和性能，从而找到最佳配置，然后构建和部署，而不会被绑死到一个平台。</p><p>具体例子可以参考：<a href="https://www.zhihu.com/question/21641778/answer/95652959" target="_blank" rel="external">https://www.zhihu.com/question/21641778/answer/95652959</a></p><h3 id="通俗的讲pass和saas的区别"><a href="#通俗的讲pass和saas的区别" class="headerlink" title="通俗的讲pass和saas的区别"></a>通俗的讲pass和saas的区别</h3><p>paas给你一个完善的开发，测试，上线的环境，应用工程代码还是需要你来开发，在开发过程需要的一些服务已经帮你做好，比如：短信服务，邮件服务，分布式文件系统服务，域名备案服务，网络端负载均衡服务，数据库端负载主从热备服务，分片服务，vpn服务，https服务，各个线上服务器的监控统计服务等；saas是应用工程帮你做好，你只需要调整下页面配置，即可上线运营，有点类似淘宝平台与淘宝入驻商家之间的关系。</p><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>saas系统分层大概是：  </p><blockquote><p>租户识别&gt;应用层&gt;数据访问层&gt;缓存层&gt;数据库  </p></blockquote><p>业务代码都是写在应用层。<br>租户识别可以用spring拦截器实现，然后使用ThreadLocal传递给后端<br>数据库和缓存层对应用层应该是透明的。程序员在写代码的时候，只关心业务逻辑，不应该担心多租户的问题。</p><h3 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h3><p>saas系统说起来很简单，任何系统似乎加个tenant_id(租户id)就变成saas系统了。比如原来的用户登录是：</p><pre><code>select username,password from users where email=&apos;abc@qq.com&apos;</code></pre><p>改成</p><pre><code>select username,password from users where email=&apos;abc@qq.com&apos; and tenant_id =1;</code></pre><p>对于复杂业务的saas系统，这样做法非常危险，而且开发效率很低。你想想如果那个程序员写sql时候忘了加 “ and tenant_id =1” . 结果不堪设想。<br>比较好做法是在数据库访问层对SQL进行改写。</p><pre><code>TenantContext.exec(&quot;select username,password from users where email=&apos;abc@qq.com&apos; &quot;);</code></pre><p>在连接池根据TenatnContext改写Sql.<br>这样做好处是，一来程序猿最多把系统搞down了，也不至于信息串了互相泄露。二来将来做分表分库也很方便，上层应用不用修改。</p><h3 id="租户识别方案"><a href="#租户识别方案" class="headerlink" title="租户识别方案"></a>租户识别方案</h3><p>比较好做法是通过url识别租户。系统是给租户生成一个随机的三级域名，比如 abc.crm.baidu.com.   如果客户想使用自己的域名，可以在cname到我们生成的三级域名，并在管理系统里面做绑定。<br>这样一个租户可以有两个域名，访问saas,一个随机生成的三级域名，另外一个租户自己的域名.代码里面可以根据过来的域名，判断是那个租户然后初始化TenantContext.<br>如果不想通过域名来做，也可以通过登录名来判断。这种方式要涉及到租户切换问题。</p><h3 id="租户管理系统（计费，订购，定制，充值，催缴）"><a href="#租户管理系统（计费，订购，定制，充值，催缴）" class="headerlink" title="租户管理系统（计费，订购，定制，充值，催缴）"></a>租户管理系统（计费，订购，定制，充值，催缴）</h3><p>Saas系统是必须考虑计费系统和租户控制系统。这个系统需要都是独立设计。比如那个租户购买了那些模块，一个月多少钱。租户可以创建最多的用户数。计费到期邮件提醒等功能。<br>计费方式一般有两种，周期性计费，类似月租方案，和使用量计费,用多少付多少。 周期性计费比较简单。也可以两者结合起来。</p><h3 id="定制化开发"><a href="#定制化开发" class="headerlink" title="定制化开发"></a>定制化开发</h3><p>SAAS的优势在于一套系统多人使用，似乎和定制化开发有冲突。比如A客户想要A功能，B客户不想要。但定制化开发是无法避免的，比如CRM系统这样复杂的系统，不可能一套系统满足所有公司的要求。定制化开发尽可能分系统，分模块去做。然后通过控制台中配置不同租户订购不同模块，那些模块可以在前端页面上显示。不同的子系统需要分开部署。前端可通过nginx根据url分发，比如 abc.crm.baidu.com/bi/xxx/xx这个地址，就分发到BI子系统。不要尝试OSGI去搞模块化，这个是个大坑。<br>还有开发和产品，现有需求一定要分析清楚，不要一上线发现后患无穷。新功能尽量做的独立可以配置。</p><h3 id="灰度升级"><a href="#灰度升级" class="headerlink" title="灰度升级"></a>灰度升级</h3><p>SAAS付费企业客户对系统问题都特别敏感。 为了减少升级可能出现问题的影响范围，一般都采用灰度升级策略。如果使用了url来区分不同租户，灰度升级配置就会很方便。可以配置nginx 来根据域名做分发，比如租户A（aaa.com）到实例1（版本1.0），租户B(bbb.com)到实例2(版本). 当需要域名配置非常多的时候，nginx配置文档会乱。这块时候可以考虑使用nignx_lua来写一些扩展模块。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="关于多租户的数据隔离方案"><a href="#关于多租户的数据隔离方案" class="headerlink" title="关于多租户的数据隔离方案"></a>关于多租户的数据隔离方案</h3><h4 id="独立数据库"><a href="#独立数据库" class="headerlink" title="独立数据库"></a>独立数据库</h4><p>这是第一种方案，即一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本较高。<br>优点：<br>为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。<br>缺点：<br>增多了数据库的安装数量，随之带来维护成本和购置成本的增加。<br>这种方案与传统的一个客户、一套数据、一套部署类似，差别只在于软件统一部署在运营商那里。如果面对的是银行、医院等需要非常高数据隔离级别的租户，可以选择这种模式，提高租用的定价。如果定价较低，产品走低价路线，这种方案一般对运营商来说是无法承受的。</p><h4 id="共享数据库，隔离数据架构"><a href="#共享数据库，隔离数据架构" class="headerlink" title="共享数据库，隔离数据架构"></a>共享数据库，隔离数据架构</h4><p>这是第二种方案，即多个或所有租户共享Database，但是每个租户一个Schema（也可叫做一个user）。<br>优点：<br>为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可支持更多的租户数量。<br>缺点：<br>如果出现故障，数据恢复比较困难，因为恢复数据库将牵涉到其他租户的数据；<br>如果需要跨租户统计数据，存在一定困难。</p><h4 id="共享数据库，共享数据架构"><a href="#共享数据库，共享数据架构" class="headerlink" title="共享数据库，共享数据架构"></a>共享数据库，共享数据架构</h4><p>这是第三种方案，即租户共享同一个Database、同一个Schema，但在表中增加TenantID多租户的数据字段。这是共享程度最高、隔离级别最低的模式。<br>优点：<br>三种方案比较，第三种方案的维护和购置成本最低，允许每个数据库支持的租户数量最多。<br>缺点：<br>隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；<br>数据备份和恢复最困难，需要逐表逐条备份和还原。<br>如果希望以最少的服务器为最多的租户提供服务，并且租户接受牺牲隔离级别换取降低成本，这种方案最适合。</p><h3 id="选择合理的实现模式"><a href="#选择合理的实现模式" class="headerlink" title="选择合理的实现模式"></a>选择合理的实现模式</h3><p>衡量三种模式主要考虑的因素是隔离还是共享。</p><h4 id="成本角度因素"><a href="#成本角度因素" class="headerlink" title="成本角度因素"></a>成本角度因素</h4><p>隔离性越好，设计和实现的难度和成本越高，初始成本越高。共享性越好，同一运营成本下支持的用户越多，运营成本越低。</p><h4 id="安全因素"><a href="#安全因素" class="headerlink" title="安全因素"></a>安全因素</h4><p>要考虑业务和客户的安全方面的要求。安全性要求越高，越要倾向于隔离。</p><h4 id="租户数量因素"><a href="#租户数量因素" class="headerlink" title="租户数量因素"></a>租户数量因素</h4><p>系统要支持多少租户？上百？上千还是上万？可能的租户越多，越倾向于共享。<br>平均每个租户要存储数据需要的空间大小。存贮的数据越多，越倾向于隔离。<br>每个租户的同时访问系统的最终用户数量。需要支持的越多，越倾向于隔离。<br>是否想针对每一租户提供附加的服务，例如数据的备份和恢复等。这方面的需求越多， 越倾向于隔离。</p><h4 id="信息监管因素"><a href="#信息监管因素" class="headerlink" title="信息监管因素"></a>信息监管因素</h4><p>要考虑政府，机关，企业，公司的安全和信息监管相关的一些政策和规定。</p><h3 id="基于laravel框架开发SaaS系统"><a href="#基于laravel框架开发SaaS系统" class="headerlink" title="基于laravel框架开发SaaS系统"></a>基于laravel框架开发SaaS系统</h3><ol><li>利用laravel内置的前置中间件对租户请求域名进行判断，进而区分租户。</li><li>每个租户的密钥来对应请求域名，后端鉴权通过每个租户不同的密钥和请求域名来制造签名，中心API服务器以此鉴权。实现ACL，防止数据遭窃。</li><li>分库分表，实现数据隔离，可以使分库作为本公司master数据库的一个备库扩展库，从而实现读写分离，数据安全，查询优化等功能。</li><li>为saas用户提供服务器前端项目，不提供数据链接，服务器前端项目为可转发请求的服务治理中间件功能的框架（curl，guzzle），租户可以买账号直接使用系统，也可以搭在自己服务器，自行增减配置运维，写前端代码添加个性化的内容比如商标、首页、详情页等等。后端接口维护在本公司的服务器，如果系统有bug可以随时处理而不需要去所有租户的服务器重新部署，实现平滑升级。</li></ol><p>1</p>]]></content>
    
    <summary type="html">
    
      对我们phper来讲，这些概念不难理解
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>PHP中的ob_start()</title>
    <link href="http://martist.cn/2018/03/30/PHP%E4%B8%AD%E7%9A%84ob_start()/"/>
    <id>http://martist.cn/2018/03/30/PHP中的ob_start()/</id>
    <published>2018-03-29T16:00:00.000Z</published>
    <updated>2018-04-02T10:26:29.584Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a><br>(PHP 4, PHP 5, PHP 7)</p><blockquote><p>ob_start — 打开输出控制缓冲  </p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code>bool ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] )</code></pre><p>此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。</p><p>内部缓冲区的内容可以用 ob_get_contents() 函数复制到一个字符串变量中。 想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。另外， 使用 ob_end_clean() 函数会静默丢弃掉缓冲区的内容。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Output Control 函数可以让你自由控制脚本中数据的输出。它非常地有用，特别是对于：当你想在数据已经输出后，再输出文件头的情况。输出控制函数不对使用 header() 或 setcookie(), 发送的文件头信息产生影响,只对那些类似于 echo() 和 PHP 代码的数据块有作用。<br>我们先举一个简单的例子，让大家对Output Control有一个大致的印象：</p><pre><code>&lt;?phpob_start(); //打开缓冲区echo &quot;Hellon&quot;; //输出header(&quot;location:index.php&quot;); //把浏览器重定向到index.phpob_end_flush();//输出全部内容到浏览器?&gt;</code></pre><blockquote><p>这段代码的实际效果是输出b.php的内容，a.php的内容就废弃掉了，不会输出在浏览器，但如果你用curl或者php-cli去执行，那么a.php的内容将输出，不会真的跳转到b.php去执行。</p></blockquote><p>所有对header()函数有了解的人都知道，这个函数会发送一段文件头给浏览器，但是如果在使用这个函数之前已经有了任何输出（包括空输出，比如空格，回车和换行）就会提示出错。<br>如果我们去掉第一行的ob_start()，再执行此程序，我们会发现得到了一条错误提示：”Header had all ready send by”！但是加上ob_start，就不会提示出错，原因是当打开了缓冲区，echo后面的字符不会输出到浏览器，而是保留在服务器，直到你使用 flush或者ob_end_flush才会输出，所以并不会有任何文件头输出的错误！</p><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><pre><code>ob_get_contents() - 返回输出缓冲区的内容ob_end_clean() - 清空（擦除）缓冲区并关闭输出缓冲ob_end_flush() - 冲刷出（送出）输出缓冲区内容并关闭缓冲ob_implicit_flush() - 打开/关闭绝对刷送ob_gzhandler() - 在ob_start中使用的用来压缩输出缓冲区中内容的回调函数。ob_start callback function to gzip output bufferob_iconv_handler() - 以输出缓冲处理程序转换字符编码mb_output_handler() - 在输出缓冲中转换字符编码的回调函数ob_tidyhandler() - ob_start callback function to repair the buffer</code></pre><p><a href="http://php.net/manual/zh/function.ob-start.php" target="_blank" rel="external">http://php.net/manual/zh/function.ob-start.php</a></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="1-用于header-之前"><a href="#1-用于header-之前" class="headerlink" title="1.用于header()之前"></a>1.用于header()之前</h3><pre><code>ob_start(); //打开缓冲区echo /&quot;Hellon/&quot;; //输出header(&quot;location:index.php&quot;); //把浏览器重定向到index.phpob_end_flush();//输出全部内容到浏览器</code></pre><h3 id="2-phpinfo-函数可获取客户端和服务器端的信息-但要保存客户端信息用缓冲区的方法是最好的选择"><a href="#2-phpinfo-函数可获取客户端和服务器端的信息-但要保存客户端信息用缓冲区的方法是最好的选择" class="headerlink" title="2.phpinfo()函数可获取客户端和服务器端的信息,但要保存客户端信息用缓冲区的方法是最好的选择."></a>2.phpinfo()函数可获取客户端和服务器端的信息,但要保存客户端信息用缓冲区的方法是最好的选择.</h3><pre><code>ob_start(); //打开缓冲区phpinfo(); //使用phpinfo函数$info=ob_get_contents(); //得到缓冲区的内容并且赋值给$info$file=fopen(/&apos;info.txt/&apos;,/&apos;w/&apos;); //打开文件info.txtfwrite($file,$info); //写入信息到info.txtfclose($file); //关闭文件info.txt</code></pre><h3 id="3-静态页面技术"><a href="#3-静态页面技术" class="headerlink" title="3.静态页面技术"></a>3.静态页面技术</h3><pre><code>ob_start();//打开缓冲区$content = ob_get_contents();//取得php页面输出的全部内容$fp = fopen(&quot;output00001.html&quot;, &quot;w&quot;); //创建一个文件，并打开，准备写入fwrite($fp, $content); //把php页面的内容全部写入output00001.html，然后……fclose($fp);</code></pre><h3 id="4-输出代码"><a href="#4-输出代码" class="headerlink" title="4.输出代码"></a>4.输出代码</h3><pre><code>function run_code($code) {If($code) {ob_start();eval($code);$contents = ob_get_contents();ob_end_clean();}else {echo &quot;错误！没有输出&quot;;exit();}return $contents;}//$code的本身就是一个含有变量的输出页面，而这个例子用eval把$code中的变量替换，然后对输出结果再进行输出捕捉，再一次的进行处理……</code></pre><h2 id="ob-flush和flush"><a href="#ob-flush和flush" class="headerlink" title="ob_flush和flush"></a>ob_flush和flush</h2><p>注意：ob_flush()和flush()这两个函数一般要一起使用，顺序是先ob_flush()，然后flush（），它们的作用是刷新缓冲区<br>具体可以参考：<br><a href="http://php.net/manual/zh/function.flush.php" target="_blank" rel="external">http://php.net/manual/zh/function.flush.php</a></p><p>1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php-fpm小结</title>
    <link href="http://martist.cn/2018/03/20/php-fpm%E4%BC%98%E5%8C%96/"/>
    <id>http://martist.cn/2018/03/20/php-fpm优化/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-04-16T08:55:13.389Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a><br>fpm 是FastCGI Process Manager (FPM)的简拼。是FastCGI</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><pre><code>支持平滑停止/启动的高级进程管理功能；可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe_mode 的设置）；stdout 和 stderr 日志记录;在发生意外情况的时候能够重新启动并缓存被破坏的 opcode;文件上传优化支持;&quot;慢日志&quot; - 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢;fastcgi_finish_request() - 特殊功能：用于在请求完成和刷新数据后，继续在后台执行耗时的工作（录入视频转换、统计处理等）；动态／静态子进程产生；基本 SAPI 运行状态信息（类似Apache的 mod_status）；基于 php.ini 的配置文件。</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先要找到php-fpm.conf配置文件,查看pid的配置路径</p><pre><code>machuangdeMacBook-Pro:etc machuang$  ps aux | grep php-fpm   machuang          1619   0.0  0.0  4267768    888 s000  S+   10:17上午   0:00.00 grep php-fpm_www              1610   0.0  0.0  4327128    856   ??  S    10:17上午   0:00.00 /usr/local/Cellar/php71/7.1.11_22/sbin/php-fpm --daemonize --fpm-config /usr/local/etc/php/7.1/php-fpm.conf --pid /usr/local/var/run/php-fpm.pid_www              1609   0.0  0.0  4328152    892   ??  S    10:17上午   0:00.00 /usr/local/Cellar/php71/7.1.11_22/sbin/php-fpm --daemonize --fpm-config /usr/local/etc/php/7.1/php-fpm.conf --pid /usr/local/var/run/php-fpm.pidroot              1608   0.0  0.0  4326104   1108   ??  Ss   10:17上午   0:00.00 /usr/local/Cellar/php71/7.1.11_22/sbin/php-fpm --daemonize --fpm-config /usr/local/etc/php/7.1/php-fpm.conf --pid /usr/local/var/run/php-fpm.pid</code></pre><p>查看php-fpm进程数:</p><pre><code>ps aux | grep -c php-fpm</code></pre><p>参考 <a href="http://php.net/manual/zh/install.fpm.configuration.php" target="_blank" rel="external">http://php.net/manual/zh/install.fpm.configuration.php</a></p><h2 id="CGI、FastCGI、php-fpm的关系"><a href="#CGI、FastCGI、php-fpm的关系" class="headerlink" title="CGI、FastCGI、php-fpm的关系"></a>CGI、FastCGI、php-fpm的关系</h2><p> ps aux | grep php-fpm   </p><h2 id="进程数和并发数的关系"><a href="#进程数和并发数的关系" class="headerlink" title="进程数和并发数的关系"></a>进程数和并发数的关系</h2><h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="nginx" scheme="http://martist.cn/categories/nginx/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>深蹲膝盖要不要过脚尖</title>
    <link href="http://martist.cn/2018/03/18/%E6%B7%B1%E8%B9%B2%E8%86%9D%E7%9B%96%E8%A6%81%E4%B8%8D%E8%A6%81%E8%BF%87%E8%84%9A%E5%B0%96/"/>
    <id>http://martist.cn/2018/03/18/深蹲膝盖要不要过脚尖/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-04-12T12:05:03.724Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>网上流传着“深蹲时膝盖不能过脚尖，过了脚尖容易伤膝盖”这种说法。今天，我们来探讨一下。</p><p>本来我以为这个事已经达成共识了，还是有人问，那么，我觉得有必要说两句。</p><p>看到一个说法，首先可以提问，对于这个说法，该问的就是：为什么不过脚尖能保护膝盖？网上的解释一般是：膝盖过脚尖，膝关节承受的压力会增加，于是受伤风险增加。</p><p>脊椎和任何关节，都与膝关节一样，增加压力就会提高受伤风险。现在，有这么一个膝盖和脚尖关系的说法，好，我炮制一个“背角（躯干与地面的夹角）小于45度就有椎间盘突出的风险”，你觉得怎么样？你说我没有理论支撑，那你找找看，深蹲脚尖这个事，有理论支撑吗？上网一查就发现，原来这说法没有任何文献，和我刚编出来的东西差不多，是拍脑门的产物。</p><p>你说，压力增加，就是容易受伤啊。他们这个说法虽然没有文献支撑，但是也没错啊。</p><p>我就奇了怪了，照他们这么说，深蹲就不能负重，因为一旦负重，膝关节承受的压力肯定就增加了，于是，大家都徒手深蹲吧。既然要减轻膝关节的压力，那徒手深蹲也不合适，最好找个人辅助一下。都这么干了，为啥还要膝盖不过脚尖地深蹲啊，干脆就别蹲了。为了减轻膝关节的压力，而采用膝盖不过脚尖的办法，还蹲什么啊？</p><p>哦，还是要蹲，还是要负重，毕竟还得训练，只是找一个最安全的办法，这种说法也站不住脚。与其用不过脚尖的怪异姿势保护膝关节，为什么不减轻一点重量用正常动作呢？嫌强度不够，那做硬拉得了。</p><p>哦，硬拉和深蹲不一样，就得蹲，就得上重量。你看，不蹲最安全，你要蹲；轻重量相对安全，你要上重量。你已经决定要让膝关节承受很大的压力，也就是说，你可以接受风险啊。膝关节压力增加，受伤的风险增加，说得很对，问题是，它是废话。你只要训练，只要想提高，要么增加强度、要么增加训练量（文末扩展阅读），受伤的风险就会增加，没有人会几十年如一日地用同样的负重、同样的组次、同样的节奏来训练吧。</p><p>你说你要翘臀，伸膝的事无所谓。那么，你最好做纯直腿的站躬身或硬拉，这样伸膝就没多少参与了。可是，你要知道，一旦站姿负重，这些重量就直接作用于膝关节上了，而且即便你完全直着腿，伸髋的时候腘绳肌发力，一样会再次增加膝关节压力的。</p><p>所以，无论怎么练，只要负重，甚至就算徒手，都会增大膝关节压力，照他们这个理论，也就增加了膝伤风险。显然，我们还是要锻炼的，不能因为它受压就放弃，所以，要探讨的就是膝伤风险问题了。</p><p>干什么事都有风险对不对？不能接受风险的话，应该老老实实躺在床上，不然上楼、跑步，甚至走路都有伤膝盖的风险，出门还有被车撞的风险呢。像我这种脸大的，躺床上看手机都有被砸到的风险。如果一听说风险就要避免，人是没法活了。</p><p>人活着，只要风险在可接受的范围内，生活就是第一位的。锻炼也是如此，只要风险可接受，训练目的就应该是第一位的。</p><p>你知道几个人单纯因为膝盖超脚尖深蹲导致膝伤的？你说健身房那个胖子某甲这么蹲膝盖就受伤了。这就没意思了，你只看见他“深蹲时膝盖超脚尖”和“受伤”这两件事了，也许它们相关，但不能说就是因果啊。我奶奶啥都没干，膝盖还坏了呢，实际上是退行性的事，我一定把她的“膝盖坏了”和“啥都没干”建立起因果关系，得出“什么都没干易导致膝伤”的结论，不合适吧。</p><p>你应该看看健身房里那些负重比较大的训练者，他们深蹲时膝盖都过脚尖了，他们是否受伤。如果得出的结论是：那些膝盖超脚尖的训练者，负重非常大，没有一个因此而膝伤的。那么就说明，这样的训练方式受伤概率极低，尽管这个风险可能存在，但是，它是可接受的。于是，你也应该考虑不管这个拍脑门出来的说法，而把训练目的放在首要位置。</p><p>也许你又想了，虽然这说法没什么道理，但宁可信其有不可信其无，反正也没什么坏处。我得告诉你，你真这么干的话，有坏处。</p><p>现在，好像大家都非常爱护自己的膝关节，说起啥来都是伤膝盖。难道，大家身上除了膝关节就没有别的关节了吗？</p><p>我们还要保护腰部，因为过于后倾的深蹲，对腰部肌肉甚至骨骼的损害是很大的。希望大家在健身过程中，保护好自己的身体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="健身" scheme="http://martist.cn/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>linux之curl命令</title>
    <link href="http://martist.cn/2018/03/18/linux%E4%B9%8BCURL%E5%91%BD%E4%BB%A4/"/>
    <id>http://martist.cn/2018/03/18/linux之CURL命令/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-04-10T10:16:21.487Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>curl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>curl(选项)(参数)</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><pre><code>-a/--append    上传文件时，附加到目标文件-A/--user-agent &lt;string&gt;    设置用户代理发送给服务器-anyauth    可以使用“任何”身份验证方法-b/--cookie &lt;name=string/file&gt;    cookie字符串或文件读取位置    --basic    使用HTTP基本验证-B/--use-ascii    使用ASCII /文本传输-c/--cookie-jar &lt;file&gt;    操作结束后把cookie写入到这个文件中-C/--continue-at &lt;offset&gt;    断点续转-d/--data &lt;data&gt;    HTTP POST方式传送数据    --data-ascii &lt;data&gt;    以ascii的方式post数据    --data-binary &lt;data&gt;    以二进制的方式post数据    --negotiate    使用HTTP身份验证    --digest    使用数字身份验证    --disable-eprt    禁止使用EPRT或LPRT    --disable-epsv    禁止使用EPSV-D/--dump-header &lt;file&gt;    把header信息写入到该文件中    --egd-file &lt;file&gt;    为随机数据(SSL)设置EGD socket路径    --tcp-nodelay    使用TCP_NODELAY选项-e/--referer    来源网址-E/--cert &lt;cert[:passwd]&gt;    客户端证书文件和密码 (SSL)    --cert-type &lt;type&gt;    证书文件类型 (DER/PEM/ENG) (SSL)    --key &lt;key&gt;    私钥文件名 (SSL)    --key-type &lt;type&gt;    私钥文件类型 (DER/PEM/ENG) (SSL)    --pass &lt;pass&gt;    私钥密码 (SSL)    --engine &lt;eng&gt;    加密引擎使用 (SSL). &quot;--engine list&quot; for list    --cacert &lt;file&gt;    CA证书 (SSL)    --capath &lt;directory&gt;    CA目录 (made using c_rehash) to verify peer against (SSL)    --ciphers &lt;list&gt;    SSL密码    --compressed    要求返回是压缩的形势 (using deflate or gzip)    --connect-timeout &lt;seconds&gt;    设置最大请求时间    --create-dirs    建立本地目录的目录层次结构    --crlf    上传是把LF转变成CRLF-f/--fail    连接失败时不显示http错误    --ftp-create-dirs    如果远程目录不存在，创建远程目录    --ftp-method [multicwd/nocwd/singlecwd]    控制CWD的使用    --ftp-pasv    使用 PASV/EPSV 代替端口    --ftp-skip-pasv-ip    使用PASV的时候,忽略该IP地址    --ftp-ssl    尝试用 SSL/TLS 来进行ftp数据传输    --ftp-ssl-reqd    要求用 SSL/TLS 来进行ftp数据传输-F/--form &lt;name=content&gt;    模拟http表单提交数据    --form-string &lt;name=string&gt;    模拟http表单提交数据-g/--globoff    禁用网址序列和范围使用{}和[]-G/--get    以get的方式来发送数据-H/--header &lt;line&gt;    自定义头信息传递给服务器    --ignore-content-length    忽略的HTTP头信息的长度-i/--include    输出时包括protocol头信息-I/--head    只显示请求头信息-j/--junk-session-cookies    读取文件进忽略session cookie    --interface &lt;interface&gt;    使用指定网络接口/地址    --krb4 &lt;level&gt;    使用指定安全级别的krb4-k/--insecure    允许不使用证书到SSL站点-K/--config    指定的配置文件读取-l/--list-only    列出ftp目录下的文件名称    --limit-rate &lt;rate&gt;    设置传输速度    --local-port&lt;NUM&gt;    强制使用本地端口号-m/--max-time &lt;seconds&gt;    设置最大传输时间    --max-redirs &lt;num&gt;    设置最大读取的目录数    --max-filesize &lt;bytes&gt;    设置最大下载的文件总量-M/--manual    显示全手动-n/--netrc    从netrc文件中读取用户名和密码    --netrc-optional    使用 .netrc 或者 URL来覆盖-n    --ntlm    使用 HTTP NTLM 身份验证-N/--no-buffer    禁用缓冲输出-o/--output    把输出写到该文件中-O/--remote-name    把输出写到该文件中，保留远程文件的文件名-p/--proxytunnel    使用HTTP代理    --proxy-anyauth    选择任一代理身份验证方法    --proxy-basic    在代理上使用基本身份验证    --proxy-digest    在代理上使用数字身份验证    --proxy-ntlm    在代理上使用ntlm身份验证-P/--ftp-port &lt;address&gt;    使用端口地址，而不是使用PASV-q    作为第一个参数，关闭 .curlrc-Q/--quote &lt;cmd&gt;    文件传输前，发送命令到服务器-r/--range &lt;range&gt;    检索来自HTTP/1.1或FTP服务器字节范围--range-file    读取（SSL）的随机文件-R/--remote-time    在本地生成文件时，保留远程文件时间    --retry &lt;num&gt;    传输出现问题时，重试的次数    --retry-delay &lt;seconds&gt;    传输出现问题时，设置重试间隔时间    --retry-max-time &lt;seconds&gt;    传输出现问题时，设置最大重试时间-s/--silent    静默模式。不输出任何东西-S/--show-error    显示错误    --socks4 &lt;host[:port]&gt;    用socks4代理给定主机和端口    --socks5 &lt;host[:port]&gt;    用socks5代理给定主机和端口    --stderr &lt;file&gt;     -t/--telnet-option &lt;OPT=val&gt;    Telnet选项设置    --trace &lt;file&gt;    对指定文件进行debug    --trace-ascii &lt;file&gt;    Like --跟踪但没有hex输出    --trace-time    跟踪/详细输出时，添加时间戳-T/--upload-file &lt;file&gt;    上传文件    --url &lt;URL&gt;    Spet URL to work with-u/--user &lt;user[:password]&gt;    设置服务器的用户和密码-U/--proxy-user &lt;user[:password]&gt;    设置代理用户名和密码-w/--write-out [format]    什么输出完成后-x/--proxy &lt;host[:port]&gt;    在给定的端口上使用HTTP代理-X/--request &lt;command&gt;    指定什么命令-y/--speed-time    放弃限速所要的时间，默认为30-Y/--speed-limit    停止传输速度的限制，速度时间</code></pre><p>具体可看：<a href="http://man.linuxde.net/curl" target="_blank" rel="external">http://man.linuxde.net/curl</a></p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><h3 id="一、查看网页源码"><a href="#一、查看网页源码" class="headerlink" title="一、查看网页源码"></a>一、查看网页源码</h3><p>直接在curl命令后加上网址，就可以看到网页源码。我们以网址www.sina.com为例（选择该网址，主要因为它的网页代码较短）：</p><pre><code>　　$ curl www.sina.com　　&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;　　&lt;html&gt;&lt;head&gt;　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;　　&lt;/head&gt;&lt;body&gt;　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;　　&lt;p&gt;The document has moved &lt;a href=&quot;http://www.sina.com.cn/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;　　&lt;/body&gt;&lt;/html&gt;</code></pre><p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用wget命令了。</p><pre><code>　　$ curl -o [文件名] www.sina.com</code></pre><h3 id="二、自动跳转"><a href="#二、自动跳转" class="headerlink" title="二、自动跳转"></a>二、自动跳转</h3><p>有的网址是自动跳转的。使用<code>-L</code>参数，curl就会跳转到新的网址。</p><pre><code>　　$ curl -L www.sina.com</code></pre><p>键入上面的命令，结果就自动跳转为www.sina.com.cn。</p><h3 id="三、显示头信息"><a href="#三、显示头信息" class="headerlink" title="三、显示头信息"></a>三、显示头信息</h3><p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p><pre><code>　　$ curl -i www.sina.com　　HTTP/1.0 301 Moved Permanently　　Date: Sat, 03 Sep 2011 23:44:10 GMT　　Server: Apache/2.0.54 (Unix)　　Location: http://www.sina.com.cn/　　Cache-Control: max-age=3600　　Expires: Sun, 04 Sep 2011 00:44:10 GMT　　Vary: Accept-Encoding　　Content-Length: 231　　Content-Type: text/html; charset=iso-8859-1　　Age: 3239　　X-Cache: HIT from sh201-9.sina.com.cn　　Connection: close　　&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;　　&lt;html&gt;&lt;head&gt;　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;　　&lt;/head&gt;&lt;body&gt;　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;　　&lt;p&gt;The document has moved &lt;a href=&quot;http://www.sina.com.cn/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;　　&lt;/body&gt;&lt;/html&gt;</code></pre><p><code>-I</code>参数则是只显示http response的头信息。</p><h3 id="四、显示通信过程"><a href="#四、显示通信过程" class="headerlink" title="四、显示通信过程"></a>四、显示通信过程</h3><p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p><pre><code>　　$ curl -v www.sina.com　　* About to connect() to www.sina.com port 80 (#0)　　* Trying 61.172.201.195... connected　　* Connected to www.sina.com (61.172.201.195) port 80 (#0)　　&gt; GET / HTTP/1.1　　&gt; User-Agent: curl/7.21.3 (i686-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18　　&gt; Host: www.sina.com　　&gt; Accept: */*　　&gt;　　* HTTP 1.0, assume close after body　　&lt; HTTP/1.0 301 Moved Permanently　　&lt; Date: Sun, 04 Sep 2011 00:42:39 GMT　　&lt; Server: Apache/2.0.54 (Unix)　　&lt; Location: http://www.sina.com.cn/　　&lt; Cache-Control: max-age=3600　　&lt; Expires: Sun, 04 Sep 2011 01:42:39 GMT　　&lt; Vary: Accept-Encoding　　&lt; Content-Length: 231　　&lt; Content-Type: text/html; charset=iso-8859-1　　&lt; X-Cache: MISS from sh201-19.sina.com.cn　　&lt; Connection: close　　&lt;　　&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;　　&lt;html&gt;&lt;head&gt;　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;　　&lt;/head&gt;&lt;body&gt;　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;　　&lt;p&gt;The document has moved &lt;a href=&quot;http://www.sina.com.cn/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;　　&lt;/body&gt;&lt;/html&gt;　　* Closing connection #0</code></pre><p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p><pre><code>　　$ curl --trace output.txt www.sina.com</code></pre><p>或者</p><pre><code>　　$ curl --trace-ascii output.txt www.sina.com</code></pre><p>运行后，请打开output.txt文件查看。</p><h3 id="五、发送表单信息"><a href="#五、发送表单信息" class="headerlink" title="五、发送表单信息"></a>五、发送表单信息</h3><p>发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。</p><pre><code>　　$ curl example.com/form.cgi?data=xxx</code></pre><p>POST方法必须把数据和网址分开，curl就要用到–data参数。</p><pre><code>　　$ curl -X POST --data &quot;data=xxx&quot; example.com/form.cgi</code></pre><p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是<code>--data-urlencode</code>。</p><pre><code>　　$ curl -X POST--data-urlencode &quot;date=April 1&quot; example.com/form.cgi</code></pre><h3 id="六、HTTP动词"><a href="#六、HTTP动词" class="headerlink" title="六、HTTP动词"></a>六、HTTP动词</h3><p>curl默认的HTTP动词是GET，使用<code>-X</code>参数可以支持其他动词。</p><pre><code>　　$ curl -X POST www.example.com　　$ curl -X DELETE www.example.com</code></pre><h3 id="七、文件上传"><a href="#七、文件上传" class="headerlink" title="七、文件上传"></a>七、文件上传</h3><p>假定文件上传的表单是下面这样：</p><pre><code>　　&lt;form method=&quot;POST&quot; enctype=&apos;multipart/form-data&apos; action=&quot;upload.cgi&quot;&gt;　　　　&lt;input type=file name=upload&gt;　　　　&lt;input type=submit name=press value=&quot;OK&quot;&gt;　　&lt;/form&gt;</code></pre><p>你可以用curl这样上传文件：</p><pre><code>　　$ curl --form upload=@localfilename --form press=OK [URL]</code></pre><h3 id="八、Referer字段"><a href="#八、Referer字段" class="headerlink" title="八、Referer字段"></a>八、Referer字段</h3><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p><pre><code>　　$ curl --referer http://www.example.com http://www.example.com</code></pre><h3 id="九、User-Agent字段"><a href="#九、User-Agent字段" class="headerlink" title="九、User Agent字段"></a>九、User Agent字段</h3><p>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p><p>iPhone4的User Agent是</p><pre><code>　　Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</code></pre><p>curl可以这样模拟：</p><pre><code>　　$ curl --user-agent &quot;[User Agent]&quot; [URL]</code></pre><h3 id="十、cookie"><a href="#十、cookie" class="headerlink" title="十、cookie"></a>十、cookie</h3><p>使用<code>--cookie</code>参数，可以让curl发送cookie。</p><pre><code>　　$ curl --cookie &quot;name=xxx&quot; www.example.com</code></pre><p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p><p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p><pre><code>　　$ curl -c cookies http://example.com　　$ curl -b cookies http://example.com</code></pre><h3 id="十一、增加头信息"><a href="#十一、增加头信息" class="headerlink" title="十一、增加头信息"></a>十一、增加头信息</h3><p>有时需要在http request之中，自行增加一个头信息。<code>--header</code>参数就可以起到这个作用。</p><pre><code>　　$ curl --header &quot;Content-Type:application/json&quot; http://example.com</code></pre><h3 id="十二、HTTP认证"><a href="#十二、HTTP认证" class="headerlink" title="十二、HTTP认证"></a>十二、HTTP认证</h3><p>有些网域需要HTTP认证，这时curl需要用到<code>--user</code>参数。</p><pre><code>　　$ curl --user name:password example.com</code></pre><h3 id="十三、监控"><a href="#十三、监控" class="headerlink" title="十三、监控"></a>十三、监控</h3><p>1、开启gzip请求</p><pre><code>curl -I http://www.sina.com.cn/ -H Accept-Encoding:gzip,defalte</code></pre><p>2、监控网页的响应时间</p><pre><code>curl -o /dev/null -s -w &quot;time_connect: %{time_connect}\ntime_starttransfer: %{time_starttransfer}\ntime_total: %{time_total}\n&quot; &quot;http://www.kklinux.com&quot;</code></pre><p>3、 监控站点可用性</p><pre><code>curl -o /dev/null -s -w %{http_code} &quot;http://www.kklinux.com&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>关于php的单例模式</title>
    <link href="http://martist.cn/2018/03/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://martist.cn/2018/03/12/单例模式的理解/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-13T07:59:01.274Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><blockquote><p>单例模式(Singleton Pattern)：顾名思义，就是只有一个实例。作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p></blockquote><h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><p>1、PHP语言本身的局限性<br>PHP语言是一种解释型的脚本语言，这种运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收。也就是说，PHP在语言级别上没有办法让某个对象常驻内存，这和asp.NET、Java等编译型是不同的，比如在Java中单例会一直存在于整个应用程序的生命周期里，变量是跨页面级的，真正可以做到这个实例在应用程序生命周期中的唯一性。然而在PHP中，所有的变量无论是全局变量还是类的静态成员，都是页面级的，每次页面被执行时，都会重新建立新的对象，都会在页面执行完毕后被清空，这样似乎PHP单例模式就没有什么意义了，所以PHP单例模式我觉得只是针对单次页面级请求时出现多个应用场景并需要共享同一对象资源时是非常有意义的。</p><p>2、应用场景<br>一个应用中会存在大量的数据库操作，比如过数据库句柄来连接数据库这一行为，使用单例模式可以避免大量的new操作，因为每一次new操作都会消耗内存资源和系统资源。<br>如果系统中需要有一个类来全局控制某些配置信息,那么使用单例模式可以很方便的实现.</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>一个类只能有一个对象</li><li>必须是自行创建这个类的对象</li><li>要想整个系统提供这一个对象</li></ol><h2 id="具体实现的重点"><a href="#具体实现的重点" class="headerlink" title="具体实现的重点"></a>具体实现的重点</h2><ol><li>单例模式的类只提供私有的构造函数，</li><li>类定义中含有一个该类的静态私有对象，</li><li>该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>class Singleton{        //存放实例        private static $_instance = null;        //私有化构造方法、        private function __construct(){            echo &quot;单例模式的实例被构造了&quot;;        }        //私有化克隆方法        private function __clone(){        }        //公有化获取实例方法        public static function getInstance(){            if (!(self::$_instance instanceof Singleton)){                self::$_instance = new Singleton();            }            return self::$_instance;        }    }    $singleton=Singleton::getInstance();</code></pre><h2 id="OOP知识补习"><a href="#OOP知识补习" class="headerlink" title="OOP知识补习"></a>OOP知识补习</h2><h3 id="类型运算符instanceof"><a href="#类型运算符instanceof" class="headerlink" title="类型运算符instanceof"></a>类型运算符instanceof</h3><pre><code>&lt;?phpclass MyClass{}class NotMyClass{}$a = new MyClass;var_dump($a instanceof MyClass);var_dump($a instanceof NotMyClass);?&gt;</code></pre><p>以上例程会输出：</p><pre><code>bool(true)bool(false)</code></pre><p>instanceof用于确定一个变量是不是实现了某个类，继承类，接口的对象的实例。<br>如果被检测的变量不是对象，instanceof 并不发出任何错误信息而是返回 FALSE。不允许用来检测常量。</p><h3 id="魔术方法-construct"><a href="#魔术方法-construct" class="headerlink" title="魔术方法__construct()"></a>魔术方法__construct()</h3><p>构造方法声明为private，防止直接创建对象 ，这样new Singleton() 会报错。</p><p>  private function __construct()<br>  {<br>      echo ‘Iam constructed’;<br>  }</p><h3 id="魔术方法-clone"><a href="#魔术方法-clone" class="headerlink" title="魔术方法__clone()"></a>魔术方法__clone()</h3><p>当类的复制完成时，如果定义了<strong>clone()方法，则新创建的对象（复制生成的对象）中的</strong>clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。私有化<strong>clone可以防止克隆该类的对象。<br>注意一点：clone的对象不执行</strong>construct里的方法</p><p>所以我们在防止单例模式的 $singleton对象被clone，有两种方法可以做到。</p><p>第一种方法:设置魔术方法<strong>clone();访问权限为private<br>第二种方法:若</strong>clone()为公用方法，则在函数中加上自定义错误。</p><pre><code>// 阻止用户复制对象实例public function __clone(){    trigger_error(&apos;Clone is not allowed.&apos;,E_USER_ERROR);}</code></pre><blockquote><p>关于 <strong>clone() , PHP官方的文档： Once the cloing is complete, if a </strong>clone() method is defined, then the newly created object’s __clone() method will be called, to allow any necessary properties that need to be changed.</p></blockquote><h3 id="关键字clone和赋值"><a href="#关键字clone和赋值" class="headerlink" title="关键字clone和赋值"></a>关键字clone和赋值</h3><pre><code>class foo {    public $bar = &apos;php&apos;;}$foo = new foo();$a = $foo; // 标识符赋值(把$a赋值为null,原来的$foo并不会变成null,但通过$a能够修改$foo的成员$bar)$a = &amp;$foo; // 引用赋值(把$a赋值为null,原来的$foo也会跟着变成null)$a = clone $foo; // 值赋值(赋值后互不影响，在计算机内存上的体现属于浅复制)</code></pre><h3 id="对象复制"><a href="#对象复制" class="headerlink" title="对象复制"></a>对象复制</h3><p>在PHP中， 对象间的赋值操作实际上是引用操作 （事实上，绝大部分的编程语言都是如此! 主要原因是内存及性能的问题) ， 比如 :</p><pre><code>class myclass {public $data;}$obj1 = new myclass();$obj1-&gt;data = &quot;aaa&quot;；$obj2 = $obj1;$obj2-&gt;data =&quot;bbb&quot;;     //$obj1-&gt;data的值也会变成&quot;bbb&quot;</code></pre><p>因为$obj1和$obj2都是指向同一个内存区的引用，所以修改任何一个对象都会同时修改另外一个对象。</p><p>在有些时候，我们其实不希望这种reference式的赋值方式， 我们希望能完全复制一个对象，这是侯就需要用到 Php中的clone (对象复制）。</p><pre><code>class myclass {public $data;}$obj1 = new myclass();$obj1-&gt;data =&quot;aaa&quot;;$obj2 = clone $obj1;$obj2-&gt;data =&quot;bbb&quot;;     // $obj1-&gt;data的值仍然为&quot;aaa&quot;</code></pre><p>因为clone的方式实际上是对整个对象的内存区域进行了一次复制并用新的对象变量指向新的内存， 因此赋值后的对象和源对象相互之间是基本来说独立的。</p><h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p>什么？ 基本独立？！这是什么意思？ 因为PHP的object clone采用的是浅复制(shallow copy)的方法, 如果对象里的属性成员本身就是reference类型的，clone以后这些成员并没有被真正复制，仍然是引用的。 （事实上，其他大部分语言也是这样实现的， 如果你对C++的内存，拷贝，copy constructor等概念比较熟悉，就很容易理解这个概念）, 下面是一个例子来说明：</p><pre><code>class myClass{public $data;}$sss =&quot;aaa&quot;;$obj1 = new myClass();$obj1-&gt;data =&amp;$sss;   //注意，这里是个reference!$obj2 = clone $obj1;$obj2-&gt;data=&quot;bbb&quot;;  //这时，$obj1-&gt;data的值变成了&quot;bbb&quot; 而不是&quot;aaa&quot;!var_dump($obj1);var_dump($obj2);</code></pre><p>我们再举一个更实用的例子来说明一下PHP clone这种浅复制带来的后果：</p><pre><code>class testClass{   public $str_data;   public $obj_data;}$dateTimeObj = new DateTime(&quot;2014-07-05&quot;, new DateTimeZone(&quot;UTC&quot;));$obj1 = new testClass();$obj1-&gt;str_data =&quot;aaa&quot;;$obj1-&gt;obj_data = $dateTimeObj;$obj2 = clone $obj1;var_dump($obj1);    // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;var_dump($obj2);    // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;$obj2-&gt;str_data =&quot;bbb&quot;;$obj2-&gt;obj_data-&gt;add(new DateInterval(&apos;P10D&apos;));      //给$obj2-&gt;obj_date 的时间增加了10天var_dump($obj1);     // str_data：&quot;aaa&quot;   obj_data：&quot;2014-07-15 00:00:00&quot;  !!!!var_dump($obj2);     // str_data：&quot;bbb&quot;   obj_data：&quot;2014-07-15 00:00:00&quot;var_dump($dateTimeObj)  // 2014-07-15 00:00:00&quot;</code></pre><p>这一下可以更加清楚的看到问题了吧。 一般来讲，你用clone来复制对象，希望是把两个对象彻底分开，不希望他们之间有任何关联， 但由于clone的shallow copy的特性， 有时候会出现非你期望的结果.</p><h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>1) $obj1-&gt;obj_data =$dateTimeObj 这句话实际上是个引用类型的赋值. 还记得前面提到的PHP中对象直接的赋值是引用操作么？除非你用$obj1-&gt;obj_dat = clone $dataTimeObj!</p><p>2) $obj2 = clone $obj1 这句话生成了一个obj1对象的浅复制对象，并赋给obj2. 由于是浅复制，obj2中的obj_data也是对$dateTimeObj的引用！</p><p>3）$dateTimeObj, $obj1-&gt;obj_data, $obj2-&gt;obj_data 实际上是同一个内存区对象数据的引用，因此修改其中任何一个都会影响其他两个！</p><p>如何解决这个问题呢？ 采用PHP中的 __clone方法 把浅复制转换为深复制（这个方法给C++中的copy constructor概念上有些相似，但执行流程并不一样）</p><pre><code>class testClass{ public $str_data; public $obj_data; public function __clone() {   $this-&gt;obj_data = clone $this-&gt;obj_data;}$dateTimeObj = new DateTime(&quot;2014-07-05&quot;, new DateTimeZone(&quot;UTC&quot;));$obj1 = new testClass();$obj1-&gt;str_data =&quot;aaa&quot;;$obj1-&gt;obj_data = $dateTimeObj;$obj2 = clone $obj1;var_dump($obj1);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;var_dump($obj2);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;$obj2-&gt;str_data =&quot;bbb&quot;;$obj2-&gt;obj_data-&gt;add(new DateInterval(&apos;P10D&apos;));var_dump($obj1);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-05 00:00:00&quot;var_dump($obj2);  // str_data：&quot;aaa&quot;  obj_data：&quot;2014-07-15 00:00:00&quot;var_dump($dateTimeObj);  //&quot;2014-07-05 00:00:00&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>让我们脱离国定器械</title>
    <link href="http://martist.cn/2018/03/03/%E8%84%B1%E7%A6%BB%E5%9B%BD%E5%AE%9A%E5%99%A8%E6%A2%B0/"/>
    <id>http://martist.cn/2018/03/03/脱离国定器械/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2018-04-12T12:00:05.603Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><blockquote><p>从安全角度讲，为什么不推荐史密斯架等固定轨迹器械训练？</p></blockquote><p>我说来说去都是杠铃、哑铃（其实哑铃我都没说过），从不推荐练史密斯架或是各种各样的固定轨迹器械。这是为什么？今天，我从安全角度来说说。针对普通训练者，高阶健美、康复阶段等不在探讨范围内。</p><p>看我文章的，大多是去过健身房的。健身房的一大特色就是，那里总有一堆一堆的器械，看上去很高级，甚至让初学者神往。有不少人问我，健身房的那些器械不会用，怎么办？我的回答很简单：那太好了，你直接路过就行，别碰它们。</p><p>我这么说，不是想拉人来我的地方训练，更不是不负责任，仅仅是从安全角度为他们考虑。</p><p>很多人认为，那些固定器械很安全，掉不下来，砸不到人，不会出事故。这是对的，非常正确的，所以，健身房就有了这些东西，注意——是为了不出事故。健身房不希望你深蹲的时候，哦，对了，好多健身房连自由深蹲架都没有，卧推吧。健身房不希望你卧推的时候被杠铃压在下面，你左右扭动，最终把杠铃扔到地上了，结果地板上多了一个坑；他们也不希望你左右扭动，却没扭出来，结果受伤了。所以，健身房要有那些能确保不会出现人身事故、财产损失的家伙，于是，“安全”的固定轨迹器械就诞生了。</p><p>可是，好像从没有人考虑，这些器械，对于自己的训练，会不会出问题。其实不是不考虑，是很多人考虑不到。我今天要说的安全，是关于训练者自己的，而不是关于健身房的经营者的。</p><p>我们还是拿一个几乎所有人都会做且都做过的项目来说吧——卧推。</p><p>这个动作功能性、结构性都很差，但力量表现很好，而且，当泵感上来的时候，借用我一个学员的话：“很屌的感觉”。那么卧推的时候，简单地说，主要发力肌群是胸大肌、肱三头肌、三角肌前束，这是我们都知道的。卧推在向心收缩过（把杠铃推起，向心离心搞不清楚的，请看文末扩展阅读）程中，主要是胸大肌、三角肌前束负责改变肩关节角度，肱三头肌伸展肘关节。但是，请注意，胸前那个家伙是相当重的啊，负责稳定的肌群要保证杠铃轨迹，千万不能让它远离我们控制的范围，换句话说，就是还有一些肌肉要保证杠铃别跑到眼睛或肚子上方。</p><p>可是在史密斯架卧推的时候呢，重量大了或次数多了，主发力肌群力量不足，而轨迹又被固定了，那么无论你的力是朝着哪个方向，只要有一点向上的意思杠铃就能向上走。结果显而易见，当即将力竭或是训练者无法准确控制动作的时候，所有负责稳定的肌群就都会参与发力，于是，关节只能承受50公斤的时候，你60公斤也一样推得起来。在史密斯架上，50公斤的力量、50公斤承受能力，推60公斤的杠铃，推一次可以，推十次，我就想问问你肩关节还是否舒服了。</p><p>再说了，如果你对自己的肩关节负责的话，卧推，能直上直下吗？</p><p>所有让负责稳定的肌群无需发力控制轨迹的固定轨迹器械，对普通训练者都非常糟糕。当然，作为职业健美运动员，这些器械是有价值的，它们可以让训练者更好地训练目标肌群。请注意，职业运动员，成绩是第一位的，其它都不重要。带伤上场、比赛受伤都是很常见的，现在禁药查得这么严，很多运动员不照样用嘛。但这作为他们的职业，就像你明知熬夜不好、作息颠倒不好，为了工作，有时候不也得这么干嘛。</p><p>问题是，你是职业健美运动员吗，你致力于成为职业健美运动员吗，你具备职业健美运动员的训练水平吗？不是的话，咱还是照着普通人健身的思路走，悠着点吧。</p><p>史密斯架深蹲，和史密斯架卧推还是有区别的。但是，深蹲这事，肩上那个杠铃很重，重到你不愿出现一点点重心不稳的情况，有保护还好，不然一不小心就是事故。而史密斯架深蹲就不一样了，什么节律、什么重心、什么前后左右，统统不用管，你就可劲干吧。50公斤的力量、50公斤承受能力，深蹲60公斤的杠铃。</p><p>健身房里，见过史密斯架前有人做“老熊蹭树”的动作吧？就是双脚站在杠铃投影前面老远做深蹲。蹲下去的时候躯干竖直，从侧面看就像是扛着杠铃坐上了一个不可见的椅子。你在侧面看一会，就能理解这诡异的动作为什么叫“老熊蹭树”了。如果他们的理由是这动作不伤膝盖，因为膝盖不会过脚尖，请看扩展阅读，深蹲能否过脚尖这事我写过了。</p><p>说道这，结论该有了。固定轨迹的器械会让训练者负责稳定的肌群参与发力。随着时间的推移，关节承受不了的重量长时间被使用，最终，训练者受伤。这时候，你到哪说理去呢？</p><p>如果你还对那些看上去很高级的器械神往的话，希望你看了这篇小文能有所收获，为了你自己，为了将陪你一辈子的关节考虑，放弃那些为健身房经营者设计的玩意吧。</p><p>多说一句。钢线器械不一样啊，不是固定轨迹的。钢线很好，不像杠铃哑铃壶铃之类只能对抗向下的重力，它可以让阻力朝向任何你需要的方向。比如，练肩外旋的同志们，用哑铃可苦了，得趴着或撅着，有了钢线器械，你想站着、坐着、甚至躺着都行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="健身" scheme="http://martist.cn/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
      <category term="健身" scheme="http://martist.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="http://martist.cn/2018/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://martist.cn/2018/03/02/中间件/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-03-27T07:38:10.575Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>根据zend-framework中的定义：</p><pre><code>所谓中间件是指提供在请求和响应之间的，能够截获请求，并在其基础上进行逻辑处理，与此同时能够完成请求的响应或传递到下一个中间件的代码。</code></pre><p>在两个服务之间的模块，都可以称为中间件。</p><p>中间件应该一种架构方法，不局限于特定的语言。<br>例如提供不同应用之间消息通讯的消息中间件。淘宝下面很多产品之间都需要信息共享，通过一个中间人来专门传递消息。这样做很容易扩展，对上层应用提供统一消息操作接口就行了。<br>单个程序内部也可以有中间件，一个程序内部实现对中间件接口对支持。<br>把底层的接口包装一层，然后向上层提供接口。这样底层改变的话，上层也就是你写的代码不用动，只改中间件即可。由于只有中间件一个地方调用底层，改起来会比较方便。</p><h2 id="有哪些"><a href="#有哪些" class="headerlink" title="有哪些"></a>有哪些</h2><p>非底层操作系统软件、非业务应用软件，不是直接给最终用户使用的，不能直接给客户带来价值的软件，统称中间件。常见的有如下几种：服务中间件、集成中间件、数据中间件、消息中间件、安全中间件。</p><p>用Java实现的中间件，统称Java中间件。中间件，可以理解为类库，介于类库和产品之间。中间件真的是java世界的产物，我等phper能找的资料太少了。</p><p>说简单一点，就是你的程序A和程序B互相通信使用的协议，程序A,B可以由不同语言不同平台构建。但是协议可以保证他们能互相认识互发的东西。</p><p>简单说，中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件是不可替换的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。</p><h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>消息中间件就是一个临时存储器。主要解决应用耦合，异步消息，流量削锋等问题，是大型分布式系统不可缺少的中间件。</p><pre><code>1.用于海量数据洪峰的临时存储,比如抢购秒杀,后端程序一下子处理不了这么多抢购请求,那就由消息中间件来存储抢购请求,后端程序再慢慢取出消息处理呗2.用于多个系统之间的消息传递</code></pre><p>目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。</p><h3 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h3><p>使用场景的比较多，比如：</p><pre><code>1、读写分离2、数据库从库的负载均衡3、分布式事务4、支持多种数据库（Mysql、PG、Oracle等）</code></pre><h3 id="框架中的中间件"><a href="#框架中的中间件" class="headerlink" title="框架中的中间件"></a>框架中的中间件</h3><p>CI框架和tp框架中的hook（钩子），就是中间件的一种。<br>laravel中可以使用php artisan 命令创建中间件，比如请求过滤器就是最常见的中间件使用方法一种。Laravel支持全局的中间件和根据具体路由规定的中间件两种，同时优先级又以定义顺序为准。<br>ZendFramework是由zend公司推出的php框架，其目标就是建立一套大而全的php框架。以满足企业应用开发的目标。其中”zend-stratigility” 负责提供中间件以及中间件执行流的功能。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>一片比较巧妙设计中间件的文章<br><a href="https://blog.csdn.net/qq_20329253/article/details/52202811" target="_blank" rel="external">https://blog.csdn.net/qq_20329253/article/details/52202811</a><br>一片用闭包实现中间件的文章<br><a href="http://blog.csdn.net/allen_tsang/article/details/51777911" target="_blank" rel="external">http://blog.csdn.net/allen_tsang/article/details/51777911</a></p>]]></content>
    
    <summary type="html">
    
      谈谈我对中间件的理解
    
    </summary>
    
      <category term="常识" scheme="http://martist.cn/categories/%E5%B8%B8%E8%AF%86/"/>
    
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>php实现汉诺塔</title>
    <link href="http://martist.cn/2018/03/01/php%E5%AE%9E%E7%8E%B0%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <id>http://martist.cn/2018/03/01/php实现汉诺塔/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-03-27T08:32:25.748Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      算法入门
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的模式方法__tostring()和__invoke()</title>
    <link href="http://martist.cn/2018/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95__tostring()%E5%92%8C__invoke()/"/>
    <id>http://martist.cn/2018/03/01/面向对象的魔术方法__tostring()和__invoke()/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-04-16T07:43:06.650Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="tostring-魔术方法"><a href="#tostring-魔术方法" class="headerlink" title="__tostring()魔术方法"></a>__tostring()魔术方法</h2><p>　　将一个对象当做一个字符串来使用时，会自动调用该方法，并且在该方法中，可以返回一定的字符串，以表明该对象转换为字符串之后的结果。该魔术方法比较常用。<br>　　注意：如果没有定义该方法，则对象无法当做字符串来使用！<br>类里面未定义__tostring()方法的例子：</p><pre><code>&lt;?phpini_set(&apos;display_errors&apos;, 1);class A{    public $name;    public $age;    public $sex;    function __construct($name, $age, $sex){        $this-&gt;name = $name;        $this-&gt;age = $age;        $this-&gt;sex = $sex;       }}$obj1 = new A(&apos;张三&apos;, 15, &apos;男&apos;);echo $obj1;    //echo 后面为字符串，而对象不是字符串，会报错$v1 = &quot;abc&quot; . $obj1;  //.为字符串连接符，会报错$v2 = &quot;abx&quot; + $obj1;  //+为加法运算符，会报错?&gt;</code></pre><p>3个报错内容分别为</p><pre><code>Catchable fatal error: Object of class A could not be converted to stringCatchable fatal error: Object of class A could not be converted to stringNotice: Object of class A could not be converted to int</code></pre><p>类里面定义__tostring()方法</p><pre><code>&lt;?phpini_set(&apos;display_errors&apos;, 1);class A{    public $name;    public $age;    public $sex;    function __construct($name, $age, $sex){        $this-&gt;name = $name;        $this-&gt;age = $age;        $this-&gt;sex = $sex;       }    function __tostring(){        $str = &quot;姓名：&quot; . $this-&gt;name;           $str .= &quot;年龄：&quot; . $this-&gt;age;            $str .= &quot;，性别：&quot; . $this-&gt;sex;        return $str;   //这里可以返回“任何字符串内容”    }}$obj1 = new A(&apos;张三&apos;, 15, &apos;男&apos;);echo $obj1;    //调用__tostring(),不会报错?&gt;</code></pre><p>运行结果</p><pre><code>姓名：张三年龄：15，性别：男</code></pre><h2 id="invoke-魔术方法"><a href="#invoke-魔术方法" class="headerlink" title="__invoke()魔术方法"></a>__invoke()魔术方法</h2><p>　　将对象当作函数来使用时，会自动调用该方法。通常不推荐这么做。</p><pre><code>class A{    function __invoke(){        echo &quot;&lt;br /&gt;我是一个对象呀，你别把我当作一个函数来调用啊！&quot;;    }}$obj = new A();$obj();    //此时就会调用类中的方法：__invoke()</code></pre><p>结果：</p><pre><code>我是一个对象呀，你别把我当作一个函数来调用啊！</code></pre>]]></content>
    
    <summary type="html">
    
      php
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>鸟哥的一次采访实录【转载】</title>
    <link href="http://martist.cn/2018/02/24/%E6%83%A0%E6%96%B0%E5%AE%B8%E9%87%87%E8%AE%BF/"/>
    <id>http://martist.cn/2018/02/24/惠新宸采访/</id>
    <published>2018-02-23T16:00:00.000Z</published>
    <updated>2018-03-27T07:38:16.069Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a><br>PHP 7.1 已于12月1日正式发布，带来了全新的特性和功能。对于 PHP 开发者来说，每个正式版本的更新都是值得记住的日子，每次发布的新特性也都值得去尝试和研究。本期，【开源访谈】邀请到了 PHP 大神鸟哥惠新宸<a href="https://my.oschina.net/laruence" target="_blank" rel="external">@Laruence</a> ，听听他对 PHP 7.1 的看法，聊聊他当初学习 PHP 的那些事。</p><p>【本期嘉宾】</p><p>惠新宸，鸟哥，国内最有影响力的 PHP 技术专家， PHP 开发组核心成员，PHP 7 核心开发者。曾供职于雅虎、百度、新浪，现任链家网技术副总裁兼总架构师。是 Yaf、Yar 以及 Yac 、Taint 等多个开源项目的作者。</p><p>【采访实录】</p><h3 id="1、最初是因为什么喜欢上-PHP-的？"><a href="#1、最初是因为什么喜欢上-PHP-的？" class="headerlink" title="1、最初是因为什么喜欢上 PHP 的？"></a>1、最初是因为什么喜欢上 PHP 的？</h3><p>答：其实倒没有一开始就喜欢，06年还是研究生的时候，要给学校做一些网站，就逼着自己去学，阴差阳错的学了 PHP ，然后就一直做到现在。现在来说肯定是喜欢的，有感情在里面，别人说它不好，也会不舒服。当觉得自己有力量和途径去让它变好时，当发现它有哪里不好的时候，感觉会像是一个责任，会觉得可能自己不去管或许就没人管，可能更多的时候是这种感觉吧。</p><h3 id="2、学习过程中是怎么一步步提高自己的技术能力的，有没有一些心得分享？"><a href="#2、学习过程中是怎么一步步提高自己的技术能力的，有没有一些心得分享？" class="headerlink" title="2、学习过程中是怎么一步步提高自己的技术能力的，有没有一些心得分享？"></a>2、学习过程中是怎么一步步提高自己的技术能力的，有没有一些心得分享？</h3><p>答：我觉得更多的是要去研究，把每个遇到的问题都搞清楚。我经常会跟一些刚毕业的同学讲，你现在学的东西跟你的课本到底能不能联系起来？如果现在学的、用的东西通过一系列的摸索，能跟课本里面学到的那些东西贯通起来，说明你已经找到了好的学习方法。</p><p>记得在刚开始学做网站时，听说一项新技术，我就想在自己的网站里面去实现。结果各种不通，各种搞不定。我两天一夜没有睡觉去研究它，最后发现是编码的问题。还有07年刚开始参加工作在雅虎实习的时候，有段时间公司项目组做封闭开发，当时我住得离公司比较远，就在公司附近的一个酒店住了好几个月，每天都是工作到晚上12点以后，甚至到凌晨1、2点，然后早上起来吃个饭又去上班。我觉得更多的时候是要去专研，把遇到的每个问题、每个分支都搞清楚是什么原因。比如去研究一个东西，当研究到它操作系统的层面时，操作系统会告诉你一个结论。这个结论是怎么来的？你有没有兴趣去搞清楚，我觉得这就是关键。</p><h3 id="3、据了解，您有同时参与多个项目的开发，是怎么来安排自己的时间呢？"><a href="#3、据了解，您有同时参与多个项目的开发，是怎么来安排自己的时间呢？" class="headerlink" title="3、据了解，您有同时参与多个项目的开发，是怎么来安排自己的时间呢？"></a>3、据了解，您有同时参与多个项目的开发，是怎么来安排自己的时间呢？</h3><p>答：对于那个时候的我来说，根本没有时间管理一说，基本上都是一件事搞定之后再去做另外一件事。我觉得唯一需要时间安排的就是跟人约好的事情，当涉及到别人的时候，因为要尊重别人，要守时。更多的时候，一项工作搞不定我不会去做下一项工作。当然，所谓的搞定也有一个度，比如说做到了一个里程碑，我会歇一歇，换个思路去做另一件事情。</p><p>时间管理，我觉得可能更多的时候是你的事情是相对来说比较灵活的情况下才会去做。如果是真正去研究一个问题的时候，不可能时间管理，你吃饭也想，睡觉也想，什么时候都在想，这个问题解决不了，睡不好吃不好，还谈什么时间管理。</p><h3 id="4、对于普通技术人员来说，遇到问题可以请教高手。那对于您这样的技术大神遇到阻力时，会如何去解决？"><a href="#4、对于普通技术人员来说，遇到问题可以请教高手。那对于您这样的技术大神遇到阻力时，会如何去解决？" class="headerlink" title="4、对于普通技术人员来说，遇到问题可以请教高手。那对于您这样的技术大神遇到阻力时，会如何去解决？"></a>4、对于普通技术人员来说，遇到问题可以请教高手。那对于您这样的技术大神遇到阻力时，会如何去解决？</h3><p>答：每个人都有一套自己的学习方法，这分很多种。比如说，问别人，这也是一套学习的方法，但问别人必须要有人可问。我刚开始做 PHP 的时候，几乎整个中国都没有几个人在做内核这块相关的东西。当时为了研究出一个变量的含义，去 Google 查不到，了解到上海有一个人写过一些内核的文章，就给他留言、发邮件，他可能比较忙也没回我。当费了好大的劲去研究一个东西，如果还搞不明白，那就重头再来！从它相关的地方开始读，直到有一天，恍然大悟，原来是这个样子。</p><p>很多时候，大家需要的只是一个学习的方法。对于我来说，就是去 Google ，去搜索，去读一些别人写的东西。当然，这两年，整个开发环境好了很多，资料越来越多。你要去研究任何的东西，基本上都会有人已经有一些研究和产出，而且他们也比较愿意去分享。</p><p>以前大家可能也没那么乐意去分享，包括我自己。我一开始也不想去分享，因为你分享一些东西，你说不清楚。比如分享一些东西涉及到操作系统层面，那操作系统层面有一些高手会说你这什么东西啊，这完全不对。不过慢慢的，我愿意去分享，愿意把知道的那些分享出来。如果你告诉我哪哪错了，我会非常感激，因为你帮助我学到了一些东西。学东西不是只有主动学习，被动学习也未尝不可。我有时候会出错，很多人会出错，我现在看以前写的文章，有很多关键点是错的，还是有很多东西没有搞明白。</p><h3 id="5、PHP-7-1-刚刚发布，最喜欢或最看好的新特性是什么？"><a href="#5、PHP-7-1-刚刚发布，最喜欢或最看好的新特性是什么？" class="headerlink" title="5、PHP 7.1 刚刚发布，最喜欢或最看好的新特性是什么？"></a>5、PHP 7.1 刚刚发布，最喜欢或最看好的新特性是什么？</h3><p>答：还真没有。我在北京源创会年终盛典上分享新特性时也说过，大部分我都投了反对票。因为我其实觉得语法糖这样的东西，会把这个语言搞得越来越复杂。我表达了我的观点，因为 PHP 比较民主。我记得前两天有一个特性30多个人赞成，就我一个反对。但我不觉得有什么，因为我表达了我的意见，我反对，不同意，我认为这个东西不好，没意义。但别人会觉得有意义，有的人会喜欢。</p><p>我觉得每一个去做开源，或者是做一些跟别人打交道特别多的工作的人，一定要有这样的心理素质，或养成这么个习惯，就是勇于表达自己的观点，不要害怕别人的反对。别人反对你，没关系，如果耐心的去听每个人的理由，其实都会有一定道理。这些新特性也是如此，他们也有自己的理由。我强烈反对的情况下或许是因为这东西对性能有影响，如果它对性能没有影响，我只会表达说它好或者不好。比如说 List 那个我觉得还 OK，因为它是一致性的问题。还有一个 Catch 多个 Exception，也是如此。非要说喜欢的话，那个 List 可以用方括号代替的特性还行，写起来可能会方便一点。</p><h3 id="6、PHP-7-1-是否达到了最佳性能？"><a href="#6、PHP-7-1-是否达到了最佳性能？" class="headerlink" title="6、PHP 7.1 是否达到了最佳性能？"></a>6、PHP 7.1 是否达到了最佳性能？</h3><p>答：不能说最，别看 PHP 7.1 现在这么快，但相比其它语言，在某些场景下，还是有差距的。这跟它天然的像动态、符号表、间接引用等特性有很大关系。PHP 7.1 相比 7.0 来说，做的最大的工作，就是一个类型推断系统加一个类型相关的中间代码执行引擎。这个不是新的工作，在2013年我们做 PHP 5.5 的 JIT 的时候类型推断系统已经做出来了，但当时把这个项目停掉了，现在把那项工作其中的类型推断部分拿过来，放到 7.1 。基于这个类型推断未来还可以做更多的东西。PHP 7.1 更多的是对 7.0 未完成的工作的一个补充。</p><h3 id="7、PHP-国内开发环境越来越成熟，您觉得-PHP-的未来会是怎样？"><a href="#7、PHP-国内开发环境越来越成熟，您觉得-PHP-的未来会是怎样？" class="headerlink" title="7、PHP 国内开发环境越来越成熟，您觉得 PHP 的未来会是怎样？"></a>7、PHP 国内开发环境越来越成熟，您觉得 PHP 的未来会是怎样？</h3><p>答：这个真不好说，谁知道呢是吧！之前有人问我为什么 PHP 这么火，我觉得是跟它的历史原因是有关系的。因为在 Web 诞生时期，其实可学的不多。但是现在可学的特别多，写 Web 的可以有 PHP、Go、Java、Node.js、Python 等等。时代在进步，大家的选择越来越多，根据喜好每个人的选择也不一样。未来到底怎样？这个真不好说……</p><h3 id="8、伴随着-PHP-火的声音的同时，还有-PHP-人员已经饱和的争议，对此怎么看？"><a href="#8、伴随着-PHP-火的声音的同时，还有-PHP-人员已经饱和的争议，对此怎么看？" class="headerlink" title="8、伴随着 PHP 火的声音的同时，还有 PHP 人员已经饱和的争议，对此怎么看？"></a>8、伴随着 PHP 火的声音的同时，还有 PHP 人员已经饱和的争议，对此怎么看？</h3><p>答：他们说饱和就饱和呗。其实有很多时候就是这样，以前的时候我会去争论一些事情，后来觉得其实没有什么意义。哪怕这个语言只有那么几个人在用，但这些人用的舒服，解决了他们的问题，我觉得也是好的。我曾经开玩笑说，PHP 100万人用和 1000万人用对我们来说有什么区别？没有区别，可能就是演讲的时候来的人多一些吧。</p><h3 id="9、还有种说法就是-PHP-学习起来特别简单，不利于展示个人能力，对此怎么看？"><a href="#9、还有种说法就是-PHP-学习起来特别简单，不利于展示个人能力，对此怎么看？" class="headerlink" title="9、还有种说法就是 PHP 学习起来特别简单，不利于展示个人能力，对此怎么看？"></a>9、还有种说法就是 PHP 学习起来特别简单，不利于展示个人能力，对此怎么看？</h3><p>答：PHP 确实简单，这也是我们追求的目标，我们希望它简单，简单难道不好吗？可能有些人会寄希望通过一些复杂的东西来体现自己的优越感，这其实也没什么问题。只是我个人不认可这种态度，我觉得什么简单就用什么呗。我们公司里面之前有个分享，有同事说他费了好大劲去完成了某项工作，我提出了反对，我觉得这项工作可以在 Ngnix 上通过简单的配置去实现，为什么偏偏要花那么多的精力去做。当然，最后他告诉我说他不知道 Ngnix 上可以这么做。很多时候，有些人习惯于自己去解决一些问题，这是好事，但一定要努力扩充自己的视野，因为你花了那么大的精力最后可能会发现做的还不如人家一两下做得好。对于你来说可能损失不会很大，但对于一个集体、组织来说，损失就大了。你在团队里很重要，你的精力很重要，你花那么多时间做出的工作，可能别人用其他方法很快就能做出来。</p><p>回过头来说，你说 PHP 简单吧它也不简单，PHP 相关的东西现在也有很多，比如一些很优雅的框架。有些框架我自己看半天也会觉得还挺复杂的，学起来费劲。</p><p>我自己是用 C，我就是喜欢用简单的东西，我不太喜欢那种特别复杂的东西，因为要去理解它。之前我跟别人好像有过一次争吵，他的意思是说你只要肯学一定能学会，学不会说明你有问题。对我来说，我会去学也会去看别人的东西，但是用起来一定是用我最顺手的东西去解决问题。</p><p>不说机器语言，汇编层面就那么多东西，类型再复杂，落到汇编上也就是Size 和偏移上的问题。只要能搞清楚这个东西，你去学习其它的，都会觉得它最终的目的就是这个，那学习其它东西还有什么意义呢。当然，这只是在这个层面，如果是人生哲理啊、工作道理什么的，还是要多学习一些。</p><h3 id="10、能简单透露一点PHP后续的动作吗？"><a href="#10、能简单透露一点PHP后续的动作吗？" class="headerlink" title="10、能简单透露一点PHP后续的动作吗？"></a>10、能简单透露一点PHP后续的动作吗？</h3><p>答：我们几个人现在对新特性关注的比较少，更多的还是关注性能。现在我们在做 PHP 的 JIT 引擎，不出意外的在最近几个月就可能会合并到主干。</p><h3 id="11：最后，对于处于迷茫期的PHP新手有怎样的一些建议？"><a href="#11：最后，对于处于迷茫期的PHP新手有怎样的一些建议？" class="headerlink" title="11：最后，对于处于迷茫期的PHP新手有怎样的一些建议？"></a>11：最后，对于处于迷茫期的PHP新手有怎样的一些建议？</h3><p>答：我觉得不仅仅是学习 PHP ，学习任何东西都一样，一定要自己去专研。很多时候，有人问我的问题特别简单的话，我不会去回答他。一方面是我确实比较忙，另一方面是我觉得回答他反而对他不好。我更建议他们多去想，多去了解。每一个学习新东西的人，一定要养成自己的一个良好的学习方法，这也会是最高效的方法。尽量少问人，多问搜索引擎，多看 paper，多把自己学的东西和遇到的问题结合起来，学会融会贯通。举例说，你去学习 PHP ，你要搞清楚 PHP 是怎么跑起来的，当一个请求过来，它是怎么通过一系列东西去运行的。说到底我觉得就是需要养成良好的学习方法，而这个方法一定不是去问别人，即便你身边有个特别牛的人，人家也很难做到天天有耐心解答你的问题。</p><p>转载自【开源中国】<br><a href="https://www.oschina.net/question/2896879_2212316" target="_blank" rel="external">https://www.oschina.net/question/2896879_2212316</a></p>]]></content>
    
    <summary type="html">
    
      看看大神是怎么字里行间装b的
    
    </summary>
    
      <category term="人生" scheme="http://martist.cn/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="人生" scheme="http://martist.cn/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>PHPstorm快捷键 for Mac</title>
    <link href="http://martist.cn/2018/02/11/PHPstorm%E5%BF%AB%E6%8D%B7%E9%94%AE%20for%20Mac/"/>
    <id>http://martist.cn/2018/02/11/PHPstorm快捷键 for Mac/</id>
    <published>2018-02-11T07:30:16.000Z</published>
    <updated>2018-02-11T07:14:40.093Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>对应键</p><pre><code>⌘——Command⌃ ——Control⌥——Option/Alt⇧——Shift⇪——Caps Lockfn——功能键就是fn</code></pre><p>编辑</p><pre><code>Command+alt+T 用 (if..else, try..catch, for, etc.)包住Command+/ 注释/取消注释的行注释Command+alt+/ 注释/取消注释与块注释alt+↑ 向上选取代码块alt+↓ 向下选取代码块Command+alt+L 格式化代码tab,shift+tab 调整缩进Control+alt+I 快速调整缩进Command+C 复制Command+X 剪切Command+V 粘贴Command+shift+V 从剪贴板里选择粘贴Command+D 复制代码副本Command+delete 删除当前行Control+Shift+J 清除缩进变成单行shift+回车 快速换行Command+回车 换行光标还在原先位置Command+shift+U 大小写转换Command+shift+[,Command+shift+] 文件选项卡快速切换Command+加号,Command+减号 收缩代码块Command+shift+加号，Command+shift+减号 收缩整个文档的代码块Command+W 关闭当前文件选项卡alt+单击 光标在多处定位Control+shift+J 把下面行的缩进收上来shift + F6 高级修改，可快速修改光标所在的标签、变量、函数等alt+/ 代码补全</code></pre><p>调试</p><pre><code>Control+alt+R 运行项目Command+Control+R 运行DebugCommand+F8 添加断点Command+shift+F8 打开断点列表</code></pre><p>导航</p><pre><code>Command+O 跳转到某个类Command+shift+O 跳转到某个文件Command+alt+O 跳转到某个符号Control+←,Control+→ 转到上/下一个编辑器选项卡F12 打开之前打开的工具窗口（TODO、终端等）Command+L 跳转行Command+E 弹出最近文件Command+alt+←,Command+alt+→ 向前向后导航到代码块交接处（一般是空行处）Command+shift+delete 导航到上一个编辑位置的位置Command+B 跳转到变量声明处Control+J 获取变量相关信息（类型、注释等，注释是拿上一行的注释）Command+Y 小浮窗显示变量声明时的行Command+[,Command+] 光标现在的位置和之前的位置切换Command+F12 文件结构弹出式菜单alt+H 类的层次结构F2,shift+F2 切换到上\下一个突出错误的位置Command+↑ 跳转到导航栏F3 添加书签alt+F3 添加带助记的书签alt+1,alt+2… 切换到相应助记的书签位置Command+F3 打开书签列表VCS/本地历史记录control+V 打开VST小浮窗Command+K 提交项目Command+T 更新项目alt+shift+C 打开最近修改列表</code></pre><p>搜索和替换</p><pre><code>Command+F 搜索Command+R 替换Command+G 查找下一个Command+shift+G 查找下一个Command+shift+F 按路径搜索Command+shift+R 按路径替换</code></pre><p>选中文字的搜索</p><pre><code>Command+F7 向声明的地方搜索并选中Command+shift+F7 打开搜索框进行搜索Command+alt+F7 打开小浮窗显示搜索列表</code></pre><p>对项目文件的操作（重构）</p><pre><code>F5 复制文件到某个目录F6 移动文件到某个目录Command+delete 安全删除shift+F6 重命名</code></pre><p>全局的</p><pre><code>双击shift 弹出小浮窗搜索所有Command+~切换项目 Command+shift+~ 反向切换项目 (在打开的不同项目中切换)Command+shift+A 整个工程的查找操作Command+1,Command+2… 打开各种工具窗口alt+shift+F 把文件添加到收藏夹alt+shift+I 打开项目描述alt+~ 快速切换当前计划Command+, 设置编辑器Control+Tab 选项卡和工具窗口之间进行切换alert+回车 显示npm版本升级列表</code></pre>]]></content>
    
    <summary type="html">
    
      生产力提升
    
    </summary>
    
      <category term="常识" scheme="http://martist.cn/categories/%E5%B8%B8%E8%AF%86/"/>
    
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>错误和异常</title>
    <link href="http://martist.cn/2018/01/02/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <id>http://martist.cn/2018/01/02/错误和异常/</id>
    <published>2018-01-01T16:00:00.000Z</published>
    <updated>2018-03-27T07:40:21.419Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>PHP提供了错误处理和日志记录的功能. 这些函数允许你定义自己的错误处理规则，以及修改错误记录的方式. 这样，你就可以根据自己的需要，来更改和加强错误输出信息以满足实际需要.</p><p>通过日志记录功能，你可以将信息直接发送到其他日志服务器，或者发送到指定的电子邮箱（或者通过邮件网关发送），或者发送到操作系统日志等，从而可以有选择的记录和监视你的应用程序和网站的最重要的部分。</p><p>错误报告功能允许你自定义错误反馈的级别和类型，可以是简单的提示信息或者使用自定义的函数进行处理并返回信息.</p><h3 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h3><p>  debug_backtrace — 产生一条回溯跟踪(backtrace)<br>  debug_print_backtrace — 打印一条回溯。<br>  error_clear_last — 清除最近一次错误<br>  error_get_last — 获取最后发生的错误<br>  error_log — 发送错误信息到某个地方<br>  error_reporting — 设置应该报告何种 PHP 错误<br>  restore_error_handler — 还原之前的错误处理函数<br>  restore_exception_handler — 恢复之前定义过的异常处理函数。<br>  set_error_handler — 设置用户自定义的错误处理函数<br>  set_exception_handler — 设置用户自定义的异常处理函数<br>  trigger_error — 产生一个用户级别的 error/warning/notice 信息<br>  user_error — trigger_error 的别名</p><p>详见 <a href="http://php.net/manual/zh/ref.errorfunc.php" target="_blank" rel="external">http://php.net/manual/zh/ref.errorfunc.php</a></p><h2 id="error-reporting"><a href="#error-reporting" class="headerlink" title="error_reporting()"></a>error_reporting()</h2><p>规定不同的错误级别报告<br>PHP 有诸多错误级别，使用该函数可以设置在脚本运行时的级别。如果没有设置可选参数 level，error_reporting() 仅会返回当前的错误报告级别。</p><pre><code>1     E_ERROR           致命的运行错误。错误无法恢复，暂停执行脚本。2     E_WARNING         运行时警告(非致命性错误)。非致命的运行错误，脚本执行不会停止。4     E_PARSE           编译时解析错误。解析错误只由分析器产生。8     E_NOTICE          运行时提醒(这些经常是你代码中的bug引起的，也可能是有意的行为造成的。)16    E_CORE_ERROR PHP  启动时初始化过程中的致命错误。32    E_CORE_WARNING    PHP启动时初始化过程中的警告(非致命性错)。64    E_COMPILE_ERROR   编译时致命性错。这就像由Zend脚本引擎生成了一个E_ERROR。128   E_COMPILE_WARNING 编译时警告(非致性错)。这就像由Zend脚本引擎生成了E_WARNING警告。256   E_USER_ERROR      自定义错误消息。像用PHP函数trigger_error（程序员设置E_ERROR）512   E_USER_WARNING    自定义警告消息。像用PHP函数trigger_error（程序员设的E_WARNING警告）1024  E_USER_NOTICE     自定义的提醒消息。像由使用PHP函数trigger_error（程序员E_NOTICE集）2048  E_STRICT          编码标准化警告。允许PHP建议修改代码以确保最佳的互操作性向前兼容性。4096  E_RECOVERABLE_ERROR   开捕致命错误。像E_ERROR，但可以通过用户定义的处理捕获（又见set_error_handler（））8191  E_ALL             所有的错误和警告(不包括 E_STRICT) (E_STRICT will be part of E_ALL as of PHP 6.0)16384 E_USER_DEPRECATED30719 E_ALL</code></pre><p>15个正好对应二进制的15位。<br>需要注意的是, 上述表中的字段, 不是一成不变的, 不同的PHP版本, 值可能会不同, 详细的请参考 php预定义常量</p><p>任意数目的以上选项都可以用“或”来连接(用 OR 或 |)，这样可以报告所有需要的各级别错误。<br>例如，下面的代码关闭了用户自定义的错误和警告，执行了某些操作，然后恢复到原始的报错级别：<br>例：</p><pre><code>&lt;?php error_reporting(0);                //禁用错误报告 error_reporting(E_ERROR | E_WARNING | E_PARSE);//报告运行时错误 error_reporting(E_ALL);            //报告所有错误 error_reporting(E_ALL ^ E_NOTICE); //除E_NOTICE报告所有错误，是在php.ini的默认设置 error_reporting(-1);               //报告所有 PHP 错误 error_reporting(3);                //不报E_NOTICE error_reporting(11);               //报告所有错误 ini_set(&apos;error_reporting&apos;, E_ALL); // 和 error_reporting(E_ALL); 一样 error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);//表示php错误，警告，语法错误，提醒都返错。?&gt;</code></pre><p>关于错误的文档可以参考<br><a href="http://www.w3school.com.cn/php/php_ref_error.asp" target="_blank" rel="external">http://www.w3school.com.cn/php/php_ref_error.asp</a></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote><p>异常（Exception）用于在指定的错误发生时改变脚本的正常流程。</p></blockquote><h3 id="Try-throw-和-catch"><a href="#Try-throw-和-catch" class="headerlink" title="Try, throw 和 catch"></a>Try, throw 和 catch</h3><p>要避免上面例子出现的错误，我们需要创建适当的代码来处理异常。</p><p>正确的处理程序应当包括：</p><pre><code>Try - 使用异常的函数应该位于 &quot;try&quot; 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。Throw - 这里规定如何触发异常。每一个 &quot;throw&quot; 必须对应至少一个 &quot;catch&quot;Catch - &quot;catch&quot; 代码块会捕获异常，并创建一个包含异常信息的对象</code></pre><p>下面来触发一个异常：</p><pre><code>&lt;?php//创建可抛出一个异常的函数function checkNum($number) { if($number&gt;1)  {  throw new Exception(&quot;Value must be 1 or below&quot;);  } return true; }//在 &quot;try&quot; 代码块中触发异常try { checkNum(2); //If the exception is thrown, this text will not be shown echo &apos;If you see this, the number is 1 or below&apos;; }//捕获异常catch(Exception $e) { echo &apos;Message: &apos; .$e-&gt;getMessage(); }?&gt;</code></pre><p>上面代码将获得类似这样一个错误：</p><pre><code>Message: Value must be 1 or below</code></pre><p>例子解释：</p><p>上面的代码抛出了一个异常，并捕获了它：</p><pre><code>创建 checkNum() 函数。它检测数字是否大于 1。如果是，则抛出一个异常。在 &quot;try&quot; 代码块中调用 checkNum() 函数。checkNum() 函数中的异常被抛出&quot;catch&quot; 代码块接收到该异常，并创建一个包含异常信息的对象 ($e)。通过从这个 exception 对象调用 $e-&gt;getMessage()，输出来自该异常的错误消息</code></pre><p>不过，为了遵循“每个 throw 必须对应一个 catch”的原则，可以设置一个顶层的异常处理器来处理漏掉的错误。</p><h3 id="设置顶层异常处理器-（Top-Level-Exception-Handler）"><a href="#设置顶层异常处理器-（Top-Level-Exception-Handler）" class="headerlink" title="设置顶层异常处理器 （Top Level Exception Handler）"></a>设置顶层异常处理器 （Top Level Exception Handler）</h3><p>set_exception_handler() 函数可设置处理所有未捕获异常的用户定义函数。</p><pre><code>&lt;?phpfunction myException($exception){echo &quot;&lt;b&gt;Exception:&lt;/b&gt; &quot; , $exception-&gt;getMessage();}set_exception_handler(&apos;myException&apos;);throw new Exception(&apos;Uncaught Exception occurred&apos;);?&gt;</code></pre><p>以上代码的输出应该类似这样：</p><pre><code>Exception: Uncaught Exception occurred</code></pre><p>在上面的代码中，不存在 “catch” 代码块，而是触发顶层的异常处理程序。应该使用此函数来捕获所有未被捕获的异常。</p><h3 id="异常的规则"><a href="#异常的规则" class="headerlink" title="异常的规则"></a>异常的规则</h3><pre><code>需要进行异常处理的代码应该放入 try 代码块内，以便捕获潜在的异常。每个 try 或 throw 代码块必须至少拥有一个对应的 catch 代码块。使用多个 catch 代码块可以捕获不同种类的异常。可以在 try 代码块内的 catch 代码块中再次抛出（re-thrown）异常。</code></pre><p>简而言之：如果抛出了异常，就必须捕获它。</p><h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><p>请一定要注意，没有特殊说明：本例 PHP Version &lt; 7<br>　　说起PHP异常处理，大家首先会想到try-catch，那好，我们先看一段程序吧：有一个test.php文件，有一段简单的PHP程序，内容如下，然后命令行执行：</p><pre><code>&lt;?php   $num = 0;   try {       echo 1/$num;   } catch (Exception $e){       echo $e-&gt;getMessage();   }?&gt;</code></pre><blockquote><p>我的问题是：这段程序能正确的捕捉到除0的错误信息吗？<br>如果你回答能，那你就把这篇文章看完吧！应该能学点东西。</p></blockquote><p>本文章分5个部分介绍我的异常处理的理解：</p><h3 id="一、异常与错误的概述"><a href="#一、异常与错误的概述" class="headerlink" title="一、异常与错误的概述"></a>一、异常与错误的概述</h3><p>PHP中什么是异常：<br>　　程序在运行中出现不符合预期的情况，允许发生（你也不想让他出现不正常的情况）但他是一种不正常的情况，按照我们的正常逻辑本不该出的错误，但仍然会出现的错误，属于逻辑和业务流程的错误，而不是编译或者语法上的错误。</p><p>PHP中什么是错误：<br>　　属于php脚本自身的问题，大部分情况是由错误的语法，服务器环境导致，使得编译器无法通过检查，甚至无法运行的情况。warning、notice都是错误，只是他们的级别不同而已，并且错误是不能被try-catch捕获的。</p><p>上面的说法是有前提条件的：<br>　　在PHP中，因为在其他语言中就不能这样下结论了，也就是说异常和错误的说法在不同的语言有不同的说法。在PHP中任何自身的错误或者是非正常的代码都会当做错误对待，并不会以异常的形式抛出，但是也有一些情况会当做异常和错误同时抛出(据说是，我没有找到合适的例子)。也就是说，你想在数据库连接失败的时候自动捕获异常是行不通的，因为这就不是异常，是错误。但是在java中就不一样了，他会把很多和预期不一致的行为当做异常来进行捕获。</p><p>PHP异常处理很鸡肋？<br>　　在上面的分析中我们可以看出，PHP并不能主动的抛出异常，但是你可以手动抛出异常，这就很无语了，如果你知道哪里会出问题，你添加if else解决不就行了吗，为啥还要手动抛出异常，既然能手动抛出就证明这个不是异常，而是意料之中。以我的理解，这就是PHP异常处理鸡肋的地方（不一定对啊）。所以PHP的异常机制不是那么的完美，但是使用过框架的同学都知道有这个情况：你在框架中直接写开头那段php“自动”捕获异常的代码是可以的，这是为什么？看过源码的同学都知道框架中都会涉及三个函数：register_shutdown_function，set_error_handler，set_exception_handler后面我会重点讲解着三个黑科技，通过这几个函数我们可以实现PHP假自动捕获异常和错误。</p><h3 id="二、ERROR的级别"><a href="#二、ERROR的级别" class="headerlink" title="二、ERROR的级别"></a>二、ERROR的级别</h3><p>只有熟悉错误级别才能对错误捕捉有更好的认识。</p><p>Fatal Error:致命错误（脚本终止运行）<br>        E_ERROR         // 致命的运行错误，错误无法恢复，暂停执行脚本<br>        E_CORE_ERROR    // PHP启动时初始化过程中的致命错误<br>        E_COMPILE_ERROR // 编译时致命性错，就像由Zend脚本引擎生成了一个E_ERROR<br>        E_USER_ERROR    // 自定义错误消息。像用PHP函数trigger_error（错误类型设置为：E_USER_ERROR）</p><pre><code>Parse Error：编译时解析错误，语法错误（脚本终止运行）    E_PARSE  //编译时的语法解析错误Warning Error：警告错误（仅给出提示信息，脚本不终止运行）    E_WARNING         // 运行时警告 (非致命错误)。    E_CORE_WARNING    // PHP初始化启动过程中发生的警告 (非致命错误) 。    E_COMPILE_WARNING // 编译警告    E_USER_WARNING    // 用户产生的警告信息Notice Error：通知错误（仅给出通知信息，脚本不终止运行）    E_NOTICE      // 运行时通知。表示脚本遇到可能会表现为错误的情况.    E_USER_NOTICE // 用户产生的通知信息。</code></pre><p>由此可知有5类是产生ERROR级别的错误，这种错误直接导致PHP程序退出。可以定义成：</p><pre><code>ERROR = E_ERROR | E_CORE_ERROR |  E_COMPILE_ERROR | E_USER_ERROR | E_PARSE</code></pre><h3 id="三、PHP异常处理中的黑科技"><a href="#三、PHP异常处理中的黑科技" class="headerlink" title="三、PHP异常处理中的黑科技"></a>三、PHP异常处理中的黑科技</h3><p>前面提到框架中是可以捕获所有的错误和异常的，之所以能实现应该是使用了黑科技，哈哈！其实也不是什么黑科技，主要是三个重要的函数：</p><h4 id="1：set-error-handler"><a href="#1：set-error-handler" class="headerlink" title="1：set_error_handler()"></a>1：set_error_handler()</h4><p>　　看到这个名字估计就知道什么意思了，这个函数用于捕获错误，设置一个用户自定义的错误处理函数。</p><pre><code>&lt;?php    set_error_handler(&apos;zyferror&apos;);    function zyferror($type, $message, $file, $line)    {    　　var_dump(&apos;&lt;b&gt;set_error_handler: &apos; . $type . &apos;:&apos; . $message . &apos; in &apos; . $file . &apos; on &apos; . $line . &apos; line .&lt;/b&gt;&lt;br /&gt;&apos;);    }?&gt;</code></pre><p>当程序出现错误的时候自动调用此方法，不过需要注意一下两点：第一，如果存在该方法，相应的error_reporting()就不能在使用了。所有的错误都会交给自定义的函数处理。第二，此方法不能处理以下级别的错误：E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，set_error_handler() 函数所在文件中产生的E_STRICT，该函数只能捕获系统产生的一些Warning、Notice级别的错误。<br>并且他有多种调用的方法：</p><pre><code>&lt;?php     // 直接传函数名 NonClassFunction     set_error_handler(&apos;function_name&apos;);     // 传 class_name &amp;&amp; function_name     set_error_handler(array(&apos;class_name&apos;, &apos;function_name&apos;));?&gt;</code></pre><h4 id="2：register-shutdown-function"><a href="#2：register-shutdown-function" class="headerlink" title="2：register_shutdown_function()"></a>2：register_shutdown_function()</h4><p>　　捕获PHP的错误：Fatal Error、Parse Error等，这个方法是PHP脚本执行结束前最后一个调用的函数，比如脚本错误、die()、exit、异常、正常结束都会调用，多么牛逼的一个函数啊！通过这个函数就可以在脚本结束前判断这次执行是否有错误产生，这时就要借助于一个函数：error_get_last()；这个函数可以拿到本次执行产生的所有错误。error_get_last();返回的信息：</p><p>[type]           - 错误类型<br>[message] - 错误消息<br>[file]              - 发生错误所在的文件<br>[line]             - 发生错误所在的行  </p><pre><code>&lt;?php    register_shutdown_function(&apos;zyfshutdownfunc&apos;);    function zyfshutdownfunc()    {        if ($error = error_get_last()) {            var_dump(&apos;&lt;b&gt;register_shutdown_function: Type:&apos; . $error[&apos;type&apos;] . &apos; Msg: &apos; . $error[&apos;message&apos;] . &apos; in &apos; . $error[&apos;file&apos;] . &apos; on line &apos; . $error[&apos;line&apos;] . &apos;&lt;/b&gt;&apos;);        }    }?&gt;</code></pre><p>通过这种方法就可以巧妙的打印出程序结束前所有的错误信息。但是我在测试的时候我发现并不是所有的错误终止后都会调用这个函数，可以看下面的一个测试文件，内容是：</p><pre><code>&lt;?php    register_shutdown_function(&apos;zyfshutdownfunc&apos;);    function zyfshutdownfunc()    {        if ($error = error_get_last()) {            var_dump(&apos;&lt;b&gt;register_shutdown_function: Type:&apos; . $error[&apos;type&apos;] . &apos; Msg: &apos; . $error[&apos;message&apos;] . &apos; in &apos; . $error[&apos;file&apos;] . &apos; on line &apos; . $error[&apos;line&apos;] . &apos;&lt;/b&gt;&apos;);        }    }    var_dump(23+-+); //此处语法错误?&gt;</code></pre><p>自己可以试一下，你可以看到根本就不会触发zyfshutdownfunc()函数，其实这是一个语法错误，直接报了一个：</p><pre><code>&lt;?php   Parse error: syntax error, unexpected &apos;)&apos; in /www/mytest/exception/try-catch.php on line 71?&gt;</code></pre><p>由此引出一个奇葩的问题：问什么不能触发，为什么框架中是可以的？其实原因很简单，只在parse-time出错时是不会调用本函数的。只有在run-time出错的时候，才会调用本函数，我的理解是语法检查器前没有执行register_shutdown_function()去把需要注册的函数放到调用的堆栈中，所以就根本不会运行。那框架中为什么任何错误都能进入到register_shutdown_function()中呢，其实在框架中一般会有统一的入口index.php，然后每个类库文件都会通过include ** 的方式加载到index.php中，相当与所有的程序都会在index.php中聚集，同样，你写的具有语法错误的文件也会被引入到入口文件中，这样的话，调用框架，执行index.php，index.php本身并没有语法错误，也就不会产生parse-time错误，而是 include 文件出错了，是run-time的时候出错了，所以框架执行完之后就会触发register_shutdown_function();<br>所以现在可是试一下这个写法，这样就会触发zyfshutdownfunc()回调了：</p><pre><code>a.php文件&lt;?php　　// 模拟语法错误　　var_dump(23+-+);?&gt;b.php文件&lt;?php    register_shutdown_function(&apos;zyfshutdownfunc&apos;);    function zyfshutdownfunc()    {        if ($error = error_get_last()) {            var_dump(&apos;&lt;b&gt;register_shutdown_function: Type:&apos; . $error[&apos;type&apos;] . &apos; Msg: &apos; . $error[&apos;message&apos;] . &apos; in &apos; . $error[&apos;file&apos;] . &apos; on line &apos; . $error[&apos;line&apos;] . &apos;&lt;/b&gt;&apos;);        }    }    require &apos;a.php&apos;;?&gt;</code></pre><h4 id="3：set-exception-handler"><a href="#3：set-exception-handler" class="headerlink" title="3：set_exception_handler()"></a>3：set_exception_handler()</h4><p>　　设置默认的异常处理程序，用在没有用try/catch块来捕获的异常，也就是说不管你抛出的异常有没有人捕获，如果没有人捕获就会进入到该方法中，并且在回调函数调用后异常会中止。看一下用法：</p><pre><code>&lt;?php    set_exception_handler(&apos;zyfexception&apos;);    function zyfexception($exception)    {        var_dump(&quot;&lt;b&gt;set_exception_handler: Exception: &quot; . $exception-&gt;getMessage()  . &apos;&lt;/b&gt;&apos;);    }    throw new Exception(&quot;zyf exception&quot;);?&gt;</code></pre><h3 id="四、巧妙的捕获错误和异常"><a href="#四、巧妙的捕获错误和异常" class="headerlink" title="四、巧妙的捕获错误和异常"></a>四、巧妙的捕获错误和异常</h3><h4 id="1：把错误以异常的形式抛出-不能完全抛出"><a href="#1：把错误以异常的形式抛出-不能完全抛出" class="headerlink" title="1：把错误以异常的形式抛出(不能完全抛出)"></a>1：把错误以异常的形式抛出(不能完全抛出)</h4><p>　　　　由上面的讲解我们知道，php中的错误是不能以异常的像是捕获的，但是我们需要让他们抛出，已达到扩展 try-catch的影响范围，我们前面讲到过set_error_handler() 方法，他是干嘛用的，他是捕获错误的，所以我们就可以借助他来吧错误捕获，然后再以异常的形式抛出，ok，试试下面的写法：</p><pre><code>&lt;?php    set_error_handler(&apos;zyferror&apos;);    function zyferror($type, $message, $file, $line)    {        throw new \Exception($message . &apos;zyf错误当做异常&apos;);    }    $num = 0;    try {        echo 1/$num;    } catch (Exception $e){        echo $e-&gt;getMessage();    }?&gt;</code></pre><p>好了，试一下，会打印出：</p><pre><code>Division by zero zyf123</code></pre><p>流程：本来是除0错误，然后触发set_error_handler()，在set_error_handler()中相当与杀了个回马枪，再把错误信息以异常的形式抛出来，这样就可以实现错误以异常的形式抛出。大家要注意：这样做是有缺点的，会受到set_error_handler()函数捕获级别的限制。</p><h4 id="2：捕获所有的错误"><a href="#2：捕获所有的错误" class="headerlink" title="2：捕获所有的错误"></a>2：捕获所有的错误</h4><p>由set_error_handler()可知，他能够捕获一部分错误，不能捕获系统级E_ERROR、E_PARSE等错误，但是这部分可以由register_shutdown_function()捕获。所以两者结合能出现很好的功能。<br>看下面的程序：</p><pre><code>a.php内容：&lt;?    // 模拟Fatal error错误    //test();    // 模拟用户产生ERROR错误    //trigger_error(&apos;zyf-error&apos;, E_USER_ERROR);    // 模拟语法错误    var_dump(23+-+);    // 模拟Notice错误    //echo $f;    // 模拟Warning错误    //echo &apos;123&apos;;    //ob_flush();    //flush();    //header(&quot;Content-type:text/html;charset=gb2312&quot;);?&gt;b.php内容：&lt;?    error_reporting(0);    register_shutdown_function(&apos;zyfshutdownfunc&apos;);    function zyfshutdownfunc()    {        if ($error = error_get_last()) {            var_dump(&apos;&lt;b&gt;register_shutdown_function: Type:&apos; . $error[&apos;type&apos;] . &apos; Msg: &apos; . $error[&apos;message&apos;] . &apos; in &apos; . $error[&apos;file&apos;] . &apos; on line &apos; . $error[&apos;line&apos;] . &apos;&lt;/b&gt;&apos;);        }    }    set_error_handler(&apos;zyferror&apos;);    function zyferror($type, $message, $file, $line)    {        var_dump(&apos;&lt;b&gt;set_error_handler: &apos; . $type . &apos;:&apos; . $message . &apos; in &apos; . $file . &apos; on &apos; . $line . &apos; line .&lt;/b&gt;&lt;br /&gt;&apos;);    }    require &apos;a.php&apos;;?&gt;</code></pre><p>到此就可以解释开头的那个程序了吧，test.php 如果是单文件执行是不能捕获到错误的，如果你在框架中执行就是可以的，当然你按照我上面介绍的来扩展也是可以的。</p><h3 id="五、自定义异常处理和异常嵌套"><a href="#五、自定义异常处理和异常嵌套" class="headerlink" title="五、自定义异常处理和异常嵌套"></a>五、自定义异常处理和异常嵌套</h3><h4 id="1：自定义异常处理"><a href="#1：自定义异常处理" class="headerlink" title="1：自定义异常处理"></a>1：自定义异常处理</h4><p>　　在复杂的系统中，我们往往需要自己捕获我们需要特殊处理的异常，这些异常可能是特殊情况下抛出的。所以我们就自己定义一个异常捕获类，该类必须是 exception 类的一个扩展，该类继承了 PHP 的 exception 类的所有属性，并且我们可以添加自定义的函数，使用的时候其实和之前的一样，大致写法如下：</p><pre><code>&lt;?php    class zyfException extends Exception    {        public function errorzyfMessage()        {            return &apos;Error line &apos; . $this-&gt;getLine().&apos; in &apos; . $this-&gt;getFile()                .&apos;: &lt;b&gt;&apos; . $this-&gt;getMessage() . &apos;&lt;/b&gt; Must in (0 - 60)&apos;;        }    }    $age = 10;    try {        $age = intval($age);        if($age &gt; 60) {            throw new zyfException($age);        }    } catch (zyfException $e) {        echo $e-&gt;errorzyfMessage();    }?&gt;</code></pre><p>2：异常嵌套</p><p>异常嵌套是比较常见的写法，在自定义的异常处理中，try 块中可以定义多个异常捕获，然后分层传递异常，理解和冒泡差不多，看下面的实现：</p><pre><code>&lt;?php    $age = 10;    try {        $age = intval($age);        if($age &gt; 60) {            throw new zyfException($age);        }        if ($age &lt;= 0) {            throw new Exception($age . &apos; must &gt; 0&apos;);        }    } catch (zyfException $e) {        echo $e-&gt;errorzyfMessage();    } catch(Exception $e) {        echo $e-&gt;getMessage();    }?&gt;</code></pre><p>当然也可以在catch中再抛出异常给上层：</p><pre><code>&lt;?php    $age = 100;    try {        try {            $age = intval($age);            if($age &gt; 60) {                throw new Exception($age);            }        } catch (Exception $e) {            throw new zyfException($age);        }    } catch (zyfException $e) {        echo $e-&gt;errorzyfMessage();    }?&gt;</code></pre><h3 id="六、PHP7中的异常处理"><a href="#六、PHP7中的异常处理" class="headerlink" title="六、PHP7中的异常处理"></a>六、PHP7中的异常处理</h3><p>现在写PHP必须考虑版本情况，上面的写法在PHP7中大部分都能实现，但是也会有不同点，在PHP7更新中有一条：更多的Error变为可捕获的Exception，现在的PHP7实现了一个全局的throwable接口，原来老的Exception和其中一部分Error实现了这个接口(interface)，PHP7中更多的Error变为可捕获的Exception返回给捕捉器，这样其实和前面提到的扩展try-catch影响范围一样，但是如果不捕获则还是按照Error对待，看下面两个：</p><pre><code>&lt;?php    try {        test();    } catch(Throwable $e) {        echo $e-&gt;getMessage() . &apos; zyf&apos;;    }    try {        test();    } catch(Error $e) {        echo $e-&gt;getMessage() . &apos; zyf&apos;;    }?&gt;</code></pre><p>因为PHP7实现了throwable接口，那么就可以使用第一个这种方式来捕获异常。又因为部分Error实现了接口，并且更多的Error变为可捕获的Exception，那么就可以使用第二种方式来捕获异常。下面是在网上找的PHP7的异常层次树：</p><pre><code>Throwable　　Exception 异常　　　　...　　Error 错误　　　　ArithmeticError 算数错误　　　　　　DivisionByZeroError 除数为0的错误　　　　AssertionError 声明错误　　　　ParseError 解析错误　　　　TypeError 类型错误</code></pre><p>本文绝大部分转载自<a href="https://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html#excetion2" target="_blank" rel="external">https://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html#excetion2</a></p>]]></content>
    
    <summary type="html">
    
      什么是错误，什么是异常，区别是什么
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>linux管理之进程管理</title>
    <link href="http://martist.cn/2018/01/01/linux%E7%AE%A1%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://martist.cn/2018/01/01/linux管理之进程管理/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-01-02T08:22:16.860Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="linux服务器治理之进程管理-进程优先级"><a href="#linux服务器治理之进程管理-进程优先级" class="headerlink" title="linux服务器治理之进程管理[进程优先级]"></a>linux服务器治理之进程管理[进程优先级]</h1><p>Linux系统是一个多用户，多任务的操作系统，linux中同时运行这非常多的进程，但是cpu同一个时钟周期，只能运算一个指令。进程优先级决定了每个进程处理的先后顺序。</p><h2 id="如何查看进程优先级"><a href="#如何查看进程优先级" class="headerlink" title="如何查看进程优先级"></a>如何查看进程优先级</h2><p>ps -le 命令打印系统进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">machuangdeMacBook-Pro:~ machuang$ ps -le</div><div class="line">  UID   PID  PPID        F CPU PRI NI       SZ    RSS WCHAN     S             ADDR TTY           TIME CMD</div><div class="line">    0     1     0     4004   0  37  0  4375272  15616 -      Ss                  0 ??         0:08.51 /sbin/launchd</div><div class="line">    0    50     1     4004   0   4  0  4351128   1640 -      Ss                  0 ??         0:00.50 /usr/sbin/syslog</div><div class="line">    0    51     1     4004   0  37  0  4383328  16944 -      Ss                  0 ??         0:00.69 /usr/libexec/Use</div><div class="line">    0    54     1     4004   0  20  0  4341096   8404 -      Ss                  0 ??         0:00.06 /System/Library/</div><div class="line">    0    55     1     4004   0  37  0  4387652  21496 -      Ss                  0 ??         0:02.84 /usr/libexec/kex</div><div class="line">    0    56     1  1004004   0  50  0  4357408  10660 -      Ss                  0 ??         0:00.91 /System/Library/</div><div class="line">    0    58     1     4004   0   4  0  4376372  18332 -      Ss                  0 ??         0:00.11 /System/Library/</div><div class="line">    0    59     1     4004   0  20  0  4448588  12940 -      Ss                  0 ??         0:00.14 /usr/local/opt/p</div><div class="line">   55    61     1     4004   0   4  0  4379836  10364 -      Ss                  0 ??         0:00.31 /System/Library/</div><div class="line">    0    62     1     4004   0   4  0  4381992  14872 -      Ss                  0 ??         0:00.37 /usr/sbin/system</div><div class="line">    0    64     1     400c   0  37  0  4382632  12472 -      Ss                  0 ??         0:00.96 /usr/libexec/con</div><div class="line">    0    65     1     4004   0  37  0  4376736  10276 -      Ss                  0 ??         0:00.88 /System/Library/</div><div class="line">    0    66     1     4004   0  20  0  4330896   4128 -      Ss                  0 ??         0:00.02 nginx: master pr</div><div class="line">    0    70     1     4004   0  37  0  4429136  13136 -      Ss                  0 ??         0:01.04 /usr/libexec/log</div></pre></td></tr></table></figure><p>pri和ni都代表优先级，数字越小优先级越高。<br>pri :priority<br>Ni:nice</p><h2 id="修改NI值注意事项"><a href="#修改NI值注意事项" class="headerlink" title="修改NI值注意事项"></a>修改NI值注意事项</h2><ul><li>NI值的范围是-20到19；</li><li>普通用户调整NI范围是0到19，而且只能调整自己的进程；</li><li>普通用户只能调高NI值，而不能降低。则原本NI值等于0，则只能调整为大于0；</li><li>root用户才能设定进程NI为负值，而且可以调整所有用户的进程。</li><li>PRI（最终值） = PRI（原始值）+NI</li><li>用户只能修改该NI的值，不能直接修改PRI</li></ul><h2 id="nice命令"><a href="#nice命令" class="headerlink" title="nice命令"></a>nice命令</h2><p>Nice可以给新执行的命令直接赋予NI值，但是不能修改已存在进程的NI值<br>nice -n NI值 命令，例如：</p><pre><code>nice -n -5 service httpd start</code></pre><h2 id="renice命令"><a href="#renice命令" class="headerlink" title="renice命令"></a>renice命令</h2><p>renice命令修改已经存在进程的NI值,renice [优先级] PID<br>例如：<br>renice -10 2125</p><p>更多请关注我的看云：<a href="http://doc.martist.cn" target="_blank" rel="external">http://doc.martist.cn</a></p>]]></content>
    
    <summary type="html">
    
      linux
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="进程" scheme="http://martist.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux之进程</title>
    <link href="http://martist.cn/2017/12/31/Linux%E4%B9%8B%E8%BF%9B%E7%A8%8B/"/>
    <id>http://martist.cn/2017/12/31/Linux之进程/</id>
    <published>2017-12-30T16:00:00.000Z</published>
    <updated>2018-01-02T09:24:09.453Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><p>程序是为了完成某种任务而设计的软件，比如OpenOffice是程序。什么是进程呢？进程就是运行中的程序。</p><p>一个运行着的程序，可能有多个进程。 比如apache服务器，许多用户同时请求httpd服务，apache服务器将会创建有多个httpd进程来对其进行服务。</p><h3 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h3><p>进程一般分为交互进程、批处理进程和守护进程三类。</p><p>值得一提的是守护进程总是活跃的，一般是后台运行，守护进程一般是由系统在开机时通过脚本自动激活启动或超级管理用户root来启动。比如在Fedora或Redhat中，我们可以定义httpd 服务器的启动脚本的运行级别，此文件位于/etc/init.d目录下，文件名是httpd，/etc/init.d/httpd 就是httpd服务器的守护程序，当把它的运行级别设置为3和5时，当系统启动时，它会跟着启动。</p><pre><code>[root@localhost ~]# chkconfig  --level 35  httpd on</code></pre><p>由于守护进程是一直运行着的，所以它所处的状态是等待请求处理任务。比如，我们是不是访问服务器，http才运行，而是httpd服务器都在运行，等待着用户来访问，也就是等待着任务处理。</p><h3 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h3><p>进程ID（PID)：是唯一的数值，用来区分进程；<br>父进程和父进程的ID（PPID)；<br>启动进程的用户ID（UID）和所归属的组（GID）；<br>进程状态：状态分为运行R、休眠S、僵尸Z；<br>进程执行的优先级；<br>进程所连接的终端名；<br>进程资源占用：比如占用资源大小（内存、CPU占用量）；</p><h3 id="父进程和子进程"><a href="#父进程和子进程" class="headerlink" title="父进程和子进程"></a>父进程和子进程</h3><p>他们的关系是管理和被管理的关系，当父进程终止时，子进程也随之而终止。但子进程终止，父进程并不一定终止。比如httpd服务器运行时，我们可以杀掉其子进程，父进程并不会因为子进程的终止而终止。</p><p>在进程管理中，当我们发现占用资源过多，或无法控制的进程时，应该杀死它，以保护系统的稳定安全运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="http://martist.cn/2017/12/30/xml/"/>
    <id>http://martist.cn/2017/12/30/xml/</id>
    <published>2017-12-29T16:00:00.000Z</published>
    <updated>2018-02-11T08:18:10.512Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面是 John 写给 George 的便签，存储为 XML：</p><pre><code>&lt;note&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt;</code></pre><h2 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML"></a>什么是 XML</h2><pre><code>XML 指可扩展标记语言（EXtensible Markup Language）XML 是一种标记语言，很类似 HTMLXML 的设计宗旨是传输数据，而非显示数据XML 标签没有被预定义。您需要自行定义标签。XML 被设计为具有自我描述性。XML 是 W3C 的推荐标准</code></pre><h3 id="对-XML-最好的描述"><a href="#对-XML-最好的描述" class="headerlink" title="对 XML 最好的描述"></a>对 XML 最好的描述</h3><p>XML 是独立于软件和硬件的信息传输工具。</p><h2 id="XML-与-HTML-的主要差异"><a href="#XML-与-HTML-的主要差异" class="headerlink" title="XML 与 HTML 的主要差异"></a>XML 与 HTML 的主要差异</h2><pre><code>XML 不是 HTML 的替代。XML 和 HTML 为不同的目的而设计：XML 被设计为传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息，而 XML 旨在传输信息。</code></pre><h2 id="一句话概括xml和html的区别"><a href="#一句话概括xml和html的区别" class="headerlink" title="一句话概括xml和html的区别"></a>一句话概括xml和html的区别</h2><pre><code>XML 被设计用来传输和存储数据。HTML 被设计用来显示数据。</code></pre><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol><li>没有任何行为的 XML，XML 是不作为的。</li><li>XML 仅仅是纯文本</li><li>可以发明自己的标签</li><li>XML 不是对 HTML 的替代，XML 是对 HTML 的补充。<br>XML 不会替代 HTML，理解这一点很重要。<br>在大多数 web 应用程序中，XML 用于传输数据，而 HTML 用于格式化并显示数据。</li></ol><h1 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h1><p>XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。<br>XML 文档必须包含根元素。该元素是所有其他元素的父元素。</p><p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p><p>所有元素均可拥有子元素：</p><pre><code>&lt;root&gt;  &lt;child&gt;    &lt;subchild&gt;.....&lt;/subchild&gt;  &lt;/child&gt;&lt;/root&gt;</code></pre><p>父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ol><li>所有 XML 元素都须有关闭标签</li><li>XML 标签对大小写敏感</li><li>XML 必须正确地嵌套</li><li>XML 文档必须有根元素</li><li>XML 的属性值须加引号</li><li><p>实体引用</p><p> &lt;     &lt;     小于<br> &gt;     &gt;     大于<br> &amp;     &amp;     和号<br> &apos;     ‘     单引号<br> &quot;     “     引号</p></li><li><p>编写注释的语法与 HTML 的语法很相似</p> <!-- This is a comment --></li><li><p>空格会被保留</p></li><li>XML 以 LF 存储换行</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>gitlab</title>
    <link href="http://martist.cn/2017/12/27/gitlab%E6%90%AD%E5%BB%BA/"/>
    <id>http://martist.cn/2017/12/27/gitlab搭建/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-01-05T10:28:50.027Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="GitLab-简介"><a href="#GitLab-简介" class="headerlink" title="GitLab 简介"></a>GitLab 简介</h2><p>GitLab 是利用 Ruby On Rails 一个开源的版本管理系统，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与 GitHub 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序( Wall )进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。</p><p>GitHub 它是一个开源的社区, 如果你想把你们公司的项目放在上面就得交钱, 如果不交钱就得开源, 而 GitLab 是一个本地的项目管理仓库, 既然是本地那么想怎么玩就怎么玩儿。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>社区版基于 MIT License 开源完全免费</li><li>无用户，协作和仓库限制</li><li>保护项目源码安全</li><li>管理仓库，用户与访问权限</li></ul><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><pre><code>官网 : https://about.gitlab.com/features/国内镜像 : https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-安装和配置必要的依赖"><a href="#1-安装和配置必要的依赖" class="headerlink" title="1). 安装和配置必要的依赖"></a>1). 安装和配置必要的依赖</h3><p>如果你安装 PostFix 发送邮件，如果你不需要邮件发送,可以跳过直接看第二步,请选择 网站设置 中。而不是使用后缀也可以使用道具或配置自定义 SMTP 服务器和它配置为 SMTP 服务器。在 CentOS 的 6 和 7，下面的命令将在系统防火墙打开 HTTP 和 SSH 访问。</p><p>  sudo apt-get install curl openssh-server ca-certificates postfix  </p><h3 id="2-切换清华大学镜像"><a href="#2-切换清华大学镜像" class="headerlink" title="2). 切换清华大学镜像"></a>2). 切换清华大学镜像</h3><p>首先信任 GitLab 的 GPG 公钥</p><p>  curl <a href="https://packages.gitlab.com/gpg.key" target="_blank" rel="external">https://packages.gitlab.com/gpg.key</a> 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null  </p><p>再选择你的 Debian/Ubuntu 版本，文本框中内容写进 /etc/apt/sources.list.d/gitlab-ce.list ubuntu14.04 如下 其他版本请跳转 国内镜像 查看 /etc/apt/sources.list.d/gitlab-ce.list 这个文件默认不存在 你需要创建并添加下面配置 vim /etc/apt/sources.list.d/gitlab-ce.list 把下面内容添加进去</p><p>  deb <a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu</a> trusty main  </p><p>添加完成后更新源, 并且安装 GitLab</p><p>  sudo apt-get update<br>  sudo apt-get install gitlab-ce  </p><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3). 配置"></a>3). 配置</h3><p>配置文件</p><p>  /etc/gitlab/gitlab.rb</p><p>修改域名</p><p>  vim /etc/gitlab/gitlab.rb 文件<br>  // 找到这一行, 填写你的域名<br>  external_url ‘你的域名’  </p><p>配置通知邮箱  </p><p>  vim /etc/gitlab/gitlab.rb</p><p>  #Sending application email via SMTP<br>  gitlab_rails[‘smtp_enable’] = true<br>  gitlab_rails[‘smtp_address’] = “smtp.163.com”<br>  gitlab_rails[‘smtp_port’] = 25<br>  gitlab_rails[‘smtp_user_name’] = “xxuser@163.com”<br>  gitlab_rails[‘smtp_password’] = “xxpassword”<br>  gitlab_rails[‘smtp_domain’] = “163.com”<br>  gitlab_rails[‘smtp_authentication’] = :login<br>  gitlab_rails[‘smtp_enable_starttls_auto’] = true</p><p>修改gitlab配置的发信人</p><p>  gitlab_rails[‘gitlab_email_from’] = “xxuser@163.com”<br>  user[“git_user_email”] = “xxuser@163.com”</p><p>如果执行不成功, 请检查配置和内存, 并且执行 gitlab-ctl reconfigure 重新编译启动</p><h3 id="4-网页配置"><a href="#4-网页配置" class="headerlink" title="4). 网页配置"></a>4). 网页配置</h3><p>apt-get 安装默认继承了 Nginx 如果你需要服务器在跑其他环境, 你需要修改你的 GitLab Nginx 的端口, 基础配置不需要改配置文件网站上就能直接修改</p><h3 id="5-查看更多命令"><a href="#5-查看更多命令" class="headerlink" title="5).查看更多命令"></a>5).查看更多命令</h3><p>  gitlab-ctl help</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>文档地址 : http://docs.gitlab.com/omnibus/转载请注明出处 : https://laravel-china.org/topics/2568友情链接 : http://blog.rooyun.com/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="git" scheme="http://martist.cn/categories/git/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="git" scheme="http://martist.cn/tags/git/"/>
    
  </entry>
  
</feed>
