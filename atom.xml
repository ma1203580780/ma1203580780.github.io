<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARTIST</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://martist.cn/"/>
  <updated>2019-01-14T07:28:09.066Z</updated>
  <id>http://martist.cn/</id>
  
  <author>
    <name>马闯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>站在开发角度，CentOS和ubuntu的区别</title>
    <link href="http://martist.cn/2019/01/14/LINUX/%E7%AB%99%E5%9C%A8%E5%BC%80%E5%8F%91%E8%A7%92%E5%BA%A6%EF%BC%8CCentOS%E5%92%8Cubuntu%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://martist.cn/2019/01/14/LINUX/站在开发角度，CentOS和ubuntu的区别/</id>
    <published>2019-01-13T16:00:00.000Z</published>
    <updated>2019-01-14T07:28:09.066Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="Linux的发行版"><a href="#Linux的发行版" class="headerlink" title="Linux的发行版"></a>Linux的发行版</h2><p>Redhat，应该称为Redhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、Fedora Core(由原来的Redhat桌面版本发展而来，免费版本)、CentOS(RHEL的社区克隆版本，免费)。Redhat应该说是在国内使用人群最多的Linux版本，甚至有人将Redhat等同于Linux，而有些老鸟更是只用这一个版本的Linux。所以这个版本的特点就是使用人群数量大，资料非常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网上的一般Linux教程都是以Redhat为例来讲解的。Redhat系列的包管理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的二进制文件。稳定性方面RHEL和CentOS的稳定性非常好，适合于服务器使用，但是Fedora Core的稳定性较差，最好只用于桌面应用。</p><p>Debian，或者称Debian系列，包括Debian和Ubuntu等。Debian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由Ian Murdock于1993年创建，分为三个版本分支（branch）： stable, testing 和 unstable。其中，unstable为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。testing的版本都经 过unstable中的测试，相对较为稳定，也支持了不少新技术（比如SMP等）。而stable一般只用于服务器，上面的软件包大部分都比较过时，但是 稳定和安全性都非常的高。Debian最具特色的是apt-get / dpkg包管理方式，其实Redhat的YUM也是在模仿Debian的APT方式，但在二进制文件发行方式中，APT应该是最好的了。Debian的资 料也很丰富，有很多支持的社区，有问题求教也有地方可去:)</p><h2 id="作为服务器系统的特点"><a href="#作为服务器系统的特点" class="headerlink" title="作为服务器系统的特点"></a>作为服务器系统的特点</h2><p>CentOS，其实是Redhat的内核，更成熟稳定一点，相比旧Redhat，多了一个yum的命令，学Debian一样自动安装软件；CentOS的可以Yum的东西相比Debian或Ubuntu实在太少了；CentOS介于年轻与成熟之间，它比Ubuntu更注重安全性，默认一装好就自带并打开防火墙就知道；SELinux让不同的程序之间权限有所限制，是CentOS一些软件经常莫名奇妙地提醒“没有权限”的一个原因。</p><p>Ubuntu，就是Debian的延续版，apt-get自动安装、更新软件的方式，是Debian首创。相比起来apt-get软件库及源强大很多，也多很多，我们的服务器除了一个magickWand(imageMagick的PHP API)，其它东西全部都是apt-get下来的，安装不需要一分钟；感觉Ubuntu更加自由，小巧，灵活，有点年轻人的感觉。</p><h2 id="对开发者的友好程度"><a href="#对开发者的友好程度" class="headerlink" title="对开发者的友好程度"></a>对开发者的友好程度</h2><p>如果公司没有专业的运维来管理服务器，由开发者来管理，ubuntu更适合。<br>如果公司的项目商业化很大，centos具备更安全可靠的特性，是必经之路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="ubuntu" scheme="http://martist.cn/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>基于web的linux管理系统【工具推荐】</title>
    <link href="http://martist.cn/2019/01/10/LINUX/%E5%9F%BA%E4%BA%8Eweb%E7%9A%84linux%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%90%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%E3%80%91%E5%9F%BA%E4%BA%8Eweb%E7%9A%84linux%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%90%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%E3%80%91/"/>
    <id>http://martist.cn/2019/01/10/LINUX/基于web的linux管理系统【工具推荐】基于web的linux管理系统【工具推荐】/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-01-11T04:19:58.399Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>Webmin是目前功能最强大的基于Web的Unix系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理动作。目前Webmin支持绝大多数的Unix系统，这些系统除了各种版本的linux以外还包括：AIX、HPUX、Solaris、Unixware、Irix和FreeBSD等。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>克隆代码，执行命令 </p><p> git clone   <a href="https://github.com/webmin/webmin.git" target="_blank" rel="external">https://github.com/webmin/webmin.git</a> </p></li></ol><ol><li><p>切换目录，执行命令</p><p> cd webmin</p></li><li><p>开始安装，执行命令 </p><p> ./setup.sh </p></li></ol><p>可能需要root权限执行。</p><ol><li>后面有几个简单的设置项，看提示填写就好了。</li></ol><p>设置语言为中文：</p><p>登录Webmin后，依次点击Webmin-&gt;Webmin Configuration,右侧点击Language，下拉框选择Simplified Chinese(ZH_CN)即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>一次性执行多条shell命令</title>
    <link href="http://martist.cn/2019/01/09/LINUX/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%9D%A1shell%E5%91%BD%E4%BB%A4/"/>
    <id>http://martist.cn/2019/01/09/LINUX/一次性执行多条shell命令/</id>
    <published>2019-01-08T16:00:00.000Z</published>
    <updated>2019-01-15T13:30:30.865Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="shell一次性执行多条命令"><a href="#shell一次性执行多条命令" class="headerlink" title="shell一次性执行多条命令"></a>shell一次性执行多条命令</h2><pre><code>1.每个命令之间用;隔开说明：各命令的执行给果，不会影响其它命令的执行。换句话说，各个命令都会执行，但不保证每个命令都执行成功。2.每个命令之间用&amp;&amp;隔开说明：若前面的命令执行成功，才会去执行后面的命令。这样可以保证所有的命令执行完毕后，执行过程都是成功的。3.每个命令之间用||隔开说明：||是或的意思，只有前面的命令执行失败后才去执行下一条命令，直到执行成功一条命令为止。</code></pre><h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>1.编写脚本文件，列出所有需要执行的命令(自定义名称为run.sh)</p><pre><code>#!/bin/shservice apache2 start;service mysql start;#!/bin/sh是指此脚本使用/bin/sh来解释执行，#!是特殊的表示符，其后面根的是此解释此脚本的shell的路径。</code></pre><p>其实第一句的#!是对脚本的解释器程序路径，脚本的内容是由解释器解释的，我们可以用各种各样的解释器来写对应的脚本。</p><p>比如说/bin/csh脚本，/bin/perl脚本，/bin/awk脚本，/bin/sed脚本，甚至/bin/echo等等。</p><p>2、修改权限</p><pre><code>chmod -R 777 run.sh</code></pre><p>3、执行该脚本文件</p><pre><code>./run.sh</code></pre><h2 id="在PHP中调用多条shell指令"><a href="#在PHP中调用多条shell指令" class="headerlink" title="在PHP中调用多条shell指令"></a>在PHP中调用多条shell指令</h2><p>&lt;?php</p><pre><code>// Run single system commandexec(&quot;ipconfig 2&gt;&amp;1&quot;, $output, $code);var_dump($output);var_dump($code);// Run multiple shell commandsexec(&quot;cd %cd%\svn_repo_child_folder\test &amp;&amp; svn update            --username &lt;your-repo-username&gt; --password &lt;your-repo-password&gt; 2&gt;&amp;1&quot;, $output, $code);var_dump($output);var_dump($code);</code></pre>]]></content>
    
    <summary type="html">
    
      linux
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="shell" scheme="http://martist.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>北漂生活回忆</title>
    <link href="http://martist.cn/2019/01/09/%E9%9D%9E%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%8C%97%E6%BC%82%E7%94%9F%E6%B4%BB%E5%9B%9E%E5%BF%86/"/>
    <id>http://martist.cn/2019/01/09/非技术文章/北漂生活回忆/</id>
    <published>2019-01-08T16:00:00.000Z</published>
    <updated>2019-01-17T09:34:59.885Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>15年，三人成团来到北京，网页布局都不会，通县实习</p><p>在篮球场，接了一个意料之中的电话，被嫌弃不会用easyUI辞退</p><p>之后，面试薪资4k的全职工作被否定</p><p>在之后，是图书馆和慕课网带我入的门</p><p>16年，大学里的青春稍纵即逝</p><p>我走出了大门，青春还在，生活却再不简单</p><p>定福黄庄，夏天每一夜，顶楼的小公寓炎热难耐</p><p>半年多的时间没有收入，饭菜清淡，油腥不沾</p><p>往返天通苑半截塔 — 三里屯，地铁公交步行穿过没有光亮的村路</p><p>17年，一台mbp竟清零了我俩的全部积蓄</p><p>薪资翻倍，恍恍惚惚，经历了属于程序猿的最快的技术成长期</p><p>蜗居，北漂，一切早已被定义</p><p>发博客，写电子书，二人生活中的磕磕碰碰和甜蜜，写满了一年的日记</p><p>18年，稳中带皮的一波操作</p><p>面试互金公司时技术过了，hr面没过，反省</p><p>新浪链家的技术面试，反省，</p><p>到年底了，太累，眼睛布满血丝，睡眠不足，过劳肥，心脏不适…</p><p>三年，我总感到一股无形的，有力的浪涌推动着我的背，让我可以向前快跑</p><p>希望生活能像陶渊明的文章，</p><p>林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。</p><p>初极狭，才通人。复行数十步，豁然开朗。</p>]]></content>
    
    <summary type="html">
    
      每个人只有一种命运
    
    </summary>
    
      <category term="人生" scheme="http://martist.cn/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="人生" scheme="http://martist.cn/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="感悟" scheme="http://martist.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>linux端口占用怎么解决</title>
    <link href="http://martist.cn/2019/01/07/LINUX/linux%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/"/>
    <id>http://martist.cn/2019/01/07/LINUX/linux端口占用怎么解决/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-01-11T02:26:01.545Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>找到占用该端口的进程id，第一步：</p><pre><code>sudo lsof -i:9000</code></pre><p>杀掉该进程，第二步：</p><pre><code>sudo kill 840</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分销海报的生成</title>
    <link href="http://martist.cn/2019/01/04/PHP/%E5%88%86%E9%94%80%E6%B5%B7%E6%8A%A5%E7%9A%84%E7%94%9F%E6%88%90/"/>
    <id>http://martist.cn/2019/01/04/PHP/分销海报的生成/</id>
    <published>2019-01-03T16:00:00.000Z</published>
    <updated>2019-01-04T10:22:33.145Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="产品需求"><a href="#产品需求" class="headerlink" title="产品需求"></a>产品需求</h2><p>最近流行用朋友圈海报图进行拉新或者一些运营活动，这个海报生成需要有一些用户的个人信息数据，怎么做到很快生成海报返回用户，并且保证清晰度呢？</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>1.PHP的gd库，通过添加水印的方式生成海报，保存海报图到服务器，然后发给用户图片地址（服务端生成，准确率高，缺点就是慢）<br>2.js的canvas特性生成（客户端生成，速度快，缺点是不稳定，不同机型不一定都能成图）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>不啰嗦了，核心代码如下</p><pre><code>&lt;div id=&quot;content&quot; &gt;    &lt;img width=&quot;100%&quot; src=&quot;&lt;{$background_img_url}&gt;&quot; alt=&quot;&quot;&gt;    &lt;p id=&quot;service_erweima&quot; class=&quot;code&quot; crossOrigin=&quot;Anonymous&quot;&gt;&lt;/p&gt;    &lt;span class=&quot;mess&quot;&gt;扫码免费领课和我一起学习&lt;/span&gt;    &lt;img src=&quot;&lt;{$head_img}&gt;&quot; alt=&quot;&quot; class=&quot;user&quot; crossOrigin=&quot;Anonymous&quot;&gt;    &lt;span class=&quot;name&quot;&gt;&lt;{$user_name}&gt;&lt;/span&gt;    &lt;input type=&quot;hidden&quot; id=&quot;m_redirect_code&quot; value=&quot;&lt;{$m_redirect_code}&gt;&quot;&gt;    &lt;input type=&quot;hidden&quot; id=&quot;code&quot; value=&quot;&lt;{$code}&gt;&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/html2canvas/0.5.0-beta4/html2canvas.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/Public/Js/qrcode.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    sleep(1000);//生成二维码    new QRCode(document.getElementById(&quot;service_erweima&quot;), {        text: ’https://www.your_host_url.com‘,        width: 100,        height: 100,        border:1,        colorDark : &apos;#000000&apos;, //前景色        colorLight : &apos;#ffffff&apos;  //背景色    });//canvas生成海报    html2canvas($(&apos;#content&apos;),{        useCORS: true,        logging: false,        onrendered: function(canvas) {            var image = new Image();            image.crossOrigin = &apos;anonymous&apos;;            image.src = canvas.toDataURL(&quot;image/png&quot;);            $(&apos;#public-content&apos;).append(image);            $(&apos;#content&apos;).hide();        }    });//需要等待图片完全加载完了，DOM渲染完了，再生成，所以等一等    function sleep(delay) {        var start = (new Date()).getTime();        while ((new Date()).getTime() - start &lt; delay) {            continue;        }    }&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>having的用法</title>
    <link href="http://martist.cn/2019/01/02/MYSQL/%20having%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://martist.cn/2019/01/02/MYSQL/ having的用法/</id>
    <published>2019-01-01T16:00:00.000Z</published>
    <updated>2019-01-14T07:29:19.902Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>having子句与where子句一样，都是用于条件判断的。</p><h2 id="区别1"><a href="#区别1" class="headerlink" title="区别1"></a>区别1</h2><p>where是判断数据从磁盘读入内存的时候；<br>having是判断分组统计之前的所有条件。</p><h2 id="区别2"><a href="#区别2" class="headerlink" title="区别2"></a>区别2</h2><p>having子句中可以使用字段别名，而where不能使用。</p><h2 id="区别3"><a href="#区别3" class="headerlink" title="区别3"></a>区别3</h2><p>having能够使用统计函数，但是where不能使用。</p><h2 id="having的特点"><a href="#having的特点" class="headerlink" title="having的特点"></a>having的特点</h2><ol><li>先分组，再判断；</li><li>having相当于是group by汇总以后的where过滤；</li><li>having 对分组进行过滤 ，不使用group by就默认表的整体为一组。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一些常用命令手记</title>
    <link href="http://martist.cn/2019/01/02/MYSQL/%E5%91%BD%E4%BB%A4/"/>
    <id>http://martist.cn/2019/01/02/MYSQL/命令/</id>
    <published>2019-01-01T16:00:00.000Z</published>
    <updated>2019-01-14T07:43:06.669Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="简单描述表结构，字段类型"><a href="#简单描述表结构，字段类型" class="headerlink" title="简单描述表结构，字段类型"></a>简单描述表结构，字段类型</h2><pre><code>desc tabl_name;</code></pre><p>显示表结构，字段类型，主键，是否为空等属性，但不显示外键。</p><h2 id="查询表中列的注释信息"><a href="#查询表中列的注释信息" class="headerlink" title="查询表中列的注释信息"></a>查询表中列的注释信息</h2><pre><code>select * from information_schema.columnswhere table_schema = &apos;db&apos; #表所在数据库and table_name = &apos;tablename&apos; ; #你要查的表</code></pre><h2 id="只查询列名和注释"><a href="#只查询列名和注释" class="headerlink" title="只查询列名和注释"></a>只查询列名和注释</h2><pre><code>select column_name, column_comment from information_schema.columns where table_schema =&apos;db&apos; and table_name = &apos;tablename&apos; ;</code></pre><h2 id="查看表的注释"><a href="#查看表的注释" class="headerlink" title="查看表的注释"></a>查看表的注释</h2><pre><code>select table_name,table_comment from information_schema.tables where table_schema = &apos;db&apos; and table_name =&apos;tablename&apos;</code></pre><h2 id="查看表生成的DDL"><a href="#查看表生成的DDL" class="headerlink" title="查看表生成的DDL"></a>查看表生成的DDL</h2><pre><code>show create table table_name;</code></pre><p>补充一些可能用到的命令：</p><h2 id="建表命令"><a href="#建表命令" class="headerlink" title="建表命令"></a>建表命令</h2><pre><code>CREATE TABLE `t_sold_order` (`id` int(11) NOT NULL AUTO_INCREMENT,`dt` date DEFAULT NULL COMMENT &apos;日期&apos;,`hour` tinyint(2) DEFAULT &apos;0&apos; COMMENT &apos;小时&apos;,`hour_order` int(11) DEFAULT &apos;0&apos; COMMENT &apos;小时订单数&apos;,`total_order` int(11) DEFAULT &apos;0&apos; COMMENT &apos;总的订单数&apos;,`prediction` int(11) DEFAULT &apos;0&apos; COMMENT &apos;预测订单数&apos;,PRIMARY KEY (`id`),UNIQUE KEY `dt_hour` (`dt`,`hour`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&apos;实时订单数&apos;</code></pre><h2 id="表操作命令"><a href="#表操作命令" class="headerlink" title="表操作命令"></a>表操作命令</h2><p>复制表结构：</p><pre><code>create table table1 like table;</code></pre><p>复制数据：</p><pre><code>insert into table1 select * from table</code></pre><p>机器授权：</p><pre><code>grant select on *.* to &apos;reader&apos;@&apos;%&apos; identified by &apos;123456&apos; WITH GRANT OPTION</code></pre><p>flush privileges</p><p>查询数据直接插入</p><pre><code>insert into t_visual_user_domain(`user_id`,`domain`,`group`) select id,&apos;www.baidu.com&apos; as domain,`group` from t_visual_user;</code></pre><p>修改表结构</p><pre><code>alter table competitor_goods add sku_id bigint(20) unsigned DEFAULT NULL COMMENT &apos;商品销售码&apos;;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="MySQL" scheme="http://martist.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://martist.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>cron的一个疑问</title>
    <link href="http://martist.cn/2018/12/31/LINUX/cron%E7%9A%84%E4%B8%80%E4%B8%AA%E7%96%91%E9%97%AE/"/>
    <id>http://martist.cn/2018/12/31/LINUX/cron的一个疑问/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2019-01-05T09:47:32.882Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><blockquote><p>crontab定时任务第一个周期未完成下一个周期执行就来了</p></blockquote><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>有一个定时任务，每分钟执行一次，前一分钟还没有执行完成，下一个分钟就来了，怎么解决。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><pre><code>#!/bin/bashecho &quot;开始 `date` &quot; &gt;&gt; /lile/shell/ll.txtsleep 70echo &quot;结束 `date` &quot; &gt;&gt; /lile/shell/ll.txt*/1 * * * * /bin/sh /lile/shell/test_cron.sh</code></pre><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用文件锁flock，使用文件锁的文件可以是任意文件 </p><pre><code>*/1 * * * * flock -xn /lile/shell/test_cron.sock -c &apos;/bin/sh /lile/shell/test_cron.sh&apos;</code></pre><p>这样的话，当前一个任务没有执行完，后一个任务就来了的话，是不会执行的，会直到这个任务执行完成后，然后一个周期的时候再执行</p><h2 id="flock常用参数（man-flock）"><a href="#flock常用参数（man-flock）" class="headerlink" title="flock常用参数（man flock）"></a>flock常用参数（man flock）</h2><pre><code>-s：获取一个共享锁-x ：获得一个独占锁-u：解除锁-n：如果获取锁失败立即返回而不是等待-w：如果获取锁失败等待的时间-c：在shell中允许一个命令</code></pre><p>你可以用队列形式设置定时任务，这样先来先执行后来后执行；或者弄个cron配置文件设置每个任务的依赖关系，比如你如果知道那个任务大概超出了间隔时间，就把它后面的任务与之设置成依赖关系，这样这个任务必须执行完后面的才执行。这样避免任务冲突！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="cron" scheme="http://martist.cn/categories/cron/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="cron" scheme="http://martist.cn/tags/cron/"/>
    
  </entry>
  
  <entry>
    <title>crontab</title>
    <link href="http://martist.cn/2018/12/27/LINUX/crontab/"/>
    <id>http://martist.cn/2018/12/27/LINUX/crontab/</id>
    <published>2018-12-26T16:00:00.000Z</published>
    <updated>2019-01-17T09:07:56.835Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>在Ubuntu14.04环境下，利用crontab编写shell脚本程序，定时执行php相关程序。在这个过程中，经常使用到的crontab命令如下：</p><p>(root权限下)</p><p>crontab启动：</p><pre><code>/etc/init.d/cron start  ( service cron start )</code></pre><p>crontab重启： </p><pre><code>/etc/init.d/cron  restart  (service cron restart )</code></pre><p>crontab关闭： </p><pre><code>/etc/init.d/cron  stop  ( service cron stop )</code></pre><p>在终端中，可以利用 ps -aux|grep cron查询crontab状态，默认情况下，是自启动的。</p><p>进入到/etc/init.d目录下，ls列出所有选项，会发现，存在cron文件</p><p>写定时任务</p><p>　　通过如下命令，就可以开启本用户的定时文件，文件存放在 /var/spool/cron/crontabs 文件夹下</p><p>并且以用的的名字命名的文件</p><pre><code>crontab -e</code></pre><p>可以通过以下命令列出某个用户cron服务的详细内容</p><pre><code>crontab -l</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="crontab" scheme="http://martist.cn/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>awk</title>
    <link href="http://martist.cn/2018/10/21/LINUX/awk/"/>
    <id>http://martist.cn/2018/10/21/LINUX/awk/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2019-01-17T09:24:51.887Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>命令示例：</p><pre><code>awk &apos;{if($0~&quot;listAuths&quot;) print}&apos; xxx.log</code></pre><p>解释说明：抽取xxx.log整个日志文件中，包含“listAuths”的行，打印输出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="linux" scheme="http://martist.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://martist.cn/tags/linux/"/>
    
      <category term="awk" scheme="http://martist.cn/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下开启mysql的bin_log日志</title>
    <link href="http://martist.cn/2018/10/12/MYSQL/Ubuntu%E4%B8%8B%E5%BC%80%E5%90%AFmysql%E7%9A%84bin_log%E6%97%A5%E5%BF%97/"/>
    <id>http://martist.cn/2018/10/12/MYSQL/Ubuntu下开启mysql的bin_log日志/</id>
    <published>2018-10-11T16:00:00.000Z</published>
    <updated>2018-11-01T03:21:56.353Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="mysqlbinlog工具"><a href="#mysqlbinlog工具" class="headerlink" title="mysqlbinlog工具"></a>mysqlbinlog工具</h2><p>mysqlbinlog是一个客户端程序，可以审查binlog文件及中继日志文件的内容。既可以读取本地也可以读取远程的binlog文件，输出二进制日志的内容。</p><p>mysqlbinlog常用的选项：</p><pre><code>—database=db_name，-d db_name</code></pre><p>只列出该数据库的条目(只用本地日志)。</p><pre><code>–force-read，-f</code></pre><p>使用该选项，如果mysqlbinlog读它不能识别的二进制日志事件，它会打印警告，忽略该事件并继续。没有该选项，如果mysqlbinlog读到此类事件则停止。</p><pre><code>–read-from-remote-server，-R</code></pre><p>从MySQL服务器读二进制日志。如果未给出该选项，任何连接参数选项将被忽略。这些选项是–host、–password、–port、–protocol、–socket和–user。</p><pre><code>–host=host_name，-h host_name</code></pre><p>获取给定主机上的MySQL服务器的二进制日志。</p><pre><code>–port=port_num，-P port_num</code></pre><p>用于连接远程服务器的TCP/IP端口号。</p><pre><code>–user=user_name，-u user_name</code></pre><p>连接远程服务器时使用的MySQL用户名。</p><pre><code>–password[=password]，-p[password]</code></pre><p>当连接服务器时使用的密码。如果使用短选项形式(-p)，选项和密码之间不能有空格。如果在命令行中–password或-p选项后面没有密码值，则提示输入一个密码。</p><pre><code>–result-file=name,-r name</code></pre><p>将输出指向给定的文件。</p><pre><code>–short-form，-s</code></pre><p>只显示日志中包含的语句，不显示其它信息。</p><pre><code>–start-datetime=datetime</code></pre><p>从二进制日志中第1个日期时间等于或晚于datetime参量的事件开始读取。datetime值相对于运行mysqlbinlog的机器上的本地时区。该值格式应符合DATETIME或TIMESTAMP数据类型。例如：</p><p>shell&gt; mysqlbinlog–start-datetime=”2004-12-25 11:25:56″binlog.000003该选项可以帮助点对点恢复。</p><pre><code>–stop-datetime=datetime</code></pre><p>从二进制日志中第1个日期时间等于或晚于datetime参量的事件起停止读。关于datetime值的描述参见–start-datetime选项。该选项可以帮助及时恢复。</p><pre><code>–start-position=N</code></pre><p>从二进制日志中第1个位置等于N参量时的事件开始读。</p><pre><code>–stop-position=N</code></pre><p>从二进制日志中第1个位置等于和大于N参量时的事件起停止读。</p><h2 id="利用mysqlbinlog-拿到你想要的原生sql"><a href="#利用mysqlbinlog-拿到你想要的原生sql" class="headerlink" title="利用mysqlbinlog 拿到你想要的原生sql"></a>利用mysqlbinlog 拿到你想要的原生sql</h2><p>执行：</p><pre><code>bin ./mysqlbinlog -v --base64-output=DECODE-ROWS  ~/Downloads/tymysql2|grep  -A4  &apos;ALTER&apos; &gt;~/Downloads/alter2.text</code></pre><p>参数：</p><pre><code>-v 是显示出一些sql的信息 -vv则是多一些注释性的东西--base64-output=DECODE-ROWS 这个是把sql解码出来~/mysql/data/mysql.bin.000001 这里是你的binlog文件grep -A4 &apos;ALTER&apos; 这个则是匹配alter语句以及后四行&gt; ~/Downloads/test.sql  则是把匹配出来的sql语句输出到指定文件</code></pre><p>参考：<br><a href="https://www.cnblogs.com/jackluo/p/3336585.html" target="_blank" rel="external">https://www.cnblogs.com/jackluo/p/3336585.html</a><br><a href="https://www.cnblogs.com/martinzhang/p/3454358.html" target="_blank" rel="external">https://www.cnblogs.com/martinzhang/p/3454358.html</a><br><a href="http://blog.51cto.com/suifu/1881116" target="_blank" rel="external">http://blog.51cto.com/suifu/1881116</a><br><a href="https://my.oschina.net/Laily/blog/648776" target="_blank" rel="external">https://my.oschina.net/Laily/blog/648776</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>laravel+elastic笔记</title>
    <link href="http://martist.cn/2018/10/10/LARAVEL/laravel+elastic%E7%AC%94%E8%AE%B0/"/>
    <id>http://martist.cn/2018/10/10/LARAVEL/laravel+elastic笔记/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2018-11-01T03:21:25.343Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>版本很重要<br>由点及面，先实践起来再学细节的原理和使用</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><pre><code>laravel5.5框架+scout组件+elasticsearch6.3.0搜索引擎</code></pre><h3 id="辅助"><a href="#辅助" class="headerlink" title="辅助"></a>辅助</h3><pre><code>elasticsearch-head 查看集群数据可视化中文分词插件Ik</code></pre><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>laravel是一款现代化的php框架<br>es是搜索引擎<br>es-head是管理查看使用es的图形界面工具<br>scout是laravel一款优秀的组件</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><h3 id="laravel"><a href="#laravel" class="headerlink" title="laravel"></a>laravel</h3><p>laravel安装器安装：</p><pre><code>laravel new larasearch</code></pre><p>配置env文件：</p><pre><code>DB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=julyeduDB_USERNAME=rootDB_PASSWORD=123456</code></pre><p>这时php artisan命令启动，访问127.0.0.1:8000 就可以看到项目首页了。</p><h3 id="es"><a href="#es" class="headerlink" title="es"></a>es</h3><p>在es的官网挑选一个合适的版本，建议选择6.3.0，以便配套使用IK和ES-head。</p><pre><code># 下载https://www.elastic.co/downloads/past-releases</code></pre><h3 id="IK"><a href="#IK" class="headerlink" title="IK"></a>IK</h3><p>1.直接plugin命令安装</p><pre><code>./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.3.0/elasticsearch-analysis-ik-6.3.0.zip</code></pre><p>2.配置修改ik的版本适应es6.3.1,修改文件plugin-descriptor.properties，config文件夹下的配置文件主要是IK本身暂时不需要修改，这个properties文件主要是和es交互，修改其es版本和jdk版本号</p><pre><code># 修改elasticsearch-head/plugin-descriptor.properties文件description=head - A web front end for an elastic search clusterversion=6.3.1site=truename=analysis-ikclassname=org.elasticsearch.plugin.analysis.ik.AnalysisIkPluginjava.version=1.8elasticsearch.version=6.3.1 </code></pre><h3 id="es-head"><a href="#es-head" class="headerlink" title="es-head"></a>es-head</h3><p>head是基于node开发的，所以需要先安装node<br>node下载地址：<a href="http://cdn.npm.taobao.org/dis" target="_blank" rel="external">http://cdn.npm.taobao.org/dis</a>…</p><p>在电脑任意一个目录下（不要在elasticsearch目录里面），执行一下命令，</p><pre><code>git clone https://github.com/mobz/elasticsearch-head.git  cd elasticsearch-head/  npm install  </code></pre><p>为了es-head可以访问es，所以需要配置跨域：</p><p>修改两个地方：</p><pre><code>#elasticsearch-headGruntfile.jsconnect: {    server: {        options: {            port: 9100,            hostname: &apos;*&apos;,            base: &apos;.&apos;,            keepalive: true        }    }}#elasticsearch-5.6.0configelasticsearch.ymlhttp.cors.enabled: true  http.cors.allow-origin: &quot;*&quot;  </code></pre><h2 id="scout"><a href="#scout" class="headerlink" title="scout"></a>scout</h2><p>通过composer安装依赖包</p><pre><code>composer require laravel/scoutcomposer require tamayo/laravel-scout-elastic</code></pre><p>基本配置</p><p>在config/app.php文件中的providers数组中加入服务提供者</p><pre><code>// config/app.php&apos;providers&apos; =&gt; [    // ...    Laravel\Scout\ScoutServiceProvider::class,    // ...    ScoutEngines\Elasticsearch\ElasticsearchProvider::class,],</code></pre><p>使用以下命令生成scout配置文件</p><pre><code>php artisan vendor:publish --provider=&quot;Laravel\Scout\ScoutServiceProvider&quot;</code></pre><p>在config/scout.php中加入elasticsearch的配置</p><pre><code>&apos;elasticsearch&apos; =&gt; [    &apos;index&apos; =&gt; env(&apos;ELASTICSEARCH_INDEX&apos;, &apos;laravel&apos;),    &apos;hosts&apos; =&gt; [        env(&apos;ELASTICSEARCH_HOST&apos;, &apos;http://localhost:9200&apos;),    ],],</code></pre><p>然后我们打开.env文件，加入scout和elasticsearch的配置</p><pre><code># scout配置SCOUT_DRIVER=elasticsearchSCOUT_PREFIX=# elasticsearch 配置ELASTICSEARCH_INDEX=esdemo# elasticsearch 地址ELASTICSEARCH_HOST=http://172.30.6.1:9200</code></pre><h3 id="相关文档地址"><a href="#相关文档地址" class="headerlink" title="相关文档地址"></a>相关文档地址</h3><p>laravel scout中文文档地址：<a href="https://laravel-china.org/docs/laravel/5.3/scout/1205" target="_blank" rel="external">https://laravel-china.org/docs/laravel/5.3/scout/1205</a><br>es中文文档地址：<a href="https://www.elastic.co/guide/cn/elasticsearch/php/current/_configuration.html" target="_blank" rel="external">https://www.elastic.co/guide/cn/elasticsearch/php/current/_configuration.html</a><br>es6.3.0地址：<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-6-3-0" target="_blank" rel="external">https://www.elastic.co/downloads/past-releases/elasticsearch-6-3-0</a><br>IK github地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="external">https://github.com/medcl/elasticsearch-analysis-ik</a></p><h2 id="启动并查看"><a href="#启动并查看" class="headerlink" title="启动并查看"></a>启动并查看</h2><p>启动es</p><pre><code>./bin/elasticsearch</code></pre><p>地址</p><pre><code>http://127.0.0.1:9200/</code></pre><p>启动es-head</p><pre><code>npm run start</code></pre><p>地址</p><pre><code>http://127.0.0.1:9100</code></pre><p>启动laravel项目</p><pre><code>php artisan serve</code></pre><p>地址</p><pre><code>http://127.0.0.1:8000/es/s?page=1</code></pre><h2 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="创建模型并填充数据"><a href="#创建模型并填充数据" class="headerlink" title="创建模型并填充数据"></a>创建模型并填充数据</h4><p>创建模型app/Ques.php，为方便后续测试，请先建表和填充数据，可以手动使用sql语句添加数据，也使用laravel自动的数据迁移和填充。</p><pre><code>&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;use Laravel\Scout\Searchable;/** * 学生模型 */class Ques extends Model{     use Searchable;    //定义关联的表名，不定义的话默认此模型关联的表为 模型名s (users)    protected $table = &apos;aws_ques_tb_0&apos;;    /******字段相关*******/    #定义主键字段名，默认是id    protected $primaryKey = &apos;id&apos;;    #定义字段白名单，允许操作表中的哪些字段    // protected $fillable = [&apos;ques&apos;,&apos;name&apos;];    #定义字段黑名单，不允许操作表中哪些字段    protected $guarded = [];    //1、使用model::create([])等方法直接对orm对象操作使，必须定义$guarded或者$fillable    //2、使用$m = new model();然后$m-&gt;save()的方式不需要定义    //3、简便的方式就是定义$fillable = [];    #定义隐藏的字段    protected $hidden = [];    /**     * 索引名称     *     * @return string     */    public function searchableAs()    {        return &apos;ques_index&apos;;    }    /**     * 索引名称     *     * @return string     */    public function searchableAs()    {        return &apos;Quess_index&apos;;    }    /**     * 可搜索的数据索引     *     * @return array     */    public function toSearchableArray()    {        $array = $this-&gt;toArray();        // Customize array...        return $array;    }}</code></pre><h4 id="把所有现有记录导入到搜索索引里"><a href="#把所有现有记录导入到搜索索引里" class="headerlink" title="把所有现有记录导入到搜索索引里"></a>把所有现有记录导入到搜索索引里</h4><pre><code>php artisan scout:import &quot;App\Ques&quot;</code></pre><h4 id="导入过程"><a href="#导入过程" class="headerlink" title="导入过程"></a>导入过程</h4><pre><code>Imported [App\Ques] models up to ID: 500Imported [App\Ques] models up to ID: 1000Imported [App\Ques] models up to ID: 1500Imported [App\Ques] models up to ID: 2000All [App\Ques] records have been imported.</code></pre><p>我们访问es，是不是已经有了刚刚导入的Quess_index索引数据。</p><pre><code>http://172.30.6.1:9200/esdemo/Ques_index/_search</code></pre><h4 id="试试搜索"><a href="#试试搜索" class="headerlink" title="试试搜索"></a>试试搜索</h4><p>在route/web.php中写个demo，试试看；</p><pre><code>Route::get(&apos;/search/{content}&apos;, function ($content) {    //直接输出数组data，限制1000条    // $res = App\Ques::search($content)-&gt;take(1000)-&gt;get()-&gt;toArray();    // 分页请求  http://127.0.0.1:8000/es/机器学习?page=1    $res = App\Ques::search($content)-&gt;paginate(100)-&gt;toArray();    dd($res);});</code></pre><h4 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h4><p>输出：</p><pre><code>array:12 [▼  &quot;current_page&quot; =&gt; 1  &quot;data&quot; =&gt; array:9 [▼    0 =&gt; array:9 [▼      &quot;id&quot; =&gt; 922      &quot;ques&quot; =&gt; &quot;哪些机器学习算法不需要做归一化处理？&quot;      &quot;analysis&quot; =&gt; &quot;&quot;&quot;        概率模型不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率，如决策树、rf。而像adaboost、svm、lr、KNN、KMeans之类的最优化问题就需要归一化。\r\n        我理解归一化和标准化主要是为了使计算更方便 比如两个变量的量纲不同 可能一个的数值远大于另一个那么他们同时作为变量的时候 可能会造成数值计算的问题，比如说求矩阵的逆可能很不精确 或者梯度下降法的收敛比较困难，还有如果需要计算欧式距离的话可能 量纲也需要调整 所以我估计lr 和 knn 保准话一下应该有好处。至于其他的算 ▶        一般我习惯说树形模型，这里说的概率模型可能是差不多的意思。引用自@寒小阳        &quot;&quot;&quot;      &quot;type_id&quot; =&gt; 3      &quot;diff&quot; =&gt; 0      &quot;isdelete&quot; =&gt; 1      &quot;created_time&quot; =&gt; &quot;2017-12-10 18:57:13&quot;      &quot;update_time&quot; =&gt; &quot;0000-00-00 00:00:00&quot;      &quot;is_show&quot; =&gt; 1    ]    1 =&gt; array:9 [▶]    2 =&gt; array:9 [▶]    3 =&gt; array:9 [▶]    4 =&gt; array:9 [▶]    5 =&gt; array:9 [▶]    6 =&gt; array:9 [▶]    7 =&gt; array:9 [▶]    8 =&gt; array:9 [▶]  ]  &quot;first_page_url&quot; =&gt; &quot;http://127.0.0.1:8000/search/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0?query=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&amp;page=1&quot;  &quot;from&quot; =&gt; 1  &quot;last_page&quot; =&gt; 1  &quot;last_page_url&quot; =&gt; &quot;http://127.0.0.1:8000/search/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0?query=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&amp;page=1&quot;  &quot;next_page_url&quot; =&gt; null  &quot;path&quot; =&gt; &quot;http://127.0.0.1:8000/search/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&quot;  &quot;per_page&quot; =&gt; 100  &quot;prev_page_url&quot; =&gt; null  &quot;to&quot; =&gt; 9  &quot;total&quot; =&gt; 9]</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>PHP使用elasticsearch搜索安装及分词方法【<a href="https://segmentfault.com/a/1190000011663833】" target="_blank" rel="external">https://segmentfault.com/a/1190000011663833】</a></p><p>Laravel中利用Scout集成Elasticsearch搜索引擎【<a href="https://segmentfault.com/a/1190000014230010】" target="_blank" rel="external">https://segmentfault.com/a/1190000014230010】</a></p><p>全文搜索引擎 Elasticsearch 入门教程【<a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html】" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html】</a></p><p>laravel使用ElasticSearch进行搜索【<a href="https://blog.csdn.net/lingchen__/article/details/77884753】" target="_blank" rel="external">https://blog.csdn.net/lingchen__/article/details/77884753】</a></p><p>elasticsearch6.3.1+IK插件安装部署全攻略【<a href="https://blog.csdn.net/superheister/article/details/81296451】" target="_blank" rel="external">https://blog.csdn.net/superheister/article/details/81296451】</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="laravel" scheme="http://martist.cn/categories/laravel/"/>
    
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 重装PHP</title>
    <link href="http://martist.cn/2018/09/27/MACBOOK/macOS%E9%87%8D%E8%A3%85PHP/"/>
    <id>http://martist.cn/2018/09/27/MACBOOK/macOS重装PHP/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2019-01-15T13:31:51.279Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><p>/usr/bin/ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p><pre><code>该方式会创建 /usr/local/* 等一系列文件夹, 熟悉Linux的用户一看就明白这个文件夹是做什么</code></pre><h2 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h2><p>由于Homebrew仓库的更新, 将homebrew/homebrew-php合并到homebrew/core中, 同时也去掉了php各种扩展包. 甚至php安装包的名称也做了统一修改</p><p>以php7.1为例, 以前的安装方式是</p><p>  brew install php71</p><p>而现在需要按照brew的统一包名称规范</p><p>  brew install php@7.1</p><h2 id="不能用brew傻瓜安装redis扩展"><a href="#不能用brew傻瓜安装redis扩展" class="headerlink" title="不能用brew傻瓜安装redis扩展"></a>不能用brew傻瓜安装redis扩展</h2><p>2018年homebrew-php已经弃用了</p><h2 id="失效命令"><a href="#失效命令" class="headerlink" title="失效命令"></a>失效命令</h2><p>  brew tap homebrew/homebrew-php<br>  brew install php71-redis</p><p>选择pecl安装或者源码安装</p><h2 id="源码安装php-redis"><a href="#源码安装php-redis" class="headerlink" title="源码安装php-redis"></a>源码安装php-redis</h2><p>phpredis下载地址</p><p>  <a href="https://github.com/phpredis/phpredis" target="_blank" rel="external">https://github.com/phpredis/phpredis</a></p><p>解压并进入源码包</p><p>  unzip phpredis-develop.zip<br>  cd phpredis-develop</p><p>生成configure配置文件:</p><p>  sudo /usr/local/Cellar/php/7.2.11/bin/phpize</p><p>编译安装:</p><p>  sudo ./configure –with-php-config=/usr/local/Cellar/php/7.2.11/bin/php-config </p><p>  sudo make &amp;&amp; make install</p><p>配置php.ini,添加扩展：</p><p>  extension=redis.so</p><p>重启php</p><p>查看fpm是否存在</p><p>  ps aux|grep fpm</p><p>关闭</p><p>  sudo pkill php-fpm</p><p>启动</p><p>  sudo /usr/local/opt/php@7.2/sbin/php-fpm -D</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>  php -m|grep redis</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>  redis</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="Mac" scheme="http://martist.cn/categories/Mac/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="Mac" scheme="http://martist.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>feed流的技术实现</title>
    <link href="http://martist.cn/2018/08/24/%E6%9E%B6%E6%9E%84/feed%E6%B5%81%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>http://martist.cn/2018/08/24/架构/feed流的技术实现/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2018-08-27T06:21:19.072Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们现在好多软件都有一个类似朋友圈的功能：微博、微信、QQ…… 只要涉及到好友、粉丝这样的 app 或者是网站，一定有这样的一个功能。那这个功能是怎么样来实现的呢？</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>简单来说，Feeds这块主要包括两块内容</p><pre><code>生成feeds更新feed</code></pre><h3 id="生成feeds"><a href="#生成feeds" class="headerlink" title="生成feeds"></a>生成feeds</h3><p>比如我们已经关注的人做了特定操作，我们需要把这些活动加入你的feeds，让你接收到。<br>比如某大牌明星发了个微博，这时候我们首先找到明星的所有关注者，然后给需要推送的关注者推送此微博，大家可以把每个人的feeds简单想象为一个个的有序列表，推送很简单，就是在每个人的列表末尾添加这个操作。</p><h3 id="更新feeds"><a href="#更新feeds" class="headerlink" title="更新feeds"></a>更新feeds</h3><p>你新关注了一个人，需要把他的活动加入已有feeds。这时候我们需要取出此人的活动历史，然后按照时间顺序把这些历史塞到你的feeds中。此操作的复杂度会比较高，需要使用合适的数据结构来达到最佳性能，目前是O(log(N))。</p><h3 id="取消关注"><a href="#取消关注" class="headerlink" title="取消关注"></a>取消关注</h3><p>你的关注点做了一些更新操作，比如你取消关注了一个人，那么他的动态就要在feeds中清除掉。</p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>我们可以在用常用的mysql设计个2个数据表，一个表存人和人的关注关系，一个表存发布动态的信息。这样通过链表查询就可以实现feeds流了。但是我们知道feeds流的数据量级应该会非常大，性能和可用性就会直线下降，单一依靠mysql实现feeds已经无法应对业务的增长。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h3><p>什么是推模式？推模式就是，用户A关注了用户B，用户B每发送一个动态，后台遍历用户B的粉丝，往他们粉丝的feed里面推送一条动态。</p><h3 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h3><p>与推模式相反，拉模式则是，用户每次刷新feed第一页，都去遍历关注的人，把最新的动态拉取回来。</p><p>但是，不管推模式还是拉模式都存在若关注数量或者粉丝数量过多，导致遍历时间太长的问题，怎么去解决 ？这里就出现了第三种模式，推拉模式。</p><h3 id="推拉模式"><a href="#推拉模式" class="headerlink" title="推拉模式"></a>推拉模式</h3><p>这是一种折中的解决方案，就是在线推，离线拉。粉丝几百上千万， 跟你发布动态同时在线的肯定也就只有那么顶天几百几千几万，何况这类大V很少，只推给在线的粉丝，离线的粉丝上线后，再去拉取动态即可！但是，不管是什么模式，每个用户都会维护一个类似发件箱跟收件箱的东西，保存自己发过的动态以及Feed动态（具体实现看下面），来完成推与拉。</p><p>而这里讲的，肯定就是推拉模式，用户A关注了用户B ， 用户B发布动态则将动态推进用户A的feed，这里使用redis的zset实现，sort为time（记得以毫秒为时间戳，秒级在数据量达到一定程度后，会有读取不到的问题，比如以时间戳为分页页码），value为具体的动态 ID（为什么是动态ID， 其实很简单， 就是因为动态的内容可以进行缓存，在redis里面全部走ID，修改动态内容也需要修改一处，动态内容可以保存在hash结构里）， 每个用户维护一个zset保存我发布的动态，一个zset保存我的feed动态，过期时间3~7天看情况而定。为什么要设计过期时间后面会细说。</p><p>OK，全局维护一个在线用户列表，怎么设计这个就自己琢磨了，为了防止用户挂后台导致与服务端为离线状态，所以最好是1~3小时未操作或者离线时间不大于3小时的，都当做在线处理，反正这个看情况定。</p><p>那么，当用户发了一条动态后，后台会有以下这些操作：<br>在线推： 异步遍历在线的粉丝，将动态ID，添加到粉丝的Feed中。<br>离线拉： 离线用户打开APP后，我们是会请求一个公共的入口接口，主做统计以及其他初始化操作，在这里，我们也开了一个异步线程，对用户进行Feed更新操作，防止用户进入APP后等待拉取时间过长，毕竟关注成千上万的人肯定有（其实万单位以下遍历都很快）。拉取过程其实就是把自己最后一条Feed的时间戳取出，去遍历关注的人的feed，将大于该时间的ID全部拉取回来。用户进入APP后，刷新即可看到最新操作。</p><p>另：如果有Feed新消息数提示的需求，可以在推拉的同时进行增加， 刷新feed时清空即可。</p><h2 id="用户feed里面过长，占用内存怎么办？"><a href="#用户feed里面过长，占用内存怎么办？" class="headerlink" title="用户feed里面过长，占用内存怎么办？"></a>用户feed里面过长，占用内存怎么办？</h2><p>我是这么处理的，一个用户的feed第一次拉取的时候，feed长度为500条，在我们APP里，相当于50页，而后的数据，都走数据库。</p><p>大页码翻页其实就是个伪需求而且耗性能的东西，用户除了第一次用这个APP，才会翻到底，第一次使用， 能有几个动态 ？而对于二次使用以上的用户，一般来讲， 翻了几页就已经到达上一次看过的地方了，所以500条数据，在关注量一般的情况下，内容已经足够消费，甚至达到疲劳，可能有关注量很大的用户他的Feed每天可能有很多很多动态，但是，不用说，肯定是做广告的，关注一堆人等着回粉，这种人更不会去消费内容，50页的内容，翻起来都累。当然，并不是说放弃了这些人，feed找不到走数据库嘛~~~~爱走不走，想走就给我翻50页再说~</p><h2 id="每个用户都维护自己的动态跟Feed队列，当用户上百万时，内存的占有量肯定不小，要怎么释放内存才合适-？"><a href="#每个用户都维护自己的动态跟Feed队列，当用户上百万时，内存的占有量肯定不小，要怎么释放内存才合适-？" class="headerlink" title="每个用户都维护自己的动态跟Feed队列，当用户上百万时，内存的占有量肯定不小，要怎么释放内存才合适 ？"></a>每个用户都维护自己的动态跟Feed队列，当用户上百万时，内存的占有量肯定不小，要怎么释放内存才合适 ？</h2><p>这里就回到上面那个问题了，为什么要给feed的key设计过期时间？为什么是设计3~7天过期时间？</p><p>原因有以下：</p><pre><code>一、一个用户3~7天不打开APP，可能已经对APP失去兴趣了，打开几率很小，或者已经被卸载了，没有存在的意义了。二、3~7天未登陆APP，关注的人发的动态也不少了，Feed未拉取回来的数据肯定也不少，那么这时候去遍历其实拉取量很大，那么还不如直接全部重新拉一边或者拉取用户最后登陆时间后产出的数据。</code></pre><p>到这里，其实已经差不多了，大部分业务逻辑已经足够满足，并且速度也理想，目前我们线上这种模式走了半年，feed一般都是10~80ms响应完毕。</p><pre><code>&lt;?php echo &apos;求关注 求喜欢&apos;;?&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      谈谈我对feed的理解
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>swoole 安装</title>
    <link href="http://martist.cn/2018/08/10/PHP/swoole%E5%AE%89%E8%A3%85%E5%92%8C%E5%85%A5%E9%97%A8/"/>
    <id>http://martist.cn/2018/08/10/PHP/swoole安装和入门/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2018-09-05T07:10:07.524Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="swoole-安装"><a href="#swoole-安装" class="headerlink" title="swoole 安装"></a>swoole 安装</h2><h3 id="homestead命令回忆"><a href="#homestead命令回忆" class="headerlink" title="homestead命令回忆"></a>homestead命令回忆</h3><p>重新加载配置</p><pre><code>vagrant provision </code></pre><p>启动</p><pre><code>vagrant up </code></pre><p>重启</p><pre><code>vagrant reload</code></pre><h3 id="平滑重启php-fpm"><a href="#平滑重启php-fpm" class="headerlink" title="平滑重启php-fpm"></a>平滑重启php-fpm</h3><p>master进程可以理解以下信号</p><pre><code>INT, TERM 立刻终止QUIT 平滑终止USR1 重新打开日志文件USR2 平滑重载所有worker进程并重新载入配置和二进制模块</code></pre><p>查找fpm的pid</p><pre><code># ps aux|grep php-fpmroot     21891  0.0  0.0 112660   960 pts/3    R+   16:18   0:00 grep --color=auto php-fpmroot     42891  0.0  0.1 182796  1220 ?        Ss   4月18   0:19 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)nobody   42892  0.0  0.6 183000  6516 ?        S    4月18   0:07 php-fpm: pool wwwnobody   42893  0.0  0.6 183000  6508 ?        S    4月18   0:17 php-fpm: pool www</code></pre><p>平滑重启php-fpm</p><pre><code>kill -USR2 42891</code></pre><h3 id="swoole下载"><a href="#swoole下载" class="headerlink" title="swoole下载"></a>swoole下载</h3><p>下载地址<br><a href="https://github.com/swoole/swoole-src/releases" target="_blank" rel="external">https://github.com/swoole/swoole-src/releases</a></p><h3 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h3><p>下载源代码包后，在终端进入源码目录</p><pre><code>cd swoolephpize./configuremake sudo make install</code></pre><h3 id="配置php-ini"><a href="#配置php-ini" class="headerlink" title="配置php.ini"></a>配置php.ini</h3><p>编译安装成功后，修改php.ini加入</p><pre><code>extension=swoole.so</code></pre><p>homestead中有fpm的php.ini和cli的php.ini.</p><p>通过php -m或phpinfo()来查看是否成功加载了swoole，如果没有可能是php.ini的路径不对，可以使用php –ini来定位到php.ini的绝对路径。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>查看端口是否被占用 </p><pre><code>netstat -anp | grep 9051</code></pre><p>websocket是基于tcp的一种新的网络协议，实现了浏览器和服务器全双工通信。</p><p>websocket协议的特点是允许服务器主动发送信息给客户端，而http协议的通信只能有客户端发起。</p><p>在sever配置域名的地方，‘0.0.0.0’代表了本机的所有地址，</p><p>swoole和websocket的官网，都有案例，websocket的官网有很多js案例。</p><h2 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h2><p><a href="https://wiki.swoole.com" target="_blank" rel="external">https://wiki.swoole.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="swoole" scheme="http://martist.cn/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>数组合并</title>
    <link href="http://martist.cn/2018/08/06/PHP/%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6/"/>
    <id>http://martist.cn/2018/08/06/PHP/数组合并/</id>
    <published>2018-08-05T16:00:00.000Z</published>
    <updated>2018-08-06T10:56:49.383Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="array-merge"><a href="#array-merge" class="headerlink" title="array_merge()"></a>array_merge()</h2><pre><code>$a1=array(&quot;red&quot;,&quot;green&quot;);$a2=array(&quot;blue&quot;,&quot;yellow&quot;);print_r(array_merge($a1,$a2));Array ( [0] =&gt; red [1] =&gt; green [2] =&gt; blue [3] =&gt; yellow ) </code></pre><p>如果两个或更多个数组元素有相同的键名，则最后的元素会覆盖其他元素。<br>输入多个数组键名是整数，则该函数将返回带有整数键名的新数组，其键名以 0 开始进行重新索引。<br>array_merge（）与 array_merge_recursive() 函数之间的不同是在处理两个或更多个数组元素有相同的键名的情况。</p><h2 id="array-merge-recursive"><a href="#array-merge-recursive" class="headerlink" title="array_merge_recursive()"></a>array_merge_recursive()</h2><p>（1）array_merge_recursive() 不会进行键名覆盖，而是将多个相同键名的值递归组成一个数组。</p><pre><code>$a1=array(&quot;a&quot;=&gt;&quot;red&quot;,&quot;b&quot;=&gt;&quot;green&quot;);$a2=array(&quot;c&quot;=&gt;&quot;blue&quot;,&quot;b&quot;=&gt;&quot;yellow&quot;);print_r(array_merge_recursive($a1,$a2));Array ( [a] =&gt; red [b] =&gt; Array ( [0] =&gt; green [1] =&gt; yellow ) [c] =&gt; blue ) </code></pre><p>（2）输入多个数组键名是整数，则该函数将返回带有整数键名的新数组，其键名以 0 开始进行重新索引。</p><pre><code>$a1=array(&quot;2&quot;=&gt;&quot;red&quot;,&quot;9&quot;=&gt;&quot;green&quot;);$a2=array(&quot;99&quot;=&gt;&quot;blue&quot;,&quot;111&quot;=&gt;&quot;yellow&quot;);print_r(array_merge_recursive($a1,$a2));Array(    [0] =&gt; red    [1] =&gt; green    [2] =&gt; blue    [3] =&gt; yellow)</code></pre><h2 id="array-combine"><a href="#array-combine" class="headerlink" title="array_combine()"></a>array_combine()</h2><p>通过合并两个数组来创建一个新数组，其中的一个数组元素为键名，另一个数组元素为键值：</p><pre><code>$fname=array(&quot;Bill&quot;,&quot;Steve&quot;,&quot;Mark&quot;);$age=array(&quot;60&quot;,&quot;56&quot;,&quot;31&quot;);$c=array_combine($fname,$age);print_r($c);Array ( [Bill] =&gt; 60 [Steve] =&gt; 56 [Mark] =&gt; 31 ) </code></pre><h2 id="合并数组并保留键值的方法"><a href="#合并数组并保留键值的方法" class="headerlink" title="合并数组并保留键值的方法"></a>合并数组并保留键值的方法</h2><pre><code>$form_data1 = array(11=&gt;&apos;A&apos;,12=&gt;&apos;B&apos;,13=&gt;&apos;C&apos;,14=&gt;&apos;D&apos;);$form_data2 = array(25=&gt;&apos;B&apos;,26=&gt;&apos;A&apos;,27=&gt;&apos;D&apos;,28=&gt;&apos;C&apos;);$result = $form_data1 + $form_data2;print_r($result);Array(    [11] =&gt; A    [12] =&gt; B    [13] =&gt; C    [14] =&gt; D    [25] =&gt; B    [26] =&gt; A    [27] =&gt; D    [28] =&gt; C)</code></pre><p>使用 “+” 运算符合并数组，可以保留数组的键值，如果合并的数组中含有相同的键值，前面的键值对覆盖后面的键值对。<br>这里和array_merge（）相反。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>DHCP</title>
    <link href="http://martist.cn/2018/07/30/WEB/DHCP%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://martist.cn/2018/07/30/WEB/DHCP的理解/</id>
    <published>2018-07-29T16:00:00.000Z</published>
    <updated>2018-07-31T10:41:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>为了便于理解，我们把DHCP客户机比做餐馆里的客人，DHCP服务器比做服务员（一个餐馆里也可以有多个服务员），IP地址比做客户需要的食物。可以这样描述整个过程：</p><p>客人走进餐馆，问：“有没有服务员啊？”（DHCP discover），<br>多个服务员同时回答：“有，我这有鸡翅”“有，我这有汉堡”（DHCP offer）。<br>客人说：“好吧，我要一份汉堡”（DHCP request，这个客人比较死板，总是选择第一次听到的食物），<br>端着汉堡的服务员回应了一声：“来啦”（DHCP ack），并把食物端到客人面前，供其享用（将网卡和IP地址绑定）。<br>客人下次来的时候，就直接找上次那个服务员点自己喜欢的汉堡了（DHCP request），如果还有汉堡，服务员会再次确认并上菜（DHCP ack），而如果已经卖完了，服务员则会告诉客人：“不好意思，已经卖完了”（DHCP nack）。<br>当然，服务员隔一段时间会来收拾一次桌子，除非客人特别说明这菜还要继续吃的，服务员会将剩菜端走。</p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作。<br>主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h2 id="DHCP的简介"><a href="#DHCP的简介" class="headerlink" title="DHCP的简介"></a>DHCP的简介</h2><p>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）是用于对多个客户计算机集中分配IP地址以及IP地址相关的信息的协议，这样就能将IP地址和TCP/IP的设置统一管理起来，而避免不必要的地址冲突的问题，因此常常用在网络中对众多计算机的管理方面，节省了网络管理员手工设置和分配地址的麻烦。</p><p>除了能够方便管理之外，DHCP还能略微达到节省IP地址的目的。假设网络中有50个计算机，但只有40个 IP地址，但是这50台计算机不会同时启动，IP地址应该满足要求。DHCP也能用于统一设置其他的一些IP设置，如缺省路由、DNS服务器等等，使用它能减少一个大型网络的管理任务。</p><p>DHCP是从原有的BootP协议发展起来的，原来的目的是为无盘工作站分配IP地址的协议，当前更多的用于集中管理IP地址。然而DHCP协议也有其缺点，例如一台DHCP客户计算机没有一个固定的IP地址，而对于提供网络服务的服务器来讲，经常变化的IP地址并不适合。并且当前的DNS协议并不能和DHCP协作，为DHCP客户直接提供主机名解析任务。</p><p>DHCP服务优点：网络管理员可以验证IP地址和其它配置参数，而不用去检查每个主机；DHCP不会同时租借相同的IP地址给两台主机；DHCP管理员可以约束特定的计算机使用特定的IP地址；可以为每个DHCP作用域设置很多选项；客户机在不同子网间移动时不需要重新设置IP地址。</p><p>但同时也存在不少缺点：DHCP不能发现网络上非DHCP客户机已经在使用的IP地址；当网络上存在多个DHCP服务器时，一个DHCP服务器不能查出已被其它服务器租出去的IP地址；DHCP服务器不能跨路由器与客户机通信，除非路由器允许BOOTP转发。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>DHCP工作时要求客户机和服务器进行交互，由客户机通过广播向服务器发起申请IP地址的请求，然后由服务器分配一个IP地址以及其他的TCP/IP设置信息。整个过程可以分为以下步骤：</p><p>IP地址租用申请：DHCP客户机的TCP/IP首次启动时，就要执行DHCP客户程序，以进行TCP/IP 的设置。由于此时客户机的TCP/IP还没有设置完毕，就只能使用广播的方式发送DHCP请求信息包，广播包使用 UDP端口67和68进行发送，广播信息中包括了客户机的网络界面的硬件地址和计算机名字，以提供DHCP服务器进行分配。</p><p>IP地址租用提供：当接收到DHCP客户机的广播信息之后，所有的DHCP服务器均为这个客户机分配一个合适的IP地址，将这些IP地址、网络掩码、租用时间等信息，按照DHCP客户提供的硬件地址发送回DHCP客户机。这个过程中对DHCP服务器没有对客户计算机进行限制，因此客户机能收到多个IP地址提供信息。</p><p>IP地址租用选择：由于客户机接收到多个服务器发送的多个IP地址提供信息，客户机将选择一个IP地址，拒绝其他提供的IP地址，以便这些地址能分配给其他客户。客户机将向它选择的服务器发送选择租用信息。</p><p>IP地址租用确认：服务器将收到客户的选择信息，如果也没有例外发生，将回应一个确认信息，将这个IP地址真正分配给这个客户机。客户机就能使用这个IP地址及相关的TCP/IP数据，来设置自己的TCP/IP堆栈。</p><p>更新租用：DHCP中，每个IP地址是有一定租期的，若租期已到，DHCP服务器就能够将这个IP地址重新分配给其他计算机。因此每个客户计算机应该提前续租它已经租用的IP地址，服务器将回应客户机的请求并更新该客户机的租期设置。一旦服务器返回不能续租的信息，那么DHCP客户机只能在租期到达时放弃原有的IP地址，重新申请一个新 IP地址。为了避免发生问题，续租在租期达到50%时就将启动，如果没有成功将不断启动续租请求过程。</p><p>释放IP地址租用：客户机可以主动释放自己的IP地址请求，也可以不释放，但也不续租，等待租期过期而释放占用的IP地址资源。</p><p>由于DHCP依赖于广播信息，因此一般的情况下，客户机和服务器应该位于同一个网络之内。然而可以设置网络中的路由器为可以转发BootP广播包，使得服务器和客户机可以位于两个不同的网络中。然而配置转发广播信息，不是一个很好的解决办法，更好的办法为使用DHCP中转计算机，DHCP中转计算机和DHCP客户机位于同一个网络中，来回应客户机的租用请求，然而它不维护DHCP数据和拥有IP地址资源，它只是将请求通过TCP/IP转发给位于另一个网络上的DHCP服务器，进行实际的IP地址分配和确认。</p><h2 id="客户端向DHCP-服务器请求IP-地址的4-个步骤"><a href="#客户端向DHCP-服务器请求IP-地址的4-个步骤" class="headerlink" title="客户端向DHCP 服务器请求IP 地址的4 个步骤"></a>客户端向DHCP 服务器请求IP 地址的4 个步骤</h2><pre><code>发现阶段（DHCP客户端在网络中广播发送DHCP DISCOVER请求报文，发现DHCP服务器，请求IP地址租约）提供阶段（DHCP服务器通过DHCP OFFER报文向DHCP客户端提供IP地址预分配）选择阶段（DHCP客户端通过DHCP REQUEST报文确认选择第一个DHCP服务器为它提供IP地址自动分配服务）确认阶段（被选择的DHCP服务器通过DHCP ACK报文把在DHCP OFFER报文中准备的IP地址租约给对应DHCP客户端）</code></pre><h2 id="路由器dhcp可以分配多少个ip"><a href="#路由器dhcp可以分配多少个ip" class="headerlink" title="路由器dhcp可以分配多少个ip"></a>路由器dhcp可以分配多少个ip</h2><p>一个C类地址可以分配256个，其中2个不可用，一个是网关，一个是网络地址。B类地址可以分配65536个，也是两个不可用。 </p><h2 id="分配ip地址的方式"><a href="#分配ip地址的方式" class="headerlink" title="分配ip地址的方式"></a>分配ip地址的方式</h2><p>DHCP服务器具有三种IP的分配方式，手动分配，自动分配和动态分配。其中动态分配功能最为强大，配置也最为烦琐。目前的DHCP服务器一般支持全部的几种分配方式或者是其中的两种。<br>手动分配：在手动分配中，网络管理员在DHCP服务器通过手工方法配置DHCP客户机的IP地址。当DHCP客户机要求网络服务时，DHCP服务器把手工配置的IP地址传递给DHCP客户机。<br>自动分配：在自动分配中，不需要进行任何的IP地址手工分配。当DHCP客户机第一次向DHCP服务器租用到IP地址后，这个地址就永久地分配给了该DHCP客户机，而不会再分配给其他客户机。<br>动态分配：当DHCP客户机向DHCP服务器租用IP地址时，DHCP服务器只是暂时分配给客户机一个IP地址。只要租约到期，这个地址就会还给DHCP服务器，以供其他客户机使用。如果DHCP客户机仍需要一个IP地址来完成工作，则可以再要求另外一个IP地址。<br>动态分配方法是惟一能够自动重复使用IP地址的方法，它对于暂时连接到网上的DHCP客户机来说尤其方便，对于永久性与网络连接的新主机来说也是分配IP地址的好方法。DHCP客户机在不再需要时才放弃IP地址，如DHCP客户机要正常关闭时，它可以把IP地址释放给DHCP服务器，然后DHCP服务器就可以把该IP地址分配给申请IP地址的DHCP客户机。</p><h2 id="公司内所有电脑ip相同是为什么"><a href="#公司内所有电脑ip相同是为什么" class="headerlink" title="公司内所有电脑ip相同是为什么"></a>公司内所有电脑ip相同是为什么</h2><p>IP分为局域网和广域网，一般局域网内部为您路由器分配的DHCP服务。<br>公司内所有电脑ip相同是外网IP，它确实是同一个。<br>公司只开了一个上网帐号（宽带帐号），然后用路由器再分出来的，所以所有的电脑用的都是同一个公网IP，但是每台电脑上显示的IP是不一样的，应该是如192.168.1.103这样的一类局域网IP。</p><h2 id="家里的拨号上网"><a href="#家里的拨号上网" class="headerlink" title="家里的拨号上网"></a>家里的拨号上网</h2><p>家里的拨号上网的ip是独立的ip，不与其他家庭的共享。<br>和公司的进入的一个宽带信号是平级的，在家里使用的路由器发射wifi信号，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="协议" scheme="http://martist.cn/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>gitlab配置https</title>
    <link href="http://martist.cn/2018/07/20/%E8%BF%90%E7%BB%B4&amp;%E5%B7%A5%E4%BD%9C/gitlab%E7%9A%84%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/"/>
    <id>http://martist.cn/2018/07/20/运维&amp;工作/gitlab的自签名证书/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2018-07-20T10:35:10.941Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a> </p><pre><code>2018-07-20更新自签名证书生成失效了，重新生成的也不能用，改用了godaddy的新证书，才好了。</code></pre><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>$ sudo vim /etc/gitlab/gitlab.rb#13行的 http &gt;&gt; httpsexternal_url &apos;https://ip:port&apos;#修改nginx配置 810行nginx[&apos;redirect_http_to_https&apos;] =truenginx[&apos;ssl_certificate&apos;] = &quot;/etc/gitlab/ssl/server.crt&quot;nginx[&apos;ssl_certificate_key&apos;] = &quot;/etc/gitlab/ssl/server.key&quot;</code></pre><h2 id="生成秘钥与证书"><a href="#生成秘钥与证书" class="headerlink" title="生成秘钥与证书"></a>生成秘钥与证书</h2><pre><code>#秘钥脚本，将以下内容保存为shell脚本，然后运行#出现提示输入信息的地方输入信息，先输入域名然后4次证书密码，任意密码，四次保持一致。#!/bin/sh# create self-signed server certificate:read -p &quot;Enter your domain [139.199.125.93]: &quot; DOMAINecho &quot;Create server key...&quot;openssl genrsa -des3 -out $DOMAIN.key 1024echo &quot;Create server certificate signing request...&quot;SUBJECT=&quot;/C=US/ST=Mars/L=iTranswarp/O=iTranswarp/OU=iTranswarp/CN=$DOMAIN&quot;openssl req -new -subj $SUBJECT -key $DOMAIN.key -out $DOMAIN.csrecho &quot;Remove password...&quot;mv $DOMAIN.key $DOMAIN.origin.keyopenssl rsa -in $DOMAIN.origin.key -out $DOMAIN.keyecho &quot;Sign SSL certificate...&quot;openssl x509 -req -days 3650 -in $DOMAIN.csr -signkey $DOMAIN.key -out $DOMAIN.crtecho &quot;TODO:&quot;echo &quot;Copy $DOMAIN.crt to /etc/nginx/ssl/$DOMAIN.crt&quot;echo &quot;Copy $DOMAIN.key to /etc/nginx/ssl/$DOMAIN.key&quot;echo &quot;Add configuration in nginx:&quot;echo &quot;server {&quot;echo &quot;    ...&quot;echo &quot;    listen 443 ssl;&quot;echo &quot;    ssl_certificate     /etc/nginx/ssl/$DOMAIN.crt;&quot;echo &quot;    ssl_certificate_key /etc/nginx/ssl/$DOMAIN.key;&quot;echo &quot;}&quot;</code></pre><h2 id="执行成功后生成文件如下"><a href="#执行成功后生成文件如下" class="headerlink" title="执行成功后生成文件如下"></a>执行成功后生成文件如下</h2><pre><code>$ ls139.199.125.93.crt  139.199.125.93.origin.key             nginx-1.7.12   vim-7.3.tar.bz2139.199.125.93.csr  apache-tomcat-8.5.28.tar.gz           ssl_genKey.sh  vimcdoc-1.8.0139.199.125.93.key  gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm  vim73          vimcdoc-1.8.0.tar.gz</code></pre><h2 id="移动到相应的位置"><a href="#移动到相应的位置" class="headerlink" title="移动到相应的位置"></a>移动到相应的位置</h2><pre><code>sudo mkdir -p /etc/gitlab/sslsudo chmod 700 /etc/gitlab/ssl/ -Rsu cp 139.199.125.93.crt /etc/gitlab/ssl/server.crtsudo cp 139.199.125.93.key /etc/gitlab/ssl/server.key</code></pre><h2 id="重建配置"><a href="#重建配置" class="headerlink" title="重建配置"></a>重建配置</h2><pre><code>sudo gitlab-ctl reconfigure</code></pre><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><pre><code>sudo gitlab-ctl restart</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/4111534b339f" target="_blank" rel="external">https://www.jianshu.com/p/4111534b339f</a><br><a href="https://www.cnblogs.com/xieshuang/p/8488458.html" target="_blank" rel="external">https://www.cnblogs.com/xieshuang/p/8488458.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="git" scheme="http://martist.cn/categories/git/"/>
    
    
      <category term="git" scheme="http://martist.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>PHP 代码简洁之道 （ PHP Clean Code）</title>
    <link href="http://martist.cn/2018/07/06/PHP/php%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    <id>http://martist.cn/2018/07/06/PHP/php代码简洁之道/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-07-08T10:50:30.588Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>附地址：<br><a href="https://blog.csdn.net/zhu_lizhen/article/details/79267432#t5" target="_blank" rel="external">https://blog.csdn.net/zhu_lizhen/article/details/79267432#t5</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="常识" scheme="http://martist.cn/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
</feed>
