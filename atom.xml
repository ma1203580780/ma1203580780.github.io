<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码仔一个人的地方</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://martist.cn/"/>
  <updated>2020-05-13T06:40:23.000Z</updated>
  <id>http://martist.cn/</id>
  
  <author>
    <name>马闯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lvs，nginx和keepalived的区别和关系</title>
    <link href="http://martist.cn/2020/05/02/2020%E6%96%87%E7%AB%A0/lvs%EF%BC%8Cnginx%E5%92%8Ckeepalive%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B3%E7%B3%BB/"/>
    <id>http://martist.cn/2020/05/02/2020文章/lvs，nginx和keepalive的区别和关系/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2020-05-13T06:40:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h2><p>keepalived是一个类似于layer3, 4 &amp; 5交换机制的软件，也就是我们平时说的第3层、第4层和第5层交换。Keepalived是自动完成，不需人工干涉。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>自动完成，不需人工干涉</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Keepalived的作用是检测服务器的状态，如果有一台web服务器宕机，或工作出现故障，Keepalived将检测到，并将有故障的服务器从系统中剔除，同时使用其他服务器代替该服务器的工作，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Layer3,4,5工作在IP/TCP协议栈的IP层，TCP层，及应用层,原理分别如下：</p><p>Layer3：Keepalived使用Layer3的方式工作式时，Keepalived会定期向服务器群中的服务器发送一个ICMP的数据包（既我们平时用的Ping程序）,如果发现某台服务的IP地址没有激活，Keepalived便报告这台服务器失效，并将它从服务器群中剔除，这种情况的典型例子是某台服务器被非法关机。Layer3的方式是以服务器的IP地址是否有效作为服务器工作正常与否的标准。</p><p>Layer4:如果您理解了Layer3的方式，Layer4就容易了。Layer4主要以TCP端口的状态来决定服务器工作正常与否。如web server的服务端口一般是80，如果Keepalived检测到80端口没有启动，则Keepalived将把这台服务器从服务器群中剔除。</p><p>Layer5：Layer5对指定的URL执行HTTP GET。然后使用MD5算法对HTTP GET结果进行求和。如果这个总数与预期值不符，那么测试是错误的，服务器将从服务器池中移除。该模块对同一服务实施多URL获取检查。如果您使用承载多个应用程序服务器的服务器，则此功能很有用。此功能使您能够检查应用程序服务器是否正常工作。MD5摘要是使用genhash实用程序（包含在keepalived软件包中）生成的。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>Keepalived软件起初是专为LVS负载均衡软件设计的，用来管理并监控LVS集群系统中各个服务节点的状态，后来又加入了可以实现高可用的VRRP功能。因此，Keepalived除了能够管理LVS软件外，还可以作为其他服务（例如：Nginx、Haproxy、MySQL等）的高可用解决方案软件。</p><p>Keepalived软件主要是通过VRRP协议实现高可用功能的。VRRP是Virtual Router RedundancyProtocol(虚拟路由器冗余协议）的缩写，VRRP出现的目的就是为了解决静态路由单点故障问题的，它能够保证当个别节点宕机时，整个网络可以不间断地运行。</p><p>所以，Keepalived 一方面具有配置管理LVS的功能，同时还具有对LVS下面节点进行健康检查的功能，另一方面也可实现系统网络服务的高可用功能。</p><h3 id="keepalived官网"><a href="#keepalived官网" class="headerlink" title="keepalived官网"></a>keepalived官网</h3><p><a href="http://www.keepalived.org" target="_blank" rel="external">http://www.keepalived.org</a></p><h2 id="lvs"><a href="#lvs" class="headerlink" title="lvs"></a>lvs</h2><h3 id="负载均衡的类型"><a href="#负载均衡的类型" class="headerlink" title="负载均衡的类型"></a>负载均衡的类型</h3><p>负载均衡可以采用硬件设备（例如常常听见的 F5），也可以采用软件负载<br>商用硬件负载设备成本通常较高（一台几十万甚至上百万），所以一般 情况下会采用软件负载<br>软件负载解决的两个核心问题是：选谁、转发，其中最著名的是 lvs </p><h3 id="lvs-是什么？"><a href="#lvs-是什么？" class="headerlink" title="lvs 是什么？"></a>lvs 是什么？</h3><p>英文全称是 Linux Virtual Server，即 Linux 虚拟服务器<br>由 章 文 嵩 博 士 发 起 的 自 由 软 件 项 目 ， 它 的 官 方 站 点 是 www.linuxvirtualserver.org<br>Linux2.4 内核以后，LVS 已经是 Linux 标准内核的一部分<br>可以将请求分发给后端真实服务器处理<br>有许多比较著名网站和组织都在使用 LVS 架设的集群系统，例如：Linux 的门户网站（www.linux.com）、向 RealPlayer 提供音频视频服务而闻 名的 Real 公司（www.real.com ）、全球最大的开源网站 （sourceforge.net）等。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>1.轮询调度</p><p>轮询调度（Round Robin 简称’RR’）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。</p><p>2.加权轮询调度</p><p>加权轮询（Weight Round Robin 简称’WRR’）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。</p><p>3.最小连接调度</p><p>最小连接调度（Least Connections 简称’LC’）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。</p><p>（集群系统的真实服务器具有相近的系统性能，采用最小连接调度算法可以比较好地均衡负载。)</p><p>4.加权最小连接调度</p><p>加权最少连接（Weight Least Connections 简称’WLC’）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><p>5.基于局部的最少连接</p><p>基于局部的最少连接调度（Locality-Based Least Connections 简称’LBLC’）算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用’最少连接’的原则选出一个可用的服务器，将请求发送到服务器。</p><p>6.带复制的基于局部性的最少连接</p><p>带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication  简称’LBLCR’）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按’最小连接’原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按’最小连接’原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p><p>7.目标地址散列调度</p><p>目标地址散列调度（Destination Hashing 简称’DH’）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</p><p>8.源地址散列调度U</p><p>源地址散列调度（Source Hashing  简称’SH’）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。</p><p>9.最短的期望的延迟</p><p>最短的期望的延迟调度（Shortest Expected Delay 简称’SED’）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算</p><p>A：（1+1）/1=2   B：（1+2）/2=3/2   C：（1+3）/3=4/3   就把请求交给得出运算结果最小的服务器。</p><p>10.最少队列调度</p><p>最少队列调度（Never Queue 简称’NQ’）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。</p><h3 id="三种转发规则"><a href="#三种转发规则" class="headerlink" title="三种转发规则"></a>三种转发规则</h3><p>NAT：简单理解，就是数据进出都通过 LVS，性能不是很好。<br>TUNL：简单理解：隧道 。<br>DR:最高效的负载均衡规则 。</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>NAT（Network Address Translation）即网络地址转换，其作用是通过数据报头的修改，使得位于企业内部的私有IP地址可以访问外网，以及外部用用户可以访问位于公司内部的私有IP主机。VS/NAT工作模式拓扑结构如图2所示，LVS负载调度器可以使用两块网卡配置不同的IP地址，eth0设置为私钥IP与内部网络通过交换设备相互连接，eth1设备为外网IP与外部网络联通。</p><p>第一步，用户通过互联网DNS服务器解析到公司负载均衡设备上面的外网地址，相对于真实服务器而言，LVS外网IP又称VIP（Virtual IP Address），用户通过访问VIP，即可连接后端的真实服务器（Real Server），而这一切对用户而言都是透明的，用户以为自己访问的就是真实服务器，但他并不知道自己访问的VIP仅仅是一个调度器，也不清楚后端的真实服务器到底在哪里、有多少真实服务器。</p><p>第二步，用户将请求发送至124.126.147.168，此时LVS将根据预设的算法选择后端的一台真实服务器（192.168.0.1~192.168.0.3），将数据请求包转发给真实服务器，并且在转发之前LVS会修改数据包中的目标地址以及目标端口，目标地址与目标端口将被修改为选出的真实服务器IP地址以及相应的端口。</p><p>第三步，真实的服务器将响应数据包返回给LVS调度器，调度器在得到响应的数据包后会将源地址和源端口修改为VIP及调度器相应的端口，修改完成后，由调度器将响应数据包发送回终端用户，另外，由于LVS调度器有一个连接Hash表，该表中会记录连接请求及转发信息，当同一个连接的下一个数据包发送给调度器时，从该Hash表中可以直接找到之前的连接记录，并根据记录信息选出相同的真实服务器及端口信息。</p><h4 id="TUN"><a href="#TUN" class="headerlink" title="TUN"></a>TUN</h4><p>在LVS（NAT）模式的集群环境中，由于所有的数据请求及响应的数据包都需要经过LVS调度器转发，如果后端服务器的数量大于10台，则调度器就会成为整个集群环境的瓶颈。我们知道，数据请求包往往远小于响应数据包的大小。因为响应数据包中包含有客户需要的具体数据，所以LVS（TUN）的思路就是将请求与响应数据分离，让调度器仅处理数据请求，而让真实服务器响应数据包直接返回给客户端。VS/TUN工作模式拓扑结构如图3所示。其中，IP隧道（IP tunning）是一种数据包封装技术，它可以将原始数据包封装并添加新的包头（内容包括新的源地址及端口、目标地址及端口），从而实现将一个目标为调度器的VIP地址的数据包封装，通过隧道转发给后端的真实服务器（Real Server），通过将客户端发往调度器的原始数据包封装，并在其基础上添加新的数据包头（修改目标地址为调度器选择出来的真实服务器的IP地址及对应端口），LVS（TUN）模式要求真实服务器可以直接与外部网络连接，真实服务器在收到请求数据包后直接给客户端主机响应数据。</p><h4 id="DR"><a href="#DR" class="headerlink" title="DR"></a>DR</h4><p>在LVS（TUN）模式下，由于需要在LVS调度器与真实服务器之间创建隧道连接，这同样会增加服务器的负担。与LVS（TUN）类似，DR模式也叫直接路由模式，其体系结构如图4所示，该模式中LVS依然仅承担数据的入站请求以及根据算法选出合理的真实服务器，最终由后端真实服务器负责将响应数据包发送返回给客户端。与隧道模式不同的是，直接路由模式（DR模式）要求调度器与后端服务器必须在同一个局域网内，VIP地址需要在调度器与后端所有的服务器间共享，因为最终的真实服务器给客户端回应数据包时需要设置源IP为VIP地址，目标IP为客户端IP，这样客户端访问的是调度器的VIP地址，回应的源地址也依然是该VIP地址（真实服务器上的VIP），客户端是感觉不到后端服务器存在的。由于多台计算机都设置了同样一个VIP地址，所以在直接路由模式中要求调度器的VIP地址是对外可见的，客户端需要将请求数据包发送到调度器主机，而所有的真实服务器的VIP地址必须配置在Non-ARP的网络设备上，也就是该网络设备并不会向外广播自己的MAC及对应的IP地址，真实服务器的VIP对外界是不可见的，但真实服务器却可以接受目标地址VIP的网络请求，并在回应数据包时将源地址设置为该VIP地址。调度器根据算法在选出真实服务器后，在不修改数据报文的情况下，将数据帧的MAC地址修改为选出的真实服务器的MAC地址，通过交换机将该数据帧发给真实服务器。整个过程中，真实服务器的VIP不需要对外界可见。</p><h3 id="lvs-的体系结构"><a href="#lvs-的体系结构" class="headerlink" title="lvs 的体系结构"></a>lvs 的体系结构</h3><p>最前端的负载均衡层，用 Load Balancer 表示<br>中间的服务器集群层，用 Server Array 表示<br>最底端的数据共享存储层，用 Shared Storage 表示<br>在用户看来，所有的内部应用都是透明的，用户只是在使用一个虚拟服 务器提供的高性能服务 </p><h3 id="和keepAlived-组合使用"><a href="#和keepAlived-组合使用" class="headerlink" title="和keepAlived 组合使用"></a>和keepAlived 组合使用</h3><p>因为所有的请求都要经过负载均衡，所以负载均衡必然是非常重要，不 能挂掉，说白了就是要 keep the lvs alived。<br>提供的功能就是可以配置 2 台 LVS，一台主机，一台备机。并且检测任 何一个节点是否还活着。 </p><h3 id="lvs-的优点"><a href="#lvs-的优点" class="headerlink" title="lvs 的优点"></a>lvs 的优点</h3><p>抗负载能力强，因为 lvs 工作方式的逻辑是非常之简单，而且工作在网络 4 层仅做请求分发之用，没有流量，所以在效率上基本不需要太过考虑。<br>有完整的双机热备方案，当节点出现故障时，lvs 会自动判别，所以系统整体是非常稳定的。<br>基本上能支持所有应用，因为 lvs 工作在 4 层，所以它可以对几乎所有应用做负载均衡，包括 http、数据库、聊天室等等。 </p><h3 id="lvs-负载均衡机制"><a href="#lvs-负载均衡机制" class="headerlink" title="lvs 负载均衡机制"></a>lvs 负载均衡机制</h3><p>lvs 是四层负载均衡，也就是说建立在 OSI 模型的第四层——传输层之 上<br>传输层上有 TCP/UDP，lvs 支持 TCP/UDP 的负载均衡<br>因为 LVS 是四层负载均衡，因此它相对于其它高层负载均衡的解决办法， 比如 DNS 域名轮流解析、应用层负载的调度、客户端的调度等，它的效 率是非常高的<br>lvs 的转发可以通过修改 IP 地址实现（NAT 模式）<br>lvs 的转发还可以通过修改直接路由实现（DR 模式） </p><h3 id="lvs-keepAlived-的应用场景"><a href="#lvs-keepAlived-的应用场景" class="headerlink" title="lvs+keepAlived 的应用场景"></a>lvs+keepAlived 的应用场景</h3><p>大型网站负载均衡。</p><h3 id="lvs-与-nginx-对比（简单）"><a href="#lvs-与-nginx-对比（简单）" class="headerlink" title="lvs 与 nginx 对比（简单）"></a>lvs 与 nginx 对比（简单）</h3><p>负载度：    lvs 优于 nginx<br>稳定度：    lvs 优于 nginx<br>服务器性能要求： lvs 优于 nginx<br>网络层数的效率： lvs 优于 nginx（网络七层：应用层、会话层、表示层、传输层、网络层、链路层、 物理层）<br>功能多少 ：  nginx 优于 lvs </p><h3 id="lvs与nginx区别（深度）"><a href="#lvs与nginx区别（深度）" class="headerlink" title="lvs与nginx区别（深度）"></a>lvs与nginx区别（深度）</h3><p>lvs和nginx都可以用作多机负载方案，他们各有优缺点，在生产环境中需要好好分析实际情况并加以利用。</p><h4 id="一、lvs的优势"><a href="#一、lvs的优势" class="headerlink" title="一、lvs的优势"></a>一、lvs的优势</h4><p>1.抗负载能力强，因为lvs工作方式的逻辑是非常简单的，而且工作再网络层第4层，仅作请求分发用，没有流量，所以在效率上基本不需要太过考虑。lvs一般很少出现故障，即使出现故障一般也是其他地方（如内存、CPU等）出现问题导致lvs出现问题。</p><p>2.配置性地，这通常是一大劣势同时也是一大优势，因为没有太多的可配置的选项，所以除了增减服务器，并不需要经常去触碰它，大大减少了人为出错的几率。</p><p>3.工作稳定，因为其本省抗负载能力很强，所以稳定性高也是顺理成章的事，另外各种lvs都有完整的双机热备方案，所以一点不用担心均衡器本身会出什么问题，节点出现故障的话，lvs会自动判别，所以系统整体式非常稳定的。</p><p>4.无流量，lvs仅仅分发请求，而流量并不从它本身出去，所以可以利用它这点来做一些线路分流之用。没有流量同时也保住了均衡器的IO性能不会受到大流量的影响。</p><p>5.lvs基本上能支持所有应用，因为绿色工作在第4层，所以它可以对几乎所有应用做负载均衡，包括http、数据库、聊天室等。</p><p>另外：lvs也不是完全能判别节点故障的，比如在wlc分配方式下，集群里有一个节点没有配置vip，会使整个集群不能使用，这时使用wrr分配方式则会丢掉一台机器。目前这个问题还在进一步测试中。所以用lvs也得多多当心为妙。</p><h4 id="二、nginx和lvs作对比的结果"><a href="#二、nginx和lvs作对比的结果" class="headerlink" title="二、nginx和lvs作对比的结果"></a>二、nginx和lvs作对比的结果</h4><p>1.nginx工作在网络的第7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下lvs并不具备这样的功能，所以nginx单凭这点可以利用的场合就远多于lvs了；但nginx有用的这些功能使其可调整度要高于lvs，所以经常要去触碰触碰，由lvs的第2条优点来看，触碰多了，人为出现问题的几率也就会大。</p><p>2.nginx对网络的依赖较小，理论上只要ping得通，网页访问正常，nginx就能连得通，nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；lvs就比较依赖于网络环境，目前来看服务器在同一网段内并且lvs使用direct方式分流，效果较能得到保证。另外注意，lvs需要向托管商至少申请多于一个ip来做visual ip，貌似是不能用本省的ip来做VIP的。要做好lvs管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个http那么简单了。</p><p>3.nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。lvs的安装和配置、测试就要花比较长的时间，因为同上所述，lvs对网络依赖性比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦的多。</p><p>4.nginx也同样能承受很高负载且稳定，但负载度很稳定度差lvs还有几个等级：nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的；nginx没有现成的双机热备方案，所以跑在单机上还是风险比较大，单机上的事情全都很难说。</p><p>5.nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前lvs中ldirectd也能支持针对服务器内部的情况来监控，但lvs的原理使其不能重发请求。重发请求这点，比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，nginx会把上传切到另一台服务器重新处理，而lvs就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。</p><p>6.nginx对请求的异步处理可以帮助节点服务器减轻负载，键入使用Apache直接对外服务，那么出现很多的窄带链接时Apache服务器将会占用大量内存而不能释放，使用多于一个nginx做Apache代理的话，这些窄带链接会被nginx挡住，Apache上就不会堆积过多的请求，这样就减少了相当多的内存占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对Apache还是有很大帮助你的。lvs没有这些功能，也就无法能比较。</p><p>7.nginx能支持http和Email（Email的功能估计比较少人用），lvs所支持的应用在这点上会比nginx更过。</p><p>在使用上，一般最前端所采取的的策略应是lvs，也就是dns的指向应为lvs均衡器，lvs的优点另它非常适合做这个任务。</p><p>重要的ip地址，最好交由lvs托管，比如数据库的ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而来。所以将这些重要ip交给lvs托管式最为稳妥的，这样做的唯一缺点是需要VIP数量会比较多。</p><p>nginx可以作为lvs节点机器使用，一是可以利用nginx的功能，二是可以利用nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比nginx弱不少，性能上也有所逊色于nginx。</p><p>nginx也可以作为中层代理使用，这一层面nginx基本上无对手，唯一可以撼动nginx的就只有lighttpd了，不过lighttpd目前还没有能做到nginx完全的功能，配置也不那么清晰易读。另外，中层代理的ip也是重要的，所以中层代理业拥有一个VIP和lvs是最完美的方案了。</p><p>nginx也可以作为网页静态服务器。</p><p>具体的应用还得具体分析，如果是比较小的网站（日pv&lt;1000万），用nginx就完全可以了，如果机器也不少，可以用dns轮询，lvs所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候要多多考虑利用lvs。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>使用nginx+keepalived实现负载均衡，解决单点与高流量并发问题。为什么要用nginx而不用lvs？</p><p>7个理由：</p><p>1.高并发连接：官方测试能够支撑5万并发连接，在实际生产环境中跑到2——3万并发连接数。</p><p>2.内存消耗少：在3万并发连接数下，开启的10个nginx进程才消耗150M内存（150*10=150M）。</p><p>3.配置文件非常简单：风格跟程序一样通俗易懂。</p><p>4.成本低廉：nginx为开源软件，可以免费使用。而购买F5 big-ip、netscaler等硬件负载均衡交换机则需要十多万至几十万人民币。</p><p>（使用nginx做七层负载均衡的理由？）</p><p>5.支持rewrite重写规则：能够根据域名、url的不同，将http请求分到不同的后端服务器群组。</p><p>6.内置的健康检查功能：如果nginx proxy后端的某台web服务器宕机了，不会影响前端访问。</p><p>7.节省带宽：支持gzip压缩，可以添加浏览器本地缓存的header头。</p><h4 id="进一步说明"><a href="#进一步说明" class="headerlink" title="进一步说明"></a>进一步说明</h4><p>keepalived是linux下面实现vrrp备份路由的高可靠性运行件。基于keepalived设计的服务模式能够真正做到主服务器和备份服务器故障时ip瞬间无缝交接。</p><p>nginx是基于linux2.6内核中epoll模型http服务器，与Apache进程派生模式不同的是nginx进程基于master+slave多进程模型，自身具有非常稳定的子进程管理功能。在master进程分配模式下，master进程永远不进行业务处理，只是进行任务分发，从而达到master进程的存活高可靠性，slave进程所有的业务信号都由主进程发出，slave进城所有的超时任务都会被master终止，属于阻塞式人物模型。</p><p>服务器ip存活检测是由keepalived自己本身完成的，将2台服务器配置成keepalived互为主辅关系，任意一方机器故障对方都能够将ip接管过去。</p><p>keepalived的服务器ip通过其配置文件进行管理，依靠其自身的进程去确定服务器的存活状态，如果在需要对服务器进程在线维护的情况下，只需要停掉被维护机器的keepalived服务进程，另外一台服务器就能够接管该台服务器的所有应用。</p><h4 id="现实意义"><a href="#现实意义" class="headerlink" title="现实意义"></a>现实意义</h4><p>nginx实现了web服务器的高可用，如果流量入口的nginx服务器挂了，那么就web服务不可用了。<br>所以在nginx做负载均衡之前，用lvs做osi网络协议的四层负载均衡，实现nginx的高可用。lvs主要解决的是这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="nginx" scheme="http://martist.cn/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
      <category term="lvs" scheme="http://martist.cn/tags/lvs/"/>
    
      <category term="keepalive" scheme="http://martist.cn/tags/keepalive/"/>
    
  </entry>
  
  <entry>
    <title>PHP高性能缓存扩展-APCu</title>
    <link href="http://martist.cn/2020/05/01/2020%E6%96%87%E7%AB%A0/PHP%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%89%A9%E5%B1%95-APCu/"/>
    <id>http://martist.cn/2020/05/01/2020文章/PHP高性能缓存扩展-APCu/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2020-05-09T04:09:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>众所周知高性能的缓存组件有Redis和Memcached.</p><p>Redis每秒可以处理上万请求. 适合作为缓存一些热点数据. 根据二八定律 我们可以将Mysql中20%的热点数据存入Redis.</p><p>Redis存入的数据也按照二八定律,其中20%的热点中的热点数据我们可以存入程序内.当然PHP不是很好实现.好在有Swoole这种优秀的扩展出现,<br>但是今天的主角不是它.</p><p>下面让我隆重介绍下今天的主角 - APCu</p><p>扩展下载地址: </p><pre><code>http://pecl.php.net/package/APCu</code></pre><p>在PHP5版本用的是APC,PHP7之后就是APCU.它俩是同一东西.在php.ini的配置项中都以apc开头.</p><p>不过只支持FastCGI模式.PHP-CLI下会失效.需要注意!</p><p>它和Memcached很相似.只能存入key-value类型.</p><pre><code>apcu_add(&apos;key&apos;, &apos;value&apos;); // 添加数据apcu_fetch(&apos;key&apos;); // 读取数据</code></pre><p>还有很多命令,我们今天只以这两条为主.</p><p>更详细的介绍和配置可以访问官网:</p><pre><code>https://www.php.net/manual/zh/apcu.configuration.php</code></pre><p>它的缓存生命周期是整个PHP-FPM.当重启PHP-FPM时候才会清空.也就是说可以在同一PHP-FPM环境下跨文件和跨项目的使用它.</p><p>Redis在传输数据会使用网络模型.大大增加的时间.而这也是真正高并发业务的瓶颈之一.下面我们来测试下APCu和Redis的性能差</p><p>测试的服务器: 阿里云2核4G</p><p>PHP版本: 7.2.25</p><p>首先先编写一个写入数据的程序,记得在浏览器下访问一下.</p><pre><code>// 文件名: set_data.php&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;127.0.0.1&apos;, 6379);// 写入redis数据var_dump($redis-&gt;set(&apos;a&apos;, &apos;1&apos;));// 写入apcu数据var_dump(apcu_add(&apos;aa&apos;, &apos;1&apos;));?&gt;</code></pre><p>接着编写Redis测试文件</p><pre><code>&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;127.0.0.1&apos;, 6379);$start = microtime(true);for($i=0;$i&lt;100000;$i++) {    $redis-&gt;get(&apos;a&apos;);}$end = microtime(true) - $start;var_dump($end, &quot;内容是:{$redis-&gt;get(&apos;a&apos;)}&quot;);?&gt;</code></pre><p>进行10万次get操作. 结果: float(8.415806055069) string(11) “内容是:1”</p><p>下面来测试下APCu</p><pre><code>&lt;?php$start = microtime(true);for ($i=0;$i&lt;100000;$i++) {    apcu_fetch(&apos;aa&apos;);}$end = microtime(true) - $start;var_dump($end, &quot;内容是: &quot;. apcu_fetch(&apos;aa&apos;))?&gt;</code></pre><p>同样10万次get操作.结果: </p><pre><code>float(0.01537013053894) string(12) &quot;内容是: 1&quot;</code></pre><p>相差500多倍! OMG!剩下的大家都懂啦~至于如何更好的使用还得靠自己.我这里只是抛砖引玉~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>帮助 phper 理解 RPC 是怎么回事儿</title>
    <link href="http://martist.cn/2020/04/23/2020%E6%96%87%E7%AB%A0/%E5%B8%AE%E5%8A%A9%20phper%20%E7%90%86%E8%A7%A3%20RPC%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%E5%84%BF/"/>
    <id>http://martist.cn/2020/04/23/2020文章/帮助 phper 理解 RPC 是怎么回事儿/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-05-09T04:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="1-什么是rpc"><a href="#1-什么是rpc" class="headerlink" title="1.什么是rpc"></a>1.什么是rpc</h2><p>RPC全称为Remote Procedure Call，翻译过来为“远程过程调用”。</p><p>目前，主流的平台中都支持各种远程调用技术，以满足分布式系统架构中不同的系统之间的远程通信和相互调用。远程调用的应用场景极其广泛，实现的方式也各式各样。</p><h2 id="2-从通信协议的层面"><a href="#2-从通信协议的层面" class="headerlink" title="2.从通信协议的层面"></a>2.从通信协议的层面</h2><p>基于HTTP协议的（例如基于文本的SOAP（XML）、Rest（JSON），基于二进制Hessian（Binary））</p><p>基于TCP协议的（通常会借助Mina、Netty等高性能网络框架）</p><h1 id="RPC-远程过程调用-是什么"><a href="#RPC-远程过程调用-是什么" class="headerlink" title="RPC(远程过程调用)是什么"></a>RPC(远程过程调用)是什么</h1><ul><li><p>简单的说，RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</p></li><li><p>RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）</p></li><li><p>RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）</p></li><li><p>RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。</p></li></ul><h2 id="远程过程调用发展历程"><a href="#远程过程调用发展历程" class="headerlink" title="远程过程调用发展历程"></a>远程过程调用发展历程</h2><ul><li><p>ONC RPC （开放网络计算的远程过程调用），OSF RPC（开放软件基金会的远程过程调用）</p></li><li><p>CORBA（Common Object Request Broker Architecture公共对象请求代理体系结构）</p></li><li><p>DCOM（分布式组件对象模型），COM+</p></li><li><p>Java RMI</p></li><li><p>.NET Remoting</p></li><li><p>XML-RPC，SOAP，Web Service</p></li><li><p>PHPRPC，Hessian，JSON-RPC</p></li><li><p>Microsoft WCF，WebAPI</p></li><li><p>ZeroC Ice，Thrift，GRPC</p></li><li><p>Hprose</p></li></ul><h2 id="早期的-RPC"><a href="#早期的-RPC" class="headerlink" title="早期的 RPC"></a>早期的 RPC</h2><ul><li><p>第一代 RPC（ONC RPC，OSF RPC）不支持对象的传递。</p></li><li><p>CORBA 太复杂，各种不同实现不兼容，一般程序员也玩不转。</p></li><li><p>DCOM，COM+ 逃不出 Windows 的手掌心。</p></li><li><p>RMI 只能在 Java 里面玩。</p></li><li><p>.NET Remoting 只能在 .NET 平台上玩。</p></li></ul><h2 id="XML-RPC，SOAP，WebService"><a href="#XML-RPC，SOAP，WebService" class="headerlink" title="XML-RPC，SOAP，WebService"></a>XML-RPC，SOAP，WebService</h2><ul><li><p>冗余数据太多，处理速度太慢。</p></li><li><p>RPC 风格的 Web Service 跨语言性不佳，而 Document 风格的 Web Service 又太过难用。</p></li><li><p>Web Service 没有解决用户的真正问题，只是把一个问题变成了另一个问题。</p></li><li><p>Web Service 的规范太过复杂，以至于在 .NET 和 Java 平台以外没有真正好用的实现，甚至没有可用的实现。</p></li><li><p>跨语言跨平台只是 Web Service 的一个口号，虽然很多人迷信这一点，但事实上它并没有真正实现。</p></li></ul><h2 id="PHPRPC"><a href="#PHPRPC" class="headerlink" title="PHPRPC"></a>PHPRPC</h2><ul><li><p>基于 PHP 内置的序列化格式，在跨语言的类型映射上存在硬伤。</p></li><li><p>通讯上依赖于 HTTP 协议，没有其它底层通讯方式的选择。</p></li><li><p>内置的加密传输既是特点，也是缺点。</p></li><li><p>虽然比基于 XML 的 RPC 速度快，但还不是足够快。</p></li></ul><h2 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h2><ul><li><p>二进制的数据格式完全不具有可读性。</p></li><li><p>官方只提供了两个半语言的实现（Java，ActionScript 和不怎么完美的 Python 实现），其它语言的第三方实现良莠不齐。</p></li><li><p>支持的语言不够多，对 Web 前端的 JavaScript 完全无视。</p></li><li><p>虽然是动态 RPC，但动态性仍然欠佳。</p></li><li><p>虽然比基于 XML 的 RPC 速度快，但还不是足够快。</p></li></ul><h2 id="JSON-RPC"><a href="#JSON-RPC" class="headerlink" title="JSON-RPC"></a>JSON-RPC</h2><ul><li><p>JSON 具有文本可读性，且比 XML 更简洁。</p></li><li><p>JSON 受 JavaScript 语言子集的限制，可表示的数据类型不够多。</p></li><li><p>JSON 格式无法表示数据内的自引用，互引用和循环引用。</p></li><li><p>某些语言具有多种版本的实现，但在类型影射上没有统一标准，存在兼容性问题。</p></li><li><p>JSON-RPC 虽然有规范，但是却没有统一的实现。在不同语言中的各自实现存在兼容性问题，无法真正互通。</p></li></ul><h2 id="Microsoft-WCF，WebAPI"><a href="#Microsoft-WCF，WebAPI" class="headerlink" title="Microsoft WCF，WebAPI"></a>Microsoft WCF，WebAPI</h2><ul><li><p>它们是微软对已有技术的一个 .NET 平台上的统一封装，是对 .NET Remoting、WebService 和基于 JSON 、XML 等数据格式的 REST 风格的服务等技术的一个整合。</p></li><li><p>虽然号称可以在 .NET 平台以外来调用它的这些服务，但实际上跟在 .NET 平台内调用完全是两码事。它没有提供任何在其他平台的语言中可以使用的任何工具。</p></li></ul><h2 id="ZeroC-Ice，Thrift，GRPC"><a href="#ZeroC-Ice，Thrift，GRPC" class="headerlink" title="ZeroC Ice，Thrift，GRPC"></a>ZeroC Ice，Thrift，GRPC</h2><ul><li><p>初代 RPC 技术的跨语言面向对象的回归。</p></li><li><p>仍然需要通过中间语言来编写类型和接口定义。</p></li><li><p>仍然需要用代码生成器来将中间语言编写的类型和接口定义翻译成你所使用的编程语言的客户端和服务器端的占位程序（stub）。</p></li><li><p>你必须要基于生成的服务器代码来单独编写服务，而不能将已有代码直接作为服务发布。</p></li><li><p>你必须要用生成的客户端代码来调用服务，而没有其它更灵活的方式。</p></li><li><p>如果你的中间代码做了修改，以上所有步骤你都要至少重复一遍。</p></li></ul><h2 id="Hprose"><a href="#Hprose" class="headerlink" title="Hprose"></a>Hprose</h2><ul><li><p>无侵入式设计，不需要单独定义类型，不需要单独编写服务，已有代码可以直接发布为服务。</p></li><li><p>具有丰富的数据类型和完美的跨语言类型映射，支持自引用，互引用和循环引用数据。</p></li><li><p>支持众多传输方式，如 HTTP、TCP、Websocket 等。</p></li><li><p>客户端具有更灵活的调用方式，支持同步调用，异步调用，动态参数，可变参数，引用参数传递，多结果返回（Golang）等语言特征，Hprose 2.0 甚至支持推送。</p></li><li><p>具有良好的可扩展性，可以通过过滤器和中间件实现加密、压缩、缓存、代理等各种功能性扩展。</p></li><li><p>兼容的无差别跨语言调用</p></li><li><p>支持更多的常用语言和平台</p></li><li><p>支持浏览器端的跨域调用</p></li><li><p>没有中间语言，无需学习成本</p></li><li><p>性能卓越，使用简单</p></li></ul><h2 id="RPC与Socket有什么区别？"><a href="#RPC与Socket有什么区别？" class="headerlink" title="RPC与Socket有什么区别？"></a>RPC与Socket有什么区别？</h2><p>两者都是调用远程的方法，都是client/server模式。</p><p>RPC（远程过程调用）采用客户机/服务器模式实现两个进程之间相互通信。socket是RPC经常采用的通信手段之一，RPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。除了Socket，RPC还有其他的通信方法，比如：http、操作系统自带的管道等技术来实现对于远程程序的调用。微软的Windows系统中，RPC就是采用命名管道进行通信。</p><h2 id="RPC与REST有什么区别？"><a href="#RPC与REST有什么区别？" class="headerlink" title="RPC与REST有什么区别？"></a>RPC与REST有什么区别？</h2><p>通过了解RPC后，我们知道是RPC是client/server模式的，调用远程的方法，REST也是我们熟悉的一套API调用协议方法，它也是基于client/server模式的，调用远程的方法的，那他俩又有啥区别呢？</p><p>REST API 和 RPC 都是在 Server端 把一个个函数封装成接口暴露出去，以供 Client端 调用，不过 REST API 是基于HTTP协议的，REST致力于通过http协议中的POST/GET/PUT/DELETE等方法和一个可读性强的URL来提供一个http请求。而 RPC 则可以不基于 HTTP协议</p><p>因此，如果是后端两种语言互相调用，用 RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西），应该也更容易配置。如果是前端通过 AJAX 调用后端，那么用 REST API 的形式比较好（因为无论如何也避不开 HTTP 这道坎）。</p><p>1、<strong>HTTP和RPC同一级别，还是被RPC包含？</strong></p><p>2、<strong>Restful也属于RPC么？</strong></p><p><img src="images/screenshot_1586854421991.png" alt=""></p><p>上图是一个比较完整的关系图，这时我们发现HTTP（图中蓝色框）出现了两次。其中一个是和RPC并列的，都是跨应用调用方法的解决方案；另一个则是被RPC包含的，是RPC通信过程的可选协议之一。</p><p>因此，<strong>第一个问题的答案是都对。看指的是哪一个蓝色框。</strong>从题主的提问看，既然题主在纠结这两者，应该是指与RPC并列的蓝色框。</p><p>第二个问题是在问远程过程调用（红色框）是不是包含了Restful（黄色框），这种理解的关键在于对RPC的理解。</p><p>RPC字面理解是远程过程调用，即在一个应用中调用另一个应用的方法。那Restful是满足的，通过它可以实现在一个应用中调用另一个应用的方法。</p><p>但是，上述理解使得RPC的定义过于宽泛。RPC通常特指在一个应用中调用另一个应用的接口而实现的远程调用，即红色框所指的范围。这样，RPC是不包含Restful的。</p><p>因此，<strong>第二个问题的答案是Restful不属于RPC，除非对RPC有着非常规的宽泛理解。</strong></p><p>RPC的英文全称是Remote Procedure Call，翻译为中文叫“远程过程调用”。其中稍显晦涩的其实就是“过程”，过程其实就是方法。所以，可以把RPC理解为“远程方法调用”。</p><p>要了解远程过程调用，那先理解过程调用。非常简单，如下图，就是调用一个方法。这太常见了，不多解释。</p><p><img src="images/screenshot_1586854499834.png" alt=""></p><p>而在分布式系统中，因为每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A调用服务B中方法的需求，即远程过程调用。</p><p>要想让服务A调用服务B中的方法，最先想到的就是通过HTTP请求实现。是的，这是很常见的，例如服务B暴露Restful接口，然后让服务A调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。</p><p>然而，如前面所述，基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。</p><p>服务A调用服务B的过程是应用间的内部过程，<strong>牺牲可读性提升效率、易用性是可取的</strong>。基于这种思路，RPC产生了。</p><h2 id="通过hprose实现rpc"><a href="#通过hprose实现rpc" class="headerlink" title="通过hprose实现rpc"></a>通过hprose实现rpc</h2><p><strong>HPROSE</strong> 是 <em>High Performance Remote Object Service Engine</em> 的缩写，翻译成中文就是“高性能远程对象服务引擎”。</p><p>它是一个先进的轻量级的跨语言跨平台面向对象的高性能远程动态通讯中间件。它不仅简单易用，而且功能强大。你只需要稍许的时间去学习，就能用它轻松构建跨语言跨平台的分布式应用系统了。</p><p>Hprose 支持众多流行的编程语言，例如：</p><ul><li><p>AAuto Quicker</p></li><li><p>ActionScript</p></li><li><p>ASP</p></li><li><p>C++</p></li><li><p>Delphi/Free Pascal</p></li><li><p>dotNET(C#, Visual Basic…)</p></li><li><p>Golang</p></li><li><p>Java</p></li><li><p>JavaScript</p></li><li><p>Node.js</p></li><li><p>Objective-C</p></li><li><p>Perl</p></li><li><p>PHP</p></li><li><p>Python</p></li><li><p>Ruby</p></li></ul><p>通过 Hprose，你就可以在这些语言之间方便高效的实现互通了。</p><h2 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h2><p>在同一个文件夹下，执行一下操作，分别是拉取组建的命令，创建两个文件和执行php文件。</p><p>拉取hprose组件</p><p>composer require hprose/hprose</p><p>建立server.php</p><p>&lt;?php</p><p>require_once “./vendor/autoload.php”;</p><p>use Hprose\Socket\Server;</p><p>function hello($name) {</p><p>return “Hello $name!”;</p><p>}</p><p>$server = new Server(“tcp://0.0.0.0:1314”);</p><p>$server-&gt;setErrorTypes(E_ALL);</p><p>$server-&gt;setDebugEnabled();</p><p>$server-&gt;addFunction(‘hello’);</p><p>$server-&gt;start();</p><p>建立client.php</p><p>&lt;?php</p><p>require_once “./vendor/autoload.php”;</p><p>use \Hprose\Future;</p><p>use \Hprose\Socket\Client;</p><p>$test = new Client(“tcp://127.0.0.1:1314”);</p><p>$test-&gt;fullDuplex = true;</p><p>Future\co(function() use ($test) {</p><p>try {</p><p>var_dump((yield $test-&gt;hello(“yield world1”)));</p><p>var_dump((yield $test-&gt;hello(“yield world2”)));</p><p>var_dump((yield $test-&gt;hello(“yield world3”)));</p><p>var_dump((yield $test-&gt;hello(“yield world4”)));</p><p>var_dump((yield $test-&gt;hello(“yield world5”)));</p><p>var_dump((yield $test-&gt;hello(“yield world6”)));</p><p>}</p><p>catch (\Exception $e) {</p><p>echo ($e);</p><p>}</p><p>});</p><p>执行</p><p>php server.php</p><p>php client.php</p><p>结果</p><p>string(19) “Hello yield world1!”</p><p>string(19) “Hello yield world2!”</p><p>string(19) “Hello yield world3!”</p><p>string(19) “Hello yield world4!”</p><p>string(19) “Hello yield world5!”</p><p>string(19) “Hello yield world6!”</p><p>可继续学习：</p><p><a href="https://github.com/hprose/hprose-php/wiki" target="_blank" rel="external">Hprose for PHP 用户手册</a></p><p>本文摘自：<br><a href="https://www.kancloud.cn/martist/micro_service" target="_blank" rel="external">https://www.kancloud.cn/martist/micro_service</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>《和面试官抬杠系列》单机等于没有高可用么</title>
    <link href="http://martist.cn/2020/04/22/2020%E6%96%87%E7%AB%A0/%E3%80%8A%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E6%8A%AC%E6%9D%A0%E7%B3%BB%E5%88%97%E3%80%8B%E5%8D%95%E6%9C%BA%E7%AD%89%E4%BA%8E%E6%B2%A1%E6%9C%89%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%88/"/>
    <id>http://martist.cn/2020/04/22/2020文章/《和面试官抬杠系列》单机等于没有高可用么/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-05-09T04:09:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="什么是高可用"><a href="#什么是高可用" class="headerlink" title="什么是高可用"></a>什么是高可用</h2><p>高可用，指系统的可用程度。没有100%的可用性。打个夸张的比方说，你的web服务部署的所有机房都停电了，那么系统就不能再提供服务。一般我们只需要做到4个9就已经很不错了，如下图:</p><p><img src="https://cdn.learnku.com/uploads/images/202004/23/6600/id1wgYBf2m.png!large" alt="《和面试官抬杠系列》单机等于没有高可用么"></p><h2 id="高可用的实现套路"><a href="#高可用的实现套路" class="headerlink" title="高可用的实现套路"></a>高可用的实现套路</h2><p>高可用性集群中的节点一般是一主一备，或者一主多备，通过备份提高整个系统可用性。<br>负载均衡集群一般是多主，每个节点都分担流量。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>单机对应的就是负载均衡下的多台机器。</p><p>多台机器可以对服务进来的流量分摊，解决的问题是不让一台机器不可用，导致web服务终断或不可用，多台机器经常组成一个集群，来处理所有的负载。<br>相关软件：haproxy,lvs，nginx，这些软件提供对集群的管理，是集群的大门.</p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>高可用 指整个系统高可用，也指主机的冗余接管。尽可能采取措施减少系统服务中断时间，进而提高业务程序持续对外提供服务的能力。</p><h3 id="负载均衡和高可用的关系"><a href="#负载均衡和高可用的关系" class="headerlink" title="负载均衡和高可用的关系"></a>负载均衡和高可用的关系</h3><p>单台负载均衡器位于网络的最前端，它起着分流客户请求的作用，相当于整个网站或系统的入口，如果它出现故障，这个网站也会出现故障。所以，这时有一种方案，它能在短时间内将崩溃的负载均衡器接管过去，这也可称高可用。至于负载均衡器后端的Web集群、数据库集群、因为有负载均衡器的内部机制，即使其中的某一台或两台发生问题，也不会影响真个系统的使用。</p><p>用得较多的负载均衡器硬件有F5 BIG-IP，软件有LVS,Nginx及HA-Proxy。高可用软件有Hearbeat和keepalived。成熟的Linux集群架构有LVX+Keepalived、Nginx+keepalived及DRBD+Hearbeat。</p><h3 id="常见的高可用架构"><a href="#常见的高可用架构" class="headerlink" title="常见的高可用架构"></a>常见的高可用架构</h3><p><img src="https://cdn.learnku.com/uploads/images/202004/23/6600/zZ41tBsiSs.png!large" alt="《和面试官抬杠系列》单机等于没有高可用么"></p><p>大多人理解的高可用就是单台机器挂掉了整个服务不会挂掉，所以写代码的时候使用集群的思想去写代码，比如做成无状态的服务，保证在集群使用的时候无状态，单机故障不影响服务，从而达到高可用的效果。</p><p>首先，这种架构模式本身并没什么问题，而且也确实很好，有服务发现，有集群，单台机器挂掉了还有其他机器可使用，在搜索系统，推荐系统，广告系统，网站后台系统中都在大量使用。</p><p>很多人接收到的信息是有了上图的那种架构，那么这个系统就变成了一个高可用的系统了。</p><h2 id="所以，单机就不存在高可用？"><a href="#所以，单机就不存在高可用？" class="headerlink" title="所以，单机就不存在高可用？"></a>所以，单机就不存在高可用？</h2><blockquote><p>一味追求集群架构，脱离了业务场景和团队配置的实际，进行的架构设计就是过度设计</p></blockquote><p>但实际上，上图的系统解决的主要是下面的问题。</p><ul><li>数据同步，公共配置这种少量被忽略的数据的在各个机器间的同步。</li><li>服务发现，新增或者减少机器以后，让其他机器能感知得到有新节点加入或者有老节点下线了。</li></ul><p>高可用这种东西不是一个架构的模式能解决的，一个高可用的系统是代码级别解决的，不是靠几个开源模块能解决的。</p><p>有些人总认为高可用系统有银弹，在各种论坛，会议上看到各种架构，而且基本上都用到了一些成熟的开源软件，所以觉得有了这些以后就可以是一个高可用的系统了，我有zookeeper，那么服务单机挂了，服务照常跑，但实际上然并卵，zookeeper解决的是外部不可控因素导致的机器挂了，比如机器硬盘坏了，网络断了，这种因素导致的服务挂了，zookeeper能解决，你代码出问题导致机器挂了，zookeeper下挂1000台机器也解决不了啊，一般情况下还是一挂全挂。</p><p>比如一个分布式的搜索系统，索引分片了，所以有个集群，有50台机器，每个分片大概10台机器，并且机器可以动态增加减少，集群用zookeeper管理，这算高可用系统吗？这可是一个标准的搜索系统的高可用架构，也只能说，在代码优秀的前提下，这个系统高可用了，网络问题和机器硬件问题已经比较难搞挂整个集群了。但一旦代码有个小bug，或者索引数据生成的时候出现了点问题，一般情况下，集群就全挂了，谈何高可用。</p><p>高可用没有银弹，你在各处看到的，听到的，学习到的各种高可用架构，他们只会告诉你这个系统架构多么牛逼，用几个框框框住某几个模块，然后告诉你，这个框框里的服务各种突发情况都能自适应，流量洪峰来了线性加机器就能解决，对你来说却是然并卵，他们没有告诉你他们的代码有多牛逼，并且只有在这个前提下才高可用的，想纯粹靠几个框框来架构出一个高可用的系统，那是PPT架构师。</p><p>真正的高可用不用纠结架构设计，只需要代码的健壮，健壮的代码加上主备系统设计，不需要其他的，基本上就是一个高可用的系统了，银行的核心数据处理中心加上异地灾备就是这样子的，你敢说他不是高可用的？</p><p>所以，写好代码吧，才能高可用，学习架构，更多的只是对提高系统全局性认识的一种补充，高可用的架构不存在，存在的只有高可用的代码。</p><h2 id="高可用的根本在哪"><a href="#高可用的根本在哪" class="headerlink" title="高可用的根本在哪"></a>高可用的根本在哪</h2><p>优秀的代码就是一切高可用架构的基石，优秀的代码加上合理的架构就是高可用的架构，一个高可用的架构不是靠开源软件搭积木来得到的，成熟的开源软件解决的是把一部分本应该你写的代码变得更优秀。</p><p>资金层面，与其做多服务器的所谓的高可用架构，不如把买多余的集群服务器的钱，花在购买读写更快的硬盘，更大内存和核心的cpu，服务器带宽，cdn加速服务，辅以一定的运维工具，即可保证服务的高可用。</p><p>代码层面，不要出现一些低级的空指针问题，框架使用不当导致内存溢出的问题，以及接口响应超时等等问题，代码交付前，有针对性的做性能测试（并发，压力，执行效率测试），优秀的代码才是高可用的根本。</p><p>架构层面，动静分离，消息队列异步去消化耗时耗内存的任务，redis缓存防止请求直接打到DB，同时处理好缓存穿透，击穿，雪崩的防御方案，如果觉得redis单机内存不够大，可以用redis2.0，开启VM功能，突破物理内存的限制，redis还能自己在内存保持热点数据。</p><p>运维层面，用supervisor守护php-fpm，mysql等进程，对服务器和数据库服务做好cpu，硬盘空间等多个指标的预警，再者，单机的安全防御方面也相对好做一些。</p><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>一本写给phper的架构入门书，也可以通过微信扫码阅读。<br><a href="https://www.kancloud.cn/martist/micro_service" target="_blank" rel="external">https://www.kancloud.cn/martist/micro_service</a></p><p><img src="https://cdn.learnku.com/uploads/images/202004/23/6600/udOYCrsCJu.png!large" alt="《和面试官抬杠系列》单机等于没有高可用么"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>总结git的一些高级用法</title>
    <link href="http://martist.cn/2020/02/05/2020%E6%96%87%E7%AB%A0/git/"/>
    <id>http://martist.cn/2020/02/05/2020文章/git/</id>
    <published>2020-02-04T16:00:00.000Z</published>
    <updated>2020-02-10T08:54:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>（1）git stash save “save message”  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p><p>（2）git stash list  ：查看stash了哪些存储</p><p>（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</p><p>（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@{$num}  -p ，比如第二个：git stash show  stash@{1}  -p</p><p>（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} </p><p>（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</p><p>（7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储</p><p>（8）git stash clear ：删除所有缓存的stash</p><p>需要注意：没有在git 版本控制中的文件，是不能被git stash 存起来的。<br>那要怎么办呢，这个文件我也想存起来，很明显，先执行下git add 加到git版本控制中，然后再git stash就可以了</p><p>##导航 —— 跳到之前的分支</p><pre><code>git checkout -</code></pre><h2 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h2><pre><code># 每个提交在一行内显示git log --oneline# 在所有提交日志中搜索包含「homepage」的提交git log --all --grep=&apos;homepage&apos;# 获取某人的提交日志 git log --author=&quot;Maxence&quot;</code></pre><h2 id="查看操作历史"><a href="#查看操作历史" class="headerlink" title="查看操作历史"></a>查看操作历史</h2><pre><code># 获取所有操作历史git reflog</code></pre><h2 id="精准回滚"><a href="#精准回滚" class="headerlink" title="精准回滚"></a>精准回滚</h2><pre><code># 重置到相应提交git reset HEAD@{4}# ……或者……git reset --hard &lt;提交的哈希值&gt;</code></pre><h2 id="分支本地版本和仓库一致"><a href="#分支本地版本和仓库一致" class="headerlink" title="分支本地版本和仓库一致"></a>分支本地版本和仓库一致</h2><pre><code>git fetch origingit checkout mastergit reset --hard origin/master</code></pre><h2 id="定制提交"><a href="#定制提交" class="headerlink" title="定制提交"></a>定制提交</h2><pre><code># 编辑上次提交git commit --amend -m &quot;更好的提交日志&quot;# 在上次提交中附加一些内容，保持提交日志不变git add . &amp;&amp; git commit --amend --no-edit# 空提交 —— 可以用来重新触发 CI 构建git commit --allow-empty -m &quot;chore: re-trigger build&quot;</code></pre><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><pre><code># 移除远程仓库上不存在的分支git fetch -p# 移除所有包含 `greenkeeper` 的分支git fetch -p &amp;&amp; git branch --remote | fgrep greenkeeper | sed &apos;s/^.\{9\}//&apos; | xargs git push origin --delete</code></pre><h2 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h2><p>可以学习这篇<br><a href="https://www.jianshu.com/p/684a8ae9dcf1" target="_blank" rel="external">https://www.jianshu.com/p/684a8ae9dcf1</a></p><h2 id="git-别名"><a href="#git-别名" class="headerlink" title="git 别名"></a>git 别名</h2><pre><code>alias g=&apos;git&apos;alias glog=&apos;git log --oneline --decorate --graph&apos;alias gst=&apos;git status&apos;alias gp=&apos;git push&apos;alias ga=&apos;git add&apos;alias gc=&apos;git commit -v&apos;# 🤘alias yolo=&apos;git push --force&apos;# 每周站会汇报工作时用git-standup() {    AUTHOR=${AUTHOR:=&quot;`git config user.name`&quot;}    since=yesterday    if [[ $(date +%u) == 1 ]] ; then        since=&quot;2 days ago&quot;    fi    git log --all --since &quot;$since&quot; --oneline --author=&quot;$AUTHOR&quot;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="git" scheme="http://martist.cn/categories/git/"/>
    
    
      <category term="git" scheme="http://martist.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>supervisor的应用</title>
    <link href="http://martist.cn/2019/12/30/2019%E6%96%87%E7%AB%A0/supervisor%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://martist.cn/2019/12/30/2019文章/supervisor的应用/</id>
    <published>2019-12-29T16:00:00.000Z</published>
    <updated>2020-02-10T03:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Supervisor是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。它可以很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被杀死，supervisort监听到进程死后，会自动将它重新拉起，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>pip install supervisor</code></pre><h2 id="查看任务状态"><a href="#查看任务状态" class="headerlink" title="查看任务状态"></a>查看任务状态</h2><pre><code># supervisorctl statusSmartCoin                        RUNNING   pid 13203, uptime 0:04:05coin                             RUNNING   pid 30744, uptime 17 days, 20:45:18deepwellserver                   RUNNING   pid 30257, uptime 30 days, 4:13:01jingtumassetapi                  RUNNING   pid 14536, uptime 45 days, 19:18:08moac                             RUNNING   pid 20015, uptime 15 days, 5:15:11new                              RUNNING   pid 10041, uptime 43 days, 22:41:56nginx                            RUNNING   pid 18752, uptime 22:59:40redis                            RUNNING   pid 14542, uptime 45 days, 19:18:08sonyflakeserver                  FATAL     can&apos;t find command &apos;go&apos;sparkportal                      RUNNING   pid 26073, uptime 1 day, 23:11:17sparkportal2                     RUNNING   pid 25732, uptime 1 day, 23:11:21sparkportal3                     RUNNING   pid 25834, uptime 1 day, 23:11:20sparkportal4                     RUNNING   pid 25974, uptime 1 day, 23:11:18sparkuser                        RUNNING   pid 26957, uptime 9 days, 23:07:21sparkwallet                      RUNNING   pid 29045, uptime 5 days, 15:11:58summaryservice                   RUNNING   pid 14535, uptime 45 days, 19:18:08</code></pre><p>第一列是服务名；第二列是运行状态，RUNNING表示运行中，FATAL 表示运行失败，STARTING表示正在启动,STOPED表示任务已停止；　第三/四列是进程号,最后是任务已经运行的时间。</p><p>##查看单个任务状态<br>supervisorctl status　服务名</p><pre><code># supervisorctl status sparkportalsparkportal                      RUNNING   pid 26073, uptime 1 day, 23:12:10</code></pre><p>##启动任务<br>supervisorctl start 服务名</p><pre><code># supervisorctl stop sparkportalsparkportal: stopped#supervisorctl status sparkportalsparkportal                      STOPPED   Jan 05 01:59 PM</code></pre><p>##停止任务<br>supervisorctl stop 服务名</p><pre><code># supervisorctl start sparkportalsparkportal: started# supervisorctl status sparkportalsparkportal                      RUNNING   pid 32207, uptime 0:00:05</code></pre><p>##重启任务</p><p>supervisorctl restart 服务名</p><pre><code># supervisorctl restart sparkportalsparkportal: stoppedsparkportal: started# supervisorctl status sparkportalsparkportal                      RUNNING   pid 4952, uptime 0:00:03</code></pre><p>##新增任务</p><p>任务模板<br>    [program:&lt;服务名&gt;]<br>    command=&lt;启动命令&gt;<br>    process_name=%(program_name)s ; process_name expr (default %(program_name)s)<br>    numprocs=1                    ; number of processes copies to start (def 1)<br>    directory=&lt;运行目录&gt;                ; directory to cwd to before exec (def no cwd)<br>    ;umask=022                     ; umask for process (default None)<br>    ;priority=999                  ; the relative start priority (default 999)<br>    autostart=true                ; start at supervisord start (default: true)<br>    autorestart=unexpected        ; whether/when to restart (default: unexpected)<br>    startsecs=1                   ; number of secs prog must stay running (def. 1)<br>    startretries=3                ; max # of serial start failures (default 3)<br>    exitcodes=0,2                 ; ‘expected’ exit codes for process (default 0,2)<br>    stopsignal=QUIT               ; signal used to kill process (default TERM)<br>    stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)<br>    stopasgroup=false             ; send stop signal to the UNIX process group (default false)<br>    killasgroup=false             ; SIGKILL the UNIX process group (def false)<br>    ;user=skywell                  ; setuid to this UNIX account to run the program<br>    ;redirect_stderr=true          ; redirect proc stderr to stdout (default false)<br>    stdout_logfile=/var/log/&lt;服务名&gt;.log        ; stdout log path, NONE for none; default AUTO<br>    stdout_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)<br>    stdout_logfile_backups=1     ; # of stdout logfile backups (default 10)<br>    stdout_capture_maxbytes=1MB   ; number of bytes in ‘capturemode’ (default 0)<br>    stdout_events_enabled=false   ; emit events on stdout writes (default false)<br>    stderr_logfile=/var/log/&lt;服务名&gt;.err        ; stderr log path, NONE for none; default AUTO<br>    stderr_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)<br>    stderr_logfile_backups=10     ; # of stderr logfile backups (default 10)<br>    stderr_capture_maxbytes=1MB   ; number of bytes in ‘capturemode’ (default 0)<br>    stderr_events_enabled=false   ; emit events on stderr writes (default false)<br>    environment=A=”1”,B=”2”,HOME=”/home/skywell”       ; process environment additions (def no adds)<br>    serverurl=AUTO                ; override serverurl computation (childutils)</p><p>首先添加任务描述文件，在/etc/supervisor目录下新建文件sparkportal.conf，　将上面任务模板内容复制进文件sparkportal.conf中,将&lt;服务名&gt;替换为任务名sparkportal，将&lt;启动命令&gt;替换为node www.js，将&lt;运行目录&gt;替换为程序所在目录/usr/local/sparkportal/bin。</p><p>sparkportal的配置文件为</p><pre><code>[program:sparkportal]command=node www.jsprocess_name=%(program_name)s ; process_name expr (default %(program_name)s)numprocs=1                    ; number of processes copies to start (def 1)directory=/usr/local/sparkportal/bin                ; directory to cwd to before exec (def no cwd);umask=022                     ; umask for process (default None);priority=999                  ; the relative start priority (default 999)autostart=true                ; start at supervisord start (default: true)autorestart=unexpected        ; whether/when to restart (default: unexpected)startsecs=1                   ; number of secs prog must stay running (def. 1)startretries=3                ; max # of serial start failures (default 3)exitcodes=0,2                 ; &apos;expected&apos; exit codes for process (default 0,2)stopsignal=QUIT               ; signal used to kill process (default TERM)stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)stopasgroup=false             ; send stop signal to the UNIX process group (default false)killasgroup=false             ; SIGKILL the UNIX process group (def false);user=skywell                  ; setuid to this UNIX account to run the program;redirect_stderr=true          ; redirect proc stderr to stdout (default false)stdout_logfile=/var/log/sparkportal.log        ; stdout log path, NONE for none; default AUTOstdout_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)stdout_logfile_backups=1     ; # of stdout logfile backups (default 10)stdout_capture_maxbytes=1MB   ; number of bytes in &apos;capturemode&apos; (default 0)stdout_events_enabled=false   ; emit events on stdout writes (default false)stderr_logfile=/var/log/sparkportal.err        ; stderr log path, NONE for none; default AUTOstderr_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)stderr_logfile_backups=10     ; # of stderr logfile backups (default 10)stderr_capture_maxbytes=1MB   ; number of bytes in &apos;capturemode&apos; (default 0)stderr_events_enabled=false   ; emit events on stderr writes (default false)environment=A=&quot;1&quot;,B=&quot;2&quot;,HOME=&quot;/home/skywell&quot;       ; process environment additions (def no adds)serverurl=AUTO                ; override serverurl computation (childutils)</code></pre><p>##增加任务</p><p>supervisorctl update</p><pre><code># supervisorctl updatesparkportal: added process group</code></pre><p>该命令会将sparkportal.conf所描述的任务启动并纳入管理。然后运用查看任务命令即可查看新增任务的运行状态，如若运行失败，可查看/usr/log目录下的相关日志分析原因。</p><p>##设置环境变量<br>在配置文件找到environment所在行，若没有没有最下面增加environment=变量名=”变量值”即可，如果多个环境变量用逗号分隔，例如environment=变量名1=”变量值１”,变量名2=”变量值2”。</p><p>将nodejs运行环境设置为生产环境，增加如下代码：<br>environment=NODE_ENV=production</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="微服务" scheme="http://martist.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>你究竟有多想成功</title>
    <link href="http://martist.cn/2019/11/24/2019%E6%96%87%E7%AB%A0/%E4%BD%A0%E7%A9%B6%E7%AB%9F%E6%9C%89%E5%A4%9A%E6%83%B3%E6%88%90%E5%8A%9F/"/>
    <id>http://martist.cn/2019/11/24/2019文章/你究竟有多想成功/</id>
    <published>2019-11-23T16:00:00.000Z</published>
    <updated>2019-12-05T07:51:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>曾经有一个年轻人，他想赚很多很多的钱 。所以他找到了一位他视为偶像的大师，并告诉大师他想成为像大师一样强大的人。大师说，如果你想成为像我一样的人，那么明天早晨来海滩见我。<br>所以那个年轻人四点的时候就赶到了，想显得自己信心满满，西装革履，他当时应该穿着短裤。大师走过来摸着他的头问：“你有多想成功呢？”年轻人说：“我真的很想！”接着大师让他走下水。所以他就这样走进海里。海水差不多淹到年轻人的腰际。此时的他就像一个疯子一样。<br>年轻人心里想：“我只想赚钱，他却只教我游泳。我可不想成为一个救生员。我只想成功！”<br>大师察觉到这一点。所以他就对年轻人说：“再走远一点。”然后年轻人又走远了一些。这时候水差不多已经淹到他们肩膀附近了。年轻人心里想：“这老家伙真是个疯子，他很会赚钱但却是个疯子。”<br>而大师却就一直说：“再走远一点，再远一点。”这时候水已经快要淹没他的嘴了。此时大师让年轻人往回走，这家伙一定疯了。大师这时候说：“你告诉我你想成功的。”年轻人回答道：“是的！”大师让他又走远了一点。这时候大师走进年轻人，把他的头按倒水里，再提起来，再按倒水里。就在年轻人快不行的时候，大师把他拎了起来。他对年轻人说我有话要告诉你，他对年轻人说：当你对成功的欲望足以与对呼吸的欲望媲美的时候，你就会成功。<br>我不知道在看视频的你们有多少人有过哮喘的体验？如果你曾经有过这种体验，你感到气息不足，你就会像这样深呼吸并喘气。这时候你唯一要做的，就是去吸取新鲜空气。此时的你不会在意NBA停摆，不会在意电视正在播什么，不会在意有没有人给你打电话，不会在意派对的琐事！这时候你在意的只是在呼吸的时候吸取一些新鲜空气，这就是全部了！当你理解到自己对成功的渴望就像对呼吸的渴望一样时，你就会取得成功！让我来告诉你：第一：你们好多人都说自己想要成功，但实际上没有那么想，只是有点想而已。<br>你们对成功的渴望甚至不如对派对的渴望，不如对耍帅的渴望。你们中的大多数人对成功的渴望甚至比不上对睡懒觉的渴望。<br>你们中的一些人甚至更愿意睡懒觉。我要告诉你，如果你是一个生来就要成功的人，你需要乐意去放弃睡觉的权利。<br>你会愿意放弃两小时甚至是三小时的睡眠时间！如果你真的很想成功，某些时候，你将会连续三天熬夜。因为如果你这时候去睡觉，你也许会失去一些成功的机会。这正是考验你有多想成功的时刻。你会经历一些不眠之夜，听着，你甚至会因为成功而忘记吃饭。<br>碧昂斯说过，她曾经忙于一些失误以至于三天过去了，她竟然忘记自己都没有吃过饭。她太过于用心了！<br>我记得当50cent第一次当电影导演的时候，我采访过他！他当时说他如果不在做电影的时候，也一定是在做他的录音带！然后就有人问他：50cent，你什么时候睡觉？<br>50cent说：睡觉？只有破产的人才睡觉，我不睡觉，因为我现在有了一个实现梦想的机会！<br>不要哭泣不要想到放弃！你已经感受过疼痛，已经受过伤，争取得到奖赏吧！不要去睡觉，那是一种不成功的表现。小子，听着，我今天告诉你：50cent你可以做自己想做的任何事，你可以随意的逛来逛去，花钱的时候你也可以花得很兴奋。但如果你没有狠狠地逼自己一把的话，你就不是成功的。<br>直到你不会再安慰自己说，其实我不需要那些钱，我已经拥有了我想要的一切！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="人生" scheme="http://martist.cn/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="人生" scheme="http://martist.cn/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu修改欢迎登录页面</title>
    <link href="http://martist.cn/2019/11/17/2019%E6%96%87%E7%AB%A0/Ubuntu%E4%BF%AE%E6%94%B9%E6%AC%A2%E8%BF%8E%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/"/>
    <id>http://martist.cn/2019/11/17/2019文章/Ubuntu修改欢迎登录页面/</id>
    <published>2019-11-16T16:00:00.000Z</published>
    <updated>2019-11-19T09:02:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>Ubuntu欢迎信息保存在/etc/update-motd.d/，修改其中的文件即可修改欢迎信息</p><pre><code># ls /etc/update-motd.d/</code></pre><p>00-header  10-help-text  90-updates-available  91-release-upgrade  98-fsck-at-reboot  98-reboot-required<br>修改相应文件后，执行</p><pre><code># run-parts /etc/update-motd.d/</code></pre><p>默认欢迎信息：</p><pre><code>Welcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-24-generic x86_64) * Documentation:  https://help.ubuntu.com/260 packages can be updated.130 updates are security updates.You have new mail.Last login: Wed Jun 17 22:21:45 2015 from service</code></pre><p>例如修改00-header：</p><pre><code>[ -r /etc/lsb-release ] &amp;&amp; . /etc/lsb-releaseif [ -z &quot;$DISTRIB_DESCRIPTION&quot; ] &amp;&amp; [ -x /usr/bin/lsb_release ]; then        # Fall back to using the very slow lsb_release utility        DISTRIB_DESCRIPTION=$(lsb_release -s -d)fiprintf &quot;Welcome to %s (%s %s %s)\n&quot; &quot;My OS&quot; &quot;$(uname -o)&quot; &quot;$(uname -r)&quot; &quot;$(uname -m)&quot;cat /etc/kylin     #  注意这里的文件路径</code></pre><p>然后新建文件/etc/kylin:</p><pre><code>            /*   *                             _ooOoo_   *                            o8888888o   *                            88&quot; . &quot;88   *                            (| -_- |)   *                            O\  =  /O   *                         ____/`---&apos;\____   *                       .&apos;  \\|     |//  `.   *                      /  \\|||  :  |||//  \   *                     /  _||||| -:- |||||-  \   *                     |   | \\\  -  /// |   |   *                     | \_|  &apos;&apos;\---/&apos;&apos;  |   |   *                     \  .-\__  `-`  ___/-. /   *                   ___`. .&apos;  /--.--\  `. . __   *                .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.   *               | | :  `- \`.;`\ _ /`;.`/ - ` : | |   *               \  \ `-.   \_ __\ /__ _/   .-` /  /   *          ======`-.____`-.___\_____/___.-`____.-&apos;======   *                             `=---=&apos;   *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ *                               高鹏举 *                      佛祖保佑        永无BUG   *            佛曰:   *                   写字楼里写字间，写字间里程序员；   *                   程序人员写程序，又拿程序换酒钱。   *                   酒醒只在网上坐，酒醉还来网下眠；   *                   酒醉酒醒日复日，网上网下年复年。   *                   但愿老死电脑间，不愿鞠躬老板前；   *                   奔驰宝马贵者趣，公交自行程序员。   *                   别人笑我忒疯癫，我笑自己命太贱；   *                   不见满街漂亮妹，哪个归得程序员？  */</code></pre><p>然后执行下面命令，可见效果。</p><pre><code>run-parts /etc/update-motd.d/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="运维" scheme="http://martist.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://martist.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>你究竟有多想成功【英文版】</title>
    <link href="http://martist.cn/2019/11/15/2019%E6%96%87%E7%AB%A0/%E4%BD%A0%E7%A9%B6%E7%AB%9F%E6%9C%89%E5%A4%9A%E6%83%B3%E6%88%90%E5%8A%9Fen/"/>
    <id>http://martist.cn/2019/11/15/2019文章/你究竟有多想成功en/</id>
    <published>2019-11-14T16:00:00.000Z</published>
    <updated>2019-11-15T09:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>There was a young man who you know he wanted to make a lot of money and so he went to this guru, right? He told the guru “you know i wanna be on the same level you on”. And the guru said “if you wanna be on the same level I’m on, I’ll meet you tomorrow at the beach.”</p><p>So the young man got there at 4am, he all ready to rock n roll, got on a suit .Should a wore shorts. The old man grabs his hand he says “how bad do you wanna be successful?” He said “real bad” He said “walk on out into the water”. So he walks out into the water. Watch this.When he walks out into the water it goes waist de</p><p>He’s thinkin’, “I wanna make money, he’s got me out here swimming. I don’t want to be a life guard, I want to make money.”</p><p>He got the meaning,so he said “come out a little further” he walked out a little further till it was right around this area.the shoulder area.So this old man crazy, he makin money but he crazy.</p><p>He said “come out a little further”, He came out a little further and it was right at his mouth. He’s like “I’m about to get outta here this guy outta his mind”. So the old man said “i thought you wanted to be successful?” he said “i do” he said “walk a little further” he came, dropped his head in, held him down, holdin him down, the man kickin and scratching. hold him down, he had held him down, Just before he was about to pass out, he raised him up. He said “I got a question for you,he told the guy.He said:“ when you want to succeed as bad as you wanna breathe, then you’ll be successful.”</p><p>I do not know how many of you all have asthma in here today, but have you ever had an asthma attack before, you are short of breathe, you’re weezy, and the only thing you’re trying to do is get some air.You do not care about no basketball game! You don’t care about what’s on TV. You don’t care about anybody calling you. You don’t care about a party. The only thing you care about when u trying to breathe is getting some fresh air, that’s it!</p><p>When you get to the point where all you wanna like to be is successful as bad as you would want to breathe, then you will be successful! I’m here to tell you that the No.1 the most of you say you want to be successful but you don’t want it bad , you just kind of want it.  You don’t want it badder than you would like to party, you don’t want it as much as you wanna be cool, most of you don’t want success as much as you want to sleep!</p><p>Some of you love sleep more than you love success. And I’m here to tell you that if you’re going to be successful you’ve got to be willing to give up sleep.</p><p>You got to be willing to work of three hours, two hours. If you really want to be successful somedays you’re going to have to stay up for three days in a row!</p><p>Because if you go to sleep you might miss the opportunity to be successful. That’s how bad you have to want it. You got the days wanna?Listen to me, You gotta want to be successful so bad that you forget to eat.</p><p>Beyonce said once she was on the set, doing her thing. Three days has gone by, she forgot she didn’t eat, cause she was engaged.”I never forgot when 50 Cent was doing his movie? Did a little research, 50 cent that when he wasn’t doing his movie, he was doing his soundtrack. And they said, “When do you sleep 50!?”</p><p>“Sleep?!”, he said, “Sleep?! Sleep is for those people who are broke. I don’t sleep. I got an opportunity to make a dream a reality.”</p><p>Don’t cry and quits. You’re already in pain, you’re already hurt, get a reward from it! Don’t go to sleep until you succeed. Listen to me,I’m here to today to tell you can come here, you can jump up,you can do? you can be excited when we give away money.But listen to me you will never be successful if I have to so much as give you a dime…</p><p>You won’t be successful until you say “I don’t need that money cause I got it in here!” </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="人生" scheme="http://martist.cn/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="人生" scheme="http://martist.cn/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>okr</title>
    <link href="http://martist.cn/2019/11/14/2019%E6%96%87%E7%AB%A0/okr/"/>
    <id>http://martist.cn/2019/11/14/2019文章/okr/</id>
    <published>2019-11-13T16:00:00.000Z</published>
    <updated>2019-11-14T11:04:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><blockquote><p>好目标+好的关键结果=使命感+激情+50%担心+50%信心</p></blockquote><h2 id="什么是OKR"><a href="#什么是OKR" class="headerlink" title="什么是OKR"></a>什么是OKR</h2><p> object &amp; key results   目标和关键结果（不忘本心，轻过程，重结果），何为目标？目标是大多数人的共同愿景，而不是少数人的</p><h2 id="企业面临的两个基本问题"><a href="#企业面临的两个基本问题" class="headerlink" title="企业面临的两个基本问题"></a>企业面临的两个基本问题</h2><ol><li>如何调动团队积极性 </li><li>如何评估工作绩效</li></ol><h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h2><p>首先设定有挑战性、可衡量的目标；其次是确保你和你的团队都按这个目标前进，不被其他事情干扰；最后是把握节奏，所有成员一直明确需要努力达成的目标，相互鼓励与支持。</p><p>一个好的目标，要像一个使命宣言既能够激励团队斗志又看起来比较难以实现，但是仍有希望完成的。 首先目标要明确方向并且鼓舞人心，比如“拿下它”或“干掉它”；其次，目标要有时间期限，比如一个月或一个季度完成；再次，要由独立的团队来执行目标，这是因为如果由2个以上团队来执行，则很有可能出现责任划分不清，互相推诿的情况。</p><p>一个好的关键结果应该是实现起来比较困难，但并非不可能的，作者认为50%的失败概率是最好的定位。如果我们看到关键结果，觉着它们很有趣，想着“我们真的要把所有力气花在这些事上：，那么我们很可能就正确的设定了关键结果；如果我们想着”我们死定了“，那说明目标设定的太难了；如果想着”我只要稍微努把力就可以完成“，那可能就是设定得太简单了。</p><p>如何设定OKR呢？首先设定的目标和关键结果都不能多，目标1-2个就够了，1个单一目标对应设定3个关键结果。其次我们可以结合SMART原则来制定，使每一个 KR具体、可衡量、可实现，既不脱离目标又有时间限制。</p><h2 id="实施过程中面临的问题"><a href="#实施过程中面临的问题" class="headerlink" title="实施过程中面临的问题"></a>实施过程中面临的问题</h2><p>制定目标和关键成果过程中会存在困惑，这些都是正常的；在执行过程中，也会受到业务压力所影响，变得焦虑。早期会小心翼翼，目标设定过低或过高，或者含糊概括不清，都是正常的，需要慢慢修正。</p><h2 id="容易造成的误解"><a href="#容易造成的误解" class="headerlink" title="容易造成的误解"></a>容易造成的误解</h2><p>目标和关键结果制定了就一定要达成，否则就是失败的。一般在开始制定的时候或多或少都会有偏差，这并不影响，就算是最终没有达成最好的结果，至少也能帮助团队整体战斗力更上一层台阶。因为在这个目标的实施过程中，我们收获的团队的凝聚力<br>7 管理者期望大家都能做到100分，而执行团队伙伴的内心，他们觉得自己“只是”来赚钱的，只要多做一件事就会跟你急，能塞给别人表现的机会反而积极。到最后的结果，可能只变成50～40分，定制了各种应对措施也无济于事，恶性循环的结果就是大家会越来越消极</p><h2 id="应该避免的弯路"><a href="#应该避免的弯路" class="headerlink" title="应该避免的弯路"></a>应该避免的弯路</h2><p>设置了多个目标：如果希望OKR清晰到公司里的每个人都把它深深地印在脑海里，那就尝试只设置一个目标。如果你设置了5个目标，所有人都不会记得公司的目标到底是什么。若果公司有多条业务线则另当别论<br>设置的OKR周期过短——一周或者一个月<br>用绩效指标来驱动目标的完成：这是许多MBA的失败之处。你爱数字，你爱钱，可谁不爱呢？目标本身是需要鼓舞人心的，它可以把人们从床上叫醒，准备迎接新的一天和新的挑战<br>把周一的会议当作汇报例会，而不是谈话：只讨论需要讨论的事情<br>会议非必要，尽量不要超过一个小时，长时间的会议会提升参会人员的疲惫感从而使得效率降低<br>会议的讨论的问题应该很明确，直达关键点，杜绝花冗长的时间去回顾去铺垫，该过程恰恰会分散参会人员的注意力</p><h2 id="无法达成目标的5个关键因素"><a href="#无法达成目标的5个关键因素" class="headerlink" title="无法达成目标的5个关键因素"></a>无法达成目标的5个关键因素</h2><p>没有给目标设置优先级。如果所有事情都同等重要，就意味着它们也同等不重要。</p><p>缺乏充分沟通，导致没能准确理解目标。如果希望团队能聚焦在重要的事情上，你就必须每天和团队成员不停地沟通目标。周一会议明确各自的责任，每周的OKR状态邮件及周五的庆祝活动不断重复阶段性目标。要让目标贯穿所有的工作。</p><p>没有做好计划。只有目标和意志是不行的，必须要有一个计划，可以有效推进你的目标。</p><p>没有把时间花在重要的事情上。当你目标无法完成时，一定要统计自己的时间消耗，看看是不是自己没有在 P1 这类最重要的事情上投入足够的时间和精力。</p><p>轻易放弃。成功唯一的希望就是反复尝试，找出哪些事情对目标的推进有效，不断做有效的事情，少做无效的事情。</p><h2 id="skills"><a href="#skills" class="headerlink" title="skills"></a>skills</h2><p>事事分轻重缓急、划分优先级<br>责任制，工作不可分心，同事做多件事，最坏的结果是都没做好<br>确保团队主要成员聚焦在重要目标上，而不是被一些疑问所困扰，内部争论不休<br>不要成为公司的害群之马——在公司讨论一些与公司目标相悖的问题，如融资失败，面临倒闭，项目没前途等<br>定制周、月、年度计划，实时回顾总结<br>很多人认为只要有意志就没问题了，坚持执行就会有好结果。这种做法是错误。因为你没有目标，没有方向，没有量化的衡量指标<br>用人当不疑，有些人稍微督促一下就会有很高的产出<br>聚焦关键目标结果，less is more<br>OKR需要有挑战，不要和绩效挂钩，否则和KPI没有差别了<br>实时跟踪目标进度，避免目标进度走偏<br>自上而下兼顾自下而上，有来自管理层层分解出来的目标（O），也有来下级自己制定的KR（关键结果）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="效率" scheme="http://martist.cn/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="效率" scheme="http://martist.cn/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>技术人员如何建立个人品牌</title>
    <link href="http://martist.cn/2019/10/24/2019%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%93%81%E7%89%8C/"/>
    <id>http://martist.cn/2019/10/24/2019文章/技术人员如何建立个人品牌/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2019-10-24T12:05:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="个人品牌的作用"><a href="#个人品牌的作用" class="headerlink" title="个人品牌的作用"></a>个人品牌的作用</h2><h3 id="增加信任"><a href="#增加信任" class="headerlink" title="增加信任"></a>增加信任</h3><p>对于程序员而言,大公司出来都自带光环效应,不提技术如何,但就履历这一层,日后在职场江湖中,将带来极大的便利.</p><p>表面是大厂员工,其实就等同于身份认同,在转行和换工作场景时,大厂的经验意味之前已经通过了大厂面试时的背景审查,基础能力的校验,熟悉了大厂的企业文化,工作制度等.</p><p>但如果是默默无名的小公司,那么就代表着鱼龙混杂,金子也有,但是得一个一个翻开来仔细看,这个时代,忙到看你一眼简历的时间都不会有,哪有心思看你是什么样,即使技术再好,也不会轻易把重要的事物分派给你。</p><p>事实上,在工作中同事看到过你的技术博客,求职时面试官提到你开发或参与的开源项目或者看过你的书的例子也有不少，单就沟通成本而言,就能降低很多,不必像查户口一样,追根究底的去问,人与人之间的熟悉和信任,就是在这样的细节和事物中体现出来,至少,一次简短的面试是远远不足以了解一个人的。</p><h3 id="品牌溢价"><a href="#品牌溢价" class="headerlink" title="品牌溢价"></a>品牌溢价</h3><p>当你写得电子书，被很多人看过，制作的开源项目star数很高，那么你的影响力就与日俱增，当你在面试一个岗位，另一位竞争者和你其他方面差不多，但是你有影响力（品牌本身），你的胜算就高很多。</p><h3 id="增值"><a href="#增值" class="headerlink" title="增值"></a>增值</h3><p>有了个人品牌这个工具，即便你在睡觉，它也能自动帮你做“自我介绍”。<br>而不是你面对面、1对1地解释：我可告诉你啊，我很厉害的，你晓得不……<br>说得远一些，强大的个人品牌能带来机会。<br>影响力做够了，一些意想不到的机会就会“送上门”：<br>要不要出书？见个人？谈一下合作？对接下资源？</p><h2 id="搭建个人品牌"><a href="#搭建个人品牌" class="headerlink" title="搭建个人品牌"></a>搭建个人品牌</h2><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p>参加社区并不能直接给你营销个人品牌，但是可以帮你制造一个走出舒适区的环境。</p><p>遇到过一些工作多年的技术人士，都言有疲惫感，工作上的内容已经驾轻就熟，提升空间有限，转型或者换公司，代价都太大。这个可能是工作范围过窄的缘故，也有可能是自己视野受局限的缘故，每天工作家庭两点一线，遇到的都是固定人群，谈论的是固定话题。在社区中能遇到写代码的，做设计的，搞翻译的，做媒体的，自己创业的，从事文艺工作的种种人等，都蛮有想法，蛮有特色，这种环境，能帮助人打开视野，有时候还能碰撞产生火花。任何一家公司都提供不了这样的氛围。社区能提供多样性选择。</p><p>很多人工作到了一定年限，都会遇到一些瓶颈。而这时回馈社会可能是一种拯救方式。看到不少人退休后的理想是去当老师，应该是想把自己多年经验积累传播出去，让更多人受益，拔高些可能是一些人眼中的人生意义所在。当老师并不需要等退休后，社区中提供很多这样的机会，即使是更毕业的学生，也有机会给那些更年长的人们当老师。社区提供了一个分享的平台。</p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>出一本实体书(难度稍高)</p><p>出一个系列的在线课程或者专栏(质量优,且学员足够的多)</p><p>运营一个自媒体账户,包括不限微信公众号,独立博客,其他自媒体平台(有足够的流量和粉丝)</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>参与社区</p><p>创建开源项目</p><h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><p>打磨一个独具特色的个人产品,包括不限于网站,app,软件等技术型产品</p><h3 id="圈子"><a href="#圈子" class="headerlink" title="圈子"></a>圈子</h3><p>参加一些技术活动和演讲,认识更多的朋友</p><p>工作中善于沟通和协作,并且不断提升自己的技术能力</p><p>自己作为主动者发布一些技术活动或者是参与演讲</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>建立个人关系网络，结识一些知名的活跃人士，这些人或者能影响你，或者能引领你加入某些个小圈子，或者能帮你推广。比如极端的例子，微博上开复老师推荐一次，就能让某人的粉丝数，一天增长一万多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="人生" scheme="http://martist.cn/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="人生" scheme="http://martist.cn/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>研发效能合理提升之道</title>
    <link href="http://martist.cn/2019/09/16/2019%E6%96%87%E7%AB%A0/%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD/"/>
    <id>http://martist.cn/2019/09/16/2019文章/研发效能/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2019-09-17T03:12:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h1 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h1><h2 id="局部效率-不等于-高效交付"><a href="#局部效率-不等于-高效交付" class="headerlink" title="局部效率 不等于 高效交付"></a>局部效率 不等于 高效交付</h2><p>今天，不管是创业公司还是 BAT 这样的大公司，每个人都很繁忙——至少是看上去是繁忙的。但用户关注的并不是，组织内部繁忙与否，他们在乎的是：需求是不是快速、有效地被满足。对应组织能力就是：需求顺畅和高质量的流动，直至交付。我们称之为（用户价值的）流动效率。</p><p>“局部效率不等于高效交付”这是研发效能面临的第一个挑战。为此，我们必须：以流动效率为核心，提升团队的持续交付能力。</p><h2 id="高效交付-不等于-业务成功"><a href="#高效交付-不等于-业务成功" class="headerlink" title="高效交付 不等于 业务成功"></a>高效交付 不等于 业务成功</h2><p>除此之外，高效交付一定会带来业务的成功么？显然不是，我们还必须保障交付的是有用的需求，而不是高效交付一堆垃圾。只有保证交付的是有效价值，才能助力业务成功。</p><p>“高效交付 不等于 业务成功”这是研发效能面对的第二个挑战。为此我们必须：以用户价值为核心，规划和探索有效的产品。</p><h2 id="高效交付-不等于-持续高效"><a href="#高效交付-不等于-持续高效" class="headerlink" title="高效交付 不等于 持续高效"></a>高效交付 不等于 持续高效</h2><p>第三个方面。仅仅短期高效是不够的。随着时间的推进，一个优秀的组织应该不断积累自己的软件资产，如：技术和业务中台；工程基础设施和能力，如：良好管理的开发、测试环境，持续交付设施等），交付效率持续提高。然而现实中，很多团队的情况恰恰相反，他们积累的不是资产，而是债务——糟糕的设计、劣化的代码、工程能力的缺失，都会让效率不可持续。</p><p>“高效交付不等于持续高效”这是研发效能面对的第三个挑战。为此我们必须：以长期效率为核心，沉淀优质软件资产和工程能力。</p><h1 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h1><h2 id="以流动效率为核心提升团队的持续交付能力"><a href="#以流动效率为核心提升团队的持续交付能力" class="headerlink" title="以流动效率为核心提升团队的持续交付能力"></a>以流动效率为核心提升团队的持续交付能力</h2><p>典型的效率竖井，即我们常常说的 silo。什么叫效率竖井呢？在产品开发过程中，企业通常是按职能组织团队的，如业务部门、产品部门、开发部门、测试部门及运维部门等，每个职能都可以说自己很高效，从各自的视角去提升效率，看上去每一个职能都很繁忙，看似高效。但是从用户/客户的角度去看，用户关心的是需求是以多快速度交付到他的手中，满足他“所想即所得”的述求。我们看单个需求在研发过程流动的整个周期，从需求提出到完成的整个时间线上，我们分别用红线表示等待时长，绿线表示被处理的时长，红长绿短。为什么会这样呢？</p><p>刚才讲效率竖井，如果追求效率，你会如何做呢？可能一些团队会选择攒一批需求，对某个职能来说，批量去做该职能的事情，从直觉上来说是最快的，如产品同学批量去做需求分析、开发同学攒一批需求，一起完成开发。但如果从单个需求的视角来看，问题是什么呢？单个人一段时间只能处理一个需求，其它需求就会处于等待，等待不仅仅是因为批量，还可能是各部门的协调问题，可能是时间上没有对齐，可能一个人做完的东西不是另一个人立即需要的，一人做了 A，一人做了 B，时间上没有对齐。此外，还有一些重要的原因，比如流程的要求，例如要批量做测试，就会造成等待。这种等待从用户角度来看是实实在在的等待；从业务响应的角度来说，它降低了响应；从效率的角度来说，这种等待会导致很多工作的重启，问题延后的发现，不仅降低了流动效率，也降低了资源有效的效率。</p><p>在互联网开发当中，我们应该避免效率竖井，但是往往有时由于意识和方法做的不够好，依然存在这样的问题。效率竖井是效能提升的最大限令和误区。</p><p>有时面对效率竖井也很无奈，由于组织结构导致了这样的状态。在一些互联网企业，这样的链条不会太长，一些传统型企业的链条则可能更长，有十多个职能。当然，互联网行业也在发生变化，以前没有面临这些挑战，现在也在面临着新的挑战，由于技术变复杂了，有些行业类型的产品的交付链条也在变长，有时候也很难适应，所以这是传统软件开发和互联网软件开发面临的共同挑战。那么我们如何去应对挑战呢？</p><p>要把以局部资源效率为核心变成以用户价值流动效率为核心。局部效率看单点资源是否被充分利用，即每个人忙不忙。而流动效率不再指人，是指用户的价值、用户的需求的从起点到终点的流速。当换一个视角时，方法体系也会被重构，所以要以流动效率为核心来提升团队的持续能力交付，用这个视角来重新组织、构建和度量整个研发的过程。</p><p>缩短交付周期不仅仅是提升快速交付价值能力，也快速的得到反馈（后续还会讲到快速反馈），可以更好的调整和探索，这就需要看的是系统而非局部的改进。局部是看各个职能模块，系统是看端到端整个完整链条。</p><p>为了提升持续、快速交付价值的能力，这需要精益和敏捷协作实践，包括：第一部分端到端的拉通和可视化，即可见到用户需求的交付过程，它有没有走走停停，如果发生了等待是什么原因，只有可见才能管理这个过程；第二部分是怎么管理价值的流动，即可控，控制不是控制人而是流程，目的是让价值的流动更加顺畅;第三部分要讲流动的度量、反馈和持续改进，度量和反馈永远是个热门话题，却又永远也不简单，其中有很多陷阱和误区，我们试图去破解这些陷阱和误区，度量的目的是帮助改进而不是责备谁，它能回答流动效率怎么样，可以在哪些方面改进。</p><p>以流动效率为核心提升团队的持续交付能力，把每个人的工作变成一个整体的有效快速交付就够了吗？高效交付不等于业务成功，我们还要以用户价值为核心规划和探索有效的产品。</p><h2 id="以用户价值为核心规划和探索有效的产品"><a href="#以用户价值为核心规划和探索有效的产品" class="headerlink" title="以用户价值为核心规划和探索有效的产品"></a>以用户价值为核心规划和探索有效的产品</h2><p>从业务目标或者用户目标出发做出两条路，这两条路哪个更重要？有强烈的价值主张的一定是用户目标更重要。一定是从用户目标开始，因为只有解决了用户问题，才能实现你的业务目标。基于它去分析业务，做出迭代规划，后续还会讲组织好这些需求怎样传递给开发。</p><p>接下来在精益需求管理主题中，再看如何设计需求，然后做出迭代规划，如何在快速交付情况下把需求交给开发之前保证质量，不仅仅是要把需求写好，更要让开发真正理解需求。所以讲需求分析和澄清，沟通过程很重要，信息不仅要准确地表达，还要无损地传递。</p><p>很多人也经常会问，怎样把一个很大的需求拆分成一些小一点的需求，其实这也是在澄清和分析的过程。之所以没有去讲需求拆分，因为我们认为它是需求分析的副产物，当带着一个正确的价值观去做，比如要更快的交付时，真正的做到有效需求分析时，需求自然就拆分开来。不应该把需求拆分当成一个独立的话题，你会发现需求拆分在分析过程中自然而然的发生了。</p><p>一个莫比乌斯环。希望把这两个探索过程和持续交付的过程真正融为一个整体连接在一起，加快需求分析和探索、反馈的循环，减少其中的摩擦，这才能做到真正的以用户价值为核心规划和探索必要的需求。</p><p>总结一下，以用户价值为核心，规划和探索有效产品，就是把问题给定义出来，再找到一条路径走过去，解决这个问题。</p><h2 id="以长期效率为核心沉淀优质软件资产和工程能力"><a href="#以长期效率为核心沉淀优质软件资产和工程能力" class="headerlink" title="以长期效率为核心沉淀优质软件资产和工程能力"></a>以长期效率为核心沉淀优质软件资产和工程能力</h2><p>如果为了追求短期效率，开发的越多，接下来做的就越慢，代码写的不好，后面的测试、持续交付又没跟上，所谓出来混总是要还的，前面欠的太多，就需要还债，甚至是利息，如果只是还债，赶工节约的时间早晚会补回来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="工作" scheme="http://martist.cn/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="工作" scheme="http://martist.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>工程师文化</title>
    <link href="http://martist.cn/2019/09/16/2019%E6%96%87%E7%AB%A0/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96/"/>
    <id>http://martist.cn/2019/09/16/2019文章/工程师文化/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2019-09-16T08:22:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="三种商业公司"><a href="#三种商业公司" class="headerlink" title="三种商业公司"></a>三种商业公司</h2><h3 id="运营或销售驱动型的公司"><a href="#运营或销售驱动型的公司" class="headerlink" title="运营或销售驱动型的公司"></a>运营或销售驱动型的公司</h3><p>这类的公司以运营和营销见长，技术对于他们来说，更多的只是为了支持大规模的营销活动，以及成本上的控制，所以，基本上来说不太需要技术创新。这种公司最大的问题就是缺乏安全感。</p><h3 id="产品驱动型的公司"><a href="#产品驱动型的公司" class="headerlink" title="产品驱动型的公司"></a>产品驱动型的公司</h3><p>这类公司以产品见长，通过创造能提升用户生活体验的产品见长，技术对于他们来说，除了支持大规模的在线用户之外，他们会更多的去寻找那些为了增强用户体验，提高整个业务流程效率的技术创新。比如：UI的交互方面的，整个业务流程方面的。这种公司最大的问题，就是容易被别人模仿和抄袭。</p><h3 id="技术驱动型的公司"><a href="#技术驱动型的公司" class="headerlink" title="技术驱动型的公司"></a>技术驱动型的公司</h3><p>这类的公司相信技术能改变世界，他们更多的是用强大的工程技术来创造有颠覆性的东西，更多的是用各种自动化的技术取代人类。比如：近代的蒸汽机技术取代了大量的人工，数字技术取代了大量信息传递的人工，现代，这类公司还希望通过人工智能来取代愚蠢的人类来做决定。这种公司最大的问题就是可能做出叫好不叫座的东西。</p><p>这三种公司都可能成功，也都有问题，但是，无一例外，他们都需要强大的技术支撑，只不过，他们把技术所放在的位置不一样。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="自我驱动"><a href="#自我驱动" class="headerlink" title="自我驱动"></a>自我驱动</h3><p>自己管理自己是最好的管理。最失败的管理就是家长和保姆式的管理。兴趣出发的工作才可能迸发出真正的动力。</p><h3 id="不害怕错误"><a href="#不害怕错误" class="headerlink" title="不害怕错误"></a>不害怕错误</h3><p>处理错误的正确的姿势是分析总结教训，而不是惩罚故障人。前者让人改善进步，后者让人萎缩不前。最大的错误就是不敢犯错，最大的问题就是不敢直面问题。</p><h3 id="对效率的理解"><a href="#对效率的理解" class="headerlink" title="对效率的理解"></a>对效率的理解</h3><p>工程师天生是追求效率的。有人说认为程序员花大量的时间做自动化的工具，还不如人肉的效率高，比如，写自动化的脚本花5个小时，而重复做这件事200次只花3个小时。有这样的理解的人根本不懂工程。</p><h2 id="理性思维"><a href="#理性思维" class="headerlink" title="理性思维"></a>理性思维</h2><p>对于事物有更深刻的认识，能够提高决策的准确性和有效性，同时也更有可能积累可以复现的经验，也就是知识。由于对事物的观察不够深入，人们非很容易把表面的相关性当成规律，比如很多伟大的公司都建有宏伟的总部大楼，会飞的鸟儿都有羽毛，但是我们不能说要成为伟大的公司就应该建设宏伟的总部大楼，而要想飞就一定要给自己粘上羽毛。只有真正认识到逻辑性的人，才有可能洞察其中的真正的规律，找出有价值的理论，比如按照流体力学的理论来设计飞机，而非粘上羽毛。</p><p>整个人类的技术发展史其实就是一部理性思维的历史，如果不是历史上的人们用理性思维来观察和了解这个世界，那么今天我们还是非洲草原上的一群猴子。</p><p>对于个人而言，理性地看待自己的人生，有助于认识自己，获得内心的平静，做真正想要的自己，简单来说就是活得比较明白。只有这样，才更有可能在自己真正感兴趣的事情上做出成绩，获得成就感。</p><p>理性思维不等于自动掌握了一切知识，恰恰相反，运用理性思维的人会认识到自身的不足，知道自己的知识仅仅是对世界非常小的一部分的抽象总结，因此也愿意以更加开放的心态来了解世界上的事物。</p><p>理性思维不是价值观，但是理性思维有助于梳理价值观。</p><p>理性思维不是万能的，比如碰到经典的掉到水里先救谁的问题的时候，一定不能用理性思维来回答此类问题，不过可以理性地识别这个问题是感性问题，需要切换到感性模式。</p><p>理性思维不等于能力，能力还是需要靠学习和训练才能达到，但是理性思维可能有助于学习的效率。</p><p>理性思维不是辩论手法，不是玩文字游戏，而是一个人思考的过程。</p><h2 id="好奇心"><a href="#好奇心" class="headerlink" title="好奇心"></a>好奇心</h2><p>鼓励好奇心意味着鼓励知识共享，鼓励思想的自由交流，包容不同的想法，允许开放的争议。</p><p>当然，鼓励好奇心主要在于思想层面，而不是行为层面，一个团队或者组织可以允许自由的思想，却很难允许完全自由的行为。</p><h2 id="问：理性思维是否让我们变得复杂？"><a href="#问：理性思维是否让我们变得复杂？" class="headerlink" title="问：理性思维是否让我们变得复杂？"></a>问：理性思维是否让我们变得复杂？</h2><p>答：不是理性思维让我们变得复杂，而是这个世界本来就是复杂的，理性思维只是让我们更加客观地理解这个世界的复杂性。</p><h2 id="问：为什么在这儿讨论哲学问题，能帮我解决具体问题吗？"><a href="#问：为什么在这儿讨论哲学问题，能帮我解决具体问题吗？" class="headerlink" title="问：为什么在这儿讨论哲学问题，能帮我解决具体问题吗？"></a>问：为什么在这儿讨论哲学问题，能帮我解决具体问题吗？</h2><p>答：一张地图并不能让你环游世界，但是有地图会更方便。</p><h2 id="问：关于如何做个优秀的工程师，有没有一句话总结？"><a href="#问：关于如何做个优秀的工程师，有没有一句话总结？" class="headerlink" title="问：关于如何做个优秀的工程师，有没有一句话总结？"></a>问：关于如何做个优秀的工程师，有没有一句话总结？</h2><p>答：保持好奇心，多问为什么，理性思考。</p><h2 id="问：做到这几条就是优秀工程师吗？"><a href="#问：做到这几条就是优秀工程师吗？" class="headerlink" title="问：做到这几条就是优秀工程师吗？"></a>问：做到这几条就是优秀工程师吗？</h2><p>答：知道珠穆朗玛在哪儿不等于已经上了8848米，路还是要自己走的。</p><h2 id="问：拥有工程师文化的公司一定会成功吗？"><a href="#问：拥有工程师文化的公司一定会成功吗？" class="headerlink" title="问：拥有工程师文化的公司一定会成功吗？"></a>问：拥有工程师文化的公司一定会成功吗？</h2><p>答：不一定，但是个人认为拥有工程师文化的公司会提高公司成功的概率。</p><h2 id="问：你好像也没有把问题讲透嘛？"><a href="#问：你好像也没有把问题讲透嘛？" class="headerlink" title="问：你好像也没有把问题讲透嘛？"></a>问：你好像也没有把问题讲透嘛？</h2><p>答：如果你因此而思考，吾愿足矣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="工作" scheme="http://martist.cn/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="生活" scheme="http://martist.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="工作" scheme="http://martist.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>xhprof+Graphviz性能分析</title>
    <link href="http://martist.cn/2019/09/14/2019%E6%96%87%E7%AB%A0/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://martist.cn/2019/09/14/2019文章/性能分析/</id>
    <published>2019-09-13T16:00:00.000Z</published>
    <updated>2019-09-18T02:49:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="下载扩展"><a href="#下载扩展" class="headerlink" title="下载扩展"></a>下载扩展</h2><p>该 xhprof扩展版本是从 <a href="https://github.com/longxinH/xhprof" target="_blank" rel="external">https://github.com/longxinH/xhprof</a> 获取的（第三方的一个库，官方版本不支持php7）</p><pre><code>git clone https://github.com/longxinH/xhprof</code></pre><h2 id="安装扩展"><a href="#安装扩展" class="headerlink" title="安装扩展"></a>安装扩展</h2><p>php的扩展安装都是这三步</p><pre><code>cd xhprof/extension/phpize./configure makemake install</code></pre><h2 id="修改php-ini配置"><a href="#修改php-ini配置" class="headerlink" title="修改php.ini配置"></a>修改php.ini配置</h2><p>其中 xhprof.output_dir 是 xhprof 的输出目录，每次执行 xhprof 的 save_run 方法时都会生成一个 run_id.project_name.xhprof 文件。这个目录在哪里并不重要。注意此路径的权限要可读写！！否则文件无法生成成功</p><pre><code>[xhprof]extension=xhprof.so;xhprof.output_dir=/tmp/xhprof</code></pre><h2 id="重启-php-fpm"><a href="#重启-php-fpm" class="headerlink" title="重启 php-fpm"></a>重启 php-fpm</h2><pre><code>sudo service php7.1-fpm restart</code></pre><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>在需要测试的代码开头和结尾处添加统计代码</p><pre><code>&lt;?phpxhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);// 要检查性能的代码$xhprof_data = xhprof_disable();include_once &apos;/var/www/html/xhprof/xhprof_lib/utils/xhprof_lib.php&apos;;include_once &apos;/var/www/html/xhprof/xhprof_lib/utils/xhprof_runs.php&apos;;$xhprof_runs = new \XHProfRuns_Default();$run_id = $xhprof_runs-&gt;save_run($xhprof_data, &apos;your_project&apos;);</code></pre><h2 id="查看生成报告"><a href="#查看生成报告" class="headerlink" title="查看生成报告"></a>查看生成报告</h2><p>需要访问：xhprof/xhprof_html/index.php文件查看：</p><pre><code>http://localhost/xhprof/xhprof_html/index.php?run=5b35d3dfa8c29&amp;source=your_project//run后的参数为$run_id，source参数为your_project配置的名字</code></pre><h2 id="安装graphviz插件"><a href="#安装graphviz插件" class="headerlink" title="安装graphviz插件"></a>安装graphviz插件</h2><p>安装Graphviz的目的是为了xhprof图形化web工具查看profiling log文件</p><p>方式一：</p><pre><code>sudo apt-get install graphviz</code></pre><p>方式二：</p><pre><code>sudo wget http://www.graphviz.org/pub/graphviz/stable/SOURCES/graphviz-2.28.0.tar.gzsudo tar -zxvf graphviz-2.28.0.tar.gzsudo cd graphviz-2.28.0sudo ./configuresudo makesudo make install</code></pre><p>方式三： </p><pre><code>brew install graphviz //macbook</code></pre><p>安装完成后，会生成/usr/local/bin/dot文件，确保路径在PATH环境变量里，以便XHProf能找到它，graphviz处于/usr/local/lib/graphviz。</p><pre><code>sudo vi ~/.bash_profilesudo source ~/.bash_profileecho $PATH</code></pre><p>看看输出里面是不是已经有了/usr/local/bin/dot这个路径了。</p><h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><pre><code> Notice: Undefined variable: pipes in /home/www/phpsite/pt/xhprof_lib/utils/callgraph_utils.php on line 112 Warning:proc_open() has been disabled for security reasons in /home/www/phpsite/pt/xhprof_lib/utils/callgraph_utils.php on line 112 failed to execute cmd &quot; dot -Tpng&quot;vi /usr/local/php/etc/php.ini//找到disable_functions，把proc_open()从disable_functions列表中去掉。</code></pre><h2 id="看懂XHProf分析报告"><a href="#看懂XHProf分析报告" class="headerlink" title="看懂XHProf分析报告"></a>看懂XHProf分析报告</h2><div class="table-box"><table><tbody><tr><td style="background:rgb(153,204,255);"><br><p>列名</p><br></td><br><td style="background:rgb(153,204,255);"><br><p>描述</p><br></td><br></tr><tr><td><br><p>Function&nbsp;Name</p><br></td><br><td><br><p>方法名称。</p><br></td><br></tr><tr><td><br><p>Calls</p><br></td><br><td><br><p>方法被调用的次数。</p><br></td><br></tr><tr><td><br><p>Calls%</p><br></td><br><td><br><p>方法调用次数在同级方法总数调用次数中所占的百分比。</p><br></td><br></tr><tr><td><br><p>Incl.Wall&nbsp;Time</p><br><p>(microsec)</p><br></td><br><td><br><p>方法执行花费的时间，包括子方法的执行时间。（单位：微秒）</p><br></td><br></tr><tr><td><br><p>IWall%</p><br></td><br><td><br><p>方法执行花费的时间百分比。</p><br></td><br></tr><tr><td><br><p>Excl.&nbsp;Wall&nbsp;Time</p><br><p>(microsec)</p><br></td><br><td><br><p>方法本身执行花费的时间，不包括子方法的执行时间。（单位：微秒）</p><br></td><br></tr><tr><td><br><p>EWall%</p><br></td><br><td><br><p>方法本身执行花费的时间百分比。</p><br></td><br></tr><tr><td><br><p>Incl.&nbsp;CPU</p><br><p>(microsecs)</p><br></td><br><td><br><p>方法执行花费的<span style="font-family:Arial;">CPU</span><span style="font-family:'宋体';">时间，包括子方法的执行时间。（单位：微秒）</span></p><br></td><br></tr><tr><td><br><p>ICpu%</p><br></td><br><td><br><p>方法执行花费的<span style="font-family:Arial;">CPU</span><span style="font-family:'宋体';">时间百分比。</span></p><br></td><br></tr><tr><td><br><p>Excl.&nbsp;CPU</p><br><p>(microsec)</p><br></td><br><td><br><p>方法本身执行花费的<span style="font-family:Arial;">CPU</span><span style="font-family:'宋体';">时间，不包括子方法的执行时间。（单位：微秒）</span></p><br></td><br></tr><tr><td><br><p>ECPU%</p><br></td><br><td><br><p>方法本身执行花费的<span style="font-family:Arial;">CPU</span><span style="font-family:'宋体';">时间百分比。</span></p><br></td><br></tr><tr><td><br><p>Incl.MemUse</p><br><p>(bytes)</p><br></td><br><td><br><p>方法执行占用的内存，包括子方法执行占用的内存。（单位：字节）</p><br></td><br></tr><tr><td><br><p>IMemUse%</p><br></td><br><td><br><p>方法执行占用的内存百分比。</p><br></td><br></tr><tr><td><br><p>Excl.MemUse</p><br><p>(bytes)</p><br></td><br><td><br><p>方法本身执行占用的内存，不包括子方法执行占用的内存。（单位：字节）</p><br></td><br></tr><tr><td><br><p>EMemUse%</p><br></td><br><td><br><p>方法本身执行占用的内存百分比。</p><br></td><br></tr><tr><td><br><p>Incl.PeakMemUse</p><br><p>(bytes)</p><br></td><br><td><br><p>Incl.MemUse<span style="font-family:'宋体';">峰值。（单位：字节）</span></p><br></td><br></tr><tr><td><br><p>IPeakMemUse%</p><br></td><br><td><br><p>Incl.MemUse<span style="font-family:'宋体';">峰值百分比。</span></p><br></td><br></tr><tr><td><br><p>Excl.PeakMemUse</p><br><p>(bytes)</p><br></td><br><td><br><p>Excl.MemUse<span style="font-family:'宋体';">峰值。单位：（字节）</span></p><br></td><br></tr><tr><td><br><p>EPeakMemUse%</p><br></td><br><td><br><p>Excl.MemUse<span style="font-family:'宋体';">峰值百分比。</span></p><br></td><br></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="php" scheme="http://martist.cn/categories/php/"/>
    
    
      <category term="php" scheme="http://martist.cn/tags/php/"/>
    
      <category term="性能" scheme="http://martist.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Code Review</title>
    <link href="http://martist.cn/2019/09/02/2019%E6%96%87%E7%AB%A0/code%20review/"/>
    <id>http://martist.cn/2019/09/02/2019文章/code review/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-17T01:33:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>Code Review做得好的是一些比较偏技术的团队，而偏业务的技术团队基本上没有看到Code Review的记录。在业务团队不仅没有Code Review，而且认为Code Review没用，因为：</p><pre><code>1）工期压得太紧，业务应用开发忙的跟狗一样，时间连coding都不够，以上线为目的，2）需求老变，代码的生命周期太短。所以，写好的代码没有任何意义，烂就烂吧，反正与绩效无关。3），而且业务逻辑变化快，通用性差，code review的成本要比底层高。4）Code Review是一种教条，意义不大，有测试，只要不出错，就可以了。5）现在的主要矛盾是倒排出来的工期和不靠谱的程序员之间的矛盾，我认为cr不是解决这个问题的银弹。不从实际情况出发光打正义的嘴炮实在太过于自慰了 。</code></pre><h2 id="工程师文化"><a href="#工程师文化" class="headerlink" title="工程师文化"></a>工程师文化</h2><p>Code Review没用? 我心里非常不认同这样的观点，我觉得我是程序员，我是工程师，就像医生一样，不是把病人医好就好了，还要对病人的长期健康负责。对于常见病，要很快地医好病人很简单，下猛药，大量使用抗生素，好得飞快。但大家都知道，这明显是“饮鸩止渴”、“竭泽而渔”的做法。医生需要有责任心和医德，我也觉得程序员工程师也要有相应的责任心和相应的修养。东西交给我我必须要负责，我觉得这种负责和修养不是”做出来“就了事了，而是要到“做漂亮”这个级别，这就是“山寨”和“工业”的差别。而只以“做出来”为目的标准，我只能以为，这样的做法只不过是“按部就班”的堆砌代码罢了，和劳动密集型的“装配生产线”和“砌砖头”没有什么差别，在这种环境里呆着还不如离开。</p><h2 id="技术团队和业务团队的矛盾"><a href="#技术团队和业务团队的矛盾" class="headerlink" title="技术团队和业务团队的矛盾"></a>技术团队和业务团队的矛盾</h2><p>我们可以看到，上面观点其实和Code Review没有太多关系，其实是在抱怨另外的问题。这些观点其实是技术团队和业务团队的矛盾，但不知道为什么强加给了我的“Code Review很重要”的这个观点，然后这些观点反过来冲击“Code Reivew”，并说“Code Review无用”。这种讨论问题的方式在很常见，你说A，我说B，本来A、B是两件事，但就是要混为一谈，然后似是而非的用B来证明你的A观点是错的。（也许，这些工程师/架构师心存怨气，需要一个发泄的通道）</p><p>我觉得，很多时候，人思考问题思考不清楚，很大一部分原因是因为把很多问题混为一谈，连我自己有些时候都会这样。引以为戒。</p><p>即然被混为一谈，那我就来拆分一下，也是下面这三个问题：</p><pre><code>Code Review有没有用的问题。Code Review做不起来的问题。业务变化快，速度快的问题，技术疲于跟命。</code></pre><h2 id="大师点评Code-Review"><a href="#大师点评Code-Review" class="headerlink" title="大师点评Code Review"></a>大师点评Code Review</h2><p>你Google一下Code Reivew这个关键词，你就会发现Code Review的好处基本上是不存在争议的，有很多很多的文章和博文都在说Code Review的重要性，怎么做会更好，而且很多公司在面试过程中会加入“Code Review”的问题。打开Wikipedia的词条你会看到这样的描述——</p><pre><code>卡珀斯·琼斯（Capers Jones）分析了超过12,000个软件开发项目，其中使用正式代码审查的项目，发现潜在缺陷率约在60-65%之间，若是非正式的代码审查，发现潜在缺陷率不到50%。大部分的测试，发现的潜在缺陷率会在30%左右。对于一些关键的软件（例如安全关键系统的嵌入式软件），一般的代码审查速度约是一小时150行程序码，一小时审查数百行程序码的审查速度太快，可能无法找到程序中的问题。代码审查一般可以找到及移除约65%的错误，最高可以到85%。也有研究针对代码审查找到的缺陷类型进行分析。代码审查找到的缺陷中，有75%是和计算机安全隐患有关。对于产品生命周期很长的软件公司而言，代码审查是很有效的工具。</code></pre><p>Code Review的好处我觉得不用多说了，主要是让你的代码可以更好的组织起来，有更易读，有更高的维护性，同时可以达到知识共享，找到bug只是其中的副产品。这个东西已经不新鲜了，你上网可以找到很多文章，我就不多说了。就像你写程序要判断错误一样，Code Review也是最基本的常识性的东西。<br>我从2002年开始就浸泡在严格的Code Review中，我的个人成长和Code Review有很大的关系，如果我的成长过程中没有经历过Code Review这个事，我完全不敢想像。<br>我个人认为代码有这几种级别：1）可编译，2）可运行，3）可测试，4）可读，5）可维护，6）可重用。通过自动化测试的代码只能达到第3）级，而通过Code Review的代码少会在第4）级甚至更高。关于Code Review，你可以参看本站的《Code Review中的几个提示》<br>可见，Code Review直接关系到了你的工程能力！</p><h2 id="Code-Review-的问题"><a href="#Code-Review-的问题" class="headerlink" title="Code Review 的问题"></a>Code Review 的问题</h2><p>有下面几个情况会让你的Code Review没有效果。</p><h3 id="人员能力不足"><a href="#人员能力不足" class="headerlink" title="人员能力不足"></a>人员能力不足</h3><p>Code Review的过程中，大家大眼瞪小眼，没有什么好的想法，不知道什么是好的代码，什么是不好的代码。导致Code Review大多数都在代码风格上。今天，我告诉你，代码风格这种事，是每个程序员自查的事情，不应该浪费大家的时间。对此，我有两个建议：</p><pre><code>1）你团队的人招错了，该换血了。2）让你团队的人花时候阅读一下《代码大全》这本书（当然，还要读很多基础知识的书）。</code></pre><h3 id="结果更重要"><a href="#结果更重要" class="headerlink" title="结果更重要"></a>结果更重要</h3><p>做出来更重要，做漂亮不重要。因为我的KPI和年终奖based on how many works I’ve done！而不是How perfect they are ! 这让我想到那些天天在用Spring MVC 做CRUD网页的工程师，我承认，他们很熟练。大量的重复劳动。其实，仔细想一下好多东西是可以框架化，模板化，或是自动生成的。所以，为了堆出这么多网页就停地去堆，做的东西是很多，但是没有任何成长。急功近利，也许，你做得多，拿到了不错的年终奖，但是你失去的也多，失去了成为一个卓越工程师的机会。你本来可以让你的月薪在1-2年后翻1-2倍的，但一年后你只拿到了为数不多的年终奖。</p><h3 id="人员的态度问题"><a href="#人员的态度问题" class="headerlink" title="人员的态度问题"></a>人员的态度问题</h3><p>一方面就是懒，不想精益求精，只要干完活交差了事。对此，你更要大力开展Code Review了，让这种人写出来的代码曝光在更多人面前，让他为质量不好的代码蒙羞。另一方面，有人会觉得那是别人的模块，我不懂，也没时间 去懂，不懂他的业务怎么做Code Review? 我只想说，如果你的团队里这样的“各个自扫门前雪”的事越多，那么这个团队也就越没主动性，没有主动性也就越不可能是个好团队，做的东西也不可能好。而对于个人来说，也就越不可能有成长。</p><h3 id="需求变化的问题"><a href="#需求变化的问题" class="headerlink" title="需求变化的问题"></a>需求变化的问题</h3><p>有人认识，需求变得快，代码的生存周期比较短，不需要好的代码，反正过两天这些代码就会被废弃了。如果是一次性的东西，的确质量不需要太高，反正用了就扔。但是，我觉得多多少少要Review一下这个一次性的烂代码不会影响那些长期在用的代码吧，如果你的项目全部都是临时代码，那么你团队是不是也是一个临时团队？</p><h3 id="时间不够问题"><a href="#时间不够问题" class="headerlink" title="时间不够问题"></a>时间不够问题</h3><p>如果是业务逼得紧，让你疲于奔命，那么这不是Code Review好不好问题，这是需求管理和项目管理的问题以及别的非技术的问题。下面我会说。</p><h2 id="被业务逼得太紧"><a href="#被业务逼得太紧" class="headerlink" title="被业务逼得太紧"></a>被业务逼得太紧</h2><p>被业务逼得太紧，需求乱变，如果你有足够的权限，再者提供一些解决思路。</p><p>1）重新定义产品主要目标和范围，确定哪些该做，哪些不该做。<br>2）制定标准 ，API都长得基本一样，并制订接入标准。<br>3）推动重构，不再重复造轮子。</p><p>这些事情推动起来并不容易，如果被业务方逼得紧，首先不要抱怨，你没有时间被逼得像牲口一样工作，这个时候，你需要的是暂停一下想一想，为什么会像牲口一样？而这正是让你变得聪明的机会。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><h3 id="你有没有去Review业务部门给你的这么多的需求，哪些是合理的，哪些是不合理的"><a href="#你有没有去Review业务部门给你的这么多的需求，哪些是合理的，哪些是不合理的" class="headerlink" title="你有没有去Review业务部门给你的这么多的需求，哪些是合理的，哪些是不合理的"></a>你有没有去Review业务部门给你的这么多的需求，哪些是合理的，哪些是不合理的</h3><p>在Amazon，开发工程师都会被教育拿到需求后一定要问——“为什么要做？业务影响度有多大？有多少用户受益？”，回答不清这个问题，没有数据的支持，就不做。所以，产品经理要做很多数据挖拙和用户调研的工作，而不是拍拍脑袋，听极少数的用户抱怨就要开需求了。</p><h3 id="产品经理也要管理和教育的"><a href="#产品经理也要管理和教育的" class="headerlink" title="产品经理也要管理和教育的"></a>产品经理也要管理和教育的</h3><p>你要告诉你的产品经理：“你是一个好的产品经理，因为你不但对用户把握得很好，也会对软件工艺把握得很好。你不但会开出外在的功能性需求，也同样会开出内在的让软件系统更完善的非功能性需求。你不是在迁就用户，而是引导用户。你不会无限制地加功能，而是把握产品灵魂控制并简化功能。你会为自己要做的和不做东西的感到同样的自豪。”你要告诉你的产品经理：“做一个半成品不如做好半年产品”（更多这样的观点请参看《Rework摘录和感想》）</p><h3 id="做事情是要讲效率的"><a href="#做事情是要讲效率的" class="headerlink" title="做事情是要讲效率的"></a>做事情是要讲效率的</h3><p>Amazon里喜欢使用一种叫T-Shirt Size Estimation的评估方法来优先做投入小产出大的“Happy Case”。关于什么是效率，什么是T-Shirt Size Estimation，你可以看看《加班与效率》一文 。</p><h3 id="需求总是会变化的，不要抱怨需求变化太快"><a href="#需求总是会变化的，不要抱怨需求变化太快" class="headerlink" title="需求总是会变化的，不要抱怨需求变化太快"></a>需求总是会变化的，不要抱怨需求变化太快</h3><p>你应该抱怨的是为什么我们没有把握好方向？老变？这个事就像踢足球一样，你要去的地方是球将要去的地方，而不是球现在的地方。你要知道球要去哪里，你就知道球之前是怎么动的，找到了运动轨迹后，你才知道球要去像何方。如果你都不知道球要去向何方，那你就是一只无头苍蝇一样，东一下西一下。</p><blockquote><p>当你忙得跟牲口一样，你应该停下来，问一下自己，自己成为牲口的原因，是不是就是因为自己做事时候像就牲口一样思考？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="http" scheme="http://martist.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>如何设计好的接口（Google分享）</title>
    <link href="http://martist.cn/2019/08/24/2019%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <id>http://martist.cn/2019/08/24/2019文章/如何设计好的接口/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-08-26T04:04:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="好接口的特性"><a href="#好接口的特性" class="headerlink" title="好接口的特性"></a>好接口的特性</h2><p>（1）易学<br>（2）易用，甚至不需要文档<br>（3）难于误用<br>（4）容易阅读与维护<br>（5）容易扩展</p><h2 id="接口设计实现的过程"><a href="#接口设计实现的过程" class="headerlink" title="接口设计实现的过程"></a>接口设计实现的过程</h2><p>（1）分析需求</p><p>考虑是否有更佳解决方案？<br>这是否使我们这真想要的需求？</p><p>（2）设计小接口</p><p>这个阶段，快速敏捷迭代<br>小接口易于修改<br>小接口的实现给人自信，减少挫败感</p><p>（3）高频、提早撰写接口</p><p>实现自测用例</p><p>（4）撰写服务提供接口（SPI：service provider interface）尤为重要</p><p>如果提供一个接口，是否就不支持第二个？<br>如果提供两个接口，是否能够扩展，融合？<br>如果提供三个接口，是否足够？能否工作正常？</p><p>（5）注意“正常的”异常维护</p><p>你的接口是为了满足所有需求？<br>即使有异常，也不要紧</p><h2 id="接口设计的基本原则"><a href="#接口设计的基本原则" class="headerlink" title="接口设计的基本原则"></a>接口设计的基本原则</h2><p>（1）只做并做好一件事</p><p>函数名自解释；</p><p>不恰当的函数名，往往是不恰当设计的征兆</p><p>（2）如果没做到（1），就将函数分解</p><p>只增加，永远不要删除函数与接口<br>你永远不知道这个接口被谁在使用</p><p>（3）实现永远不能影响接口</p><p>举例：不能假定函数调用者只能使用hash，不能对外暴露实现细节</p><p>（4）最小化访问</p><p>尽量使用私有化成员<br>注意信息隐藏</p><p>（5）文档与注释</p><p>接口不是只写给自己（即使只给自己，也应该有说明）</p><p>（6）提高性能</p><p>（7）平台无关</p><h2 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h2><p>（1）最小易变性</p><p>举例：Date不宜设计成类，过于易变；可设计为TimerTask<br>如果可变，则要设计良好、最小化的状态子集合</p><p>（2）尽量少用继承</p><p>如果设计一个类不能被继承，则应该明确禁止</p><p>五、方法设计</p><p>（1）不要到处拷贝模板代码</p><p>模块能做的事，不用到处拷贝方法</p><p>（2）原子性应该在一个方法内保证</p><p>（3）Fail-Fast设计原则</p><p>出错尽量早点返回，交给上层处理，不要勉强抢救</p><p>（4）避免数据直接访问，而是提供访问方法</p><p>（5）谨慎重载</p><p>小心多重继承中的误重载<br>可以重载的情况，也慎重考虑是否应该重载</p><p>（6）注意参数与返回值类型</p><p>尽量明确类型<br>能不用string尽量不用<br>使用float的地方尽量用double，64bit</p><p>（7）不改变的参数使用const</p><p>（8）参数个数不宜太多</p><p>如果过多，就要考虑接口的合理性了</p><p>（9）避免返回值与异常的同时返回</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="接口" scheme="http://martist.cn/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>58到家数据库30条军规解读</title>
    <link href="http://martist.cn/2019/08/24/2019%E6%96%87%E7%AB%A0/58%E5%88%B0%E5%AE%B6%E6%95%B0%E6%8D%AE%E5%BA%9330%E6%9D%A1%E5%86%9B%E8%A7%84%E8%A7%A3%E8%AF%BB/"/>
    <id>http://martist.cn/2019/08/24/2019文章/58到家数据库30条军规解读/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-08-26T06:32:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><p>军规适用场景：并发量大、数据量大的互联网业务</p><p>军规：介绍内容</p><p>解读：讲解原因，解读比军规更重要</p><hr><h2 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h2><h3 id="（1）必须使用InnoDB存储引擎"><a href="#（1）必须使用InnoDB存储引擎" class="headerlink" title="（1）必须使用InnoDB存储引擎"></a>（1）必须使用InnoDB存储引擎</h3><p>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p><h3 id="（2）必须使用UTF8字符集"><a href="#（2）必须使用UTF8字符集" class="headerlink" title="（2）必须使用UTF8字符集"></a>（2）必须使用UTF8字符集</h3><p>解读：万国码，无需转码，无乱码风险，节省空间</p><h3 id="（3）数据表、数据字段必须加入中文注释"><a href="#（3）数据表、数据字段必须加入中文注释" class="headerlink" title="（3）数据表、数据字段必须加入中文注释"></a>（3）数据表、数据字段必须加入中文注释</h3><p>解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的</p><h3 id="（4）禁止使用存储过程、视图、触发器、Event"><a href="#（4）禁止使用存储过程、视图、触发器、Event" class="headerlink" title="（4）禁止使用存储过程、视图、触发器、Event"></a>（4）禁止使用存储过程、视图、触发器、Event</h3><p>解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧</p><h3 id="（5）禁止存储大文件或者大照片"><a href="#（5）禁止存储大文件或者大照片" class="headerlink" title="（5）禁止存储大文件或者大照片"></a>（5）禁止存储大文件或者大照片</h3><p>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好</p><h2 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h2><h3 id="（6）只允许使用内网域名，而不是ip连接数据库"><a href="#（6）只允许使用内网域名，而不是ip连接数据库" class="headerlink" title="（6）只允许使用内网域名，而不是ip连接数据库"></a>（6）只允许使用内网域名，而不是ip连接数据库</h3><h3 id="（7）线上环境、开发环境、测试环境数据库内网域名遵循命名规范"><a href="#（7）线上环境、开发环境、测试环境数据库内网域名遵循命名规范" class="headerlink" title="（7）线上环境、开发环境、测试环境数据库内网域名遵循命名规范"></a>（7）线上环境、开发环境、测试环境数据库内网域名遵循命名规范</h3><p>业务名称：xxx</p><p>线上环境：dj.xxx.db</p><p>开发环境：dj.xxx.rdb</p><p>测试环境：dj.xxx.tdb</p><p>从库在名称后加-s标识，备库在名称后加-ss标识</p><p>线上从库：dj.xxx-s.db</p><p>线上备库：dj.xxx-sss.db</p><h3 id="（8）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用"><a href="#（8）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用" class="headerlink" title="（8）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用"></a>（8）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用</h3><h3 id="（9）表名t-xxx，非唯一索引名idx-xxx，唯一索引名uniq-xxx"><a href="#（9）表名t-xxx，非唯一索引名idx-xxx，唯一索引名uniq-xxx" class="headerlink" title="（9）表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx"></a>（9）表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</h3><h2 id="三、表设计规范"><a href="#三、表设计规范" class="headerlink" title="三、表设计规范"></a>三、表设计规范</h2><h3 id="（10）单实例表数目必须小于500"><a href="#（10）单实例表数目必须小于500" class="headerlink" title="（10）单实例表数目必须小于500"></a>（10）单实例表数目必须小于500</h3><h3 id="（11）单表列数目必须小于30"><a href="#（11）单表列数目必须小于30" class="headerlink" title="（11）单表列数目必须小于30"></a>（11）单表列数目必须小于30</h3><h3 id="（12）表必须有主键，例如自增主键"><a href="#（12）表必须有主键，例如自增主键" class="headerlink" title="（12）表必须有主键，例如自增主键"></a>（12）表必须有主键，例如自增主键</h3><p>解读：</p><p>a）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用</p><p>b）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率</p><p>c） 无主键的表删除，在row模式的主从架构，会导致备库夯住</p><h3 id="（13）禁止使用外键，如果有外键完整性约束，需要应用程序控制"><a href="#（13）禁止使用外键，如果有外键完整性约束，需要应用程序控制" class="headerlink" title="（13）禁止使用外键，如果有外键完整性约束，需要应用程序控制"></a>（13）禁止使用外键，如果有外键完整性约束，需要应用程序控制</h3><p>解读：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先</p><h2 id="四、字段设计规范"><a href="#四、字段设计规范" class="headerlink" title="四、字段设计规范"></a>四、字段设计规范</h2><h3 id="（14）必须把字段定义为NOT-NULL并且提供默认值"><a href="#（14）必须把字段定义为NOT-NULL并且提供默认值" class="headerlink" title="（14）必须把字段定义为NOT NULL并且提供默认值"></a>（14）必须把字段定义为NOT NULL并且提供默认值</h3><p>解读：</p><p>a）null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化</p><p>b）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多</p><p>c）null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识</p><p>d）对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</p><h3 id="（15）禁止使用TEXT、BLOB类型"><a href="#（15）禁止使用TEXT、BLOB类型" class="headerlink" title="（15）禁止使用TEXT、BLOB类型"></a>（15）禁止使用TEXT、BLOB类型</h3><p>解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能</p><h3 id="（16）禁止使用小数存储货币"><a href="#（16）禁止使用小数存储货币" class="headerlink" title="（16）禁止使用小数存储货币"></a>（16）禁止使用小数存储货币</h3><p>解读：使用整数吧，小数容易导致钱对不上</p><h3 id="（17）必须使用varchar-20-存储手机号"><a href="#（17）必须使用varchar-20-存储手机号" class="headerlink" title="（17）必须使用varchar(20)存储手机号"></a>（17）必须使用varchar(20)存储手机号</h3><p>解读：</p><p>a）涉及到区号或者国家代号，可能出现+-()</p><p>b）手机号会去做数学运算么？</p><p>c）varchar可以支持模糊查询，例如：like“138%”</p><h3 id="（18）禁止使用ENUM，可使用TINYINT代替"><a href="#（18）禁止使用ENUM，可使用TINYINT代替" class="headerlink" title="（18）禁止使用ENUM，可使用TINYINT代替"></a>（18）禁止使用ENUM，可使用TINYINT代替</h3><p>解读：</p><p>a）增加新的ENUM值要做DDL操作</p><p>b）ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</p><h2 id="五、索引设计规范"><a href="#五、索引设计规范" class="headerlink" title="五、索引设计规范"></a>五、索引设计规范</h2><h3 id="（19）单表索引建议控制在5个以内"><a href="#（19）单表索引建议控制在5个以内" class="headerlink" title="（19）单表索引建议控制在5个以内"></a>（19）单表索引建议控制在5个以内</h3><h3 id="（20）单索引字段数不允许超过5个"><a href="#（20）单索引字段数不允许超过5个" class="headerlink" title="（20）单索引字段数不允许超过5个"></a>（20）单索引字段数不允许超过5个</h3><p>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</p><h3 id="（21）禁止在更新十分频繁、区分度不高的属性上建立索引"><a href="#（21）禁止在更新十分频繁、区分度不高的属性上建立索引" class="headerlink" title="（21）禁止在更新十分频繁、区分度不高的属性上建立索引"></a>（21）禁止在更新十分频繁、区分度不高的属性上建立索引</h3><p>解读：</p><p>a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</p><p>b）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</p><h3 id="（22）建立组合索引，必须把区分度高的字段放在前面"><a href="#（22）建立组合索引，必须把区分度高的字段放在前面" class="headerlink" title="（22）建立组合索引，必须把区分度高的字段放在前面"></a>（22）建立组合索引，必须把区分度高的字段放在前面</h3><p>解读：能够更加有效的过滤数据</p><h2 id="六、SQL使用规范"><a href="#六、SQL使用规范" class="headerlink" title="六、SQL使用规范"></a>六、SQL使用规范</h2><h3 id="（23）禁止使用SELECT-，只获取必要的字段，需要显示说明列属性"><a href="#（23）禁止使用SELECT-，只获取必要的字段，需要显示说明列属性" class="headerlink" title="（23）禁止使用SELECT *，只获取必要的字段，需要显示说明列属性"></a>（23）禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</h3><p>解读：</p><p>a）读取不需要的列会增加CPU、IO、NET消耗</p><p>b）不能有效的利用覆盖索引</p><p>c）使用SELECT * 容易在增加或者删除字段后出现程序BUG</p><h3 id="（24）禁止使用INSERT-INTO-t-xxx-VALUES-xxx-，必须显示指定插入的列属性"><a href="#（24）禁止使用INSERT-INTO-t-xxx-VALUES-xxx-，必须显示指定插入的列属性" class="headerlink" title="（24）禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性"></a>（24）禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</h3><p>解读：容易在增加或者删除字段后出现程序BUG</p><h3 id="（25）禁止使用属性隐式转换"><a href="#（25）禁止使用属性隐式转换" class="headerlink" title="（25）禁止使用属性隐式转换"></a>（25）禁止使用属性隐式转换</h3><p>解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？（这个线上问题不止出现过一次）</p><h3 id="（26）禁止在WHERE条件的属性上使用函数或者表达式"><a href="#（26）禁止在WHERE条件的属性上使用函数或者表达式" class="headerlink" title="（26）禁止在WHERE条件的属性上使用函数或者表达式"></a>（26）禁止在WHERE条件的属性上使用函数或者表达式</h3><p>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描</p><p>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p><h3 id="（27）禁止负向查询，以及-开头的模糊查询"><a href="#（27）禁止负向查询，以及-开头的模糊查询" class="headerlink" title="（27）禁止负向查询，以及%开头的模糊查询"></a>（27）禁止负向查询，以及%开头的模糊查询</h3><p>解读：</p><p>a）负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</p><p>b）%开头的模糊查询，会导致全表扫描</p><h3 id="（28）禁止大表使用JOIN查询，禁止大表使用子查询"><a href="#（28）禁止大表使用JOIN查询，禁止大表使用子查询" class="headerlink" title="（28）禁止大表使用JOIN查询，禁止大表使用子查询"></a>（28）禁止大表使用JOIN查询，禁止大表使用子查询</h3><p>解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能</p><h3 id="（29）禁止使用OR条件，必须改为IN查询"><a href="#（29）禁止使用OR条件，必须改为IN查询" class="headerlink" title="（29）禁止使用OR条件，必须改为IN查询"></a>（29）禁止使用OR条件，必须改为IN查询</h3><p>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？</p><h3 id="（30）应用程序必须捕获SQL异常，并有相应处理"><a href="#（30）应用程序必须捕获SQL异常，并有相应处理" class="headerlink" title="（30）应用程序必须捕获SQL异常，并有相应处理"></a>（30）应用程序必须捕获SQL异常，并有相应处理</h3><p>总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="mysql" scheme="http://martist.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://martist.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>nginx的常用运维知识点</title>
    <link href="http://martist.cn/2019/08/24/2019%E6%96%87%E7%AB%A0/nginx%E7%9A%84%E5%B8%B8%E7%94%A8%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://martist.cn/2019/08/24/2019文章/nginx的常用运维知识点/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-08-27T06:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="if语句中的判断条件-nginx"><a href="#if语句中的判断条件-nginx" class="headerlink" title="if语句中的判断条件(nginx)"></a>if语句中的判断条件(nginx)</h2><p>1、正则表达式匹配：</p><pre><code>==:等值比较;~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；</code></pre><p>2、文件及目录匹配判断：</p><pre><code>-f, !-f：判断指定的路径是否为存在且为文件；-d, !-d：判断指定的路径是否为存在且为目录；-e, !-e：判断指定的路径是否存在，文件或目录均可；-x, !-x：判断指定路径的文件是否存在且可执行；</code></pre><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><h3 id="从请求行中解析到的变量"><a href="#从请求行中解析到的变量" class="headerlink" title="从请求行中解析到的变量"></a>从请求行中解析到的变量</h3><pre><code>变量    含义    示例$request    整个请求行    GET /nginx-var/request-line?a=1&amp;b=2 HTTP/1.1$request_method    请求方法（如GET、POST)    GET$request_uri    完整的请求URI    /nginx-var/request-line?a=1&amp;b=2$uri    URI，除去查询字符串    /nginx-var/request-line$document_uri    同$uri    /nginx-var/request-line$args    查询字符串    a=1&amp;b=2$query_string    同$args    a=1&amp;b=2$server_protocol    请求协议（如HTTP/1.0 HTTP/1.1)    HTTP/1.1$arg_name    请求行中name参数的值    $arg_a = 1 , $arg_b = 2</code></pre><h3 id="从请求头中解析到的变量"><a href="#从请求头中解析到的变量" class="headerlink" title="从请求头中解析到的变量"></a>从请求头中解析到的变量</h3><pre><code>变量    含义    示例$host    该变量按如下优先级获得：请求行中解析到的host、请求头“Host”中的host、配置文件中匹配到的server_name    invo.com$remote_addr    客户端ip地址    127.0.0.1$remote_port    客户端端口    4204$http_user_agent    用户代理（“User-Agent”请求头的值)    Mozilla/5.0 (Windows NT 6.1; rv:50.0) Gecko/20100101 Firefox/50.0$http_cookie    “Cookie”请求头的值    CA=abc;CB=123$cookie_name    Cookie中名为name的值    $cookie_CA=abc, $cookie_CB=123$http_referer    “Http-Referer”请求头的值    http://invo.com</code></pre><h3 id="其它内置变量"><a href="#其它内置变量" class="headerlink" title="其它内置变量"></a>其它内置变量</h3><pre><code>变量    含义    $body_bytes_sent    发给客户端的数据大小，以字节计，不包括http报头    $bytes_sent    发给客户端的数据大小，以字节计    $status    http响应状态码    $request_time    请求处理时间    $upstream_response_time    从与upstream建立连接到收到最后一个字节所经历的时间（nginx做反向代理服务器时可用）    $upstream_connect_time    与upstream建立连接所消耗的时间（nginx做反向代理服务器时可用）</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="nginx" scheme="http://martist.cn/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://martist.cn/tags/nginx/"/>
    
      <category term="运维" scheme="http://martist.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>互联网架构，如何进行容量设计？</title>
    <link href="http://martist.cn/2019/08/21/2019%E6%96%87%E7%AB%A0/%E4%BA%92%E8%81%94%E7%BD%91%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AE%B9%E9%87%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://martist.cn/2019/08/21/2019文章/互联网架构，如何进行容量设计/</id>
    <published>2019-08-20T16:00:00.000Z</published>
    <updated>2019-08-20T17:07:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="一，需求缘起"><a href="#一，需求缘起" class="headerlink" title="一，需求缘起"></a>一，需求缘起</h2><p>互联网公司，这样的场景是否似曾相识：</p><p>场景一：pm要做一个很大的运营活动，技术老大杀过来，问了两个问题：<br>（1）机器能抗住么？</p><p>（2）如果扛不住，需要加多少台机器？</p><p>场景二：系统设计阶段，技术老大杀过来，又问了两个问题：<br>（1）数据库需要分库么？</p><p>（2）如果需要分库，需要分几个库？</p><p>技术上来说，这些都是系统容量预估的问题，容量设计是架构师必备的技能之一。常见的容量评估包括数据量、并发量、带宽、CPU/MEM/DISK等，今天分享的内容，就以【并发量】为例，看看如何回答好这两个问题。</p><h2 id="二，容量评估的步骤与方法"><a href="#二，容量评估的步骤与方法" class="headerlink" title="二，容量评估的步骤与方法"></a>二，容量评估的步骤与方法</h2><h3 id="【步骤一：评估总访问量】"><a href="#【步骤一：评估总访问量】" class="headerlink" title="【步骤一：评估总访问量】"></a>【步骤一：评估总访问量】</h3><p>如何知道总访问量？对于一个运营活动的访问量评估，或者一个系统上线后PV的评估，有什么好的方法？</p><p>答案是：询问业务方，询问运营同学，询问产品同学，看对运营活动或者产品上线后的预期是什么。</p><p>举例：58要做一个APP-push的运营活动，计划在30分钟内完成5000w用户的push推送，预计push消息点击率10%，求push落地页系统的总访问量？</p><p>回答：5000w*10% = 500w</p><h3 id="【步骤二：评估平均访问量QPS】"><a href="#【步骤二：评估平均访问量QPS】" class="headerlink" title="【步骤二：评估平均访问量QPS】"></a>【步骤二：评估平均访问量QPS】</h3><p>如何知道平均访问量QPS？</p><p>答案是：有了总量，除以总时间即可，如果按照天评估，一天按照4w秒计算。</p><p>举例1：push落地页系统30分钟的总访问量是500w，求平均访问量QPS</p><p>回答：500w/(30*60) = 2778，大概3000QPS</p><p>举例2：主站首页估计日均pv 8000w，求平均访问QPS</p><p>回答：一天按照4w秒算，8000w/4w=2000，大概2000QPS</p><p>提问：为什么一天按照4w秒计算？</p><p>回答：一天共24小时60分钟60秒=8w秒，一般假设所有请求都发生在白天，所以一般来说一天只按照4w秒评估</p><h3 id="【步骤三：评估高峰QPS】"><a href="#【步骤三：评估高峰QPS】" class="headerlink" title="【步骤三：评估高峰QPS】"></a>【步骤三：评估高峰QPS】</h3><p>系统容量规划时，不能只考虑平均QPS，而是要抗住高峰的QPS，如何知道高峰QPS呢？</p><p>答案是：根据业务特性，通过业务访问曲线评估</p><p>举例：日均QPS为2000，业务访问趋势图如下图，求峰值QPS预估？</p><p>回答：峰值QPS大概是均值QPS的2.5倍，日均QPS为2000，于是评估出峰值QPS为5000。</p><p>说明：有一些业务例如“秒杀业务”比较难画出业务访问趋势图，这类业务的容量评估不在此列。</p><h3 id="【步骤四：评估系统、单机极限QPS】"><a href="#【步骤四：评估系统、单机极限QPS】" class="headerlink" title="【步骤四：评估系统、单机极限QPS】"></a>【步骤四：评估系统、单机极限QPS】</h3><p>如何评估一个业务，一个服务单机能的极限QPS呢？</p><p>答案是：压力测试</p><p>在一个服务上线前，一般来说是需要进行压力测试的（很多创业型公司，业务迭代很快的系统可能没有这一步，那就悲剧了），以APP-push运营活动落地页为例（日均QPS2000，峰值QPS5000），这个系统的架构可能是这样的：</p><p>1）访问端是APP</p><p>2）运营活动H5落地页是一个web站点</p><p>3）H5落地页由缓存cache、数据库db中的数据拼装而成</p><p>通过压力测试发现，web层是瓶颈，tomcat压测单机只能抗住1200的QPS（一般来说，1%的流量到数据库，数据库500QPS还是能轻松抗住的，cache的话QPS能抗住，需要评估cache的带宽，假设不是瓶颈），我们就得到了web单机极限的QPS是1200。一般来说，线上系统是不会跑满到极限的，打个8折，单机线上允许跑到QPS1000。</p><h3 id="【步骤五：根据线上冗余度回答两个问题】"><a href="#【步骤五：根据线上冗余度回答两个问题】" class="headerlink" title="【步骤五：根据线上冗余度回答两个问题】"></a>【步骤五：根据线上冗余度回答两个问题】</h3><p>好了，上述步骤1-4已经得到了峰值QPS是5000，单机QPS是1000，假设线上部署了2台服务，就能自信自如的回答技术老大提出的问题了：</p><p>（1）机器能抗住么？ -&gt; 峰值5000，单机1000，线上2台，扛不住</p><p>（2）如果扛不住，需要加多少台机器？ -&gt; 需要额外3台，提前预留1台更好，给4台更稳</p><p>除了并发量的容量预估，数据量、带宽、CPU/MEM/DISK等评估亦可遵循类似的步骤。</p><h2 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h2><p>互联网架构设计如何进行容量评估：</p><p>【步骤一：评估总访问量】 -&gt; 询问业务、产品、运营</p><p>【步骤二：评估平均访问量QPS】-&gt; 除以时间，一天算4w秒</p><p>【步骤三：评估高峰QPS】 -&gt; 根据业务曲线图来</p><p>【步骤四：评估系统、单机极限QPS】 -&gt; 压测很重要</p><p>【步骤五：根据线上冗余度回答两个问题】 -&gt; 估计冗余度与线上冗余度差值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>nginx实现实用的灰度发布</title>
    <link href="http://martist.cn/2019/08/20/2019%E6%96%87%E7%AB%A0/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"/>
    <id>http://martist.cn/2019/08/20/2019文章/灰度发布/</id>
    <published>2019-08-19T16:00:00.000Z</published>
    <updated>2019-08-19T15:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>：-} <a id="more"></a></p><h2 id="根据ip实现灰度发布"><a href="#根据ip实现灰度发布" class="headerlink" title="根据ip实现灰度发布"></a>根据ip实现灰度发布</h2><p>在百度查自己公司的公网IP</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>同时把两个不同版本的代码拉成两个项目，根据ip来判断用户可以去哪个项目，灰度发布的项目目录指向高版本的项目，其他ip的所有用户仍然访问相对的低版本的项目。</p><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><pre><code>server {    listen 80;    server_name  mb.com;        gzip on;    charset utf-8;    set $mulu  /var/www/mb/dist ;    if ($remote_addr = 1.2.3.4) {        set $mulu  /var/www/mr/build;      }     location / {         root $mulu;            index  index.html;        location / {            try_files $uri $uri/ /index.html;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;：-}
    
    </summary>
    
      <category term="web" scheme="http://martist.cn/categories/web/"/>
    
    
      <category term="web" scheme="http://martist.cn/tags/web/"/>
    
      <category term="laravel" scheme="http://martist.cn/tags/laravel/"/>
    
  </entry>
  
</feed>
