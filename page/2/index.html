<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MARTIST</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="MARTIST">
<meta property="og:url" content="http://martist.cn/page/2/index.html">
<meta property="og:site_name" content="MARTIST">
<meta property="og:locale" content="简体中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MARTIST">
  
    <link rel="alternate" href="/atom.xml" title="MARTIST" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://martist.cn"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MARTIST</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-大负载高并发网站的前期准备" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/大负载高并发网站的前期准备/" class="article-date">
  <time datetime="2016-08-01T16:00:00.000Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/entrepreneurship/">entrepreneurship</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/大负载高并发网站的前期准备/">大并发高负载网站的前期准备</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<p>对互联网有了解的人都有自己的想法，有人就把想法付诸实现，做个网站然后开始运营。其实从纯网站技术上来说，因为开源模式的发展，现在建一个小网站 已经很简单也很便宜。当访问量到达一定数量级的时候成本就开始飙升了，问题也开始显现了。因为带宽的增加、硬件的扩展、人员的扩张所带来的成本提高是显而 易见的，而还有相当大的一部分成本是因为代码重构、架构重构，甚至底层开发语言更换引起的，最惨的就是数据丢失，辛辛苦苦好几年，一夜回到entrepreneurship前。</p>
<p>减少成本就是增加利润。很多事情，我们在一开始就可以避免，先打好基础，往后可以省很多精力，少操很多心。</p>
<p>假设你是一个参与创业的技术人员，当前一穷二白，什么都要自己做，自己出钱，初期几十万的资金，做一个应用不是特别复杂的网站，那么就要注意以下几点：</p>
<h2 id="一、开发语言"><a href="#一、开发语言" class="headerlink" title="一、开发语言"></a>一、开发语言</h2><p>一般来说，技术人员（程序员）entrepreneurship都是根据自己技术背景选择自己最熟悉的语言，不过考虑到不可能永远是您一个人写程序，这点还得仔细想想。无论用什么语言，最终代码质量是看管理，所以我们还是从纯语言层面来说实际一点。现在流行的java、php、.net、python、ruby都 有自己的优劣，python和ruby，现在人员还是相对难招一些，性能优化也会费些力气，.net平台买不起windows server。java、php用的还是最多。对于初期，应用几乎都是靠前端支撑的网站来说，php的优势稍大一些，入门简单、设计模式简单、写起来快、 性能足够等，不过不注重设计模式也是它的劣势，容易变得松散，隐藏bug稍多、难以维护。java的优势在于整套管理流程已经有很多成熟工具来辅助，强类 型也能避免一些弱智BUG，大多数JAVA程序员比较注重设计模式，别管实不实际，代码格式看起来还是不错的。这也是个劣势，初学者可能太注重模式而很难 解决实际需求。</p>
<p>前端不只是html、css这类。整个负责跟用户交互的部分都是前端，包括处理程序。这类程序还是建议用php，主要原因就是开发迅速、从业人员广泛。至于后端例如行为分析、银行接口、异步消息处理等，随便用什么程序，那个只能是根据不同业务需求来选择不同语言了。</p>
<h2 id="二、代码版本管理"><a href="#二、代码版本管理" class="headerlink" title="二、代码版本管理"></a>二、代码版本管理</h2><p>如果开发人员之间的网络速度差不多，就SVN；比较分散例如跨国，就hg。大多数人还是svn的.</p>
<p>假设选了svn，那么有几点考虑。一是采用什么树结构。初期可能只有一条主干，往后就需要建立分支，例如一条开发分支，一条上线分支，再往后，可能 要每个小组一个分支。建议一开始人少时选择两条分支，开发和线上，每个功能本地测试无误后提交到开发分支，最后统一测试，可以上线时合并到上线分支。如果 喜欢把svn当做移动硬盘用，写一点就commit一次也无所谓，就是合并的时候头大一些，这些人可以自己建个分支甚至建立个本地代码仓库，随便往自己的 分支提交，测试完毕后再提交到开发分支上。</p>
<p>部署，可以手工部署也可以自动部署。手工部署相对简单，一般是直接在服务器上svn update，或者找个新目录svn checkout，再把web root给ln -s过去。应用越复杂，部署越复杂，没有什么统一标准，只要别再用ftp上传那种形式就好，一是上传时文件引用不一致错误率增加，二是很容易出现开发人员 的版本跟线上版本不一致，导致本来想改个错字结果变成回滚的杯具。如果有多台服务器还是建议自动部署，更换代码的机器从当前服务池中临时撤出，更新完毕后 再重新加入。</p>
<p>不管项目多小，养成使用版本管理的好习惯，最起码还可以当做你的备份，我的 <a href="http://zhiyi.us" target="_blank" rel="external">http://zhiyi.us</a> 虽然就是一个wordpress，可还是svn了，只改动一两句css那也是劳动成果。</p>
<h2 id="三、服务器硬件"><a href="#三、服务器硬件" class="headerlink" title="三、服务器硬件"></a>三、服务器硬件</h2><p>别羡慕大客户和有钱人，看看机房散户区，一台服务器孤独的支撑的网站数不清。如果资金稍微充足，建议至少三台的标准配置，分别用作web处理、数据 库、备份。web服务器至少要8G内存，双sata raid1，如果经济稍微宽松，或静态文件或图片多，则15k sas raid1+0。数据库至少16G内存，15k sas raid 1+0。备份服务器最好跟数据库服务器同等配置。硬件可以自己买品牌的底板，也就是机箱配主板和硬盘盒，CPU内存硬盘都自己配，也可以上整套品牌，也可 以兼容机。三台机器，市场行情6、7万也就配齐了。</p>
<p>web服务器可以既跑程序又当内存缓存，数据库服务器则只跑主数据库（假如是MySQL的话），备份服务器干的活就相对多一些，web配置、缓存配置、数据库配置都要跟前两台一致，这样WEB和数据库任意一台出问题，把备份服务器换个ip就切换上去了。备份策略，可以drbd，可以rsync，或者其他的很多很多的开源备份方案可选择。rsync最简单，放cron里自己跑就行。备份和切换，建议多做测试，选最安全最适合业务的，并且尽可能异地备份。</p>
<h2 id="四、机房"><a href="#四、机房" class="headerlink" title="四、机房"></a>四、机房</h2><p>三种机房尽量不要选：联通访问特别慢的电信机房、电信访问特别慢的联通机房、电信联通访问特别慢的移动或铁通机房。那网通机房呢？亲，网通联通N久 以前合并改叫联通了。多多寻找，实地参观，多多测试，多方打探，北京、上海、广州等各个主节点城市，还是有很多优质机房的，找个网络质量好，管理严格的机 房，特别是管理要严格，千万别网站无法访问了，打个电话过去才知道别人维护时把你网线碰掉了，这比DOS都头疼。自己扯了几根光纤就称为机房的，看您抗风 险程度和心理素质了。机房可以说是非常重要，直接关系到网站访问速度，网站访问速度直接关系到用户体验，我可以翻墙看风景，但买个网游vpn才能打开你这 个还不怎么知名的网站就有难度了。或许您网站的ajax很出色，可是document怎么也不ready，一些代码永远绝缘于用户。</p>
<h2 id="五、架构"><a href="#五、架构" class="headerlink" title="五、架构"></a>五、架构</h2><p>初期架构一般比较简单，web负载均衡+数据库主从+缓存+分布式存储+队列。大方向上也确实就这几样东西，细节上也无数文章都重复过了，按照将来 会有N多WEB，N多主从关系，N多缓存，N多xxx设计就行，基本方案都是现成的，只是您比其他人厉害之处就在于设计上考虑到缓存失效时的雪崩效应、主 从同步的数据一致性和时间差、队列的稳定性和失败后的重试策略、文件存储的效率和备份方式等等意外情况。缓存总有一天会失效，数据库复制总有一天会断掉， 队列总有一天会写不进去，电源总有一天会烧坏。根据墨菲定律，如果不考虑这些，网站早晚会成为茶几。</p>
<h2 id="六、服务器软件"><a href="#六、服务器软件" class="headerlink" title="六、服务器软件"></a>六、服务器软件</h2><p>Linux、nginx、php、mysql，几乎是标配，我们除了看名字，还得选版本。Linux发行版众多，只要没特殊要求，就选个用的人最多的，社区最活跃的，配置最方便的，软件包最全最新的，例如debian、ubuntu。 至于RHEL之类的嘛，你用只能在RHEL上才能运行的软件么？剩下的nginx、php、mysql、activemq、其他的等等，除非你改过这些软 件或你的程序真的不兼容新版本，否则尽量版本越新越好，版本新，意味着新特性增多、BUG减少、性能增加。总有些道听途说的人跟你说老的版本稳定。所谓稳 定，是相对于特殊业务来说的，而就一个php写的网站，大多数人都没改过任何服务器软件源代码，绝大多数情况是能平稳的升级到新版本的。类似于jdk5到 jdk6，python2到python3这类变动比较大的升级还是比较少见的。看看ChangeLog，看看升级说明，结合自己情况评估一下，越早升级 越好，别人家都用php6写程序了这边还php4的逛游呢。优秀的开源程序升级还是很负责任的，看好文档，别怕。</p>
<p>以上这六点准备完毕，现在我们有了运行环境，有了基本架构骨架，有了备份和切换方案，应该开始着手设计开发方面的事情了。开发方面的事情无数，下一篇会先说一些重点。<br>原文地址</p>
<h2 id="七、数据库"><a href="#七、数据库" class="headerlink" title="七、数据库"></a>七、数据库</h2><p>几乎所有操作最后都要落到数据库身上，它又最难扩展（存储也挺难）。对于mysql，什么样的表用myisam，什么样的表用innodb，在开发 之前要确定。复制策略、分片策略，也要确定。表引擎方面，一般，更新不多、不需要事务的表可以用myisam，需要行锁定、事务支持的，用innodb。 myisam的锁表不一定是性能低下的根源，innodb也不一定全是行锁，具体细节要多看相关的文档，熟悉了引擎特性才能用的更好。现代WEB应用越来 越复杂了，我们设计表结构时常常设计很多冗余，虽然不符合传统范式，但为了速度考虑还是值得的，要求高的情况下甚至要杜绝联合查询。编程时得多注意数据一 致性。</p>
<p>复制策略方面，多主多从结构也最好一开始就设计好，代码直接按照多主多从来编写，用一些小技巧来避免复制延时问题，并且还要解决多数据库数据是否一致，可以自己写或者找现成的运维工具。</p>
<p>分片策略。总会有那么几个表数据量超大，这时分片必不可免。分片有很多策略，从简单的分区到根据热度自动调整，依照具体业务选择一个适合自己的。避免自增ID作为主键，不利于分片。</p>
<p>用存储过程是比较难扩展的，这种情形多发生于传统C/S，特别是OA系统转换过来的开发人员。低成本网站不是一两台小型机跑一个数据库处理所有业务的模式，是机海作战。方便水平扩展比那点预分析时间和网络传输流量要重要的多的多。</p>
<p>NoSQL。这只是一个概念。实际应用中，网站有着越来越多的密集写操作、上亿的简单关系数据读取、热备等，这都不是传统关系数据库所擅长的，于是 就产生了很多非关系型数据库，比如Redis/TC&amp;TT/MongoDB/Memcachedb等，在测试中，这些几乎都达到了每秒至少一万次 的写操作，内存型的甚至5万以上。例如MongoDB，几句配置就可以组建一个复制+自动分片+failover的环境，文档化的存储也简化了传统设计库 结构再开发的模式。很多业务是可以用这类数据库来替代mysql的。</p>
<h2 id="八、缓存"><a href="#八、缓存" class="headerlink" title="八、缓存"></a>八、缓存</h2><p>数据库很脆弱，一定要有缓存在前面挡着，其实我们优化速度，几乎就是优化缓存，能用缓存的地方，就不要再跑到后端数据库那折腾。缓存有持久化缓存、 内存缓存，生成静态页面是最容易理解的持久化缓存了，还有很多比如varnish的分块缓存、前面提到的memcachedb等，内存缓 存，memcached首当其冲。缓存更新可用被动更新和主动更新。被动更新的好处是设计简单，缓存空了就自动去数据库取数据再把缓存填上，但容易引发雪 崩效应，一旦缓存大面积失效，数据库的压力直线上升很可能挂掉。主动缓存可避免这点但是可能引发程序取不到数据的问题。这两者之间如何配合，程序设计要多 动脑筋。</p>
<h2 id="九、队列"><a href="#九、队列" class="headerlink" title="九、队列"></a>九、队列</h2><p>用户一个操作很可能引发一系列资源和功能的调动，这些调动如果同时发生，压力无法控制，用户体验也不好，可以把这样一些操作放入队列，由另几个模块 去异步执行，例如发送邮件，发送手机短信。开源队列服务器很多，性能要求不高用数据库当做队列也可以，只要保证程序读写队列的接口不变，底层队列服务可随 时更换就可以，类似Zend Framework里的Zend_Queue类，java.util.Queue接口等。</p>
<h2 id="十、文件存储"><a href="#十、文件存储" class="headerlink" title="十、文件存储"></a>十、文件存储</h2><p>除了结构化数据，我们经常要存放其他的数据，像图片之类的。这类数据数量繁多、访问量大。典型的就是图片，从用户头像到用户上传的照片，还要生成不 同的缩略图尺寸。存储的分布几乎跟数据库扩展一样艰难。不使用专业存储的情况下，基本都是靠自己的NAS。这就涉及到结构。拿图片存储举例，图片是非常容 易产生热点的，有些图片上传后就不再有人看，有些可能每天被访问数十万次，而且大量小文件的异步备份也很耗费时间。</p>
<p>为了将来图片走cdn做准备，一开始最好就将图片的域名分开，且不用主域名。很多网站都将cookie设置到了.domain.ltd，如果图片也在这个域名下，很可能因为cookie而造成缓存失效，并且占多余流量，还可能因为浏览器并发线程限制造成访问缓慢。</p>
<p>如果用普通的文件系统存储图片，有一个简单的方法。计算文件的hash值，比如md5，以结果第一位作为第一级目录，这样第一级有16个目录。从0 到F，可以把这个字母作为域名，0.yourimg.com到f.yourimg.com（客户端dns压力会增大），还可以扩展到最多16个NAS集群 上。第二级可用年月例如，201011，第三级用日，第四级可选，根据上传量，比如am/pm，甚至小时。最终的目录结构可能会是 e/201008/25/am/e43ae391c839d82801920cf.jpg。rsync备份时可以用脚本只同步某年某日某时的文件，避免计 算大量文件带来的开销。当然最好是能用专门的分布式文件系统或更专业点的存储解决方案。</p>
<p>下面，我们要谈谈代码了。</p>
<p>这一系列的最后一篇写给普通编程人员，如果不感兴趣可直接看本文最后几段。开始设计代码结构之前，先回顾一下之前准备过的事情：我们有负载均衡的 WEB服务器，有主从DB服务器并可能分片，有缓存，有可扩展的存储。在组织代码的各个方面，跟这些准备息息相关，我一二三的列出来分别说，并且每一条都 以“前面讲到”这个经典句式开头，为了方便对照。</p>
<p>别着急看经典句式，我思维跳跃了，插一段。实际开发中，我们总会在性能和代码优雅性上作折中。对于当今的计算机和语言解释器，多几层少几层对象调 用、声明变量为Map还是HashMap这种问题是最后才需要考虑的问题，永远要考虑系统最慢的部分，从最慢的部分解决。例如看看你用的ORM是不是做了 很多你用不到的事情，是不是有重复的数据调用。我们做的是web应用开发，不是底层框架API，代码易读易懂是保证质量很重要的一方面。</p>
<p>前面讲到，WEB 服务器是要做负载均衡的，图片服务器是要分开的。对于这点，代码在处理客户端状态时，不要把状态放到单机上，举例，不要用文件session，嗯，常识。 如果有可能，最好在一开始就做好用户单点认证的统一接口，包括跨域如何判断状态、静态页面如何判断状态，需要登录时的跳转和返回参数定义，底层给好接口， 应用层直接就用（可参考GAE的 user服务）。登录方面的设计要考虑移动设备的特性，比如电脑可以用浮动层窗口，但NOKIA自带的浏览器或UCWEB就无法处理这种表现形式，程序一 定既能处理AJAX请求又能直接通过URL来处理请求。图片服务器分开，资源文件最好也布局到图片服务器，也就是WEB服务器只服务动态程序。虽然开发测 试时稍微复杂（因为需要绝对URI才能访问），但将来页面前端优化上会轻松许多，并且你的WEB服务器IO优化也轻松许多。程序引用资源文件时，要有一个 统一的处理方法，在方法内部可以自动完成很多事情，例如将css/js根据组合，拼成一个文件，或者自动在生成的URI后面加上QUERYSTRING， 如果将来前端用了缓存服务，那生成QUERYSTRING是最简单的刷新服务端缓存和客户端缓存的办法。</p>
<p>前面讲到， 数据库会有复制，可能会多主多从，可能会分片。我们程序在处理数据的过程中，最好能抽象出来单独放做一层。拿现在流行的MVC模式来说，就是在M层下方再 放一个数据层，这个数据层不是通常所说的JDBC/PDO/ActiveRecord等，而是你自己的存取数据层，仅对外暴露方法，隐藏数据存取细节。这 个数据层内部不要怕写的难看，但一定要提供所有的数据存储功能，其他任何层次不要看到跟数据库打交道的字眼。之所以这样做，是因为在单关系数据库的情况 下，可能会SELECT…JOIN…或直接INSERT…INTO…，可你可能会将一些表放到key-value数据库里存储，或者分片，这么做之后原来 的语句和方式要全部改变，如果过于分散，则移植时会耗费很大精力，或得到一个很大的Model。在数据层面的设计上，尽量避免JOIN查询，我们可以多做 冗余，多做缓存，每种数据尽量只需要一次查询，然后在你的程序里面进行组合。对于比较复杂的数据组合，在实时性要求不高的情况下，可采用异步处理，用户访 问时只取处理后的结果。在对于主键的处理上，避免使用自增ID，可以用一定规则生成的唯一值当做主键，这种主键是最简单的分片分布策略。即使用自增ID， 也最好用一个自增ID发生器，否则从数据库不小心被写了一下，那主键很容易冲突。</p>
<p>前面讲到，咱数据库前面还有某些缓存挡着。别把 mysql的query cache当缓存，应用稍复杂的时候QUERY CACHE反而会成为累赘。缓存跟数据库和业务结合的很紧密，正因为跟业务关系紧密，所以这点没有放之四海而皆准的方法。但我们还是有一些规则可参照。规 则一：越接近前端，缓存的颗粒度越大。例如在WEB最前端缓存整个页面，再往后一层缓存部分页面区域，再往后缓存区域内的单条记录。因为越靠近后端，我们 的可操作性越灵活，并且变化最多的前端代码也比较方便编写。在实践中，因为产品需求变化速度非常快，迭代周期越来越短，有时很难将Controller和 Model分的那么清楚，Controller层面处理部分缓存必不可免，但要保证如果出现这种情况，Controller所操作的缓存一定不要影响其他 数据需求方，也就是要保证这个缓存数据只有这一个Controller在用。规则二：没有缓存时程序不能出错。在不考虑缓存失效引发的雪崩效应时，你的程 序要有缓存跟没缓存一个样，不能像新浪微博一样，缓存一失效，粉丝微博全空，整个应用都乱套了。在缓存必不可少的情况下，给用户出错信息都比给一个让人误 解的信息强。规则三，缓存更新要保证原子性或称作线程安全，特别是采用被动缓存的方式时，很可能两个用户访问时导致同一个缓存被更新，通常情况这不是大问 题，可缓存失效后重建时很可能是引发连锁反应的原因之一。规则四：缓存也是有成本的。不只是技术成本，还有人工时间成本。如果一个功能使用缓存和不使用， 在可预见的访问量情况下区别微小，但使用缓存会使复杂度增加，那就不用，我们可以加个TODO标注，在下次迭代的时候加上缓存处理。</p>
<p>前 面讲到，文件存储是独立的，那么所有的文件操作就都是远程调用。可以在文件服务器上提供一个很简单的RESTful接口，也可以提供xmlrpc 或json serveice，WEB服务器端所生成和处理的文件，全部通过接口通知文件服务器去处理，WEB服务器本身不要提供任何文件存储。你会发现很多大网站的 上传图片跟保存文章是分两步完成的，就是基于这个原因。</p>
<p>以上几条“前面讲到”，其实无数人都讲过，我也只是结合前几篇文章用自己的话重 复了一遍，真正分析起来精髓很简单——除了良好的功能逻辑分层，我们 还要为数据库存储、缓存、队列、文件服务等程序外层资源调用单独设计接口，你可以把你的程序想象成是运行在 Amazon EC2 上并用他的所有web service服务，你的数据库就是它的SimpleDB，你的队列就是他的SQS，你的存储就是他的S3，唯一不同是amazon的接口是远程调用，你的是内部调用。</p>
<p>将支撑服务接口化，意味着将MySQL更换到PostgreSQL不需要更改业务处理程序，移植团队甚至不需要跟业务开发团队过多沟通；意味着业务开发团队是对接口编程而不是对数据库编程；意味着不会因为某个业务开发人员的失误而拖垮性能。</p>
<p>对程序扫盲不感兴趣的直接看这里——</p>
<p>产品设计完了，程序框架搭完了，可能有矛盾在这个节骨眼儿产生了。不断有产品设计抱怨说他的创意没实现到预期效果，有程序员抱怨说产品设计不切实 际。这种抱怨多缘于产品人员不懂技术，技术人员不理解产品。从广义上来讲，产品包含市场策略、营销手段、功能设计，产品和技术在争论时往往把焦点放在功能 上，而实际重点是，实现这个功能所消耗的成本跟能这个功能带来的利益能否换算，能否取其轻重。若可以，争议解决。若不能，则抛硬币看运气。因为一个功能的 加强而引发指标井喷，或因项目拖延而导致贻误战机的例子比比皆是。激进的决策者注重利益，保守的决策者注重损失，聪明的决策者会考虑这个问题是否真的那么 严重。</p>
<p>关系到未来的事情谁都说不准，要不怎么说entrepreneurship一半靠运气呢。不过总有能说的准的事情，那就得靠数据说话。</p>
<p>没有100%也有99.9%的网站安装了访问统计代码，连我的 <a href="http://zhiyi.us" target="_blank" rel="external">http://zhiyi.us</a> 也不例外，新闻联播也总说科学决策科学发展的。有了统计，能确定的事情就很多了。例如，可以根据来源-目标转化率来分析哪类渠道的人均获取成本低，根据来 源-内容访问猜测用户跳出率原因，根据用户点击行为判断链接位置是否合理等。将数据以不同方式组合起来，找到内在联系，分析内因外因，制定对应策略，减少 拍脑门决策。靠数据支撑运营是个非常专业的事情，虽然不懂深奥的数学模型不会复杂的公式计算，渐渐学会因为A所以B，因为A和B所以C还是相对简单的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/08/02/大负载高并发网站的前期准备/" data-id="cj89jua4q001isf2noi26urje" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/entrepreneurship/">entrepreneurship</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-文件上传OSS 三部曲（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/文件上传OSS 三部曲（三）/" class="article-date">
  <time datetime="2016-08-01T16:00:00.000Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/文件上传OSS 三部曲（三）/">文件上传OSS三部曲（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<p>最近在做这个新闻模块，编辑新闻的实现采用了ueditor富文本编辑器。<br>因为ueditor支持服务器本地存储上传文件（在新闻主题中插入的图片），和七牛云OSS存储，并不支持阿里云OSS存储，由于项目依托在阿里云的各种服务上，便于一个账号管理使用的阿里云OSS，没有使用七牛云，此时就需要我们的一些动手能力，给ueditor集成上对aliyunOSS的支持。<br>首先下载<a href="http://ueditor.baidu.com" target="_blank" rel="external">ueditor</a>。<br>在这里没有使用组件化开发，因为富文本编辑器一般不会有什么巨大的漏洞，用户能实现常用的编辑文字和添加样式的功能即可。只需在页面引入几个js文件即可使用。<br><strong>示例：</strong></p>
<h3 id="1-blade模板载入编辑器"><a href="#1-blade模板载入编辑器" class="headerlink" title="1.blade模板载入编辑器"></a>1.blade模板载入编辑器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123;asset(&apos;ueditor/ueditor.config.js&apos;)&#125;&#125;&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123;asset(&apos;ueditor/ueditor.all.min.js&apos;)&#125;&#125;&quot;&gt; &lt;/script&gt;</div><div class="line">&lt;script id=&quot;content&quot; name=&quot;content&quot; type=&quot;text/plain&quot;&gt;</div><div class="line">@if(!empty($new))</div><div class="line">&#123;!! $new-&gt;content !!&#125;</div><div class="line">@endif</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;!-- 实例化编辑器 --&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">UE.getEditor(&apos;content&apos;,&#123;</div><div class="line">initialFrameWidth : 800,</div><div class="line">initialFrameHeight : 400,</div><div class="line"></div><div class="line">&#125;);</div><div class="line">var ue = UE.getEditor(&apos;content&apos;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>将你编辑后需要保存的的内容添加name属性在id=content的<code>&lt;script&gt;</code>标签内。   </p>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>查看ueditor的./php/目录可知Uploader.class.php是它的上传文件工具类。对其进行改造。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line">     * 上传文件的主处理方法</div><div class="line">     * @return mixed</div><div class="line">     */</div><div class="line">    private function upFile()</div><div class="line">    &#123;</div><div class="line">        $file = $this-&gt;file = $_FILES[$this-&gt;fileField];</div><div class="line">        if (!$file) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_FILE_NOT_FOUND&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if ($this-&gt;file[&apos;error&apos;]) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo($file[&apos;error&apos;]);</div><div class="line">            return;</div><div class="line">        &#125; else if (!file_exists($file[&apos;tmp_name&apos;])) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_TMP_FILE_NOT_FOUND&quot;);</div><div class="line">            return;</div><div class="line">        &#125; else if (!is_uploaded_file($file[&apos;tmp_name&apos;])) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_TMPFILE&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $this-&gt;oriName = $file[&apos;name&apos;];</div><div class="line">        $this-&gt;fileSize = $file[&apos;size&apos;];</div><div class="line">        $this-&gt;fileType = $this-&gt;getFileExt();</div><div class="line">//        $this-&gt;fullName = $this-&gt;getFullName();</div><div class="line">        $this-&gt;filePath = $this-&gt;getFilePath();</div><div class="line">        $this-&gt;fileName = $this-&gt;getFileName();</div><div class="line">        $dirname = dirname($this-&gt;filePath);</div><div class="line"></div><div class="line">        //检查文件大小是否超出限制</div><div class="line">        if (!$this-&gt;checkSize()) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_SIZE_EXCEED&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //检查是否不允许的文件格式</div><div class="line">        if (!$this-&gt;checkType()) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_TYPE_NOT_ALLOWED&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // //创建目录失败</div><div class="line">        // if (!file_exists($dirname) &amp;&amp; !mkdir($dirname, 0777, true)) &#123;</div><div class="line">        //     $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_CREATE_DIR&quot;);</div><div class="line">        //     return;</div><div class="line">        // &#125; else if (!is_writeable($dirname)) &#123;</div><div class="line">        //     $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_DIR_NOT_WRITEABLE&quot;);</div><div class="line">        //     return;</div><div class="line">        // &#125;</div><div class="line">        //</div><div class="line">        // //移动文件</div><div class="line">        // if (!(move_uploaded_file($file[&quot;tmp_name&quot;], $this-&gt;filePath) &amp;&amp; file_exists($this-&gt;filePath))) &#123; //移动失败</div><div class="line">        //     $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_FILE_MOVE&quot;);</div><div class="line">        // &#125; else &#123; //移动成功</div><div class="line">        //     $this-&gt;stateInfo = $this-&gt;stateMap[0];</div><div class="line">        // &#125;</div><div class="line">        //        include_once(&apos;../../../app/Services/oss.php&apos;);</div><div class="line">        //        \App\Services\OSS::upload($osspath, $serverpath);</div><div class="line">        include_once(&quot;oss.php&quot;);</div><div class="line">        //取得临时地址</div><div class="line">        $serverpath = $file[&quot;tmp_name&quot;];</div><div class="line">        //获得文件类型</div><div class="line">        $titles = $this-&gt;fileType;</div><div class="line">        //拼接文件名</div><div class="line">        $key = time() . rand(10000, 99999999) .$titles;</div><div class="line">        //上传文件夹路径</div><div class="line">        $osspath = &quot;news/content/&quot; . $key;</div><div class="line">        //上传结果</div><div class="line">        $result = OSS::upload($osspath, $serverpath);</div><div class="line">        //拼接url</div><div class="line">        $this-&gt;fullName = &apos;http://yourself-bucket-name.oss-cn-beijing.aliyuncs.com/&apos;.$osspath;</div><div class="line">        //判断结果，给定返回值。</div><div class="line">        if ($result) &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;stateMap[0];</div><div class="line">            &#125; else &#123;</div><div class="line">            $this-&gt;stateInfo = $this-&gt;getStateInfo(&quot;ERROR_FILE_MOVE&quot;);</div><div class="line">        &#125;</div><div class="line">				//上传后，删除临时文件</div><div class="line">       /* @unlink($file[&quot;tmp_name&quot;]);*/</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>此处要注意修改并维持页面回调当前上传文件的各项信息getFileInfo()方法内的参数。</p>
<h3 id="3-添加oss-php"><a href="#3-添加oss-php" class="headerlink" title="3.添加oss.php"></a>3.添加oss.php</h3><p>在php的目录下新建oss.php文件，给ueditor添加阿里云oss的支持。  </p>
<pre><code>&lt;?php
/*
  time: 2016-12-30
  author: 马闯
  blog: martist.cn
*/
require_once(&apos;../../../vendor/autoload.php&apos;);

use JohnLui\AliyunOSS\AliyunOSS;

class OSS
{

    private $ossClient;
    private static $bucketName;
    public $ossServer = &apos;http://oss-cn-beijing.aliyuncs.com&apos;;                   // 外网
    public $ossServerInternal = &apos;http://oss-cn-beijing-internal.aliyuncs.com&apos;;       // 内网
    public $AccessKeyId = &apos;wwwwwwwwwwww&apos;;                      // key
    public $AccessKeySecret = &apos;wwwwwwwwwwwww&apos;;          // secret
    public $BucketName = &apos;bucket&apos;;                // bucket
    public function __construct($isInternal = false)
    {
        $serverAddress = $isInternal ? $this -&gt; ossServerInternal : $this -&gt; ossServer;
        $this-&gt;ossClient = AliyunOSS::boot(
            $serverAddress,
            $this -&gt; AccessKeyId,
            $this -&gt; AccessKeySecret
        );
    }

    public static function upload($ossKey, $filePath)
    {
        $oss = new OSS(false); // 上传文件使用内网，免流量费
        $oss-&gt;ossClient-&gt;setBucket(&apos;weiyuyan&apos;);
        $res = $oss-&gt;ossClient-&gt;uploadFile($ossKey, $filePath);
        return $res;
    }

    /**
     * 直接把变量内容上传到oss
     * @param $osskey
     * @param $content
     */
    public static function uploadContent($osskey, $content)
    {
        $oss = new OSS(false); // 上传文件使用内网，免流量费
        $oss-&gt;ossClient-&gt;setBucket($this -&gt; BucketName);
        $oss-&gt;ossClient-&gt;uploadContent($osskey, $content);

    }

    /**
     * 删除存储在oss中的文件
     *
     * @param string $ossKey 存储的key（文件路径和文件名）
     * @return
     */
    public static function deleteObject($ossKey)
    {
        $oss = new OSS(false); // 上传文件使用内网，免流量费

        return $oss-&gt;ossClient-&gt;deleteObject($this -&gt; BucketName, $ossKey);
    }

    /**
     * 复制存储在阿里云OSS中的Object
     *
     * @param string $sourceBuckt 复制的源Bucket
     * @param string $sourceKey - 复制的的源Object的Key
     * @param string $destBucket - 复制的目的Bucket
     * @param string $destKey - 复制的目的Object的Key
     * @return Models\CopyObjectResult
     */
    public function copyObject($sourceBuckt, $sourceKey, $destBucket, $destKey)
    {
        $oss = new OSS(true); // 上传文件使用内网，免流量费

        return $oss-&gt;ossClient-&gt;copyObject($sourceBuckt, $sourceKey, $destBucket, $destKey);
    }

    /**
     * 移动存储在阿里云OSS中的Object
     *
     * @param string $sourceBuckt 复制的源Bucket
     * @param string $sourceKey - 复制的的源Object的Key
     * @param string $destBucket - 复制的目的Bucket
     * @param string $destKey - 复制的目的Object的Key
     * @return Models\CopyObjectResult
     */
    public function moveObject($sourceBuckt, $sourceKey, $destBucket, $destKey)
    {
        $oss = new OSS(true); // 上传文件使用内网，免流量费

        return $oss-&gt;ossClient-&gt;moveObject($sourceBuckt, $sourceKey, $destBucket, $destKey);
    }

    public static function getUrl($ossKey)
    {
        $oss = new OSS();
        $oss-&gt;ossClient-&gt;setBucket($this -&gt; BucketName);
        return $oss-&gt;ossClient-&gt;getUrl($ossKey, new \DateTime(&quot;+1 day&quot;));
    }

    public static function createBucket($bucketName)
    {
        $oss = new OSS();
        return $oss-&gt;ossClient-&gt;createBucket($bucketName);
    }

    public static function getAllObjectKey($bucketName)
    {
        $oss = new OSS();
        return $oss-&gt;ossClient-&gt;getAllObjectKey($bucketName);
    }

    /**
     * 获取指定Object的元信息
     *
     * @param  string $bucketName 源Bucket名称
     * @param  string $key 存储的key（文件路径和文件名）
     * @return object 元信息
     */
    public static function getObjectMeta($bucketName, $osskey)
    {
        $oss = new OSS();
        return $oss-&gt;ossClient-&gt;getObjectMeta($bucketName, $osskey);
    }

}
</code></pre><p>ok ! 这样便实现了在ueditor中集成阿里云oss文件上传的功能。<br><strong>Thanks</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/08/02/文件上传OSS 三部曲（三）/" data-id="cj89jua4y001vsf2njhe4jlhv" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-创业圈，什么是“天派”“地派”？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/01/创业圈，什么是“天派”“地派”？/" class="article-date">
  <time datetime="2016-07-31T16:00:00.000Z" itemprop="datePublished">2016-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/entrepreneurship/">entrepreneurship</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/01/创业圈，什么是“天派”“地派”？/">entrepreneurship圈，什么事天派和地派</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<h2 id="天派"><a href="#天派" class="headerlink" title="天派"></a>天派</h2><p>就是基本是融资能力大于赚钱能力，但他知道用户很重要，商业模式很重要，要快速发展，所以要快速的，不赚钱也可以上市，不赚钱也能成功，只要用户多，所以互联网的这种思维，我们叫“天派”，叫天马行空一样。  </p>
<h2 id="地派"><a href="#地派" class="headerlink" title="地派"></a>地派</h2><p>的传统企业我们认为他们脚踏实地，能够让企业持久、稳健增长，但是爆发力不够。  </p>
<p>“天派”是爆发力很够，但是他的这种稳健性不够。后来我就慢慢的把这个黑马营的两种人总结为“天派”和“地派”，我们后来开玩笑说黑马营就是天地汇，汇是汇合的汇。希望互联网思维和传统企业的产业理解能够融合在一起，他们同学之间互相取长补短、互相学习。   </p>
<p>最后我发现到一期毕业的时候他们彼此之间互相学习很多，融合很好，到现在我们就发现都分不清楚哪是纯粹的“天派”，哪是纯粹的“地派”了。比如戴赛鹰理论上讲他是“地派”，但是他的三个爸爸是融资最成功的一家公司，而且他的发展最快，他完全用互联网的方式做了一个智能硬件的公司，三个爸爸的净化器。然后现在又做了一个儿童的机器人，他的速度在一年多时间融资很快，你感觉戴赛鹰不再是一个卖东西的人，是一个会做用户的人。我们另外几个“天派”的高大上的，他们都高大上，但是他们企业发展都很稳健，都没有说下一步财融不到就会有问题，他们的这个经营思路我觉得更像今天中国这几种特色。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/08/01/创业圈，什么是“天派”“地派”？/" data-id="cj89jua4d000zsf2n6o2j9o4t" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/entrepreneurship/">entrepreneurship</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-同步与异步，阻塞与非阻塞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/24/同步与异步，阻塞与非阻塞/" class="article-date">
  <time datetime="2016-07-24T01:28:51.000Z" itemprop="datePublished">2016-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/24/同步与异步，阻塞与非阻塞/">同步与异步，阻塞和非阻塞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<h1 id="老张喝茶-教你同步异步-阻塞与非阻塞"><a href="#老张喝茶-教你同步异步-阻塞与非阻塞" class="headerlink" title="老张喝茶 教你同步异步 阻塞与非阻塞"></a>老张喝茶 教你同步异步 阻塞与非阻塞</h1><p>老张爱喝茶，废话不说，煮开水。</p>
<p>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p>
<h4 id="1-老张把水壶放到火上，立等水开。（同步阻塞）"><a href="#1-老张把水壶放到火上，立等水开。（同步阻塞）" class="headerlink" title="1 老张把水壶放到火上，立等水开。（同步阻塞）"></a>1 老张把水壶放到火上，立等水开。（同步阻塞）</h4><p>老张觉得自己有点傻</p>
<h4 id="2-老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）"><a href="#2-老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）" class="headerlink" title="2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）"></a>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</h4><p>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀 ~ ~ ~ ~ 的噪音。</p>
<h4 id="3-老张把响水壶放到火上，立等水开。（异步阻塞）"><a href="#3-老张把响水壶放到火上，立等水开。（异步阻塞）" class="headerlink" title="3 老张把响水壶放到火上，立等水开。（异步阻塞）"></a>3 老张把响水壶放到火上，立等水开。（异步阻塞）</h4><p>老张觉得这样傻等意义不大</p>
<h4 id="4-老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）"><a href="#4-老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）" class="headerlink" title="4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）"></a>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</h4><p>老张觉得自己<strong> 聪明 </strong>了。  </p>
<p>所谓同步异步，只是对于水壶而言。</p>
<p>普通水壶，同步；响水壶，异步。</p>
<p>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。</p>
<p>同步只能让调用者去轮询自己，造成老张效率的低下。   </p>
<p>所谓阻塞非阻塞，仅仅对于老张而言。         </p>
<p><table></table></p>
<p><tr><td>情景</td><td>状态</td></tr></p>
<p><tr><td>立等的老张</td><td>阻塞</td></tr></p>
<p><tr><td>看电视的老张</td><td>非阻塞</td></tr><br><br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。<br>程序员写程序，很多情况下，老张和水壶都要涉及，即调用者与被调用者。四种组合模式各有所长。</p>
<p>这个例子和银行排队有异曲同工之妙，可是我觉得这个会比较容易理解一些。</p>
<p>老张一次比一次聪明，我承认跟老张很像。刚开始的情况逻辑比较简单，但效率低下。随着慢慢的提高，效率也提高了。所以个人认为，程序的效率和简单程度是成反比的。</p>
<p>但不是说异步非阻塞就一定是最好的，有的情况下更适合使用同步或者阻塞。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/07/24/同步与异步，阻塞与非阻塞/" data-id="cj89jua4g0014sf2nwb70voia" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-文件上传OSS 三部曲（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/26/文件上传OSS 三部曲（二）/" class="article-date">
  <time datetime="2016-05-25T16:00:00.000Z" itemprop="datePublished">2016-05-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/26/文件上传OSS 三部曲（二）/">文件上传OSS三部曲（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<p>本文讲解如何讲解客户端文件上传aliOSS。<br><strong>要点</strong><br>签名在服务端（php）完成，然后直接通过表单上传到OSS 。<br><strong>背景</strong><br>每个用OSS的用户，都会用到上传。由于是网页上传，其中包括一些APP里面的html5页面，对上传的需求很强烈，很多人采用的做法是用户在浏览器／APP上传到应用服务器，然后应用服务器再把文件上传到OSS。<br><img src="http://ohszpnte4.bkt.clouddn.com/image/c436b7458bdf5f618711bf2d949688cd.png" alt=""></p>
<blockquote>
<p>这种方法有三个<strong>缺点</strong>，<br>第一：上传慢，先上传到应用服务器，再上传到OSS，网络传送多了一倍，而且OSS是采用BGP带宽，能保证各地各运营商的速度。<br>第二：扩展性不好，如果后续用户多了，应用服务器会成为瓶颈。<br>第三：费用高，因为OSS上传流量是免费的。如果数据直传到OSS，不走应用服务器。那么将能省下几台应用服务器。 </p>
</blockquote>
<p>相对于文件上传三部曲（一）的操作，我们提出<strong>改进方案</strong>：</p>
<blockquote>
<p>客户端用JS直接签名，然后上传到OSS </p>
</blockquote>
<p><img src="http://ohszpnte4.bkt.clouddn.com/image/e796006d97c90765aa0bb498b70495c2.png" alt=""></p>
<p>OSS的PostObject API细节可以参照(看不懂没有关系)：<br><a href="https://docs.aliyun.com/#/pub/oss/api-reference/object&amp;PostObject" target="_blank" rel="external">https://docs.aliyun.com/#/pub/oss/api-reference/object&amp;PostObject</a><br>这里有一个很严重的安全隐患。就是OSS AccessId/AccessKey暴露在前端页面。可以随意拿到accessid/accesskey. 这是非常不安全的做法<br>将此例子进化，签名及上传policy从后端php代码取。<br>请求逻辑是：<br>1.客户端要上传图片时,到应用服务器取上传的policy及签名<br>2.客户端拿到签名直接上传到OSS<br><img src="http://ohszpnte4.bkt.clouddn.com/image/863ca729c4b943e6ae34516ed461b18e.png" alt=""><br><strong>示例</strong>                              </p>
<p>直接用网页访问：<a href="http://oss-demo.aliyuncs.com/oss-h5-upload-js-php/index.html" target="_blank" rel="external">http://oss-demo.aliyuncs.com/oss-h5-upload-js-php/index.html</a>  </p>
<p>用手机测试该上传是否有效。二维码：可以用手机(微信，QQ，手机浏览器等）扫一扫试试（这个不是广告，只是上述网址的二维码。这为了让大家看一下这个实现能在手机端完美运行。）<br>文件上传是上传到一个测试的公共 bucket , 会定时清理，所以不要传一些敏感及重要数据<br><img src="http://ohszpnte4.bkt.clouddn.com/image/3ada2871d6b39a6a1ee765410dbe52b8.png" alt=""><br><strong>原理 </strong></p>
<p>设置plupload 上传参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">multipart_params: &#123;</div><div class="line">    &apos;key&apos; : key + &apos;$&#123;filename&#125;&apos;　//后面会介绍到，key是应用服务器返回的，指定用户必须以这个前缀上传文件。</div><div class="line">    &apos;policy&apos;: policyBase64,</div><div class="line">    &apos;OSSAccessKeyId&apos;: accessid,</div><div class="line">    &apos;success_action_status&apos; : &apos;200&apos;, //让服务端返回200,不然，默认会返回204</div><div class="line">    &apos;signature&apos;: signature,</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>js最主要是从后端取到policyBase64, 及accessid,及signature这三个变量。 往后端取这三个变量核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">phpUrl = &apos;./php/get.php&apos;</div><div class="line">        xmlhttp.open( &quot;GET&quot;, phpUrl, false );</div><div class="line">        xmlhttp.send( null );</div><div class="line">        var obj = eval (&quot;(&quot; + xmlhttp.responseText+ &quot;)&quot;);</div><div class="line">        host = obj[&apos;host&apos;]</div><div class="line">        policyBase64 = obj[&apos;policy&apos;]</div><div class="line">        accessid = obj[&apos;accessid&apos;]</div><div class="line">        signature = obj[&apos;signature&apos;]</div><div class="line">        expire = parseInt(obj[&apos;expire&apos;])</div><div class="line">        key = obj[&apos;dir&apos;]</div></pre></td></tr></table></figure></p>
<p> 现在咱们来一起解析一下xmlhttp.responseText（这个是我设计的范围，并不一定要求是以下的格式，但是必须有signature, accessid, policy这三个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;accessid&quot;:&quot;6MKOqxGiGU4AUk44&quot;,</div><div class="line">&quot;host&quot;:&quot;http://post-test.oss-cn-hangzhou.aliyuncs.com&quot;,</div><div class="line">&quot;policy&quot;:&quot;eyJleHBpcmF0aW9uIjoiMjAxNS0xMS0wNVQyMDoyMzoyM1oiLCJjxb25kaXRpb25zIjpbWyJjcb250ZW50LWxlbmd0aC1yYW5nZSIsMCwxMDQ4NTc2MDAwXSxbInN0YXJ0cy13aXRoIiwiJGtleSIsInVzZXItZGlyXC8iXV19&quot;,</div><div class="line">&quot;signature&quot;:&quot;I2u57FWjTKqX\/AE6doIdyff151E=&quot;,</div><div class="line">&quot;expire&quot;:1446726203,&quot;dir&quot;:&quot;user-dir/&quot;&#125;</div></pre></td></tr></table></figure>
<p>第一个变量accessid: 指的用户请求的accessid,注意单知道accessid, 对数据不会有影响。<br>第二个变量host: 指的是用户要往哪个域名发往上传请求。<br>第三个变量policy:指的是用户表单上传的策略policy, 是经过base64编码过的字符串<br>第四个变更signature:是对上述第三个变量policy签名后的字符串<br>第五个变量expire:指的是当前上传策略失效时间，这个变量，并不是用来发送到OSS，因为这个已经指定在policy里面，这个变量的含义，后面讲。 </p>
<p>现在咱们分析一下policy的内容，将其解码后的内容是： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;expiration&quot;:&quot;2015-11-05T20:23:23Z&quot;,</div><div class="line">&quot;conditions&quot;:[[&quot;content-length-range&quot;,0,1048576000],</div><div class="line">[&quot;starts-with&quot;,&quot;$key&quot;,&quot;user-dir\/&quot;]]</div></pre></td></tr></table></figure>
<p>这里有一个关键的地方，PolicyText指定了该Policy 上传失效的最终时间。即在这个失效时间之前，都可以利用这个policy上传文件，所以没有必要每次上传，都去后端取签名。减少后端的压力。在这里我的设计是：初始化上传时，每上传一个文件后，取一次签名。然后再上传时，将当前时间跟签名时间对比，看是签名时间是否失效了。如果失效了，就重新取一次签名，如果没有失效就不取。这里就用到了第五个变量expire </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">now = timestamp = Date.parse(new Date()) / 1000;</div><div class="line">[color=#000000]//可以判断当前expire是否超过了当前时间,如果超过了当前时间,就重新取一下.3s 做为缓冲[/color]</div><div class="line">    if (expire &lt; now + 3)</div><div class="line">&#123;  </div><div class="line">　　   .....</div><div class="line">　　   phpUrl = &apos;./php/get.php&apos;</div><div class="line">　　   xmlhttp.open( &quot;GET&quot;, phpUrl, false );</div><div class="line">　　   xmlhttp.send( null );</div><div class="line">　　   ......</div><div class="line">&#125;</div><div class="line">return .</div></pre></td></tr></table></figure>
<p> 再看一下上面policy 的内容比上面增加了starts-with, 这个指定此次上传的文件名，必须是user-dir开头（这个字符串，用户可以自己指定）<br>　为什么要增加这个的含义是：很多场景，一个应用一个bucket,不同用户的数据，为了防止数字覆盖，每个人上传到OSS，可以有特定的前缀。那么问题来了，那用户获取到这个policy后，是不是在失效期内，都能修改上传前缀，从而上传到别人的目录呢？所以，应用服务器可以在上传时就指定让用户传文件时，必须是某个前缀。如果用户拿到了policy他也没有办法上传别人的前缀上。保证了数据的安全性。 </p>
<p> 代码下载：<a href=" http://blogxiao.oss-cn-shanghai.aliyuncs.com/oss-h5-upload-js-php.tar.gz" target="_blank" rel="external">Touch Me</a><br> <hr><br> <strong>注意，下面实战讲解：</strong><br> <strong>注意，下面实战讲解：</strong><br> <strong>注意，下面实战讲解：</strong><br> 最近在做一个entrepreneurship公司网站的新闻模块，新闻视频采用了这种直传的方式。<br> 在这贴上我的代码好了<br> <strong>控制器：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">     * 视频上传</div><div class="line">     * */</div><div class="line"></div><div class="line">    public function gmt_iso8601($time) &#123;</div><div class="line">        $dStr = date(&apos;Y-m-d H:i:s&apos;,$time);</div><div class="line">        $expiration = str_replace(&quot; &quot;,&quot;T&quot;,$dStr);</div><div class="line">       return $expiration.&quot;Z&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public function ueditor()&#123;</div><div class="line">        return view(&apos;admin.news.ueditor&apos;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    public function upload()</div><div class="line">    &#123;</div><div class="line">        $id= &apos;xxxxxxxxxxxxx;</div><div class="line">        $key= &apos;CCCCCCCCCCCCCCCC&apos;;</div><div class="line">        $host = &apos;http://youself.oss-cn-beijing.aliyuncs.com&apos;;</div><div class="line"></div><div class="line">       $now = time();</div><div class="line">        $expire = 30; //设置该policy超时时间是30s. 即这个policy过了这个有效时间，不能访问</div><div class="line">        $end = $now + $expire;</div><div class="line">        $expiration = $this-&gt;gmt_iso8601($end);</div><div class="line">        $dir = &apos;news/video/&apos;;</div><div class="line"></div><div class="line">        //最大文件大小.用户可以自己设置</div><div class="line">        $condition = array(0=&gt;&apos;content-length-range&apos;, 1=&gt;0, 2=&gt;1048576000);</div><div class="line">        $conditions[] = $condition;</div><div class="line"></div><div class="line">        //表示用户上传的数据,必须是以$dir开始, 不然上传会失败,这一步不是必须项,只为了安全起见,防止用户通过policy上传到别人的目录</div><div class="line">        $start = array(0=&gt;&apos;starts-with&apos;, 1=&gt;&apos;$key&apos;, 2=&gt;$dir);</div><div class="line">        $conditions[] = $start;</div><div class="line"></div><div class="line"></div><div class="line">        $arr = array(&apos;expiration&apos;=&gt;$expiration,&apos;conditions&apos;=&gt;$conditions);</div><div class="line">        //echo json_encode($arr);</div><div class="line">        //return;</div><div class="line">        $policy = json_encode($arr);</div><div class="line">        $base64_policy = base64_encode($policy);</div><div class="line">        $string_to_sign = $base64_policy;</div><div class="line">        $signature = base64_encode(hash_hmac(&apos;sha1&apos;, $string_to_sign, $key, true));</div><div class="line"></div><div class="line">        $response = array();</div><div class="line">        $response[&apos;accessid&apos;] = $id;</div><div class="line">        $response[&apos;host&apos;] = $host;</div><div class="line">        $response[&apos;policy&apos;] = $base64_policy;</div><div class="line">        $response[&apos;signature&apos;] = $signature;</div><div class="line">        $response[&apos;expire&apos;] = $end;</div><div class="line">        //这个参数是设置用户上传指定的前缀</div><div class="line">        $response[&apos;dir&apos;] = $dir;</div><div class="line">        echo json_encode($response);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p> <strong>blade模板</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> @section(&apos;script&apos;)</div><div class="line"> //引入js</div><div class="line">    &lt;script src=&apos;&#123;&#123; asset(&apos;js/htmlToOSS/lib/plupload-2.1.2/js/plupload.full.min.js&apos;)&#125;&#125;&apos;&gt;&lt;/script&gt;&quot; +</div><div class="line">    &quot;&lt;script src=&apos;&#123;&#123; asset(&apos;js/htmlToOSS/upload.js&apos;)&#125;&#125;&apos;&gt;&lt;/script&gt;</div><div class="line">@endsection</div><div class="line">```  </div><div class="line"></div><div class="line"> form表单：</div></pre></td></tr></table></figure></p>
<p> <table class="table table-bordered table-striped table-hover"><br>                  <tr><br>                      <td><br>                      <div style="display:none"><br>                          <form name="theform"><br>                              <input type="radio" name="myradio" value="local_name" checked="true/"> 上传文件名字保持本地文件名字<br>                              <input type="radio" name="myradio" value="random_name"> 上传文件名字是随机文件名, 后缀保留<br>                          </form><br>                      </div></td></tr></table></p>
<pre><code>      &lt;h4&gt;如有新闻视频,在此飞快上传：&lt;/h4&gt;
      &lt;div id=&quot;ossfile&quot;&gt;你的浏览器不支持flash,Silverlight或者HTML5！因此不能使用该浏览器进行视频文件上传！&lt;/div&gt;

      &lt;br/&gt;

      &lt;div id=&quot;container&quot; style=&quot;margin-bottom: 20px;&quot;&gt;
          &lt;a id=&quot;selectfiles&quot; href=&quot;javascript:void(0);&quot; class=&apos;btn&apos;&gt;选择文件&lt;/a&gt;
          &lt;a id=&quot;postfiles&quot; href=&quot;javascript:void(0);&quot; class=&apos;btn&apos;&gt;开始上传&lt;/a&gt;
      &lt;/div&gt;

      &lt;pre id=&quot;console&quot;&gt;&lt;/pre&gt;
      &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>```</p>
<p><strong> 附录</strong><br><a href="https://bbs.aliyun.com/read/262307.html?spm=5176.bbsl211.0.0.8gmdkz" target="_blank" rel="external">OSS官链</a><br><a href="https://promotion.aliyun.com/ntms/act/ossdoclist.html" target="_blank" rel="external">OSS用户成长</a></p>
<p><strong>Thanks</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/05/26/文件上传OSS 三部曲（二）/" data-id="cj89jua50001xsf2nz01313uu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-文件上传OSS三部曲（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/22/文件上传OSS三部曲（一）/" class="article-date">
  <time datetime="2016-05-21T16:00:00.000Z" itemprop="datePublished">2016-05-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/22/文件上传OSS三部曲（一）/">文件上传OSS三部曲（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<p><strong>对象存储</strong>（Object Storage Service，简称OSS），是阿里云对外提供的海量、安全和高可靠的云存储服务。RESTful API的平台无关性，容量和处理能力的弹性扩展，按实际容量付费真正使您专注于核心业务。   </p>
<p>第一步，给大家普及下<strong>OSS大法好</strong>：  </p>
<p><pre></pre></p>
<pre><code>___     __    _                                    ____    _____   _____
</code></pre><p>   /   |   / /   (<em>)   <strong>  </strong>  <strong>  </strong>   <strong>__          / </strong> \  / __</em>/  / <strong>_/<br>  / /| |  / /   / /   / / / / / / / /  / </strong> \        / / / /  _<em> \   __ \<br> / __</em> | / /   / /   / /<em>/ / / /</em>/ /  / / / /       / /<em>/ /  __</em>/ /  <strong><em>/ /<br>/</em>/  |<em>|/</em>/   /_/    \</strong>, /  _<em>,</em>/  /<em>/ /</em>/        _<strong>_/  /__</strong>/  /<strong><strong>/<br>                    /</strong></strong>/<br></p>
<table><br><br>      <thead><br>      <tr><br>        <th style="width: 200px"></th><br>        <th><i class="icon-oss-big margin-right"></i>对象存储 OSS</th><br>        <th>自建服务器存储</th><br><br><br>      </tr><br>      </thead><br><br>      <tbody><br><br><br>      <tr><br>        <td style="width: 200px"><h3><img src="//img.alicdn.com/tps/TB1QMVOKXXXXXbwXFXXXXXXXXXX-32-32.png">可靠性</h3></td><br>        <td>服务可用性不低于<b>99.9%</b>。<br>规模自动扩展，不影响对外服务；<br>数据持久性不低于<b>99.99999999%</b>。数据自动<b>多重冗余备份</b></td><br>        <td>受限于硬件可靠性，易出问题，一旦出现磁盘坏道，容易出现不可逆转的数据丢失。<br>人工数据恢复困难、耗时、耗力。</td><br><br><br>      </tr><br><br>      <tr><br>        <td style="width: 200px"><h3><img src="//img.alicdn.com/tps/TB1oGFWKXXXXXbxXpXXXXXXXXXX-32-32.png">安全</h3></td><br>        <td>提供企业级<b>多层次安全防护</b>，多用户资源隔离机制;支持<b>跨区域复制、异地容灾</b>机制 <br>提供多种鉴权和授权机制及白名单、防盗链、主子账号功能</td><br>        <td>清洗和黑洞设备需要另外购买，价格昂贵<br>安全机制需要单独实现，开发和维护成本高</td><br><br><br>      </tr><br><br>      <tr><br>        <td style="width: 200px"><h3><img src="//img.alicdn.com/tps/TB1dOXJKXXXXXXvXVXXXXXXXXXX-32-32.png">成本</h3></td><br>        <td><b>高性价比</b>最低只需要0.14/GB/月<br><b>多线BGP</b>骨干网络，无带宽限制，<b>上行流量免费</b><br>无需运维人员与托管费用，<b>0成本运维</b></td><br>        <td>一次性投入高，资源利用率很低 <br>存储受硬盘容量限制，需人工扩容 <br>单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容 <br>需专人运维，成本高</td><br><br><br>      </tr><br><br>      <tr><br>        <td style="width: 200px"><h3><img src="//img.alicdn.com/tps/TB15S64KXXXXXcrXpXXXXXXXXXX-32-32.png">数据处理能力</h3></td><br>        <td>提供图片处理、音视频转码、内容加速分发、鉴黄服务、归档服务等<b>多种数据增值服务</b>，并不断丰富中</td><br>        <td>需要额外采购，单独部署</td><br>                </tr><br>      </tbody><br>    </table>

<p><br><br>OSS是什么？  它相对自建服务器存储优势在哪里？  我们怎么使用OSS？<br>一些详细深入的介绍，可见阿里云官网（在看完本文可以初步使用后，你再去深入了解，现在不要走吖吖吖）。<a href="https://www.aliyun.com/product/oss/" target="_blank" rel="external">Touch me</a><br><strong>环境：</strong><br>在lnmp环境下基于laravel5.1LTS框架。当然，该组件支持php任何框架。</p>
<p><strong>安装：</strong>      </p>
<pre><code>composer require &quot;johnlui/aliyun-oss&quot;      
</code></pre><p><strong>配置：</strong><br>此处可参考作者推荐配置方式，详情请点击<a href="https://packagist.org/packages/johnlui/aliyun-oss" target="_blank" rel="external">Touch me</a><br>此处把composer链接引用过来，并贴上部分aliyunoss组件文章的部分代码，是为了让初学者不需要页面切换，只需要看一篇教程，就可以学到怎样使用OSS，增强可读性。<br><strong>构建 Service 文件：</strong><br>新建 app/services/OSS.php：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">namespace App\Services;</div><div class="line">use JohnLui\AliyunOSS\AliyunOSS;</div><div class="line">use Config;</div><div class="line">class OSS &#123;</div><div class="line">  private $ossClient;</div><div class="line">  public function __construct($isInternal = false)</div><div class="line">  &#123;</div><div class="line">    $serverAddress = $isInternal ? Config::get(&apos;app.ossServerInternal&apos;) : Config::get(&apos;app.ossServer&apos;);</div><div class="line">    $this-&gt;ossClient = AliyunOSS::boot(</div><div class="line">      $serverAddress,</div><div class="line">      Config::get(&apos;app.AccessKeyId&apos;),</div><div class="line">      Config::get(&apos;app.AccessKeySecret&apos;)</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  public static function upload($ossKey, $filePath)</div><div class="line">  &#123;</div><div class="line">    $oss = new OSS(true); // 上传文件使用内网，免流量费</div><div class="line">    $oss-&gt;ossClient-&gt;setBucket(&apos;你的 bucket 名称&apos;);</div><div class="line">    return $oss-&gt;ossClient-&gt;uploadFile($ossKey, $filePath);</div><div class="line">  &#125;</div><div class="line">  /**</div><div class="line">   * 直接把变量内容上传到oss</div><div class="line">   * @param $osskey</div><div class="line">   * @param $content</div><div class="line">   */</div><div class="line">  public static function uploadContent($osskey,$content)</div><div class="line">  &#123;</div><div class="line">    $oss = new OSS(true); // 上传文件使用内网，免流量费</div><div class="line">    $oss-&gt;ossClient-&gt;setBucket(&apos;你的 bucket 名称&apos;);</div><div class="line">    return $oss-&gt;ossClient-&gt;uploadContent($osskey,$content);</div><div class="line">  &#125;</div><div class="line">  /**</div><div class="line">   * 删除存储在oss中的文件</div><div class="line">   *</div><div class="line">   * @param string $ossKey 存储的key（文件路径和文件名）</div><div class="line">   * @return</div><div class="line">   */</div><div class="line">  public static function deleteObject($ossKey)</div><div class="line">  &#123;</div><div class="line">      $oss = new OSS(true); // 上传文件使用内网，免流量费</div><div class="line">      return $oss-&gt;ossClient-&gt;deleteObject(&apos;你的 bucket 名称&apos;, $ossKey);</div><div class="line">  &#125;</div><div class="line">  /**</div><div class="line">   * 复制存储在阿里云OSS中的Object</div><div class="line">   *</div><div class="line">   * @param string $sourceBuckt 复制的源Bucket</div><div class="line">   * @param string $sourceKey - 复制的的源Object的Key</div><div class="line">   * @param string $destBucket - 复制的目的Bucket</div><div class="line">   * @param string $destKey - 复制的目的Object的Key</div><div class="line">   * @return Models\CopyObjectResult</div><div class="line">   */</div><div class="line">  public function copyObject($sourceBuckt, $sourceKey, $destBucket, $destKey)</div><div class="line">  &#123;</div><div class="line">      $oss = new OSS(true); // 上传文件使用内网，免流量费</div><div class="line">      return $oss-&gt;ossClient-&gt;copyObject($sourceBuckt, $sourceKey, $destBucket, $destKey);</div><div class="line">  &#125;</div><div class="line">  /**</div><div class="line">   * 移动存储在阿里云OSS中的Object</div><div class="line">   *</div><div class="line">   * @param string $sourceBuckt 复制的源Bucket</div><div class="line">   * @param string $sourceKey - 复制的的源Object的Key</div><div class="line">   * @param string $destBucket - 复制的目的Bucket</div><div class="line">   * @param string $destKey - 复制的目的Object的Key</div><div class="line">   * @return Models\CopyObjectResult</div><div class="line">   */</div><div class="line">  public function moveObject($sourceBuckt, $sourceKey, $destBucket, $destKey)</div><div class="line">  &#123;</div><div class="line">      $oss = new OSS(true); // 上传文件使用内网，免流量费</div><div class="line">      return $oss-&gt;ossClient-&gt;moveObject($sourceBuckt, $sourceKey, $destBucket, $destKey);</div><div class="line">  &#125;</div><div class="line">  public static function getUrl($ossKey)</div><div class="line">  &#123;</div><div class="line">    $oss = new OSS();</div><div class="line">    $oss-&gt;ossClient-&gt;setBucket(&apos;你的 bucket 名称&apos;);</div><div class="line">    return $oss-&gt;ossClient-&gt;getUrl($ossKey, new \DateTime(&quot;+1 day&quot;));</div><div class="line">  &#125;</div><div class="line">  public static function createBucket($bucketName)</div><div class="line">  &#123;</div><div class="line">    $oss = new OSS();</div><div class="line">    return $oss-&gt;ossClient-&gt;createBucket($bucketName);</div><div class="line">  &#125;</div><div class="line">  public static function getAllObjectKey($bucketName)</div><div class="line">  &#123;</div><div class="line">    $oss = new OSS();</div><div class="line">    return $oss-&gt;ossClient-&gt;getAllObjectKey($bucketName);</div><div class="line">  &#125;</div><div class="line">  /**</div><div class="line">   * 获取指定Object的元信息</div><div class="line">   * </div><div class="line">   * @param  string $bucketName 源Bucket名称</div><div class="line">   * @param  string $key 存储的key（文件路径和文件名）</div><div class="line">   * @return object 元信息</div><div class="line">   */</div><div class="line">  public static function getObjectMeta($bucketName, $osskey)</div><div class="line">  &#123;</div><div class="line">      $oss = new OSS();</div><div class="line">      return $oss-&gt;ossClient-&gt;getObjectMeta($bucketName, $osskey);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>放入自动加载：</strong><br>遵循 psr-0 的项目（如Laravel 4、CodeIgniter、TinyLara）中：<br>在 composer.json 中 autoload -&gt; classmap 处增加配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;autoload&quot;: &#123;</div><div class="line">    &quot;classmap&quot;: [</div><div class="line">      &quot;app/services&quot;</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>然后运行 <code>composer dump-autoload</code>。<br>遵循 psr-4 的项目（如 Laravel 5、Symfony）中：<br>无需配置，保证目录 App/Services 和命名空间 namespace App\Services; 一致即可自动加载。</p>
<p><strong><em>注意：我们使用的laravel框架符合psr-4代码规范，所以这一步可省略。</em></strong> </p>
<p><strong>增加相关配置</strong><br>作者建议在 app/config/app.php 中增加配置，本人建议在<em>app/config</em> 下面新建一个 <em>alioss.php</em> 文件然后在添加配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">return [  </div><div class="line">    &apos;ossServer&apos; =&gt; env(&apos;ALIOSS_SERVER&apos;, null),                      // 外网</div><div class="line">    &apos;ossServerInternal&apos; =&gt; env(&apos;ALIOSS_SERVERINTERNAL&apos;, null),      // 内网</div><div class="line">    &apos;AccessKeyId&apos; =&gt; env(&apos;ALIOSS_KEYID&apos;, null),                     // key</div><div class="line">    &apos;AccessKeySecret&apos; =&gt; env(&apos;ALIOSS_KEYSECRET&apos;, null),             // secret</div><div class="line">    &apos;BucketName&apos; =&gt; env(&apos;ALIOSS_BUCKETNAME&apos;, null)                  // bucket</div><div class="line">];</div></pre></td></tr></table></figure></p>
<p>根据laravel的生命周期可知，项目会首先加载<em>app/config</em>目录下文件，新建一个alioss.php便于和其他组件区分管理。<br>要去<strong>.env</strong>文件去配置。<br><strong>注意</strong>：<br>这里有一个大坑, 粗心的朋友一般不会发现, 在填写外网和公网配置的时候, 有的朋友直接在 OSS 管理控制台中把外网和内网一长串的链接复制走, 如下图:<br><img src="https://dn-phphub.qbox.me/uploads/images/201609/25/4430/PiBPGDxjng.png" alt="坑！坑！坑！"><br>在这个组件中, 桶名称是需要额外填写的, 所以外网和内网哪儿, 只需要填写桶名后面的内容, 如图:<br><img src="https://dn-phphub.qbox.me/uploads/images/201609/25/4430/2MJbnCh088.png" alt="坑！坑！坑！"><br>再有一点是填写外网和内网的时候需要加上 http:// 协议, 不然后面出错你又得掉坑半天出不来, 最终配置信息如下图:<br><img src="https://dn-phphub.qbox.me/uploads/images/201609/25/4430/Kz3gAHij8I.png" alt="坑！坑！坑！"></p>
<p><strong>使用：</strong><br>首先引入命名空间 use App\Services\OSS;, 在 Laravel 5.1 中使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">use App\Services\OSS;</div><div class="line"></div><div class="line">// 上传一个文件</div><div class="line">OSS::upload(&apos;文件名&apos;, &apos;本地路径&apos;);</div><div class="line"></div><div class="line">// 打印出某个文件的外网链接</div><div class="line">echo OSS::getUrl(&apos;某个文件的名称&apos;);</div><div class="line"></div><div class="line">// 新增一个 Bucket。注意，Bucket 名称具有全局唯一性，也就是说跟其他人的 Bucket 名称也不能相同。</div><div class="line">OSS::createBucket(&apos;一个字符串&apos;);</div><div class="line"></div><div class="line">// 获取该 Bucket 中所有文件的文件名，返回 Array。</div><div class="line">OSS::getAllObjectKey(&apos;某个 Bucket 名称&apos;); </div><div class="line"></div><div class="line">// 指定 options 如：Content-Type 类型</div><div class="line">OSS::upload(&apos;文件名&apos;, &apos;文件路径&apos;, [</div><div class="line">    &apos;ContentType&apos; =&gt; &apos;application/pdf&apos;,</div><div class="line">    // ...</div><div class="line"></div><div class="line">])</div></pre></td></tr></table></figure></p>
<p><strong>实际使用：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public function store(Request $request)</div><div class="line">    &#123;</div><div class="line">        $input=$request-&gt;except(&apos;_token&apos;);</div><div class="line">//        dd($input);</div><div class="line">        // 获取表单提交的图片</div><div class="line">        $pic = $request-&gt;file(&apos;picture_url&apos;);</div><div class="line">        // 判断图片有效性</div><div class="line">//        dd($pic);</div><div class="line">        //如果有上传图片</div><div class="line">        if(!empty($pic))&#123;</div><div class="line">            if (!$pic-&gt;isValid()) &#123;</div><div class="line">                return back()-&gt;withErrors(&apos;上传图片无效..&apos;);</div><div class="line">            &#125;else&#123;</div><div class="line">                //获取后缀名</div><div class="line">                $titles = $pic-&gt;getClientOriginalExtension();</div><div class="line">                // 获取图片在临时文件中的地址</div><div class="line">                $picpath = $pic-&gt;getRealPath();</div><div class="line">                // 制作文件名</div><div class="line">                $key = time() . rand(10000, 99999999) . &apos;.&apos;.$titles;</div><div class="line">                //阿里 OSS 图片上传</div><div class="line">                $result = OSS::upload(&apos;news/&apos;.$key, $picpath);</div><div class="line"></div><div class="line">                if (!$result) return back()-&gt;withErrors(&apos;上传图片失败..&apos;);</div><div class="line">                $input[&apos;picture_url&apos;]=env(&apos;ALIOSS_ACCESS&apos;,&apos;http://weiyuyan.oss-cn-beijing.aliyuncs.com/&apos;).&apos;news/&apos;.$key;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>附录：<br>官方其他的一些使用指南<a href="https://github.com/johnlui/AliyunOSS/blob/master/OSSExample.php" target="_blank" rel="external">Touch Me</a></p>
<p><strong>Thanks</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/05/22/文件上传OSS三部曲（一）/" data-id="cj89jua530025sf2nt0ski13v" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-七牛云jssdk应用总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/19/七牛云jssdk应用总结/" class="article-date">
  <time datetime="2016-05-18T16:00:00.000Z" itemprop="datePublished">2016-05-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/19/七牛云jssdk应用总结/">七牛云js-sdk应用总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><ol>
<li>首先，整个七牛云sdk的思路是，先去服务器端拿uptoken，前段js来操作上传，后端部分这里采用php。</li>
<li>js-sdk是依赖于plupload的，plupload是一个上传插件，所以应该下载的资源有，php-sdk,js-sdk以及plupload插件。另外,官网给的demo是基于bootstrap的，所以也要把bootstrap下载一下。</li>
<li>直接把官网给的demo跑通是最高效的熟悉方式。</li>
<li>将官网文档看一下，了解七牛云的工作流程以及代码。</li>
</ol>
<h2 id="准备工作和文件介绍"><a href="#准备工作和文件介绍" class="headerlink" title="准备工作和文件介绍"></a>准备工作和文件介绍</h2><ol>
<li>首先，你应该已经注册了七牛云的账号，进入‘对象存储’，创建了一个空间，会看到一个类似下面这样的域名</li>
</ol>
<pre><code>ogd29n56i.bkt.clouddn.com
</code></pre><p>   在“个人面板”-&gt;“秘钥管理”应该也能看到你自己的秘钥对。</p>
<ol>
<li>下载qiniu/php-sdk,js-sdk,plupload,bootstrap</li>
<li>js-sdk中包含了官网的demo，在index.html中引入前面下载的资源，加载顺序要注意一下：<br>css</li>
</ol>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{{url('/qiniu/bootstrap/css/bootstrap.css')}}&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{{url('/qiniu/js/highlight/highlight.css')}}&quot;&gt;
</code></pre><p>js部分</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;{{url('/qiniu/js/jquery.js')}}&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;{{url('/qiniu/js/plupload/plupload.full.min.js')}}&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;{{url('/qiniu/js/plupload/i18n/zh_CN.js')}}&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;{{url('/qiniu/js/qiniu.js')}}&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;{{url('/qiniu/js/ui.js')}}&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;{{url('/qiniu/js/main.js')}}&quot;&gt;&lt;/script&gt;
</code></pre><p>关于js引入的顺序，plupload是基于jquery的，而七牛的sdk又是基于plupload的，所以应该先引入jquery再plupload，再qiniu.js，那么main.js和ui.js是什么呢？<br>main.js是云存储的初始化代码，就是七牛js-sdk官网文档的“上传”部分的代码。<br>在这部分代码中，有关于初始化的属性设置，例如：</p>
<pre><code>var uploader = Qiniu.uploader({
        runtimes: &apos;html5,flash,html4&apos;,
        browse_button: &apos;pickfiles&apos;,
        container: &apos;container&apos;,
        drop_element: &apos;container&apos;,
        max_file_size: &apos;1000mb&apos;,
        flash_swf_url: &apos;bower_components/plupload/js/Moxie.swf&apos;,
        dragdrop: true,
        chunk_size: &apos;4mb&apos;,
        ......
</code></pre><p>也有回调函数和数据，例如</p>
<pre><code>&apos;BeforeUpload&apos;: function(up, file) {
                var progress = new FileProgress(file, &apos;fsUploadProgress&apos;);
                var chunk_size = plupload.parseSize(this.getOption(&apos;chunk_size&apos;));
                if (up.runtime === &apos;html5&apos; &amp;&amp; chunk_size) {
                    progress.setChunkProgess(chunk_size);
                }
            },
</code></pre><p>上面这个函数定义了上传开始之前的动作，括号内的up和file是两个对象，里面包含了关于在上传这个文件的所有信息，可以将他们打印出来看看。<br>同样的，也有上传中，上传完成后等等回调函数。那么在这些函数中经常会进行一些DOM操作，本例中，将这些DOM操作都封装在ui.js中。好了，这几个文件介绍好之后，现在开始正式看看，七牛云是怎样工作的。</p>
<h2 id="具体操作流程"><a href="#具体操作流程" class="headerlink" title="具体操作流程"></a>具体操作流程</h2><p>因为整个流程是围绕main.js展开的，我们就按照这个文件来展开介绍七牛云上传的所有细节。我们只说几个核心的点，其他的看文档就行了。</p>
<ol>
<li>文件上传按钮</li>
</ol>
<pre><code>var uploader = Qiniu.uploader({
            runtimes: &apos;html5,flash,html4&apos;,
            browse_button: &apos;pickfiles&apos;,
            container: &apos;container&apos;,
            ...
</code></pre><p>   browse_button,container后面的值对应了页面中两个元素的id值，并且container应该包含pickfiles，所以在html中写入下面内容</p>
<pre><code>&lt;div id=&quot;container&quot;&gt;
       &lt;button id=&quot;pickfiles&quot;&gt;选择文件&lt;/button&gt;
&lt;/div&gt;
</code></pre><ol>
<li>uptoken和domain</li>
</ol>
<p>domain上面说过了，是你的七牛云生成的空间域名，一个域对应一个空间，有些坑后面再讲。<br>uptoken是一个签证，这个js脚本运行之后，main.js会异步去你指定的链接拿到uptoken的值<br>所以，关于这两个东西你得做三个事情：（我这么写不安全，自己发挥）</p>
<p>一是前端写入隐藏dom</p>
<pre><code>&lt;input type=&quot;hidden&quot; id=&quot;domain&quot; value=&quot;http://ogd29n56i.bkt.clouddn.com/&quot;&gt;
&lt;input type=&quot;hidden&quot; id=&quot;uptoken_url&quot; value=&quot;{{url('getuptoken')}}&quot;&gt;
</code></pre><p>二是写入main.js</p>
<pre><code>uptoken_url: $(&apos;#uptoken_url&apos;).val(),
domain: $(&apos;#domain&apos;).val(),
</code></pre><p>第三步就是写好获取uptoken的php程序，这部分也比较简单，可以参考官方php文档，附上代码：</p>
<pre><code>public function getUptoken()
    {
        // 需要填写你的 Access Key 和 Secret Key
        $accessKey = &apos;VsAP-hK_hVPKiq5CQcoxWNhBT9ZpZ1Ii4z3O_W51&apos;;
        $secretKey = &apos;5dqfmvL15DFoAK1QzaVF2TwVzwJllOF8K4Puf1Po&apos;;

        // 构建鉴权对象
        $auth = new Auth($accessKey, $secretKey);

        // 要上传的空间
        $bucket = &apos;jacklin&apos;;

        // 生成上传 Token
        $token = $auth-&gt;uploadToken($bucket);
        $res = array(&apos;uptoken&apos;=&gt;$token);
        return response()-&gt;json($res);
    }
</code></pre><p> 3.到目前为止，上传功能已经可以实现了，其他的设置你也需要看一下，比如方便的设置文件大小上限，哪几个不能同时设置之类的。</p>
<p> 4.上文有说过，js版本的sdk结合了plupload这个上传插件，所以还有很多便利的地方。那就是main.js下面的部分。</p>
<pre><code>&apos;FilesAdded&apos;: function(up, files) {}
&apos;BeforeUpload&apos;: function(up, file) {}
&apos;UploadProgress&apos;: function(up, file) {}
&apos;UploadComplete&apos;: function() {}
&apos;FileUploaded&apos;: function(up, file, info) {}
&apos;Error&apos;: function(up, err, errTip) {}
&apos;Key&apos;: function(up, file) {}
</code></pre><p> 先大概了解一下这几个函数，这里的用法类似jQ的ajax，这些是回调函数和参数，其中的up,files,info里面包含了关于这个文件所有的信息，<br> 包括文件类型，大小，成功后的链接等等，所以可以用这些信息做一些DOM操作，首先前端的展示和必要的数据获取。如果你想查看这些对象里面<br> 的内容咋办呢?</p>
<pre><code>for(i in json){
    console.log(i);
    console.log(json[i]);
}
</code></pre><p>5 下面详细讲解这几个函数</p>
<pre><code>&apos;FilesAdded&apos;: function(up, files) {
    //这里定义文件加入上传队列，但是还没有开始上传的动作
    //七牛jssdk是多文件上传的，你可以试试上传的时候Ctrl添加多个文件试试
    //第一个在加载的时候其他的文件的状态就是FilesAdded
},
&apos;BeforeUpload&apos;: function(up, file) {
    //这里自定义了上传前的动作，上传前就是马上就要开始上传的临界点
},
&apos;UploadProgress&apos;: function(up, file) {
    //这里自定义上传中的动作，这个地方就比较有意思了，只要文件上传没有完成
    //这个函数就不断回调，你可以写一个alert(1)试试，文件上传中，就不断的弹弹弹
}
&apos;UploadComplete&apos;: function() {
    //这里自定义上传完成时的动作
}，
&apos;FileUploaded&apos;: function(up, file, info) {
    //这里定义了文件完成后的动作，可能你上传成功时通过ajax把url写进数据库
    //就可以把ajax写在这里，从info对象里获取到url
}
&apos;Error&apos;: function(up, err, errTip) {
    //这里定义出现错误时的动作
}
&apos;Key&apos;: function(up, file) {
    //这里也是一个关键的地方，如果你想自己定义文件名，就在这里组织，并 return key;
    // 但是前提是你已经把 unique_names save_key 注释了，我这里是加了一个时间戳
    //这里是我定义的key,其实就是字符串拼接，如果你喜欢，return &apos;123&apos; 都可以
        var extarr = file[&apos;name&apos;].split(&apos;.&apos;);
        if(extarr.length===1){
            var arr=file[&apos;type&apos;].split(&apos;/&apos;);
            var prename = extarr[0];
            var ext = (arr[arr.length-1]==&apos;undefined&apos;)?&apos;&apos;:arr[arr.length-1];
        }else{
            var ext = &apos;.&apos;+ extarr[extarr.length-1]; //得到后缀
            var index = file[&apos;name&apos;].lastIndexOf(&apos;.&apos;);//得到最后一个点的坐标
            var prename = file[&apos;name&apos;].substring(0,index);//得到最后一个点之前的字符串
        }
        var time = Date.parse(new Date())/1000;
        $(&quot;input[name=&apos;ftype&apos;]&quot;).val(prename);
        var key = prename+&apos;/&apos;+time+ ext;
        return key;
}
</code></pre><p>6 .到现在整个流程已经讲完了，下面讲这个ui.js，你打开这个文件可能吓一跳，哇塞，js面向对象，各种成员属性方法的，<br>其实ui.js是官网demo的dom操作，没有这个js，官网这个demo能上传文件，但是，你啥都看不到，他就是用了上面所说up,<br>files,info几个对象里面的信息结合了几个过程，展示出了一些信息。它定义了一个FileProgress对象，而这个对象是初始化了<br>一个dom元素作为他的容器，你看一下他大概的用法，稍微了解一下up,files,info这几个对象就可以自己写了，不过，可是，<br>这个demo有关于缩略图和大文件分块上传进度展示的功能还是很复杂的。如果你说着我也会写，那你试试。</p>
<p>##坑</p>
<p>#####400：token not specified</p>
<p>出现这个情况，说明你离成功还很远</p>
<p>1.检查你的token格式是不是跟官网的一样</p>
<p>2.我还遇到一个更坑的情况，浪费了很多时间，那就是电脑差，资源加载的慢，js还没有完全加载好，我就点击上传，也报这个错，所以，你得排除这个可能，那就是–等</p>
<p>#####400:incorrect zone ,please use up-z1.qiniu.com<br>这个问题是由于，你创建空间时候，手贱点了华北地区，七牛每个服务域名服务的地区是规定好的，所以有两个办法</p>
<ol>
<li>换空间:  重新建一个空间 我选华东的，就OK了</li>
<li>换域名: 打开qiniu.js 搜索 qiniuUploadUrls,修改成如下</li>
</ol>
<pre><code>var qiniuUploadUrls = [
    &apos;http://upload-z1.qiniu.com&apos;,
    &apos;http://up-z1.qiniu.com&apos;
]
</code></pre><p>##最后<br>其他的自定义设置可以参考官方文档，下面附上一些常用的设置</p>
<p>1 设置一次只能选一个文件</p>
<pre><code>multi_selection: false
</code></pre><p>2 取消分片  注意，最大分片也只是4M</p>
<pre><code>chunk_size: ‘0mb’
</code></pre><p>3 取消自动上传</p>
<pre><code>auto_start: false 
</code></pre><p>4 暂停上传，开始上传  </p>
<pre><code>//加入下面dom和js代码   
$(&apos;#up_load2&apos;).on(&apos;click&apos;, function(){
    uploader2.start();
 });
 $(&apos;#stop_load2&apos;).on(&apos;click&apos;, function(){
    uploader2.stop();
 });
</code></pre><p>5 多个上传按钮问题，实例化多个main.js就行了</p>
<p><a href="http://www.qiniu.com/" target="_blank" rel="external">七牛云首页</a><br><a href="http://developer.qiniu.com/code/v6/sdk/javascript.html" target="_blank" rel="external">js-sdk</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/05/19/七牛云jssdk应用总结/" data-id="cj89jua4f0011sf2nwfjm4za1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-在Mac os x 安装 Redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/24/在Mac os x 安装 Redis/" class="article-date">
  <time datetime="2016-03-24T01:28:51.000Z" itemprop="datePublished">2016-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mac/">mac</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/24/在Mac os x 安装 Redis/">在Mac os x 安装 Redis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1、下载redis-安装包"><a href="#1、下载redis-安装包" class="headerlink" title="1、下载redis 安装包"></a>1、下载redis 安装包</h3><p>打开浏览器输入地址：</p>
<pre><code>http://download.redis.io/redis-stable.tar.gz 
</code></pre><p>下载 redis 最新稳定安装包</p>
<p>mac os下载的文件默认会保存在Downloads 文件下.</p>
<h3 id="2、编译-amp-安装Redis"><a href="#2、编译-amp-安装Redis" class="headerlink" title="2、编译&amp;安装Redis"></a>2、编译&amp;安装Redis</h3><p>打开终端进入Downloads目录:</p>
<pre><code>cd Downloads
</code></pre><p>解压刚才下载的Redis 安装包：</p>
<pre><code>tar xvzf redis-stable.tar.gz
</code></pre><p>在Downloads目录下会生成 redis-stable 目录，</p>
<p>在终端进入这个目录：</p>
<pre><code>cd redis-stable
</code></pre><p>编译源代码：</p>
<pre><code>make
</code></pre><p>编译成功后会在 redis-stable/src 下生成 redis-server(redis 服务) 和 redis-cli (redis 命令行客户端),</p>
<p>拷贝redis-server 和 redis-cli 到 /usr/local/bin/</p>
<pre><code>sudo cp redis-server /usr/local/bin/

sudo cp redis-cli /usr/local/bin/
</code></pre><p>3、启动 </p>
<pre><code>redis-server
</code></pre><p>4、启动 redis-cli</p>
<p>另打开终端窗口，输入：</p>
<pre><code>redis-cli
</code></pre><p>出现 </p>
<pre><code>127.0.0.1:6379&gt; ，接着输入 ping, 如出现 

127.0.0.1:6379&gt; ping

PONG
</code></pre><p>说明 redis 已正常工作</p>
<p>5、常见问题</p>
<p>如果redis server 启动几分钟后提示如下错误：</p>
<pre><code>[35763] 04 Mar 01:51:47.088 * 1 changes in 900 seconds. Saving...
[35763] 04 Mar 01:51:47.088 * Background saving started by pid 43313
[43313] 04 Mar 01:51:47.088 # Failed opening .rdb for saving: Permission denied
</code></pre><p>解决办法：关掉当前redis server , 利用 sudo redis-server 启动redis  </p>
<h2 id="mac安装Redis可视化工具-Redis-Desktop-Manager"><a href="#mac安装Redis可视化工具-Redis-Desktop-Manager" class="headerlink" title="mac安装Redis可视化工具-Redis Desktop Manager"></a>mac安装Redis可视化工具-Redis Desktop Manager</h2><p>Redis是一个超精简的基于内存的键值对数据库(key-value)，一般对并发有一定要求的应用都用其储存session，乃至整个数据库。不过它公自带一个最小化的命令行式的数据库管理工具，有时侯使用起来并不方便。不过Github上面已经有了很多图形化的管理工具，而且都针对REDIS做了一些优化，如自动折叠带schema的key等。</p>
<p>Redis Desktop Manager<br>一款基于Qt5的跨平台Redis桌面管理软件<br>支持: Windows 7+, Mac OS X 10.10+, Ubuntu 14+<br>特点： C++ 编写，响应迅速，性能好。但不支持数据库备份与恢复。</p>
<p>安装方法</p>
<p>1.安装brew cask :</p>
<p>在终端中输入下面语句 回车</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; &lt; /dev/null 2&gt; /dev/null ; brew install caskroom/cask/brew-cask 2&gt; /dev/null
</code></pre><p>可能会需要你的mac密码，输入即可<br>安装Redis Desktop Manager</p>
<p>2.安装完cask之后，在终端中输入 回车</p>
<pre><code>brew cask install rdm
</code></pre><p>也可以去项目的github找最新的版本</p>
<pre><code>https://github.com/uglide/RedisDesktopManager/releases/
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/03/24/在Mac os x 安装 Redis/" data-id="cj89jua4o001dsf2n3wpk6vqy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mac/">mac</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Nginx + PHP（php-fpm）遇到的502 Bad Gateway错误" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/14/Nginx + PHP（php-fpm）遇到的502 Bad Gateway错误/" class="article-date">
  <time datetime="2016-03-14T10:28:51.000Z" itemprop="datePublished">2016-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nginx/">nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/Nginx + PHP（php-fpm）遇到的502 Bad Gateway错误/">nginx+php-fpm的502问题解决记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<h2 id="nginx服务器下-PHP-出现-502-解决方案"><a href="#nginx服务器下-PHP-出现-502-解决方案" class="headerlink" title="nginx服务器下 PHP 出现 502 解决方案"></a>nginx服务器下 PHP 出现 502 解决方案</h2><p>nginx出现502有很多原因，但大部分原因可以归结为资源数量不够用,也就是说后端PHP-fpm处理有问题，nginx将正确的客户端请求发给了后端的php-fpm进程，但是因为php-fpm进程的问题导致不能正确解析php代码，最终返回给了客户端502错误。<br>nginx+php出现502 bad gateway，一般这都不是nginx的问题，而是由于 fastcgi或者php的问题导致的，常见的有以下几种(其实解决问题的最好的方式还是自己去看nginx和fastcgi的errorlog):</p>
<ol>
<li>php.ini的memory_limit 过小（如果有个别php程序进程需要占用极大内存时这个必须注意）</li>
<li>php-fpm.conf中max_children或者max_requests  设置不合理（设置过小会因为没有足够的cgi进程处理请求，设置过大会出现一会儿有响应正常，一会儿等很久才有响应的情况，一般情况下children按 照内存计算，比如说1G设置64，2G128。这个根据实际情况自行调整。另外查看当前的PHP FastCGI进程数是否够用的命令为：netstat  -anpo |grep &ldquo;php-cgi&rdquo; | wc -l   如果实际使用的&ldquo;FastCGI进程数&rdquo;接近预设的&ldquo;FastCGI进程数&rdquo;，那么，说明&ldquo;FastCGI进程数&rdquo;不够用，需要增大。）</li>
<li>查看nginx错误日志，发现 pstream sent too big header while reading response  headerfrom upstream ，则检查client head buffer，fastcgi buffer  size是否过小，可设置为32K。</li>
<li><p>php程序执行时间过长而超时，检查nginx和fastcgi中各种timeout设置。（nginx 中的  fastcgi_connect_timeout 300;fastcgi_send_timeout 300  ：fastcgi_read_timeout300; keepalive_timeout ；  php-fpm中的request_terminate_timeout，php.ini中的max_execution_time）</p>
</li>
<li><p>php-fpm有一个参数 max_requests ，该参数指明了每个children最多处理多少个请求后便会被关闭。在大量处理请求下，如果该值设置过小会导致children频繁的自杀和建立而浪费 大量时间，若所有的children差不多都在这个时候自杀，则重建前将没有children响应请求，于是出现502  。可以将该值设置大一些或者是0[无限]。<br>如果你服务器并发量非常大，那只能先增加机器，然后按以下方式优化会取得更好效果;但如果你并发不大却出现502，一般都可以归结为配置问题，脚本超时问题。<br>1.php-fpm进程数不够用<br>使用netstat -napo |grep “php-fpm” | wc -l查看一下当前fastcgi进程个数，如果个数接近conf里配置的上限，就需要调高进程数。<br>但也不能无休止调高，可以根据服务器内存情况，可以把php-fpm子进程数调到100或以上，在4G内存的服务器上200就可以。</p>
</li>
<li>调高调高Linux内核打开文件数量<br>可以使用这些命令(必须是root帐号)<br>echo ‘ulimit -HSn 65536’&gt;&gt; /etc/profile<br>echo ‘ulimit -HSn 65536’&gt;&gt; /etc/rc.local<br>source /etc/profile<br>3.脚本执行时间超时<br>如果脚本因为某种原因长时间等待不返回，导致新来的请求不能得到处理，可以适当调小如下配置。<br>nginx.conf里面主要是如下<br>fastcgi_connect_timeout 300;<br>fastcgi_send_timeout 300;<br>fastcgi_read_timeout 300;<br>php-fpm.conf里如要是如下<br>request_terminate_timeout =10s<br>4.缓存设置比较小<br>修改或增加配置到nginx.conf<br>proxy_buffer_size 64k;<br>proxy_buffers  512k;<br>proxy_busy_buffers_size 128k;</li>
<li>recv()failed (104: Connection reset by peer) while reading response header fromupstream<br>可能的原因机房网络丢包或者机房有硬件防火墙禁止访问该域名<br>但最重要的是程序里要设置好超时，不要使用php-fpm的request_terminate_timeout，<br>最好设成request_terminate_timeout=0;<br>因为这个参数会直接杀掉php进程，然后重启php进程，这样前端nginx就会返回104: Connection reset by peer。这个过程是很慢，总体感觉就是网站很卡。<br>May 01 10:50:58.044162[WARNING] [pool www] child 4074, script’/usr/local/nginx/html/quancha/sameip/detail.php’ execution timed out(15.129933 sec), terminating<br>May 01 10:50:58.045725 [WARNING] [pool www] child 4074 exited on signal 15SIGTERM after 90.227060 seconds from start<br>May 01 10:50:58.046818 [NOTICE] [pool www] child 4082 started<br>说一千道一万最重要的就是程序里控制好超时，gethostbyname、curl、file_get_contents等函数的都要设置超时时间。<br>另一个就是多说，这个东西是增加了网站的交互性，但是使用的多了反应就慢了，如果你网站超时且使用了多说是，可以关闭它。<br>6、自己遇到502的解决办法：<br>调整增大php 和Nginx 的backlog数。<br>PHP-FPM高负载的解决办法<br>Postedon 2011/09/02<br>这里只是介绍了php-fpm的优化方法的，但一般情况下和nginx组合使用的时候，单独优化其中一项的话，作用不是特别的大，同时还需要对nginx进行优化．nginx的做法方法参考：<a href="http://blog.haohtml.com/archives/6213.上面的优化前和优化后的图，看得出前后差距还是特别的大的．" target="_blank" rel="external">http://blog.haohtml.com/archives/6213.上面的优化前和优化后的图，看得出前后差距还是特别的大的．</a><br>导致nginx 502 bad gateway的PHP-CGI(FASTCGI)<br>NGINX频爆502 BAD GATEWAY的错误，看了网上的教程，仍没有彻底解决。<br>目前我总结的解决502 BAD GATEWAY的方式有：<br>1.视服务器的性能，在php-fmp.conf里增加max_children的值:<br>max_children是PHP-FPM Pool 最大的子进程数,他数值取决于你的服务器内存。 假设你打算给10G内存给当前配置的PHP-FPM Pool，一般一个PHP请求占用内存10M-40M，我们按站点每个PHP请求占用内存25M，这样max_children = 10G/25M = 409。所以，这个值可以根据情况算出来<br>max_requests是每个子进程重生之前处理的请求数， 默认值为unlimited（默认为1024），可以设置小一点（如500左右），这样可以避免内存泄露带来的问题<br>Nginx代理过程，将业务服务器请求数据缓存到本地文件，再将文件数据转发给请求客户端。高并发的客户端请求，必然要求服务器文件句柄的并发打开限制。使用ulimit命令（ulimit -n），查看Linux系统文件句柄并发限制，默认是1024，我们可以改为65535（2 的 16 次方，这是系统端口的极限）。修改的方法为：修改系统文件/etc/security/limits.conf，添加如下信息，并重新启动系统生效。</li>
</ol>
<ul>
<li><p>soft   nofile  65535</p>
</li>
<li><p>hard   nofile  65535<br>然后在Nginx配置文件中，把文件限制及连接数信息改为65535：<br>worker_rlimit_nofile 65535;<br>events {<br>  use epoll;<br>  worker_connections  65535;<br>}</p>
</li>
</ul>
<p>2.用reload参数定时重载php-fpm。这个主要原因是php脚本执行时间过长造成的，重载php-fpm能杜绝这个问题。如何彻底解决php-cgi脚本占用大量内存从而导致502错误的产生还值得进一步探讨，目前该做法不失为一种好办法。<br>具体的做法是，用crontab让php-fpm平滑重启，从而不影响PHP脚本的运行。<br><em>/10</em> <em> </em> * /usr/local/php/sbin/php-fpm reload<br>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 优化设置＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p>
<p>如果您高负载网站使用PHP-FPM管理FastCGI，这些技巧也许对您有用：)<br>1.Compile PHP’s modules as less as possible, the simple the best (fast);<br>1.尽量少安装PHP模块，最简单是最好（快）的</p>
<ol>
<li>Increas PHP FastCGI child number to 100 and even more.Sometime, 200 is OK! ( On 4GB memory server);<br>2.把您的PHP FastCGI子进程数调到100或以上，在4G内存的服务器上200就可以<br>注：我的1g测试机，开64个是最好的，建议使用压力测试获取最佳值<br>3.Using SOCKET PHP FastCGI, and put into /dev/shm on Linux;<br>3.使用socket连接FastCGI，linux操作系统可以放在/dev/shm中<br>注：在php-fpm.cnf里设置<valuename=”listen_address”>/tmp/nginx.socket就可以通过socket连接FastCGI了，/dev/shm是内存文件系统，放在内存中肯定会快了.记得这时也要在nginx里的配置里进行修改，保持一致．<br>location~ .*/.(php|php5)?$<br>{<br>#<br>将Nginx与FastCGI的通信方式由TCP改为UnixSocket。TCP在高并发访问下比UnixSocket稳定，但Unix Socket速度要比TCP快。<br>fastcgi_pass  unix:/tmp/php-cgi.sock;<br>#fastcgi_pass  127.0.0.1:9000;<br>fastcgi_index index.php;<br>include fcgi.conf;<br>}</valuename=”listen_address”></li>
<li>Increase Linux “max open files”, using the following command(must be root):<h1 id="echo-‘ulimit-HSn-65536′-gt-gt-etc-profile"><a href="#echo-‘ulimit-HSn-65536′-gt-gt-etc-profile" class="headerlink" title="echo ‘ulimit -HSn 65536′&gt;&gt; /etc/profile"></a>echo ‘ulimit -HSn 65536′&gt;&gt; /etc/profile</h1><h1 id="echo-‘ulimit-HSn-65536-gt-gt-etc-rc-local"><a href="#echo-‘ulimit-HSn-65536-gt-gt-etc-rc-local" class="headerlink" title="echo ‘ulimit -HSn 65536 &gt;&gt; /etc/rc.local"></a>echo ‘ulimit -HSn 65536 &gt;&gt; /etc/rc.local</h1><h1 id="source-etc-profile"><a href="#source-etc-profile" class="headerlink" title="source /etc/profile"></a>source /etc/profile</h1></li>
</ol>
<p>4.调高linux内核打开文件数量，可以使用这些命令(必须是root帐号<br>)<br>echo ‘ulimit -HSn 65536′ &gt;&gt; /etc/profile<br>echo ‘ulimit -HSn 65536′ &gt;&gt; /etc/rc.local<br>source /etc/profile</p>
<p>注：我是修改/etc/rc.local，加入ulimit -SHn 51200的<br>5.Increase PHP-FPM open file description rlimit:</p>
<h1 id="vi-path-to-php-fpm-conf"><a href="#vi-path-to-php-fpm-conf" class="headerlink" title="vi /path/to/php-fpm.conf"></a>vi /path/to/php-fpm.conf</h1><p>Find “<value name="”rlimit_files”">1024</value>”<br>Change 1024 to 4096 or higher number.<br>Restart PHP-FPM.</p>
<p>5.增加 PHP-FPM 打开文件描述符的限制</p>
<h1 id="vi-path-to-php-fpm-conf-1"><a href="#vi-path-to-php-fpm-conf-1" class="headerlink" title="vi /path/to/php-fpm.conf"></a>vi /path/to/php-fpm.conf</h1><p>找到<br>“<value name="”rlimit_files”">1024</value>”<br>把1024更改为4096或者更高<br>.<br>重启PHP-FPM.</p>
<ol>
<li>Using PHP code accelerator,e.g eAccelerator, XCache. And set “cache_dir” to /dev/shm on Linux.<br>6.使用php代码加速器，例如eAccelerator, XCache.在linux平台上可以把<code>cache_dir</code>指向/dev/shm</li>
</ol>
<p>相关阅读：<br><a href="http://www.cnblogs.com/jackluo/p/3366612.html" target="_blank" rel="external">http://www.cnblogs.com/jackluo/p/3366612.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/03/14/Nginx + PHP（php-fpm）遇到的502 Bad Gateway错误/" data-id="cj89jua3l0006sf2ni325tumt" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Ubuntu apt-get彻底卸载软件包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/02/Ubuntu apt-get彻底卸载软件包/" class="article-date">
  <time datetime="2016-02-01T16:00:00.000Z" itemprop="datePublished">2016-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/02/Ubuntu apt-get彻底卸载软件包/">ubuntu apt-get彻底卸载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <a id="more"></a>
<p>如果你关注搜索到这篇文章，那么我可以合理怀疑你被apt-get的几个卸载命令有点搞晕了。</p>
<p>apt-get的卸载相关的命令有<code>remove/purge/autoremove/clean/autoclean</code>等。具体来说：</p>
<p><code>apt-get purge / apt-get –purge remove</code><br>删除已安装包（不保留配置文件)。<br>如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文件</p>
<p><code>apt-get autoremove</code><br>删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</p>
<p><code>apt-get remove</code><br>删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</p>
<p><code>apt-get autoclean</code><br>APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb。</p>
<p><code>apt-get clean</code><br>使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。</p>
<p>那么如何彻底卸载软件呢？<br>具体来说可以运行如下命令：</p>
<h3 id="删除软件及其配置文件"><a href="#删除软件及其配置文件" class="headerlink" title="删除软件及其配置文件"></a>删除软件及其配置文件</h3><p><code>apt-get --purge remove</code> </p>
<h3 id="删除没用的依赖包"><a href="#删除没用的依赖包" class="headerlink" title="删除没用的依赖包"></a>删除没用的依赖包</h3><p><code>apt-get autoremove</code></p>
<h3 id="此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理："><a href="#此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：" class="headerlink" title="此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理："></a>此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：</h3><p>dpkg -l |grep ^rc|awk ‘{print $2}’ |sudo xargs dpkg -P<br>当然如果要删除暂存的软件安装包，也可以再使用<code>clean</code>命令。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2016/02/02/Ubuntu apt-get彻底卸载软件包/" data-id="cj89jua3q000esf2npbyijzzf" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2100/01/01/About Me/">About Me</a>
          </li>
        
          <li>
            <a href="/2017/04/04/马闯：创业公司必经之路[3]/">entrepreneurship公司必经之路（三）</a>
          </li>
        
          <li>
            <a href="/2017/03/29/马闯：创业公司必经之路[2]/">entrepreneurship公司必经之路（二）</a>
          </li>
        
          <li>
            <a href="/2017/03/22/马闯：创业公司必经之路[1]/">entrepreneurship公司必经之路（一）</a>
          </li>
        
          <li>
            <a href="/2017/03/20/SEO排名的影响因素/">SEO影响因素</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 martist.cn&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;youemail@outlook.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>