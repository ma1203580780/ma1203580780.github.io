<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>错误和异常 | MARTIST</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是错误，什么是异常，区别是什么">
<meta name="keywords" content="常识,php">
<meta property="og:type" content="article">
<meta property="og:title" content="错误和异常">
<meta property="og:url" content="http://martist.cn/2018/01/02/错误和异常/index.html">
<meta property="og:site_name" content="MARTIST">
<meta property="og:description" content="什么是错误，什么是异常，区别是什么">
<meta property="og:locale" content="简体中文">
<meta property="og:updated_time" content="2018-03-27T07:40:21.419Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="错误和异常">
<meta name="twitter:description" content="什么是错误，什么是异常，区别是什么">
  
    <link rel="alternate" href="/atom.xml" title="MARTIST" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://martist.cn"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/2012/01/01/About Me/">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MARTIST</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-错误和异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/02/错误和异常/" class="article-date">
  <time datetime="2018-01-01T16:00:00.000Z" itemprop="datePublished">2018-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/php/">php</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      错误和异常
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>：-} <a id="more"></a></p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>PHP提供了错误处理和日志记录的功能. 这些函数允许你定义自己的错误处理规则，以及修改错误记录的方式. 这样，你就可以根据自己的需要，来更改和加强错误输出信息以满足实际需要.</p>
<p>通过日志记录功能，你可以将信息直接发送到其他日志服务器，或者发送到指定的电子邮箱（或者通过邮件网关发送），或者发送到操作系统日志等，从而可以有选择的记录和监视你的应用程序和网站的最重要的部分。</p>
<p>错误报告功能允许你自定义错误反馈的级别和类型，可以是简单的提示信息或者使用自定义的函数进行处理并返回信息.</p>
<h3 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h3><p>  debug_backtrace — 产生一条回溯跟踪(backtrace)<br>  debug_print_backtrace — 打印一条回溯。<br>  error_clear_last — 清除最近一次错误<br>  error_get_last — 获取最后发生的错误<br>  error_log — 发送错误信息到某个地方<br>  error_reporting — 设置应该报告何种 PHP 错误<br>  restore_error_handler — 还原之前的错误处理函数<br>  restore_exception_handler — 恢复之前定义过的异常处理函数。<br>  set_error_handler — 设置用户自定义的错误处理函数<br>  set_exception_handler — 设置用户自定义的异常处理函数<br>  trigger_error — 产生一个用户级别的 error/warning/notice 信息<br>  user_error — trigger_error 的别名</p>
<p>详见 <a href="http://php.net/manual/zh/ref.errorfunc.php" target="_blank" rel="external">http://php.net/manual/zh/ref.errorfunc.php</a></p>
<h2 id="error-reporting"><a href="#error-reporting" class="headerlink" title="error_reporting()"></a>error_reporting()</h2><p>规定不同的错误级别报告<br>PHP 有诸多错误级别，使用该函数可以设置在脚本运行时的级别。如果没有设置可选参数 level，error_reporting() 仅会返回当前的错误报告级别。</p>
<pre><code>1     E_ERROR           致命的运行错误。错误无法恢复，暂停执行脚本。
2     E_WARNING         运行时警告(非致命性错误)。非致命的运行错误，脚本执行不会停止。
4     E_PARSE           编译时解析错误。解析错误只由分析器产生。
8     E_NOTICE          运行时提醒(这些经常是你代码中的bug引起的，也可能是有意的行为造成的。)
16    E_CORE_ERROR PHP  启动时初始化过程中的致命错误。
32    E_CORE_WARNING    PHP启动时初始化过程中的警告(非致命性错)。
64    E_COMPILE_ERROR   编译时致命性错。这就像由Zend脚本引擎生成了一个E_ERROR。
128   E_COMPILE_WARNING 编译时警告(非致性错)。这就像由Zend脚本引擎生成了E_WARNING警告。
256   E_USER_ERROR      自定义错误消息。像用PHP函数trigger_error（程序员设置E_ERROR）
512   E_USER_WARNING    自定义警告消息。像用PHP函数trigger_error（程序员设的E_WARNING警告）
1024  E_USER_NOTICE     自定义的提醒消息。像由使用PHP函数trigger_error（程序员E_NOTICE集）
2048  E_STRICT          编码标准化警告。允许PHP建议修改代码以确保最佳的互操作性向前兼容性。
4096  E_RECOVERABLE_ERROR   开捕致命错误。像E_ERROR，但可以通过用户定义的处理捕获（又见set_error_handler（））
8191  E_ALL             所有的错误和警告(不包括 E_STRICT) (E_STRICT will be part of E_ALL as of PHP 6.0)
16384 E_USER_DEPRECATED
30719 E_ALL
</code></pre><p>15个正好对应二进制的15位。<br>需要注意的是, 上述表中的字段, 不是一成不变的, 不同的PHP版本, 值可能会不同, 详细的请参考 php预定义常量</p>
<p>任意数目的以上选项都可以用“或”来连接(用 OR 或 |)，这样可以报告所有需要的各级别错误。<br>例如，下面的代码关闭了用户自定义的错误和警告，执行了某些操作，然后恢复到原始的报错级别：<br>例：</p>
<pre><code>&lt;?php
 error_reporting(0);                //禁用错误报告
 error_reporting(E_ERROR | E_WARNING | E_PARSE);//报告运行时错误
 error_reporting(E_ALL);            //报告所有错误
 error_reporting(E_ALL ^ E_NOTICE); //除E_NOTICE报告所有错误，是在php.ini的默认设置
 error_reporting(-1);               //报告所有 PHP 错误
 error_reporting(3);                //不报E_NOTICE
 error_reporting(11);               //报告所有错误
 ini_set(&apos;error_reporting&apos;, E_ALL); // 和 error_reporting(E_ALL); 一样
 error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);//表示php错误，警告，语法错误，提醒都返错。
?&gt;
</code></pre><p>关于错误的文档可以参考<br><a href="http://www.w3school.com.cn/php/php_ref_error.asp" target="_blank" rel="external">http://www.w3school.com.cn/php/php_ref_error.asp</a></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote>
<p>异常（Exception）用于在指定的错误发生时改变脚本的正常流程。</p>
</blockquote>
<h3 id="Try-throw-和-catch"><a href="#Try-throw-和-catch" class="headerlink" title="Try, throw 和 catch"></a>Try, throw 和 catch</h3><p>要避免上面例子出现的错误，我们需要创建适当的代码来处理异常。</p>
<p>正确的处理程序应当包括：</p>
<pre><code>Try - 使用异常的函数应该位于 &quot;try&quot; 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。
Throw - 这里规定如何触发异常。每一个 &quot;throw&quot; 必须对应至少一个 &quot;catch&quot;
Catch - &quot;catch&quot; 代码块会捕获异常，并创建一个包含异常信息的对象
</code></pre><p>下面来触发一个异常：</p>
<pre><code>&lt;?php
//创建可抛出一个异常的函数
function checkNum($number)
 {
 if($number&gt;1)
  {
  throw new Exception(&quot;Value must be 1 or below&quot;);
  }
 return true;
 }

//在 &quot;try&quot; 代码块中触发异常
try
 {
 checkNum(2);
 //If the exception is thrown, this text will not be shown
 echo &apos;If you see this, the number is 1 or below&apos;;
 }

//捕获异常
catch(Exception $e)
 {
 echo &apos;Message: &apos; .$e-&gt;getMessage();
 }
?&gt;
</code></pre><p>上面代码将获得类似这样一个错误：</p>
<pre><code>Message: Value must be 1 or below
</code></pre><p>例子解释：</p>
<p>上面的代码抛出了一个异常，并捕获了它：</p>
<pre><code>创建 checkNum() 函数。它检测数字是否大于 1。如果是，则抛出一个异常。
在 &quot;try&quot; 代码块中调用 checkNum() 函数。
checkNum() 函数中的异常被抛出
&quot;catch&quot; 代码块接收到该异常，并创建一个包含异常信息的对象 ($e)。
通过从这个 exception 对象调用 $e-&gt;getMessage()，输出来自该异常的错误消息
</code></pre><p>不过，为了遵循“每个 throw 必须对应一个 catch”的原则，可以设置一个顶层的异常处理器来处理漏掉的错误。</p>
<h3 id="设置顶层异常处理器-（Top-Level-Exception-Handler）"><a href="#设置顶层异常处理器-（Top-Level-Exception-Handler）" class="headerlink" title="设置顶层异常处理器 （Top Level Exception Handler）"></a>设置顶层异常处理器 （Top Level Exception Handler）</h3><p>set_exception_handler() 函数可设置处理所有未捕获异常的用户定义函数。</p>
<pre><code>&lt;?php
function myException($exception)
{
echo &quot;&lt;b&gt;Exception:&lt;/b&gt; &quot; , $exception-&gt;getMessage();
}

set_exception_handler(&apos;myException&apos;);

throw new Exception(&apos;Uncaught Exception occurred&apos;);
?&gt;
</code></pre><p>以上代码的输出应该类似这样：</p>
<pre><code>Exception: Uncaught Exception occurred
</code></pre><p>在上面的代码中，不存在 “catch” 代码块，而是触发顶层的异常处理程序。应该使用此函数来捕获所有未被捕获的异常。</p>
<h3 id="异常的规则"><a href="#异常的规则" class="headerlink" title="异常的规则"></a>异常的规则</h3><pre><code>需要进行异常处理的代码应该放入 try 代码块内，以便捕获潜在的异常。
每个 try 或 throw 代码块必须至少拥有一个对应的 catch 代码块。
使用多个 catch 代码块可以捕获不同种类的异常。
可以在 try 代码块内的 catch 代码块中再次抛出（re-thrown）异常。
</code></pre><p>简而言之：如果抛出了异常，就必须捕获它。</p>
<h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><p>请一定要注意，没有特殊说明：本例 PHP Version &lt; 7<br>　　说起PHP异常处理，大家首先会想到try-catch，那好，我们先看一段程序吧：有一个test.php文件，有一段简单的PHP程序，内容如下，然后命令行执行：</p>
<pre><code>&lt;?php
   $num = 0;
   try {
       echo 1/$num;

   } catch (Exception $e){
       echo $e-&gt;getMessage();
   }
?&gt;
</code></pre><blockquote>
<p>我的问题是：这段程序能正确的捕捉到除0的错误信息吗？<br>如果你回答能，那你就把这篇文章看完吧！应该能学点东西。</p>
</blockquote>
<p>本文章分5个部分介绍我的异常处理的理解：</p>
<h3 id="一、异常与错误的概述"><a href="#一、异常与错误的概述" class="headerlink" title="一、异常与错误的概述"></a>一、异常与错误的概述</h3><p>PHP中什么是异常：<br>　　程序在运行中出现不符合预期的情况，允许发生（你也不想让他出现不正常的情况）但他是一种不正常的情况，按照我们的正常逻辑本不该出的错误，但仍然会出现的错误，属于逻辑和业务流程的错误，而不是编译或者语法上的错误。</p>
<p>PHP中什么是错误：<br>　　属于php脚本自身的问题，大部分情况是由错误的语法，服务器环境导致，使得编译器无法通过检查，甚至无法运行的情况。warning、notice都是错误，只是他们的级别不同而已，并且错误是不能被try-catch捕获的。</p>
<p>上面的说法是有前提条件的：<br>　　在PHP中，因为在其他语言中就不能这样下结论了，也就是说异常和错误的说法在不同的语言有不同的说法。在PHP中任何自身的错误或者是非正常的代码都会当做错误对待，并不会以异常的形式抛出，但是也有一些情况会当做异常和错误同时抛出(据说是，我没有找到合适的例子)。也就是说，你想在数据库连接失败的时候自动捕获异常是行不通的，因为这就不是异常，是错误。但是在java中就不一样了，他会把很多和预期不一致的行为当做异常来进行捕获。</p>
<p>PHP异常处理很鸡肋？<br>　　在上面的分析中我们可以看出，PHP并不能主动的抛出异常，但是你可以手动抛出异常，这就很无语了，如果你知道哪里会出问题，你添加if else解决不就行了吗，为啥还要手动抛出异常，既然能手动抛出就证明这个不是异常，而是意料之中。以我的理解，这就是PHP异常处理鸡肋的地方（不一定对啊）。所以PHP的异常机制不是那么的完美，但是使用过框架的同学都知道有这个情况：你在框架中直接写开头那段php“自动”捕获异常的代码是可以的，这是为什么？看过源码的同学都知道框架中都会涉及三个函数：register_shutdown_function，set_error_handler，set_exception_handler后面我会重点讲解着三个黑科技，通过这几个函数我们可以实现PHP假自动捕获异常和错误。</p>
<h3 id="二、ERROR的级别"><a href="#二、ERROR的级别" class="headerlink" title="二、ERROR的级别"></a>二、ERROR的级别</h3><p>只有熟悉错误级别才能对错误捕捉有更好的认识。</p>
<p>Fatal Error:致命错误（脚本终止运行）<br>        E_ERROR         // 致命的运行错误，错误无法恢复，暂停执行脚本<br>        E_CORE_ERROR    // PHP启动时初始化过程中的致命错误<br>        E_COMPILE_ERROR // 编译时致命性错，就像由Zend脚本引擎生成了一个E_ERROR<br>        E_USER_ERROR    // 自定义错误消息。像用PHP函数trigger_error（错误类型设置为：E_USER_ERROR）</p>
<pre><code>Parse Error：编译时解析错误，语法错误（脚本终止运行）
    E_PARSE  //编译时的语法解析错误

Warning Error：警告错误（仅给出提示信息，脚本不终止运行）
    E_WARNING         // 运行时警告 (非致命错误)。
    E_CORE_WARNING    // PHP初始化启动过程中发生的警告 (非致命错误) 。
    E_COMPILE_WARNING // 编译警告
    E_USER_WARNING    // 用户产生的警告信息

Notice Error：通知错误（仅给出通知信息，脚本不终止运行）
    E_NOTICE      // 运行时通知。表示脚本遇到可能会表现为错误的情况.
    E_USER_NOTICE // 用户产生的通知信息。
</code></pre><p>由此可知有5类是产生ERROR级别的错误，这种错误直接导致PHP程序退出。可以定义成：</p>
<pre><code>ERROR = E_ERROR | E_CORE_ERROR |  E_COMPILE_ERROR | E_USER_ERROR | E_PARSE
</code></pre><h3 id="三、PHP异常处理中的黑科技"><a href="#三、PHP异常处理中的黑科技" class="headerlink" title="三、PHP异常处理中的黑科技"></a>三、PHP异常处理中的黑科技</h3><p>前面提到框架中是可以捕获所有的错误和异常的，之所以能实现应该是使用了黑科技，哈哈！其实也不是什么黑科技，主要是三个重要的函数：</p>
<h4 id="1：set-error-handler"><a href="#1：set-error-handler" class="headerlink" title="1：set_error_handler()"></a>1：set_error_handler()</h4><p>　　看到这个名字估计就知道什么意思了，这个函数用于捕获错误，设置一个用户自定义的错误处理函数。</p>
<pre><code>&lt;?php
    set_error_handler(&apos;zyferror&apos;);
    function zyferror($type, $message, $file, $line)
    {
    　　var_dump(&apos;&lt;b&gt;set_error_handler: &apos; . $type . &apos;:&apos; . $message . &apos; in &apos; . $file . &apos; on &apos; . $line . &apos; line .&lt;/b&gt;&lt;br /&gt;&apos;);
    }
?&gt;
</code></pre><p>当程序出现错误的时候自动调用此方法，不过需要注意一下两点：第一，如果存在该方法，相应的error_reporting()就不能在使用了。所有的错误都会交给自定义的函数处理。第二，此方法不能处理以下级别的错误：E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，set_error_handler() 函数所在文件中产生的E_STRICT，该函数只能捕获系统产生的一些Warning、Notice级别的错误。<br>并且他有多种调用的方法：</p>
<pre><code>&lt;?php
     // 直接传函数名 NonClassFunction
     set_error_handler(&apos;function_name&apos;);

     // 传 class_name &amp;&amp; function_name
     set_error_handler(array(&apos;class_name&apos;, &apos;function_name&apos;));
?&gt;
</code></pre><h4 id="2：register-shutdown-function"><a href="#2：register-shutdown-function" class="headerlink" title="2：register_shutdown_function()"></a>2：register_shutdown_function()</h4><p>　　捕获PHP的错误：Fatal Error、Parse Error等，这个方法是PHP脚本执行结束前最后一个调用的函数，比如脚本错误、die()、exit、异常、正常结束都会调用，多么牛逼的一个函数啊！通过这个函数就可以在脚本结束前判断这次执行是否有错误产生，这时就要借助于一个函数：error_get_last()；这个函数可以拿到本次执行产生的所有错误。error_get_last();返回的信息：</p>
<p>[type]           - 错误类型<br>[message] - 错误消息<br>[file]              - 发生错误所在的文件<br>[line]             - 发生错误所在的行  </p>
<pre><code>&lt;?php
    register_shutdown_function(&apos;zyfshutdownfunc&apos;);
    function zyfshutdownfunc()
    {
        if ($error = error_get_last()) {
            var_dump(&apos;&lt;b&gt;register_shutdown_function: Type:&apos; . $error[&apos;type&apos;] . &apos; Msg: &apos; . $error[&apos;message&apos;] . &apos; in &apos; . $error[&apos;file&apos;] . &apos; on line &apos; . $error[&apos;line&apos;] . &apos;&lt;/b&gt;&apos;);
        }
    }
?&gt;
</code></pre><p>通过这种方法就可以巧妙的打印出程序结束前所有的错误信息。但是我在测试的时候我发现并不是所有的错误终止后都会调用这个函数，可以看下面的一个测试文件，内容是：</p>
<pre><code>&lt;?php
    register_shutdown_function(&apos;zyfshutdownfunc&apos;);
    function zyfshutdownfunc()
    {
        if ($error = error_get_last()) {
            var_dump(&apos;&lt;b&gt;register_shutdown_function: Type:&apos; . $error[&apos;type&apos;] . &apos; Msg: &apos; . $error[&apos;message&apos;] . &apos; in &apos; . $error[&apos;file&apos;] . &apos; on line &apos; . $error[&apos;line&apos;] . &apos;&lt;/b&gt;&apos;);
        }
    }
    var_dump(23+-+); //此处语法错误
?&gt;
</code></pre><p>自己可以试一下，你可以看到根本就不会触发zyfshutdownfunc()函数，其实这是一个语法错误，直接报了一个：</p>
<pre><code>&lt;?php
   Parse error: syntax error, unexpected &apos;)&apos; in /www/mytest/exception/try-catch.php on line 71
?&gt;
</code></pre><p>由此引出一个奇葩的问题：问什么不能触发，为什么框架中是可以的？其实原因很简单，只在parse-time出错时是不会调用本函数的。只有在run-time出错的时候，才会调用本函数，我的理解是语法检查器前没有执行register_shutdown_function()去把需要注册的函数放到调用的堆栈中，所以就根本不会运行。那框架中为什么任何错误都能进入到register_shutdown_function()中呢，其实在框架中一般会有统一的入口index.php，然后每个类库文件都会通过include ** 的方式加载到index.php中，相当与所有的程序都会在index.php中聚集，同样，你写的具有语法错误的文件也会被引入到入口文件中，这样的话，调用框架，执行index.php，index.php本身并没有语法错误，也就不会产生parse-time错误，而是 include 文件出错了，是run-time的时候出错了，所以框架执行完之后就会触发register_shutdown_function();<br>所以现在可是试一下这个写法，这样就会触发zyfshutdownfunc()回调了：</p>
<pre><code>a.php文件
&lt;?php
　　// 模拟语法错误
　　var_dump(23+-+);
?&gt;

b.php文件
&lt;?php
    register_shutdown_function(&apos;zyfshutdownfunc&apos;);
    function zyfshutdownfunc()
    {
        if ($error = error_get_last()) {
            var_dump(&apos;&lt;b&gt;register_shutdown_function: Type:&apos; . $error[&apos;type&apos;] . &apos; Msg: &apos; . $error[&apos;message&apos;] . &apos; in &apos; . $error[&apos;file&apos;] . &apos; on line &apos; . $error[&apos;line&apos;] . &apos;&lt;/b&gt;&apos;);
        }
    }
    require &apos;a.php&apos;;
?&gt;
</code></pre><h4 id="3：set-exception-handler"><a href="#3：set-exception-handler" class="headerlink" title="3：set_exception_handler()"></a>3：set_exception_handler()</h4><p>　　设置默认的异常处理程序，用在没有用try/catch块来捕获的异常，也就是说不管你抛出的异常有没有人捕获，如果没有人捕获就会进入到该方法中，并且在回调函数调用后异常会中止。看一下用法：</p>
<pre><code>&lt;?php
    set_exception_handler(&apos;zyfexception&apos;);
    function zyfexception($exception)
    {
        var_dump(&quot;&lt;b&gt;set_exception_handler: Exception: &quot; . $exception-&gt;getMessage()  . &apos;&lt;/b&gt;&apos;);
    }
    throw new Exception(&quot;zyf exception&quot;);
?&gt;
</code></pre><h3 id="四、巧妙的捕获错误和异常"><a href="#四、巧妙的捕获错误和异常" class="headerlink" title="四、巧妙的捕获错误和异常"></a>四、巧妙的捕获错误和异常</h3><h4 id="1：把错误以异常的形式抛出-不能完全抛出"><a href="#1：把错误以异常的形式抛出-不能完全抛出" class="headerlink" title="1：把错误以异常的形式抛出(不能完全抛出)"></a>1：把错误以异常的形式抛出(不能完全抛出)</h4><p>　　　　由上面的讲解我们知道，php中的错误是不能以异常的像是捕获的，但是我们需要让他们抛出，已达到扩展 try-catch的影响范围，我们前面讲到过set_error_handler() 方法，他是干嘛用的，他是捕获错误的，所以我们就可以借助他来吧错误捕获，然后再以异常的形式抛出，ok，试试下面的写法：</p>
<pre><code>&lt;?php
    set_error_handler(&apos;zyferror&apos;);
    function zyferror($type, $message, $file, $line)
    {
        throw new \Exception($message . &apos;zyf错误当做异常&apos;);
    }

    $num = 0;
    try {
        echo 1/$num;

    } catch (Exception $e){
        echo $e-&gt;getMessage();
    }
?&gt;
</code></pre><p>好了，试一下，会打印出：</p>
<pre><code>Division by zero zyf123
</code></pre><p>流程：本来是除0错误，然后触发set_error_handler()，在set_error_handler()中相当与杀了个回马枪，再把错误信息以异常的形式抛出来，这样就可以实现错误以异常的形式抛出。大家要注意：这样做是有缺点的，会受到set_error_handler()函数捕获级别的限制。</p>
<h4 id="2：捕获所有的错误"><a href="#2：捕获所有的错误" class="headerlink" title="2：捕获所有的错误"></a>2：捕获所有的错误</h4><p>由set_error_handler()可知，他能够捕获一部分错误，不能捕获系统级E_ERROR、E_PARSE等错误，但是这部分可以由register_shutdown_function()捕获。所以两者结合能出现很好的功能。<br>看下面的程序：</p>
<pre><code>a.php内容：
&lt;?
    // 模拟Fatal error错误
    //test();

    // 模拟用户产生ERROR错误
    //trigger_error(&apos;zyf-error&apos;, E_USER_ERROR);

    // 模拟语法错误
    var_dump(23+-+);

    // 模拟Notice错误
    //echo $f;

    // 模拟Warning错误
    //echo &apos;123&apos;;
    //ob_flush();
    //flush();
    //header(&quot;Content-type:text/html;charset=gb2312&quot;);
?&gt;
b.php内容：
&lt;?
    error_reporting(0);
    register_shutdown_function(&apos;zyfshutdownfunc&apos;);
    function zyfshutdownfunc()
    {
        if ($error = error_get_last()) {
            var_dump(&apos;&lt;b&gt;register_shutdown_function: Type:&apos; . $error[&apos;type&apos;] . &apos; Msg: &apos; . $error[&apos;message&apos;] . &apos; in &apos; . $error[&apos;file&apos;] . &apos; on line &apos; . $error[&apos;line&apos;] . &apos;&lt;/b&gt;&apos;);
        }
    }

    set_error_handler(&apos;zyferror&apos;);
    function zyferror($type, $message, $file, $line)
    {
        var_dump(&apos;&lt;b&gt;set_error_handler: &apos; . $type . &apos;:&apos; . $message . &apos; in &apos; . $file . &apos; on &apos; . $line . &apos; line .&lt;/b&gt;&lt;br /&gt;&apos;);
    }

    require &apos;a.php&apos;;
?&gt;
</code></pre><p>到此就可以解释开头的那个程序了吧，test.php 如果是单文件执行是不能捕获到错误的，如果你在框架中执行就是可以的，当然你按照我上面介绍的来扩展也是可以的。</p>
<h3 id="五、自定义异常处理和异常嵌套"><a href="#五、自定义异常处理和异常嵌套" class="headerlink" title="五、自定义异常处理和异常嵌套"></a>五、自定义异常处理和异常嵌套</h3><h4 id="1：自定义异常处理"><a href="#1：自定义异常处理" class="headerlink" title="1：自定义异常处理"></a>1：自定义异常处理</h4><p>　　在复杂的系统中，我们往往需要自己捕获我们需要特殊处理的异常，这些异常可能是特殊情况下抛出的。所以我们就自己定义一个异常捕获类，该类必须是 exception 类的一个扩展，该类继承了 PHP 的 exception 类的所有属性，并且我们可以添加自定义的函数，使用的时候其实和之前的一样，大致写法如下：</p>
<pre><code>&lt;?php
    class zyfException extends Exception
    {
        public function errorzyfMessage()
        {
            return &apos;Error line &apos; . $this-&gt;getLine().&apos; in &apos; . $this-&gt;getFile()
                .&apos;: &lt;b&gt;&apos; . $this-&gt;getMessage() . &apos;&lt;/b&gt; Must in (0 - 60)&apos;;
        }
    }

    $age = 10;
    try {
        $age = intval($age);
        if($age &gt; 60) {
            throw new zyfException($age);
        }

    } catch (zyfException $e) {
        echo $e-&gt;errorzyfMessage();

    }
?&gt;
</code></pre><p>2：异常嵌套</p>
<p>异常嵌套是比较常见的写法，在自定义的异常处理中，try 块中可以定义多个异常捕获，然后分层传递异常，理解和冒泡差不多，看下面的实现：</p>
<pre><code>&lt;?php
    $age = 10;
    try {
        $age = intval($age);
        if($age &gt; 60) {
            throw new zyfException($age);
        }

        if ($age &lt;= 0) {
            throw new Exception($age . &apos; must &gt; 0&apos;);
        }

    } catch (zyfException $e) {
        echo $e-&gt;errorzyfMessage();

    } catch(Exception $e) {
        echo $e-&gt;getMessage();
    }
?&gt;
</code></pre><p>当然也可以在catch中再抛出异常给上层：</p>
<pre><code>&lt;?php
    $age = 100;
    try {
        try {
            $age = intval($age);
            if($age &gt; 60) {
                throw new Exception($age);
            }

        } catch (Exception $e) {
            throw new zyfException($age);

        }

    } catch (zyfException $e) {
        echo $e-&gt;errorzyfMessage();
    }
?&gt;
</code></pre><h3 id="六、PHP7中的异常处理"><a href="#六、PHP7中的异常处理" class="headerlink" title="六、PHP7中的异常处理"></a>六、PHP7中的异常处理</h3><p>现在写PHP必须考虑版本情况，上面的写法在PHP7中大部分都能实现，但是也会有不同点，在PHP7更新中有一条：更多的Error变为可捕获的Exception，现在的PHP7实现了一个全局的throwable接口，原来老的Exception和其中一部分Error实现了这个接口(interface)，PHP7中更多的Error变为可捕获的Exception返回给捕捉器，这样其实和前面提到的扩展try-catch影响范围一样，但是如果不捕获则还是按照Error对待，看下面两个：</p>
<pre><code>&lt;?php
    try {
        test();

    } catch(Throwable $e) {
        echo $e-&gt;getMessage() . &apos; zyf&apos;;
    }

    try {
        test();

    } catch(Error $e) {
        echo $e-&gt;getMessage() . &apos; zyf&apos;;
    }
?&gt;
</code></pre><p>因为PHP7实现了throwable接口，那么就可以使用第一个这种方式来捕获异常。又因为部分Error实现了接口，并且更多的Error变为可捕获的Exception，那么就可以使用第二种方式来捕获异常。下面是在网上找的PHP7的异常层次树：</p>
<pre><code>Throwable
　　Exception 异常
　　　　...
　　Error 错误
　　　　ArithmeticError 算数错误
　　　　　　DivisionByZeroError 除数为0的错误
　　　　AssertionError 声明错误
　　　　ParseError 解析错误
　　　　TypeError 类型错误
</code></pre><p>本文绝大部分转载自<a href="https://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html#excetion2" target="_blank" rel="external">https://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html#excetion2</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2018/01/02/错误和异常/" data-id="cjgdd8h3u00am0s2njdtonxvm" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/常识/">常识</a></li></ul>

    </footer>
  </div>
  
    
    
<nav id="article-nav">
  
    <a href="/2018/02/11/PHPstorm快捷键 for Mac/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          PHPstorm快捷键 for Mac
        
      </div>
    </a>
  
  
    <a href="/2018/01/01/linux管理之进程管理/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">linux管理之进程管理</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
            <div id="SOHUCS" sid="2018/01/02/错误和异常/"> </div>
    
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#错误"><span class="toc-number">1.</span> <span class="toc-text">错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理函数"><span class="toc-number">1.1.</span> <span class="toc-text">错误处理函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error-reporting"><span class="toc-number">2.</span> <span class="toc-text">error_reporting()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-number">3.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Try-throw-和-catch"><span class="toc-number">3.1.</span> <span class="toc-text">Try, throw 和 catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置顶层异常处理器-（Top-Level-Exception-Handler）"><span class="toc-number">3.2.</span> <span class="toc-text">设置顶层异常处理器 （Top Level Exception Handler）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常的规则"><span class="toc-number">3.3.</span> <span class="toc-text">异常的规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误和异常"><span class="toc-number">4.</span> <span class="toc-text">错误和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、异常与错误的概述"><span class="toc-number">4.1.</span> <span class="toc-text">一、异常与错误的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、ERROR的级别"><span class="toc-number">4.2.</span> <span class="toc-text">二、ERROR的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、PHP异常处理中的黑科技"><span class="toc-number">4.3.</span> <span class="toc-text">三、PHP异常处理中的黑科技</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1：set-error-handler"><span class="toc-number">4.3.1.</span> <span class="toc-text">1：set_error_handler()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2：register-shutdown-function"><span class="toc-number">4.3.2.</span> <span class="toc-text">2：register_shutdown_function()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3：set-exception-handler"><span class="toc-number">4.3.3.</span> <span class="toc-text">3：set_exception_handler()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、巧妙的捕获错误和异常"><span class="toc-number">4.4.</span> <span class="toc-text">四、巧妙的捕获错误和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1：把错误以异常的形式抛出-不能完全抛出"><span class="toc-number">4.4.1.</span> <span class="toc-text">1：把错误以异常的形式抛出(不能完全抛出)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2：捕获所有的错误"><span class="toc-number">4.4.2.</span> <span class="toc-text">2：捕获所有的错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、自定义异常处理和异常嵌套"><span class="toc-number">4.5.</span> <span class="toc-text">五、自定义异常处理和异常嵌套</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1：自定义异常处理"><span class="toc-number">4.5.1.</span> <span class="toc-text">1：自定义异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、PHP7中的异常处理"><span class="toc-number">4.6.</span> <span class="toc-text">六、PHP7中的异常处理</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 马闯&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;marteeet@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/2012/01/01/About Me/" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      



<script type="text/javascript ">
    (function () {
        var appid = 'cytf1deXv';
        var conf = '6867419241543404b6c287f39f49f3ca';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
        } else {
            var loadJs = function (d, a) {
                var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
                var b = document.createElement("script");
                b.setAttribute("type", "text/javascript");
                b.setAttribute("charset", "UTF-8");
                b.setAttribute("src", d);
                if (typeof a === "function") {
                    if (window.attachEvent) {
                        b.onreadystatechange = function () {
                            var e = b.readyState;
                            if (e === "loaded" || e === "complete") {
                                b.onreadystatechange = null;
                                a()
                            }
                        }
                    } else {
                        b.onload = a
                    }
                }
                c.appendChild(b)
            };
            loadJs("http://changyan.sohu.com/upload/changyan.js", function () {
                window.changyan.api.config({
                    appid: appid,
                    conf: conf
                })
            });
        }
    })();
</script>








<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>