<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>网络协议须知 | MARTIST</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="：-}">
<meta name="keywords" content="web">
<meta property="og:type" content="article">
<meta property="og:title" content="网络协议须知">
<meta property="og:url" content="http://martist.cn/2018/06/25/WEB/网络协议须知/index.html">
<meta property="og:site_name" content="MARTIST">
<meta property="og:description" content="：-}">
<meta property="og:locale" content="简体中文">
<meta property="og:image" content="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/TCP-IP.gif">
<meta property="og:updated_time" content="2018-07-10T11:14:56.083Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络协议须知">
<meta name="twitter:description" content="：-}">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/TCP-IP.gif">
  
    <link rel="alternate" href="/atom.xml" title="MARTIST" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://martist.cn"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/2012/01/01/About Me/">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MARTIST</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-WEB/网络协议须知" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/25/WEB/网络协议须知/" class="article-date">
  <time datetime="2018-06-24T16:00:00.000Z" itemprop="datePublished">2018-06-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/web/">web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      网络协议须知
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>：-} <a id="more"></a></p>
<h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><pre><code>OSI七层模型是万能的国际标准化组织(ISO)提出的一个试图使各种计算机在世界范围内互连的理想标准，说白了理想和现实的差距就是七层模型和五层模型的差距。具体分类如下表：
</code></pre><table>
<thead>
<tr>
<th>七层模型</th>
<th style="text-align:center">五层模型</th>
<th style="text-align:right">四层模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>表示层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:right">应用层</td>
</tr>
<tr>
<td>会话层</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>传输层  | 传输层  | 传输层|<br>| 网络层| 网络层 | 网络层 |<br>|数据链路层 | 数据链路层 |     链接层/实体层 |<br>|物理层 | 物理层 |  |</p>
<p> 七层模型的上三层归为应用层即为TCP/IP五层模型，五层模型的下两层归为链接层或者说实体层即为四层模型。</p>
<p> 从本质上来区分，HTTP，WebSocket，TCP，UDP，IP都是协议，而TCP/IP是不同协议的组合，你也可以称之为协议栈，协议族，TCP/IP模型。</p>
<p> 而Socket（套接字）才是真正能操作的东西。Socket的本质是API，是先人对TCP/IP协议族的抽象或者说封装，它就像一个门面，给你一个操作TCP/IP协议的入口，来建立Socket连接。值得一提的是，此Socket是指网络编程下的Socket，而不是Unix中的Socket。虽然概念相似，但是Unix中的Socket不是基于这些乱七八糟的协议，而是基于操作系统本身的文件系统。</p>
<p>从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议。</p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><blockquote>
<p>网络之间互连的协议(Internet Protoco)</p>
</blockquote>
<p>网络之间互连的协议也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。IP地址具有唯一性，根据用户性质的不同，可以分为5类。另外，IP还有进入防护，知识产权，指针寄存器等含义。</p>
<p>IP 是无连接的</p>
<p>IP 用于计算机之间的通信。</p>
<p>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。</p>
<p>通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。</p>
<p>IP 负责将每个包路由至它的目的地。<br>IP地址</p>
<p>每个计算机必须有一个 IP 地址才能够连入因特网。</p>
<p>每个 IP 包必须有一个地址才能够发送到另一台计算机。</p>
<p>网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。</p>
<p>TCP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。<br>一个计算机字节可以包含 256 个不同的值：<br>00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ……. 直到 11111111。<br>现在，你知道了为什么 TCP/IP 地址是介于 0 到 255 之间的 4 个数字。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><blockquote>
<p>传送控制协议(Transmission Control Protocol)</p>
</blockquote>
<p> TCP是面向连接的一种传输控制协议。<br> TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。<br> 特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至。</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：<br>TCP三次握手.png</p>
<p>（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
<p>（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
<p>（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
<h4 id="简单来说，就是"><a href="#简单来说，就是" class="headerlink" title="简单来说，就是"></a>简单来说，就是</h4><p>1、建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认</p>
<p>2、服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态</p>
<p>3、客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。</p>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：</p>
<pre><code>netstat -nap | grep SYN_RECV
</code></pre><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：<br>TCP四次挥手.png</p>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p>
<p>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>
<p>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p>
<p>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
<p>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<p>参考：<a href="https://www.jianshu.com/p/ef892323e68f" target="_blank" rel="external">https://www.jianshu.com/p/ef892323e68f</a><br><a href="https://www.cnblogs.com/yueminghai/p/6646043.html" target="_blank" rel="external">https://www.cnblogs.com/yueminghai/p/6646043.html</a></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote>
<p>用户数据报协议(User Datagram Protocol)</p>
</blockquote>
<p>UDP是无连接的用户数据报协议。<br>所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。<br>故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至。</p>
<h2 id="ftp-（文件传输协议）"><a href="#ftp-（文件传输协议）" class="headerlink" title="ftp （文件传输协议）"></a>ftp （文件传输协议）</h2><blockquote>
<p>文件传输协议(File Transfer Protocol)<br>ftp用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p>
</blockquote>
<h2 id="ip和tcp"><a href="#ip和tcp" class="headerlink" title="ip和tcp"></a>ip和tcp</h2><p>TCP/IP 意味着 TCP 和 IP 在一起协同工作。</p>
<p>TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。</p>
<p>IP 负责计算机之间的通信。</p>
<p>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。</p>
<p>IP 负责将包发送至接受者。</p>
<h2 id="tcp和udp"><a href="#tcp和udp" class="headerlink" title="tcp和udp"></a>tcp和udp</h2><h2 id="TCP与UDP基本区别"><a href="#TCP与UDP基本区别" class="headerlink" title="TCP与UDP基本区别"></a>TCP与UDP基本区别</h2><pre><code>1.基于连接与无连接
2.TCP要求系统资源较多，UDP较少； 
3.UDP程序结构较简单 
4.流模式（TCP）与数据报模式(UDP); 
5.TCP保证数据正确性，UDP可能丢包 
6.TCP保证数据顺序，UDP不保证 
</code></pre><p>　　<br>UDP应用场景</p>
<pre><code>1.面向数据报方式
2.网络数据大多为短消息 
3.拥有大量Client
4.对数据安全性无特殊要求
5.网络负担非常重，但对响应速度要求高
</code></pre><p>具体编程时的区别</p>
<pre><code>1.socket()的参数不同 
2.UDP Server不需要调用listen和accept 
3.UDP收发数据用sendto/recvfrom函数 
4.TCP：地址信息在connect/accept时确定 
5.UDP：在sendto/recvfrom函数中每次均 需指定地址信息 
6.UDP：shutdown函数无效
</code></pre><p>通常我们在说到网络编程时默认是指TCP编程，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为SOCK_STREAM。即socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。</p>
<p>SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，也是双向的，即任何一方都可以收发数据，协议本身提供了一些保障机制保证它是可靠的、有序的，即每个包按照发送的顺序到达接收方。</p>
<p>SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的，因为通讯双方发送数据后不知道对方是否已经收到数据，是否正常收到数据。任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据。根本不关心对方是否存在，是否发送了数据。它的特点是通讯速度比较快。大家都知道TCP是要经过三次握手的，而UDP没有。 </p>
<p>基于上述不同，UDP和TCP编程步骤也有些不同，如下：</p>
<h3 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h3><p>TCP编程的服务器端一般步骤</p>
<pre><code>　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt(); * 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
　　4、开启监听，用函数listen()； 
　　5、接收客户端上来的连接，用函数accept()； 
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接； 
　　8、关闭监听； 
</code></pre><p>TCP编程的客户端一般步骤</p>
<pre><code>　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
　　4、设置要连接的对方的IP地址和端口等属性； 
　　5、连接服务器，用函数connect()； 
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接；
</code></pre><h3 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h3><p>UDP编程的服务器端一般步骤 </p>
<pre><code>　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
　　4、循环接收数据，用函数recvfrom(); 
　　5、关闭网络连接； 
</code></pre><p>UDP编程的客户端一般步骤 </p>
<pre><code>　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
　　4、设置对方的IP地址和端口等属性; 
　　5、发送数据，用函数sendto(); 
　　6、关闭网络连接；
</code></pre><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p>
<h3 id="UDP补充"><a href="#UDP补充" class="headerlink" title="UDP补充"></a>UDP补充</h3><p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。</p>
<h3 id="TCP补充"><a href="#TCP补充" class="headerlink" title="TCP补充"></a>TCP补充</h3><p>TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<h3 id="TCP与UDP区别总结"><a href="#TCP与UDP区别总结" class="headerlink" title="TCP与UDP区别总结"></a>TCP与UDP区别总结</h3><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议</p>
</blockquote>
<p>HTTP是基于TCP协议的应用，请求时需建立TCP连接，而且请求包中需要包含请求方法，URI，协议版本等信息，请求结束后断开连接，完成一次请求/响应操作。故称为短连接。</p>
<p>而HTTP/1.1中的keep-alive所保持的长连接则是为了优化每次HTTP请求中TCP连接三次握手的麻烦和资源开销，只建立一次TCP连接，多次的在这个通道上完成请求/响应操作。</p>
<p>值得一提的是，服务器无法主动给客户端推送消息。<br> HTTP全称是HyperText Transfer Protocal，即：超文本传输协议，HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p>
<h3 id="HTTPS通信原理"><a href="#HTTPS通信原理" class="headerlink" title="HTTPS通信原理"></a>HTTPS通信原理</h3><p>HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议 它是一个安全通信通道</p>
<p>HTTPS是HTTP over SSL/TLS，HTTP是应用层协议，TCP是传输层协议，在应用层和传输层之间，增加了一个安全套接层SSL/TLS：</p>
<p>SSL (Secure Socket Layer，安全套接字层)</p>
<p>TLS (Transport Layer Security，传输层安全协议)</p>
<p>SSL使用40 位关键字作为RC4流加密算法</p>
<h3 id="Https的作用"><a href="#Https的作用" class="headerlink" title="Https的作用"></a>Https的作用</h3><pre><code>内容加密 建立一个信息安全通道，来保证数据传输的安全；

身份认证 确认网站的真实性

数据完整性 防止内容被第三方冒充或者篡改
</code></pre><h3 id="Https和Http"><a href="#Https和Http" class="headerlink" title="Https和Http"></a>Https和Http</h3><pre><code>https协议需要到CA申请证书。

http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。

http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

http默认使用80端口，https默认使用443端口
</code></pre><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP长连接每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化，但WebSocket不仅仅在Web应用程序上得到支持。</p>
<h2 id="Socket连接和TCP连接"><a href="#Socket连接和TCP连接" class="headerlink" title="Socket连接和TCP连接"></a>Socket连接和TCP连接</h2><p>其实这就是一个文字游戏而已，建立Socket连接需要至少一对Socket（套接字），而创建Socket连接可以指定不同的传输层协议，即TCP或UDP，所以当采用TCP建立连接时，该Socket连接就视为一个TCP连接。而采用UDP则是无连接的。</p>
<h2 id="Socket和WebSocket"><a href="#Socket和WebSocket" class="headerlink" title="Socket和WebSocket"></a>Socket和WebSocket</h2><p>这两个虽然名字差不多，但却是两个完全不同的概念，就好比Java和JavaScript一样毫无关系。Socket是一套协议封装后的接口，用于建立Socket连接，而WebSocket虽然是Html5的产物，但也不仅仅局限于浏览器的应用程序，许多语言都提供了WebSocket的支持，比如C，C++，Python等。</p>
<h2 id="HTTP、WebSocket与TCP的关系"><a href="#HTTP、WebSocket与TCP的关系" class="headerlink" title="HTTP、WebSocket与TCP的关系"></a>HTTP、WebSocket与TCP的关系</h2><p>HTTP通信过程属于“你推一下，我走一下”的方式，客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯。所以，HTTP和WebSocket虽都是基于TCP协议，但是两者属于完全不同的两种通讯方式。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">层次</th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td>http</td>
<td style="text-align:center">WebSocket</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td></td>
<td style="text-align:center">tcp</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td></td>
<td style="text-align:center">ip</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/merray/p/7918977.html" target="_blank" rel="external">https://www.cnblogs.com/merray/p/7918977.html</a></p>
<p><img src="https://raw.githubusercontent.com/ma1203580780/ma1203580780.github.io/master/images/TCP-IP.gif" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://martist.cn/2018/06/25/WEB/网络协议须知/" data-id="cjr0f67ni00citt6utzwq8b69" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
    
    
<nav id="article-nav">
  
    <a href="/2018/06/26/PHP/设计模式的原则/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          设计模式的原则
        
      </div>
    </a>
  
  
    <a href="/2018/06/18/linux性能调优/性能调优的点/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">web架构优化的几个点</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
            <div id="SOHUCS" sid="2018/06/25/WEB/网络协议须知/"> </div>
    
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI模型"><span class="toc-number">1.</span> <span class="toc-text">OSI模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-number">2.</span> <span class="toc-text">IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">3.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP三次握手"><span class="toc-number">3.1.</span> <span class="toc-text">TCP三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单来说，就是"><span class="toc-number">3.1.1.</span> <span class="toc-text">简单来说，就是</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN攻击"><span class="toc-number">3.2.</span> <span class="toc-text">SYN攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP四次挥手"><span class="toc-number">3.3.</span> <span class="toc-text">TCP四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><span class="toc-number">3.4.</span> <span class="toc-text">为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-number">4.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ftp-（文件传输协议）"><span class="toc-number">5.</span> <span class="toc-text">ftp （文件传输协议）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip和tcp"><span class="toc-number">6.</span> <span class="toc-text">ip和tcp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp和udp"><span class="toc-number">7.</span> <span class="toc-text">tcp和udp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP与UDP基本区别"><span class="toc-number">8.</span> <span class="toc-text">TCP与UDP基本区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-1"><span class="toc-number">8.1.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-1"><span class="toc-number">8.2.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP补充"><span class="toc-number">8.3.</span> <span class="toc-text">UDP补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP补充"><span class="toc-number">8.4.</span> <span class="toc-text">TCP补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP与UDP区别总结"><span class="toc-number">8.5.</span> <span class="toc-text">TCP与UDP区别总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">9.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS通信原理"><span class="toc-number">9.1.</span> <span class="toc-text">HTTPS通信原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Https的作用"><span class="toc-number">9.2.</span> <span class="toc-text">Https的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Https和Http"><span class="toc-number">9.3.</span> <span class="toc-text">Https和Http</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket"><span class="toc-number">10.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket连接和TCP连接"><span class="toc-number">11.</span> <span class="toc-text">Socket连接和TCP连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket和WebSocket"><span class="toc-number">12.</span> <span class="toc-text">Socket和WebSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP、WebSocket与TCP的关系"><span class="toc-number">13.</span> <span class="toc-text">HTTP、WebSocket与TCP的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">14.</span> <span class="toc-text">参考</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 马闯&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;marteeet@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/2012/01/01/About Me/" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      



<script type="text/javascript ">
    (function () {
        var appid = 'cytf1deXv';
        var conf = '6867419241543404b6c287f39f49f3ca';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
        } else {
            var loadJs = function (d, a) {
                var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
                var b = document.createElement("script");
                b.setAttribute("type", "text/javascript");
                b.setAttribute("charset", "UTF-8");
                b.setAttribute("src", d);
                if (typeof a === "function") {
                    if (window.attachEvent) {
                        b.onreadystatechange = function () {
                            var e = b.readyState;
                            if (e === "loaded" || e === "complete") {
                                b.onreadystatechange = null;
                                a()
                            }
                        }
                    } else {
                        b.onload = a
                    }
                }
                c.appendChild(b)
            };
            loadJs("http://changyan.sohu.com/upload/changyan.js", function () {
                window.changyan.api.config({
                    appid: appid,
                    conf: conf
                })
            });
        }
    })();
</script>








<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>